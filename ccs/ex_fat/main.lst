CCS PCH C Compiler, Version 5.056, 29513               03-Feb-20 15:10

               Filename:   C:\Users\maisun\Documents\PhD\offline\code\ccs\ex_fat\main.lst

               ROM used:   27306 bytes (21%)
                           Largest free fragment is 64850
               RAM used:   1381 (37%) at main() level
                           1806 (49%) worst case
               Stack used: 12 locations
               Stack size: 31

*
00000:  GOTO   642C
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                     fat_ex_shell.c                              //// 
.................... ////                                                                 //// 
.................... ////    This is a neat little shell utility that resembles a DOS or  //// 
.................... //// UNIX type shell in order to manipulate files on the FAT file    //// 
.................... //// system. This is mostly for demonstration purposes on how to use //// 
.................... //// some of the basic functionality of the FAT library.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //These settings are for the CCS PICEEC development kit which contains 
.................... //an MMC/SD connector. 
.................... #include <18F67J60.h> 
.................... //////////// Standard Header file for the PIC18F67J60 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J60 
*
00008:  DATA 0D,0A
0000A:  DATA 2D,2D
0000C:  DATA 25,73
0000E:  DATA 2D,2D
00010:  DATA 00,00
00012:  DATA 0D,0A
00014:  DATA 0D,0A
00016:  DATA 20,20
00018:  DATA 20,20
0001A:  DATA 20,20
0001C:  DATA 20,20
0001E:  DATA 20,00
00020:  DATA 0D,0A
00022:  DATA 0D,0A
00024:  DATA 2D,2D
00026:  DATA 46,41
00028:  DATA 54,20
0002A:  DATA 53,74
0002C:  DATA 61,74
0002E:  DATA 73,2D
00030:  DATA 2D,0D
00032:  DATA 0A,00
00034:  DATA 46,69
00036:  DATA 72,73
00038:  DATA 74,20
0003A:  DATA 46,41
0003C:  DATA 54,20
0003E:  DATA 73,74
00040:  DATA 61,72
00042:  DATA 74,73
00044:  DATA 20,61
00046:  DATA 74,3A
00048:  DATA 20,30
0004A:  DATA 78,25
0004C:  DATA 6C,58
0004E:  DATA 0D,0A
00050:  DATA 00,00
00052:  DATA 44,61
00054:  DATA 74,61
00056:  DATA 20,53
00058:  DATA 74,61
0005A:  DATA 72,74
0005C:  DATA 73,20
0005E:  DATA 41,74
00060:  DATA 3A,20
00062:  DATA 30,78
00064:  DATA 25,6C
00066:  DATA 58,0D
00068:  DATA 0A,00
0006A:  DATA 52,6F
0006C:  DATA 6F,74
0006E:  DATA 20,44
00070:  DATA 69,72
00072:  DATA 65,63
00074:  DATA 74,6F
00076:  DATA 72,79
00078:  DATA 20,49
0007A:  DATA 73,20
0007C:  DATA 41,74
0007E:  DATA 3A,20
00080:  DATA 30,78
00082:  DATA 25,6C
00084:  DATA 58,0D
00086:  DATA 0A,00
00088:  DATA 42,79
0008A:  DATA 74,65
0008C:  DATA 73,20
0008E:  DATA 50,65
00090:  DATA 72,20
00092:  DATA 43,6C
00094:  DATA 75,73
00096:  DATA 74,65
00098:  DATA 72,3A
0009A:  DATA 20,30
0009C:  DATA 78,25
0009E:  DATA 6C,58
000A0:  DATA 0D,0A
000A2:  DATA 00,00
000A4:  DATA 0D,0A
000A6:  DATA 0D,0A
000A8:  DATA 2D,2D
000AA:  DATA 00,00
000AC:  DATA 20,49
000AE:  DATA 6E,66
000B0:  DATA 6F,2D
000B2:  DATA 2D,00
000B4:  DATA 0D,0A
000B6:  DATA 41,74
000B8:  DATA 74,72
000BA:  DATA 69,62
000BC:  DATA 75,74
000BE:  DATA 65,73
000C0:  DATA 3A,20
000C2:  DATA 30,78
000C4:  DATA 25,58
000C6:  DATA 00,00
000C8:  DATA 0D,0A
000CA:  DATA 43,72
000CC:  DATA 65,61
000CE:  DATA 74,65
000D0:  DATA 64,3A
000D2:  DATA 20,00
000D4:  DATA 0D,0A
000D6:  DATA 4D,6F
000D8:  DATA 64,69
000DA:  DATA 66,69
000DC:  DATA 65,64
000DE:  DATA 3A,20
000E0:  DATA 00,00
000E2:  DATA 0D,0A
000E4:  DATA 53,74
000E6:  DATA 61,72
000E8:  DATA 74,69
000EA:  DATA 6E,67
000EC:  DATA 20,63
000EE:  DATA 6C,75
000F0:  DATA 73,74
000F2:  DATA 65,72
000F4:  DATA 3A,20
000F6:  DATA 25,6C
000F8:  DATA 58,00
000FA:  DATA 0D,0A
000FC:  DATA 53,74
000FE:  DATA 61,72
00100:  DATA 74,69
00102:  DATA 6E,67
00104:  DATA 20,61
00106:  DATA 64,64
00108:  DATA 72,65
0010A:  DATA 73,73
0010C:  DATA 3A,20
0010E:  DATA 25,6C
00110:  DATA 58,00
00112:  DATA 0D,0A
00114:  DATA 53,69
00116:  DATA 7A,65
00118:  DATA 3A,20
0011A:  DATA 25,6C
0011C:  DATA 75,20
0011E:  DATA 42,79
00120:  DATA 74,65
00122:  DATA 73,0D
00124:  DATA 0A,00
00126:  DATA 0D,0A
00128:  DATA 0A,25
0012A:  DATA 73,3E
0012C:  DATA 20,00
0012E:  DATA 0D,0A
00130:  DATA 44,65
00132:  DATA 6C,65
00134:  DATA 74,69
00136:  DATA 6E,67
00138:  DATA 20,27
0013A:  DATA 25,73
0013C:  DATA 27,3A
0013E:  DATA 20,00
00140:  DATA 45,72
00142:  DATA 72,6F
00144:  DATA 72,20
00146:  DATA 64,65
00148:  DATA 6C,65
0014A:  DATA 74,69
0014C:  DATA 6E,67
0014E:  DATA 20,66
00150:  DATA 69,6C
00152:  DATA 65,00
00154:  DATA 0D,0A
00156:  DATA 4D,61
00158:  DATA 6B,69
0015A:  DATA 6E,67
0015C:  DATA 20,66
0015E:  DATA 69,6C
00160:  DATA 65,20
00162:  DATA 27,25
00164:  DATA 73,27
00166:  DATA 3A,20
00168:  DATA 00,00
0016A:  DATA 45,72
0016C:  DATA 72,6F
0016E:  DATA 72,20
00170:  DATA 63,72
00172:  DATA 65,61
00174:  DATA 74,69
00176:  DATA 6E,67
00178:  DATA 20,66
0017A:  DATA 69,6C
0017C:  DATA 65,00
0017E:  DATA 0D,0A
00180:  DATA 41,70
00182:  DATA 70,65
00184:  DATA 6E,64
00186:  DATA 69,6E
00188:  DATA 67,20
0018A:  DATA 27,25
0018C:  DATA 73,27
0018E:  DATA 20,74
00190:  DATA 6F,20
00192:  DATA 27,25
00194:  DATA 73,27
00196:  DATA 3A,20
00198:  DATA 00,00
0019A:  DATA 45,72
0019C:  DATA 72,6F
0019E:  DATA 72,20
001A0:  DATA 6F,70
001A2:  DATA 65,6E
001A4:  DATA 69,6E
001A6:  DATA 67,20
001A8:  DATA 66,69
001AA:  DATA 6C,65
001AC:  DATA 00,00
001AE:  DATA 45,72
001B0:  DATA 72,6F
001B2:  DATA 72,20
001B4:  DATA 63,6C
001B6:  DATA 6F,73
001B8:  DATA 69,6E
001BA:  DATA 67,20
001BC:  DATA 66,69
001BE:  DATA 6C,65
001C0:  DATA 00,00
001C2:  DATA 0D,0A
001C4:  DATA 45,72
001C6:  DATA 72,6F
001C8:  DATA 72,20
001CA:  DATA 63,68
001CC:  DATA 61,6E
001CE:  DATA 67,69
001D0:  DATA 6E,67
001D2:  DATA 20,64
001D4:  DATA 69,72
001D6:  DATA 65,63
001D8:  DATA 74,6F
001DA:  DATA 72,79
001DC:  DATA 00,00
001DE:  DATA 0D,0A
001E0:  DATA 4D,61
001E2:  DATA 6B,69
001E4:  DATA 6E,67
001E6:  DATA 20,64
001E8:  DATA 69,72
001EA:  DATA 65,63
001EC:  DATA 74,6F
001EE:  DATA 72,79
001F0:  DATA 20,27
001F2:  DATA 25,73
001F4:  DATA 27,3A
001F6:  DATA 20,00
001F8:  DATA 45,72
001FA:  DATA 72,6F
001FC:  DATA 72,20
001FE:  DATA 63,72
00200:  DATA 65,61
00202:  DATA 74,69
00204:  DATA 6E,67
00206:  DATA 20,64
00208:  DATA 69,72
0020A:  DATA 65,63
0020C:  DATA 74,6F
0020E:  DATA 72,79
00210:  DATA 00,00
00212:  DATA 0D,0A
00214:  DATA 52,65
00216:  DATA 6D,6F
00218:  DATA 76,69
0021A:  DATA 6E,67
0021C:  DATA 20,64
0021E:  DATA 69,72
00220:  DATA 65,63
00222:  DATA 74,6F
00224:  DATA 72,79
00226:  DATA 20,27
00228:  DATA 25,73
0022A:  DATA 27,3A
0022C:  DATA 20,00
0022E:  DATA 45,72
00230:  DATA 72,6F
00232:  DATA 72,20
00234:  DATA 72,65
00236:  DATA 6D,6F
00238:  DATA 76,69
0023A:  DATA 6E,67
0023C:  DATA 20,64
0023E:  DATA 69,72
00240:  DATA 65,63
00242:  DATA 74,6F
00244:  DATA 72,79
00246:  DATA 00,00
00248:  DATA 0D,0A
0024A:  DATA 45,72
0024C:  DATA 72,6F
0024E:  DATA 72,20
00250:  DATA 6F,70
00252:  DATA 65,6E
00254:  DATA 69,6E
00256:  DATA 67,20
00258:  DATA 66,69
0025A:  DATA 6C,65
0025C:  DATA 00,00
0025E:  DATA 0D,0A
00260:  DATA 46,6F
00262:  DATA 72,6D
00264:  DATA 61,74
00266:  DATA 74,69
00268:  DATA 6E,67
0026A:  DATA 20,6D
0026C:  DATA 65,64
0026E:  DATA 69,61
00270:  DATA 20,28
00272:  DATA 73,69
00274:  DATA 7A,65
00276:  DATA 3D,25
00278:  DATA 4C,55
0027A:  DATA 29,3A
0027C:  DATA 20,00
0027E:  DATA 45,72
00280:  DATA 72,6F
00282:  DATA 72,20
00284:  DATA 66,6F
00286:  DATA 72,6D
00288:  DATA 61,74
0028A:  DATA 74,69
0028C:  DATA 6E,67
0028E:  DATA 20,6D
00290:  DATA 65,64
00292:  DATA 69,61
00294:  DATA 00,00
00296:  DATA 0D,0A
00298:  DATA 46,41
0029A:  DATA 54,20
0029C:  DATA 53,68
0029E:  DATA 65,6C
002A0:  DATA 6C,20
002A2:  DATA 48,65
002A4:  DATA 6C,70
002A6:  DATA 00,00
002A8:  DATA 0D,0A
002AA:  DATA 20,64
002AC:  DATA 65,6C
002AE:  DATA 20,66
002B0:  DATA 69,6C
002B2:  DATA 65,6E
002B4:  DATA 61,6D
002B6:  DATA 65,20
002B8:  DATA 2D,2D
002BA:  DATA 2D,20
002BC:  DATA 44,65
002BE:  DATA 6C,65
002C0:  DATA 74,65
002C2:  DATA 73,20
002C4:  DATA 74,68
002C6:  DATA 65,20
002C8:  DATA 66,69
002CA:  DATA 6C,65
002CC:  DATA 00,00
002CE:  DATA 0D,0A
002D0:  DATA 20,6D
002D2:  DATA 61,6B
002D4:  DATA 65,20
002D6:  DATA 66,69
002D8:  DATA 6C,65
002DA:  DATA 6E,61
002DC:  DATA 6D,65
002DE:  DATA 20,2D
002E0:  DATA 2D,2D
002E2:  DATA 20,43
002E4:  DATA 72,65
002E6:  DATA 61,74
002E8:  DATA 65,73
002EA:  DATA 20,61
002EC:  DATA 6E,20
002EE:  DATA 65,6D
002F0:  DATA 70,74
002F2:  DATA 79,20
002F4:  DATA 66,69
002F6:  DATA 6C,65
002F8:  DATA 00,00
002FA:  DATA 0D,0A
002FC:  DATA 20,61
002FE:  DATA 70,70
00300:  DATA 65,6E
00302:  DATA 64,20
00304:  DATA 66,69
00306:  DATA 6C,65
00308:  DATA 6E,61
0030A:  DATA 6D,65
0030C:  DATA 20,73
0030E:  DATA 74,72
00310:  DATA 69,6E
00312:  DATA 67,20
00314:  DATA 2D,2D
00316:  DATA 2D,20
00318:  DATA 41,70
0031A:  DATA 70,65
0031C:  DATA 6E,64
0031E:  DATA 73,20
00320:  DATA 73,74
00322:  DATA 72,69
00324:  DATA 6E,67
00326:  DATA 20,74
00328:  DATA 6F,20
0032A:  DATA 74,68
0032C:  DATA 65,20
0032E:  DATA 65,6E
00330:  DATA 64,20
00332:  DATA 6F,66
00334:  DATA 20,74
00336:  DATA 68,65
00338:  DATA 20,66
0033A:  DATA 69,6C
0033C:  DATA 65,00
0033E:  DATA 0D,0A
00340:  DATA 20,63
00342:  DATA 64,20
00344:  DATA 64,69
00346:  DATA 72,20
00348:  DATA 2D,2D
0034A:  DATA 2D,20
0034C:  DATA 43,68
0034E:  DATA 61,6E
00350:  DATA 67,65
00352:  DATA 20,74
00354:  DATA 68,65
00356:  DATA 20,77
00358:  DATA 6F,72
0035A:  DATA 6B,69
0035C:  DATA 6E,67
0035E:  DATA 20,64
00360:  DATA 69,72
00362:  DATA 65,63
00364:  DATA 74,6F
00366:  DATA 72,79
00368:  DATA 00,00
0036A:  DATA 0D,0A
0036C:  DATA 20,64
0036E:  DATA 69,72
00370:  DATA 20,2D
00372:  DATA 2D,2D
00374:  DATA 20,53
00376:  DATA 68,6F
00378:  DATA 77,73
0037A:  DATA 20,74
0037C:  DATA 68,65
0037E:  DATA 20,63
00380:  DATA 6F,6E
00382:  DATA 74,65
00384:  DATA 6E,74
00386:  DATA 73,20
00388:  DATA 6F,66
0038A:  DATA 20,74
0038C:  DATA 68,65
0038E:  DATA 20,64
00390:  DATA 69,72
00392:  DATA 65,63
00394:  DATA 74,6F
00396:  DATA 72,79
00398:  DATA 00,00
0039A:  DATA 0D,0A
0039C:  DATA 20,63
0039E:  DATA 61,74
003A0:  DATA 20,66
003A2:  DATA 69,6C
003A4:  DATA 65,6E
003A6:  DATA 61,6D
003A8:  DATA 65,20
003AA:  DATA 2D,2D
003AC:  DATA 2D,20
003AE:  DATA 44,69
003B0:  DATA 73,70
003B2:  DATA 6C,61
003B4:  DATA 79,73
003B6:  DATA 20,63
003B8:  DATA 6F,6E
003BA:  DATA 74,65
003BC:  DATA 6E,74
003BE:  DATA 20,6F
003C0:  DATA 66,20
003C2:  DATA 66,69
003C4:  DATA 6C,65
003C6:  DATA 00,00
003C8:  DATA 0D,0A
003CA:  DATA 20,74
003CC:  DATA 61,69
003CE:  DATA 6C,20
003D0:  DATA 66,69
003D2:  DATA 6C,65
003D4:  DATA 6E,61
003D6:  DATA 6D,65
003D8:  DATA 20,2D
003DA:  DATA 2D,2D
003DC:  DATA 20,44
003DE:  DATA 69,73
003E0:  DATA 70,6C
003E2:  DATA 61,79
003E4:  DATA 73,20
003E6:  DATA 74,68
003E8:  DATA 65,20
003EA:  DATA 6C,61
003EC:  DATA 73,74
003EE:  DATA 20,38
003F0:  DATA 30,20
003F2:  DATA 63,68
003F4:  DATA 61,72
003F6:  DATA 61,63
003F8:  DATA 74,65
003FA:  DATA 72,73
003FC:  DATA 20,6F
003FE:  DATA 66,20
00400:  DATA 66,69
00402:  DATA 6C,65
00404:  DATA 00,00
00406:  DATA 0D,0A
00408:  DATA 20,6D
0040A:  DATA 6B,64
0040C:  DATA 69,72
0040E:  DATA 20,64
00410:  DATA 69,72
00412:  DATA 20,2D
00414:  DATA 2D,2D
00416:  DATA 20,43
00418:  DATA 72,65
0041A:  DATA 61,74
0041C:  DATA 65,20
0041E:  DATA 61,20
00420:  DATA 64,69
00422:  DATA 72,65
00424:  DATA 63,74
00426:  DATA 6F,72
00428:  DATA 79,00
0042A:  DATA 0D,0A
0042C:  DATA 20,72
0042E:  DATA 6D,64
00430:  DATA 69,72
00432:  DATA 20,64
00434:  DATA 69,72
00436:  DATA 20,2D
00438:  DATA 2D,2D
0043A:  DATA 20,44
0043C:  DATA 65,6C
0043E:  DATA 65,74
00440:  DATA 65,73
00442:  DATA 20,74
00444:  DATA 68,65
00446:  DATA 20,64
00448:  DATA 69,72
0044A:  DATA 65,63
0044C:  DATA 74,6F
0044E:  DATA 72,79
00450:  DATA 00,00
00452:  DATA 0D,0A
00454:  DATA 20,66
00456:  DATA 6F,72
00458:  DATA 6D,61
0045A:  DATA 74,20
0045C:  DATA 73,69
0045E:  DATA 7A,65
00460:  DATA 20,2D
00462:  DATA 2D,2D
00464:  DATA 20,46
00466:  DATA 6F,72
00468:  DATA 6D,61
0046A:  DATA 74,20
0046C:  DATA 63,61
0046E:  DATA 72,64
00470:  DATA 2E,20
00472:  DATA 20,28
00474:  DATA 45,78
00476:  DATA 61,6D
00478:  DATA 70,6C
0047A:  DATA 65,3A
0047C:  DATA 20,27
0047E:  DATA 66,6F
00480:  DATA 72,6D
00482:  DATA 61,74
00484:  DATA 20,35
00486:  DATA 35,32
00488:  DATA 34,32
0048A:  DATA 38,38
0048C:  DATA 27,20
0048E:  DATA 66,6F
00490:  DATA 72,6D
00492:  DATA 61,74
00494:  DATA 73,20
00496:  DATA 61,20
00498:  DATA 35,31
0049A:  DATA 32,4D
0049C:  DATA 42,20
0049E:  DATA 63,61
004A0:  DATA 72,64
004A2:  DATA 29,00
004A4:  DATA 0D,0A
004A6:  DATA 20,68
004A8:  DATA 65,6C
004AA:  DATA 70,09
004AC:  DATA 59,6F
004AE:  DATA 75,20
004B0:  DATA 61,72
004B2:  DATA 65,20
004B4:  DATA 68,65
004B6:  DATA 72,65
004B8:  DATA 00,00
004BA:  DATA 0D,0A
004BC:  DATA 0A,20
004BE:  DATA 50,75
004C0:  DATA 74,20
004C2:  DATA 61,20
004C4:  DATA 70,61
004C6:  DATA 72,61
004C8:  DATA 6D,65
004CA:  DATA 74,65
004CC:  DATA 72,20
004CE:  DATA 69,6E
004D0:  DATA 20,71
004D2:  DATA 75,6F
004D4:  DATA 74,65
004D6:  DATA 73,20
004D8:  DATA 69,66
004DA:  DATA 20,69
004DC:  DATA 74,20
004DE:  DATA 68,61
004E0:  DATA 73,20
004E2:  DATA 73,70
004E4:  DATA 61,63
004E6:  DATA 65,73
004E8:  DATA 00,00
004EA:  DATA 0D,0A
004EC:  DATA 0A,45
004EE:  DATA 52,52
004F0:  DATA 4F,52
004F2:  DATA 20,49
004F4:  DATA 4E,49
004F6:  DATA 54,49
004F8:  DATA 41,4C
004FA:  DATA 49,5A
004FC:  DATA 49,4E
004FE:  DATA 47,20
00500:  DATA 46,41
00502:  DATA 54,0D
00504:  DATA 0A,0A
00506:  DATA 00,00
00508:  DATA 0D,0A
0050A:  DATA 55,6E
0050C:  DATA 6B,6F
0050E:  DATA 77,6E
00510:  DATA 20,43
00512:  DATA 6F,6D
00514:  DATA 6D,61
00516:  DATA 6E,64
00518:  DATA 20,27
0051A:  DATA 25,73
0051C:  DATA 27,00
*
00C98:  MOVLB  6
00C9A:  MOVF   x22,W
00C9C:  MULWF  x24
00C9E:  MOVFF  FF3,01
00CA2:  MOVFF  FF4,00
00CA6:  MULWF  x25
00CA8:  MOVF   FF3,W
00CAA:  ADDWF  00,F
00CAC:  MOVF   x23,W
00CAE:  MULWF  x24
00CB0:  MOVF   FF3,W
00CB2:  ADDWFC 00,W
00CB4:  MOVWF  02
00CB6:  MOVLB  0
00CB8:  RETURN 0
00CBA:  MOVLB  6
00CBC:  CLRF   xD9
00CBE:  CLRF   xDA
00CC0:  MOVLW  01
00CC2:  MOVWF  xDB
00CC4:  CLRF   FDA
00CC6:  CLRF   FD9
00CC8:  MOVLW  06
00CCA:  MOVWF  xDE
00CCC:  MOVLW  D1
00CCE:  MOVWF  xDD
00CD0:  MOVLW  06
00CD2:  MOVWF  FEA
00CD4:  MOVLW  D5
00CD6:  MOVWF  FE9
00CD8:  MOVFF  6DE,FE2
00CDC:  MOVFF  6DD,FE1
00CE0:  MOVFF  6DB,6DC
00CE4:  BCF    FD8.0
00CE6:  MOVF   FE5,W
00CE8:  MULWF  FEE
00CEA:  MOVF   FF3,W
00CEC:  ADDWFC xD9,F
00CEE:  MOVF   FF4,W
00CF0:  ADDWFC xDA,F
00CF2:  DECFSZ xDC,F
00CF4:  BRA    0CE4
00CF6:  MOVFF  6D9,FDE
00CFA:  MOVFF  6DA,6D9
00CFE:  CLRF   xDA
00D00:  BTFSC  FD8.0
00D02:  INCF   xDA,F
00D04:  INCF   xDD,F
00D06:  BTFSC  FD8.2
00D08:  INCF   xDE,F
00D0A:  INCF   xDB,F
00D0C:  MOVF   xDB,W
00D0E:  SUBLW  05
00D10:  BNZ   0CD0
00D12:  MOVLB  0
00D14:  RETURN 0
*
00F40:  TBLRD*+
00F42:  MOVF   FF5,F
00F44:  BZ    0F68
00F46:  MOVFF  FF6,5A2
00F4A:  MOVFF  FF7,5A3
00F4E:  MOVFF  FF8,5A4
00F52:  MOVF   FF5,W
00F54:  BTFSS  F9E.4
00F56:  BRA    0F54
00F58:  MOVWF  FAD
00F5A:  MOVFF  5A2,FF6
00F5E:  MOVFF  5A3,FF7
00F62:  MOVFF  5A4,FF8
00F66:  BRA    0F40
00F68:  RETURN 0
00F6A:  TBLRD*+
00F6C:  MOVFF  FF6,5C2
00F70:  MOVFF  FF7,5C3
00F74:  MOVFF  FF8,5C4
00F78:  MOVF   FF5,W
00F7A:  BTFSS  F9E.4
00F7C:  BRA    0F7A
00F7E:  MOVWF  FAD
00F80:  MOVFF  5C2,FF6
00F84:  MOVFF  5C3,FF7
00F88:  MOVFF  5C4,FF8
00F8C:  MOVLB  5
00F8E:  DECFSZ xC1,F
00F90:  BRA    0F94
00F92:  BRA    0F98
00F94:  MOVLB  0
00F96:  BRA    0F6A
00F98:  MOVLB  0
00F9A:  RETURN 0
00F9C:  MOVF   FEF,F
00F9E:  BZ    0FC0
00FA0:  MOVFF  FEA,5C2
00FA4:  MOVFF  FE9,5C1
00FA8:  MOVF   FEF,W
00FAA:  BTFSS  F9E.4
00FAC:  BRA    0FAA
00FAE:  MOVWF  FAD
00FB0:  MOVFF  5C2,FEA
00FB4:  MOVFF  5C1,FE9
00FB8:  INCF   FE9,F
00FBA:  BTFSC  FD8.2
00FBC:  INCF   FEA,F
00FBE:  BRA    0F9C
00FC0:  RETURN 0
*
015E2:  BTFSC  FD8.1
015E4:  BRA    15EE
015E6:  MOVLW  06
015E8:  MOVWF  FEA
015EA:  MOVLW  A7
015EC:  MOVWF  FE9
015EE:  CLRF   00
015F0:  CLRF   01
015F2:  CLRF   02
015F4:  CLRF   03
015F6:  MOVLB  6
015F8:  CLRF   xA7
015FA:  CLRF   xA8
015FC:  CLRF   xA9
015FE:  CLRF   xAA
01600:  MOVF   xA6,W
01602:  IORWF  xA5,W
01604:  IORWF  xA4,W
01606:  IORWF  xA3,W
01608:  BZ    1662
0160A:  MOVLW  20
0160C:  MOVWF  xAB
0160E:  BCF    FD8.0
01610:  RLCF   x9F,F
01612:  RLCF   xA0,F
01614:  RLCF   xA1,F
01616:  RLCF   xA2,F
01618:  RLCF   xA7,F
0161A:  RLCF   xA8,F
0161C:  RLCF   xA9,F
0161E:  RLCF   xAA,F
01620:  MOVF   xA6,W
01622:  SUBWF  xAA,W
01624:  BNZ   1636
01626:  MOVF   xA5,W
01628:  SUBWF  xA9,W
0162A:  BNZ   1636
0162C:  MOVF   xA4,W
0162E:  SUBWF  xA8,W
01630:  BNZ   1636
01632:  MOVF   xA3,W
01634:  SUBWF  xA7,W
01636:  BNC   1656
01638:  MOVF   xA3,W
0163A:  SUBWF  xA7,F
0163C:  MOVF   xA4,W
0163E:  BTFSS  FD8.0
01640:  INCFSZ xA4,W
01642:  SUBWF  xA8,F
01644:  MOVF   xA5,W
01646:  BTFSS  FD8.0
01648:  INCFSZ xA5,W
0164A:  SUBWF  xA9,F
0164C:  MOVF   xA6,W
0164E:  BTFSS  FD8.0
01650:  INCFSZ xA6,W
01652:  SUBWF  xAA,F
01654:  BSF    FD8.0
01656:  RLCF   00,F
01658:  RLCF   01,F
0165A:  RLCF   02,F
0165C:  RLCF   03,F
0165E:  DECFSZ xAB,F
01660:  BRA    160E
01662:  MOVFF  6A7,FEF
01666:  MOVFF  6A8,FEC
0166A:  MOVFF  6A9,FEC
0166E:  MOVFF  6AA,FEC
01672:  MOVLB  0
01674:  RETURN 0
*
03B70:  MOVFF  225,FEA
03B74:  MOVFF  224,FE9
03B78:  MOVLB  6
03B7A:  MOVFF  665,FEF
03B7E:  INCF   FE9,F
03B80:  BTFSC  FD8.2
03B82:  INCF   FEA,F
03B84:  CLRF   FEF
03B86:  MOVLB  2
03B88:  INCF   x24,F
03B8A:  BTFSC  FD8.2
03B8C:  INCF   x25,F
03B8E:  MOVLB  0
03B90:  RETURN 0
03B92:  MOVF   FE9,W
03B94:  MOVLB  6
03B96:  MOVWF  x5D
03B98:  MOVLW  3B
03B9A:  MOVWF  x64
03B9C:  MOVLW  9A
03B9E:  MOVWF  x63
03BA0:  MOVLW  CA
03BA2:  MOVWF  x62
03BA4:  CLRF   x61
03BA6:  MOVLW  0A
03BA8:  MOVWF  x5F
03BAA:  BSF    FD8.1
03BAC:  MOVLW  06
03BAE:  MOVWF  FEA
03BB0:  MOVLW  59
03BB2:  MOVWF  FE9
03BB4:  MOVFF  65C,6A2
03BB8:  MOVFF  65B,6A1
03BBC:  MOVFF  65A,6A0
03BC0:  MOVFF  659,69F
03BC4:  MOVFF  664,6A6
03BC8:  MOVFF  663,6A5
03BCC:  MOVFF  662,6A4
03BD0:  MOVFF  661,6A3
03BD4:  MOVLB  0
03BD6:  CALL   15E2
03BDA:  MOVF   01,W
03BDC:  MOVF   00,F
03BDE:  BNZ   3C06
03BE0:  MOVLB  6
03BE2:  MOVF   x5F,W
03BE4:  XORLW  01
03BE6:  BTFSS  FD8.2
03BE8:  BRA    3BEE
03BEA:  MOVLB  0
03BEC:  BRA    3C06
03BEE:  MOVF   x5D,W
03BF0:  BZ    3C0A
03BF2:  ANDLW  0F
03BF4:  SUBWF  x5F,W
03BF6:  BZ    3BFA
03BF8:  BC    3C18
03BFA:  BTFSC  x5D.7
03BFC:  BRA    3C18
03BFE:  BTFSC  x5D.6
03C00:  BRA    3C0A
03C02:  MOVLW  20
03C04:  BRA    3C0C
03C06:  MOVLB  6
03C08:  CLRF   x5D
03C0A:  MOVLW  30
03C0C:  ADDWF  00,F
03C0E:  MOVFF  00,665
03C12:  MOVLB  0
03C14:  RCALL  3B70
03C16:  MOVLB  6
03C18:  BCF    FD8.1
03C1A:  MOVFF  664,6A2
03C1E:  MOVFF  663,6A1
03C22:  MOVFF  662,6A0
03C26:  MOVFF  661,69F
03C2A:  CLRF   xA6
03C2C:  CLRF   xA5
03C2E:  CLRF   xA4
03C30:  MOVLW  0A
03C32:  MOVWF  xA3
03C34:  MOVLB  0
03C36:  CALL   15E2
03C3A:  MOVFF  03,664
03C3E:  MOVFF  02,663
03C42:  MOVFF  01,662
03C46:  MOVFF  00,661
03C4A:  MOVLB  6
03C4C:  DECFSZ x5F,F
03C4E:  BRA    3BAA
03C50:  MOVLB  0
03C52:  GOTO   3EE0 (RETURN)
*
0421C:  MOVLB  6
0421E:  MOVF   x26,W
04220:  XORWF  x27,W
04222:  ANDLW  80
04224:  MOVWF  x29
04226:  BTFSS  x26.7
04228:  BRA    422E
0422A:  COMF   x26,F
0422C:  INCF   x26,F
0422E:  BTFSS  x27.7
04230:  BRA    4236
04232:  COMF   x27,F
04234:  INCF   x27,F
04236:  MOVF   x27,W
04238:  CLRF   01
0423A:  SUBWF  x26,W
0423C:  BC    4244
0423E:  MOVFF  626,00
04242:  BRA    425C
04244:  CLRF   00
04246:  MOVLW  08
04248:  MOVWF  x28
0424A:  RLCF   x26,F
0424C:  RLCF   00,F
0424E:  MOVF   x27,W
04250:  SUBWF  00,W
04252:  BTFSC  FD8.0
04254:  MOVWF  00
04256:  RLCF   01,F
04258:  DECFSZ x28,F
0425A:  BRA    424A
0425C:  BTFSS  x29.7
0425E:  BRA    4264
04260:  COMF   01,F
04262:  INCF   01,F
04264:  MOVLB  0
04266:  RETURN 0
*
05BD6:  MOVF   FE9,W
05BD8:  MOVLB  5
05BDA:  MOVWF  x6B
05BDC:  MOVLW  3B
05BDE:  MOVWF  x72
05BE0:  MOVLW  9A
05BE2:  MOVWF  x71
05BE4:  MOVLW  CA
05BE6:  MOVWF  x70
05BE8:  CLRF   x6F
05BEA:  MOVLW  0A
05BEC:  MOVWF  x6D
05BEE:  BSF    FD8.1
05BF0:  MOVLW  05
05BF2:  MOVWF  FEA
05BF4:  MOVLW  67
05BF6:  MOVWF  FE9
05BF8:  MOVFF  56A,6A2
05BFC:  MOVFF  569,6A1
05C00:  MOVFF  568,6A0
05C04:  MOVFF  567,69F
05C08:  MOVFF  572,6A6
05C0C:  MOVFF  571,6A5
05C10:  MOVFF  570,6A4
05C14:  MOVFF  56F,6A3
05C18:  MOVLB  0
05C1A:  CALL   15E2
05C1E:  MOVF   01,W
05C20:  MOVF   00,F
05C22:  BNZ   5C4A
05C24:  MOVLB  5
05C26:  MOVF   x6D,W
05C28:  XORLW  01
05C2A:  BTFSS  FD8.2
05C2C:  BRA    5C32
05C2E:  MOVLB  0
05C30:  BRA    5C4A
05C32:  MOVF   x6B,W
05C34:  BZ    5C4E
05C36:  ANDLW  0F
05C38:  SUBWF  x6D,W
05C3A:  BZ    5C3E
05C3C:  BC    5C5A
05C3E:  BTFSC  x6B.7
05C40:  BRA    5C5A
05C42:  BTFSC  x6B.6
05C44:  BRA    5C4E
05C46:  MOVLW  20
05C48:  BRA    5C50
05C4A:  MOVLB  5
05C4C:  CLRF   x6B
05C4E:  MOVLW  30
05C50:  ADDWF  00,F
05C52:  MOVF   00,W
05C54:  BTFSS  F9E.4
05C56:  BRA    5C54
05C58:  MOVWF  FAD
05C5A:  BCF    FD8.1
05C5C:  MOVFF  572,6A2
05C60:  MOVFF  571,6A1
05C64:  MOVFF  570,6A0
05C68:  MOVFF  56F,69F
05C6C:  MOVLB  6
05C6E:  CLRF   xA6
05C70:  CLRF   xA5
05C72:  CLRF   xA4
05C74:  MOVLW  0A
05C76:  MOVWF  xA3
05C78:  MOVLB  0
05C7A:  CALL   15E2
05C7E:  MOVFF  03,572
05C82:  MOVFF  02,571
05C86:  MOVFF  01,570
05C8A:  MOVFF  00,56F
05C8E:  MOVLB  5
05C90:  DECFSZ x6D,F
05C92:  BRA    5BEE
05C94:  MOVLB  0
05C96:  GOTO   6304 (RETURN)
05C9A:  CLRF   01
05C9C:  CLRF   02
05C9E:  CLRF   00
05CA0:  CLRF   03
05CA2:  MOVLB  6
05CA4:  MOVF   x12,W
05CA6:  BNZ   5CAC
05CA8:  MOVF   x11,W
05CAA:  BZ    5CDC
05CAC:  MOVLW  10
05CAE:  MOVWF  x13
05CB0:  BCF    FD8.0
05CB2:  RLCF   x0F,F
05CB4:  RLCF   x10,F
05CB6:  RLCF   00,F
05CB8:  RLCF   03,F
05CBA:  MOVF   x12,W
05CBC:  SUBWF  03,W
05CBE:  BNZ   5CC4
05CC0:  MOVF   x11,W
05CC2:  SUBWF  00,W
05CC4:  BNC   5CD4
05CC6:  MOVF   x11,W
05CC8:  SUBWF  00,F
05CCA:  BTFSS  FD8.0
05CCC:  DECF   03,F
05CCE:  MOVF   x12,W
05CD0:  SUBWF  03,F
05CD2:  BSF    FD8.0
05CD4:  RLCF   01,F
05CD6:  RLCF   02,F
05CD8:  DECFSZ x13,F
05CDA:  BRA    5CB0
05CDC:  MOVLB  0
05CDE:  GOTO   5EB4 (RETURN)
05CE2:  MOVF   FEF,F
05CE4:  BZ    5D06
05CE6:  MOVFF  FEA,60E
05CEA:  MOVFF  FE9,60D
05CEE:  MOVFF  FEF,665
05CF2:  CALL   3B70
05CF6:  MOVFF  60E,FEA
05CFA:  MOVFF  60D,FE9
05CFE:  INCF   FE9,F
05D00:  BTFSC  FD8.2
05D02:  INCF   FEA,F
05D04:  BRA    5CE2
05D06:  RETURN 0
....................  
.................... #list 
....................  
.................... #device PASS_STRINGS = IN_RAM 
.................... #fuses NOWDT, HS, NOPROTECT 
.................... #use delay(clock=25M) 
*
0053A:  MOVLW  06
0053C:  MOVWF  FEA
0053E:  MOVLW  24
00540:  MOVWF  FE9
00542:  MOVF   FEF,W
00544:  BZ    0562
00546:  MOVLW  08
00548:  MOVWF  01
0054A:  CLRF   00
0054C:  DECFSZ 00,F
0054E:  BRA    054C
00550:  DECFSZ 01,F
00552:  BRA    054A
00554:  MOVLW  19
00556:  MOVWF  00
00558:  DECFSZ 00,F
0055A:  BRA    0558
0055C:  BRA    055E
0055E:  DECFSZ FEF,F
00560:  BRA    0546
00562:  RETURN 0
....................  
.................... #use rs232(baud=9600, UART1, errors) 
*
00FF6:  BTFSS  F9E.5
00FF8:  BRA    0FF6
00FFA:  MOVFF  FAB,04
00FFE:  MOVFF  FAE,01
01002:  BTFSS  04.1
01004:  BRA    100A
01006:  BCF    FAB.4
01008:  BSF    FAB.4
0100A:  GOTO   6556 (RETURN)
0100E:  BTFSS  F9E.4
01010:  BRA    100E
01012:  MOVWF  FAD
01014:  RETURN 0
....................  
.................... #include <stdlib.h> // for atoi32 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
012BC:  MOVFF  5A4,5A8
012C0:  MOVFF  5A3,5A7
012C4:  MOVFF  5A8,03
012C8:  MOVLB  5
012CA:  MOVFF  5A7,FE9
012CE:  MOVFF  5A8,FEA
012D2:  MOVF   FEF,F
012D4:  BZ    12E2
012D6:  INCF   xA7,F
012D8:  BTFSC  FD8.2
012DA:  INCF   xA8,F
012DC:  MOVLB  0
012DE:  BRA    12C4
012E0:  MOVLB  5
....................    while(*s2 != '\0') 
012E2:  MOVFF  5A6,03
012E6:  MOVFF  5A5,FE9
012EA:  MOVFF  5A6,FEA
012EE:  MOVF   FEF,F
012F0:  BZ    1318
....................    { 
....................       *s = *s2; 
012F2:  MOVFF  5A5,FE9
012F6:  MOVFF  5A6,FEA
012FA:  MOVFF  FEF,5AB
012FE:  MOVFF  5A8,FEA
01302:  MOVFF  5A7,FE9
01306:  MOVFF  5AB,FEF
....................       ++s; 
0130A:  INCF   xA7,F
0130C:  BTFSC  FD8.2
0130E:  INCF   xA8,F
....................       ++s2; 
01310:  INCF   xA5,F
01312:  BTFSC  FD8.2
01314:  INCF   xA6,F
01316:  BRA    12E2
....................    } 
....................  
....................    *s = '\0'; 
01318:  MOVFF  5A7,FE9
0131C:  MOVFF  5A8,FEA
01320:  CLRF   FEF
....................    return(s1); 
01322:  MOVFF  5A3,01
01326:  MOVFF  5A4,02
0132A:  MOVLB  0
0132C:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
01BC0:  MOVLB  6
01BC2:  MOVFF  679,FE9
01BC6:  MOVFF  67A,FEA
01BCA:  MOVFF  FEF,67D
01BCE:  MOVFF  67C,03
01BD2:  MOVFF  67B,FE9
01BD6:  MOVFF  67C,FEA
01BDA:  MOVF   FEF,W
01BDC:  SUBWF  x7D,W
01BDE:  BNZ   1C0A
....................       if (*s1 == '\0') 
01BE0:  MOVFF  67A,03
01BE4:  MOVFF  679,FE9
01BE8:  MOVFF  03,FEA
01BEC:  MOVF   FEF,F
01BEE:  BNZ   1BF6
....................          return(0); 
01BF0:  MOVLW  00
01BF2:  MOVWF  01
01BF4:  BRA    1C34
01BF6:  MOVFF  67A,03
01BFA:  MOVF   x79,W
01BFC:  INCF   x79,F
01BFE:  BTFSC  FD8.2
01C00:  INCF   x7A,F
01C02:  INCF   x7B,F
01C04:  BTFSC  FD8.2
01C06:  INCF   x7C,F
01C08:  BRA    1BC2
....................    return((*s1 < *s2) ? -1: 1); 
01C0A:  MOVFF  67A,03
01C0E:  MOVFF  679,FE9
01C12:  MOVFF  67A,FEA
01C16:  MOVFF  FEF,67D
01C1A:  MOVFF  67C,03
01C1E:  MOVFF  67B,FE9
01C22:  MOVFF  67C,FEA
01C26:  MOVF   FEF,W
01C28:  SUBWF  x7D,W
01C2A:  BC    1C30
01C2C:  MOVLW  FF
01C2E:  BRA    1C32
01C30:  MOVLW  01
01C32:  MOVWF  01
01C34:  MOVLB  0
01C36:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
03B2C:  MOVFF  65A,03
03B30:  MOVLB  6
03B32:  MOVFF  659,FE9
03B36:  MOVFF  65A,FEA
03B3A:  MOVF   x5B,W
03B3C:  SUBWF  FEF,W
03B3E:  BZ    3B64
....................       if (*s == '\0') 
03B40:  MOVFF  65A,03
03B44:  MOVFF  659,FE9
03B48:  MOVFF  65A,FEA
03B4C:  MOVF   FEF,F
03B4E:  BNZ   3B58
....................          return(0); 
03B50:  MOVLW  00
03B52:  MOVWF  01
03B54:  MOVWF  02
03B56:  BRA    3B6C
03B58:  INCF   x59,F
03B5A:  BTFSC  FD8.2
03B5C:  INCF   x5A,F
03B5E:  MOVLB  0
03B60:  BRA    3B2C
03B62:  MOVLB  6
....................    return(s); 
03B64:  MOVFF  659,01
03B68:  MOVFF  65A,02
03B6C:  MOVLB  0
03B6E:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
010A6:  MOVFF  576,57A
010AA:  MOVFF  575,579
010AE:  MOVFF  57A,03
010B2:  MOVLB  5
010B4:  MOVFF  579,FE9
010B8:  MOVFF  57A,FEA
010BC:  MOVF   FEF,F
010BE:  BZ    1114
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
010C0:  MOVFF  578,57C
010C4:  MOVFF  577,57B
010C8:  MOVFF  57C,03
010CC:  MOVFF  57B,FE9
010D0:  MOVFF  57C,FEA
010D4:  MOVF   FEF,F
010D6:  BZ    1108
....................          if (*sc1 == *sc2) 
010D8:  MOVFF  579,FE9
010DC:  MOVFF  57A,FEA
010E0:  MOVFF  FEF,57D
010E4:  MOVFF  57C,03
010E8:  MOVFF  57B,FE9
010EC:  MOVFF  57C,FEA
010F0:  MOVF   FEF,W
010F2:  SUBWF  x7D,W
010F4:  BNZ   1100
....................             return(sc1); 
010F6:  MOVFF  579,01
010FA:  MOVFF  57A,02
010FE:  BRA    111A
01100:  INCF   x7B,F
01102:  BTFSC  FD8.2
01104:  INCF   x7C,F
01106:  BRA    10C8
01108:  INCF   x79,F
0110A:  BTFSC  FD8.2
0110C:  INCF   x7A,F
0110E:  MOVLB  0
01110:  BRA    10AE
01112:  MOVLB  5
....................    return(0); 
01114:  MOVLW  00
01116:  MOVWF  01
01118:  MOVWF  02
0111A:  MOVLB  0
0111C:  GOTO   11C2 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
*
03A70:  MOVLB  5
03A72:  CLRF   xEE
03A74:  CLRF   xED
....................    { 
....................       if (*s == c) 
03A76:  MOVFF  5EB,03
03A7A:  MOVFF  5EA,FE9
03A7E:  MOVFF  5EB,FEA
03A82:  MOVF   xEC,W
03A84:  SUBWF  FEF,W
03A86:  BNZ   3A90
....................          p = s; 
03A88:  MOVFF  5EB,5EE
03A8C:  MOVFF  5EA,5ED
....................       if (*s == '\0') 
03A90:  MOVFF  5EB,03
03A94:  MOVFF  5EA,FE9
03A98:  MOVFF  5EB,FEA
03A9C:  MOVF   FEF,F
03A9E:  BNZ   3AAA
....................          return(p); 
03AA0:  MOVFF  5ED,01
03AA4:  MOVFF  5EE,02
03AA8:  BRA    3AB2
03AAA:  INCF   xEA,F
03AAC:  BTFSC  FD8.2
03AAE:  INCF   xEB,F
03AB0:  BRA    3A76
....................    } 
03AB2:  MOVLB  0
03AB4:  RETURN 0
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
01016:  MOVFF  576,57A
0101A:  MOVFF  575,579
0101E:  MOVFF  57A,03
01022:  MOVLB  5
01024:  MOVFF  579,FE9
01028:  MOVFF  57A,FEA
0102C:  MOVF   FEF,F
0102E:  BZ    1090
....................       for (sc2 = s2; ; sc2++) 
01030:  MOVFF  578,57C
01034:  MOVFF  577,57B
....................     if (*sc2 == '\0') 
01038:  MOVFF  57C,03
0103C:  MOVFF  57B,FE9
01040:  MOVFF  57C,FEA
01044:  MOVF   FEF,F
01046:  BNZ   105C
....................        return(sc1 - s1); 
01048:  MOVF   x75,W
0104A:  SUBWF  x79,W
0104C:  MOVWF  00
0104E:  MOVF   x76,W
01050:  SUBWFB x7A,W
01052:  MOVWF  03
01054:  MOVFF  00,01
01058:  BRA    10A0
0105A:  BRA    107C
....................          else if (*sc1 == *sc2) 
0105C:  MOVFF  579,FE9
01060:  MOVFF  57A,FEA
01064:  MOVFF  FEF,57D
01068:  MOVFF  57C,03
0106C:  MOVFF  57B,FE9
01070:  MOVFF  57C,FEA
01074:  MOVF   FEF,W
01076:  SUBWF  x7D,W
01078:  BNZ   107C
....................             break; 
0107A:  BRA    1084
0107C:  INCF   x7B,F
0107E:  BTFSC  FD8.2
01080:  INCF   x7C,F
01082:  BRA    1038
01084:  INCF   x79,F
01086:  BTFSC  FD8.2
01088:  INCF   x7A,F
0108A:  MOVLB  0
0108C:  BRA    101E
0108E:  MOVLB  5
....................    return(sc1 - s1); 
01090:  MOVF   x75,W
01092:  SUBWF  x79,W
01094:  MOVWF  00
01096:  MOVF   x76,W
01098:  SUBWFB x7A,W
0109A:  MOVWF  03
0109C:  MOVFF  00,01
010A0:  MOVLB  0
010A2:  GOTO   118C (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
04962:  MOVFF  5A4,03
04966:  MOVLB  5
04968:  MOVFF  5A3,FE9
0496C:  MOVFF  5A4,FEA
04970:  MOVF   FEF,F
04972:  BZ    49E6
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
04974:  MOVFF  5A4,5A8
04978:  MOVFF  5A3,5A7
0497C:  MOVFF  5A6,5AA
04980:  MOVFF  5A5,5A9
04984:  MOVFF  5AA,03
04988:  MOVFF  5A9,FE9
0498C:  MOVFF  5AA,FEA
04990:  MOVF   FEF,F
04992:  BZ    49C0
04994:  MOVFF  5A7,FE9
04998:  MOVFF  5A8,FEA
0499C:  MOVFF  FEF,5AB
049A0:  MOVFF  5AA,03
049A4:  MOVFF  5A9,FE9
049A8:  MOVFF  5AA,FEA
049AC:  MOVF   FEF,W
049AE:  SUBWF  xAB,W
049B0:  BNZ   49C0
049B2:  INCF   xA7,F
049B4:  BTFSC  FD8.2
049B6:  INCF   xA8,F
049B8:  INCF   xA9,F
049BA:  BTFSC  FD8.2
049BC:  INCF   xAA,F
049BE:  BRA    4984
....................  
....................       if (*t == '\0') 
049C0:  MOVFF  5AA,03
049C4:  MOVFF  5A9,FE9
049C8:  MOVFF  03,FEA
049CC:  MOVF   FEF,F
049CE:  BNZ   49DA
....................          return s1; 
049D0:  MOVFF  5A3,01
049D4:  MOVFF  5A4,02
049D8:  BRA    49EC
....................       ++s1; 
049DA:  INCF   xA3,F
049DC:  BTFSC  FD8.2
049DE:  INCF   xA4,F
....................       #ifdef FASTER_BUT_MORE_ROM 
049E0:  MOVLB  0
049E2:  BRA    4962
049E4:  MOVLB  5
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
049E6:  MOVLW  00
049E8:  MOVWF  01
049EA:  MOVWF  02
049EC:  MOVLB  0
049EE:  GOTO   4A60 (RETURN)
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
01120:  MOVFF  692,694
01124:  MOVFF  691,693
01128:  MOVFF  694,03
0112C:  MOVLB  6
0112E:  MOVFF  693,FE9
01132:  MOVFF  694,FEA
01136:  MOVF   FEF,F
01138:  BZ    1146
0113A:  INCF   x93,F
0113C:  BTFSC  FD8.2
0113E:  INCF   x94,F
01140:  MOVLB  0
01142:  BRA    1128
01144:  MOVLB  6
....................    return(sc - s); 
01146:  MOVF   x91,W
01148:  SUBWF  x93,W
0114A:  MOVWF  00
0114C:  MOVF   x92,W
0114E:  SUBWFB x94,W
01150:  MOVWF  03
01152:  MOVFF  00,01
01156:  MOVWF  02
01158:  MOVLB  0
0115A:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
0115C:  MOVLB  5
0115E:  MOVF   x6D,W
01160:  IORWF  x6E,W
01162:  BZ    116C
01164:  MOVFF  56E,03
01168:  MOVF   x6D,W
0116A:  BRA    1172
0116C:  MOVFF  06,03
01170:  MOVF   05,W
01172:  MOVWF  x71
01174:  MOVFF  03,572
....................    beg += strspn(beg, s2); 
01178:  MOVFF  572,576
0117C:  MOVFF  571,575
01180:  MOVFF  570,578
01184:  MOVFF  56F,577
01188:  MOVLB  0
0118A:  BRA    1016
0118C:  MOVF   01,W
0118E:  MOVLB  5
01190:  ADDWF  x71,F
01192:  MOVLW  00
01194:  ADDWFC x72,F
....................    if (*beg == '\0') 
01196:  MOVFF  572,03
0119A:  MOVFF  571,FE9
0119E:  MOVFF  572,FEA
011A2:  MOVF   FEF,F
011A4:  BNZ   11AE
....................       return(0); 
011A6:  MOVLW  00
011A8:  MOVWF  01
011AA:  MOVWF  02
011AC:  BRA    1210
....................        
....................    end = strpbrk(beg, s2); 
011AE:  MOVFF  572,576
011B2:  MOVFF  571,575
011B6:  MOVFF  570,578
011BA:  MOVFF  56F,577
011BE:  MOVLB  0
011C0:  BRA    10A6
011C2:  MOVFF  02,574
011C6:  MOVFF  01,573
....................    if (end != '\0') 
011CA:  MOVLB  5
011CC:  MOVF   x73,F
011CE:  BNZ   11D4
011D0:  MOVF   x74,F
011D2:  BZ    11EE
....................    { 
....................       *end = '\0'; 
011D4:  MOVFF  573,FE9
011D8:  MOVFF  574,FEA
011DC:  CLRF   FEF
....................       end++; 
011DE:  INCF   x73,F
011E0:  BTFSC  FD8.2
011E2:  INCF   x74,F
....................       save = end; 
011E4:  MOVFF  574,06
011E8:  MOVFF  573,05
....................    } 
011EC:  BRA    1208
....................    else 
....................       save = beg + strlen(beg); 
011EE:  MOVFF  572,692
011F2:  MOVFF  571,691
011F6:  MOVLB  0
011F8:  RCALL  1120
011FA:  MOVF   01,W
011FC:  MOVLB  5
011FE:  ADDWF  x71,W
01200:  MOVWF  05
01202:  MOVF   02,W
01204:  ADDWFC x72,W
01206:  MOVWF  06
....................     
....................    return(beg); 
01208:  MOVFF  571,01
0120C:  MOVFF  572,02
01210:  MOVLB  0
01212:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
0132E:  MOVLB  5
01330:  MOVFF  56E,FE9
01334:  MOVFF  56F,FEA
01338:  MOVFF  FEF,572
0133C:  MOVFF  571,03
01340:  MOVFF  570,FE9
01344:  MOVFF  571,FEA
01348:  MOVF   FEF,W
0134A:  SUBWF  x72,W
0134C:  BZ    13DE
0134E:  MOVFF  56F,03
01352:  MOVFF  56E,FE9
01356:  MOVFF  56F,FEA
0135A:  MOVFF  FEF,572
0135E:  MOVF   x72,W
01360:  SUBLW  40
01362:  BC    136A
01364:  MOVF   x72,W
01366:  SUBLW  5A
01368:  BC    1376
0136A:  MOVF   x72,W
0136C:  SUBLW  60
0136E:  BC    1408
01370:  MOVF   x72,W
01372:  SUBLW  7A
01374:  BNC   1408
01376:  MOVFF  571,03
0137A:  MOVFF  570,FE9
0137E:  MOVFF  571,FEA
01382:  MOVFF  FEF,572
01386:  MOVF   x72,W
01388:  SUBLW  40
0138A:  BC    1392
0138C:  MOVF   x72,W
0138E:  SUBLW  5A
01390:  BC    139E
01392:  MOVF   x72,W
01394:  SUBLW  60
01396:  BC    1408
01398:  MOVF   x72,W
0139A:  SUBLW  7A
0139C:  BNC   1408
0139E:  MOVFF  56E,FE9
013A2:  MOVFF  56F,FEA
013A6:  MOVFF  FEF,572
013AA:  MOVFF  571,03
013AE:  MOVFF  570,FE9
013B2:  MOVFF  571,FEA
013B6:  MOVLW  20
013B8:  ADDWF  FEF,W
013BA:  SUBWF  x72,W
013BC:  BZ    13DE
013BE:  MOVFF  570,FE9
013C2:  MOVFF  571,FEA
013C6:  MOVFF  FEF,572
013CA:  MOVFF  56F,03
013CE:  MOVFF  56E,FE9
013D2:  MOVFF  56F,FEA
013D6:  MOVLW  20
013D8:  ADDWF  FEF,W
013DA:  SUBWF  x72,W
013DC:  BNZ   1408
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
013DE:  MOVFF  56F,03
013E2:  MOVFF  56E,FE9
013E6:  MOVFF  56F,FEA
013EA:  MOVF   FEF,F
013EC:  BNZ   13F4
....................        return(0); 
013EE:  MOVLW  00
013F0:  MOVWF  01
013F2:  BRA    1432
013F4:  MOVFF  56F,03
013F8:  MOVF   x6E,W
013FA:  INCF   x6E,F
013FC:  BTFSC  FD8.2
013FE:  INCF   x6F,F
01400:  INCF   x70,F
01402:  BTFSC  FD8.2
01404:  INCF   x71,F
01406:  BRA    1330
....................  return((*s1 < *s2) ? -1: 1); 
01408:  MOVFF  56F,03
0140C:  MOVFF  56E,FE9
01410:  MOVFF  56F,FEA
01414:  MOVFF  FEF,572
01418:  MOVFF  571,03
0141C:  MOVFF  570,FE9
01420:  MOVFF  571,FEA
01424:  MOVF   FEF,W
01426:  SUBWF  x72,W
01428:  BC    142E
0142A:  MOVLW  FF
0142C:  BRA    1430
0142E:  MOVLW  01
01430:  MOVWF  01
01432:  MOVLB  0
01434:  GOTO   148A (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
05940:  MOVLB  5
05942:  CLRF   x6F
....................    sign = 0; 
05944:  CLRF   x6D
....................    base = 10; 
05946:  MOVLW  0A
05948:  MOVWF  x6E
....................    result = 0; 
0594A:  CLRF   x6C
0594C:  CLRF   x6B
0594E:  CLRF   x6A
05950:  CLRF   x69
....................  
....................    if (!s) 
05952:  MOVF   x67,W
05954:  IORWF  x68,W
05956:  BNZ   5962
....................       return 0; 
05958:  CLRF   00
0595A:  CLRF   01
0595C:  CLRF   02
0595E:  CLRF   03
05960:  BRA    5BD0
....................    c = s[index++]; 
05962:  MOVF   x6F,W
05964:  INCF   x6F,F
05966:  ADDWF  x67,W
05968:  MOVWF  FE9
0596A:  MOVLW  00
0596C:  ADDWFC x68,W
0596E:  MOVWF  FEA
05970:  MOVFF  FEF,570
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
05974:  MOVF   x70,W
05976:  SUBLW  2D
05978:  BNZ   5992
....................    { 
....................       sign = 1;         // Set the sign to negative 
0597A:  MOVLW  01
0597C:  MOVWF  x6D
....................       c = s[index++]; 
0597E:  MOVF   x6F,W
05980:  INCF   x6F,F
05982:  ADDWF  x67,W
05984:  MOVWF  FE9
05986:  MOVLW  00
05988:  ADDWFC x68,W
0598A:  MOVWF  FEA
0598C:  MOVFF  FEF,570
....................    } 
05990:  BRA    59AA
....................    else if (c == '+') 
05992:  MOVF   x70,W
05994:  SUBLW  2B
05996:  BNZ   59AA
....................    { 
....................       c = s[index++]; 
05998:  MOVF   x6F,W
0599A:  INCF   x6F,F
0599C:  ADDWF  x67,W
0599E:  MOVWF  FE9
059A0:  MOVLW  00
059A2:  ADDWFC x68,W
059A4:  MOVWF  FEA
059A6:  MOVFF  FEF,570
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
059AA:  MOVF   x70,W
059AC:  SUBLW  2F
059AE:  BTFSC  FD8.0
059B0:  BRA    5BA0
059B2:  MOVF   x70,W
059B4:  SUBLW  39
059B6:  BTFSS  FD8.0
059B8:  BRA    5BA0
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
059BA:  MOVF   x70,W
059BC:  SUBLW  30
059BE:  BNZ   59FC
059C0:  MOVF   x6F,W
059C2:  ADDWF  x67,W
059C4:  MOVWF  FE9
059C6:  MOVLW  00
059C8:  ADDWFC x68,W
059CA:  MOVWF  FEA
059CC:  MOVF   FEF,W
059CE:  SUBLW  78
059D0:  BZ    59E4
059D2:  MOVF   x6F,W
059D4:  ADDWF  x67,W
059D6:  MOVWF  FE9
059D8:  MOVLW  00
059DA:  ADDWFC x68,W
059DC:  MOVWF  FEA
059DE:  MOVF   FEF,W
059E0:  SUBLW  58
059E2:  BNZ   59FC
....................       { 
....................          base = 16; 
059E4:  MOVLW  10
059E6:  MOVWF  x6E
....................          index++; 
059E8:  INCF   x6F,F
....................          c = s[index++]; 
059EA:  MOVF   x6F,W
059EC:  INCF   x6F,F
059EE:  ADDWF  x67,W
059F0:  MOVWF  FE9
059F2:  MOVLW  00
059F4:  ADDWFC x68,W
059F6:  MOVWF  FEA
059F8:  MOVFF  FEF,570
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
059FC:  MOVF   x6E,W
059FE:  SUBLW  0A
05A00:  BNZ   5A88
....................       { 
....................          while (c >= '0' && c <= '9') { 
05A02:  MOVF   x70,W
05A04:  SUBLW  2F
05A06:  BC    5A86
05A08:  MOVF   x70,W
05A0A:  SUBLW  39
05A0C:  BNC   5A86
....................             result = (result << 1) + (result << 3);  // result *= 10; 
05A0E:  BCF    FD8.0
05A10:  RLCF   x69,W
05A12:  MOVWF  x72
05A14:  RLCF   x6A,W
05A16:  MOVWF  x73
05A18:  RLCF   x6B,W
05A1A:  MOVWF  x74
05A1C:  RLCF   x6C,W
05A1E:  MOVWF  x75
05A20:  RLCF   x69,W
05A22:  MOVWF  00
05A24:  RLCF   x6A,W
05A26:  MOVWF  01
05A28:  RLCF   x6B,W
05A2A:  MOVWF  02
05A2C:  RLCF   x6C,W
05A2E:  MOVWF  03
05A30:  RLCF   00,F
05A32:  RLCF   01,F
05A34:  RLCF   02,F
05A36:  RLCF   03,F
05A38:  RLCF   00,F
05A3A:  RLCF   01,F
05A3C:  RLCF   02,F
05A3E:  RLCF   03,F
05A40:  MOVLW  F8
05A42:  ANDWF  00,F
05A44:  MOVF   x72,W
05A46:  ADDWF  00,F
05A48:  MOVF   x73,W
05A4A:  ADDWFC 01,F
05A4C:  MOVF   x74,W
05A4E:  ADDWFC 02,F
05A50:  MOVF   x75,W
05A52:  ADDWFC 03,F
05A54:  MOVFF  03,56C
05A58:  MOVFF  02,56B
05A5C:  MOVFF  01,56A
05A60:  MOVFF  00,569
....................             result += (c - '0'); 
05A64:  MOVLW  30
05A66:  SUBWF  x70,W
05A68:  ADDWF  x69,F
05A6A:  MOVLW  00
05A6C:  ADDWFC x6A,F
05A6E:  ADDWFC x6B,F
05A70:  ADDWFC x6C,F
....................             c = s[index++]; 
05A72:  MOVF   x6F,W
05A74:  INCF   x6F,F
05A76:  ADDWF  x67,W
05A78:  MOVWF  FE9
05A7A:  MOVLW  00
05A7C:  ADDWFC x68,W
05A7E:  MOVWF  FEA
05A80:  MOVFF  FEF,570
05A84:  BRA    5A02
....................          } 
....................       } 
05A86:  BRA    5BA0
....................       else if (base == 16)    // The number is a hexa number 
05A88:  MOVF   x6E,W
05A8A:  SUBLW  10
05A8C:  BTFSS  FD8.2
05A8E:  BRA    5BA0
....................       { 
....................          c = toupper(c); 
05A90:  MOVF   x70,W
05A92:  SUBLW  60
05A94:  BC    5AA2
05A96:  MOVF   x70,W
05A98:  SUBLW  7A
05A9A:  BNC   5AA2
05A9C:  MOVF   x70,W
05A9E:  ANDLW  DF
05AA0:  BRA    5AA4
05AA2:  MOVF   x70,W
05AA4:  MOVWF  x70
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
05AA6:  MOVF   x70,W
05AA8:  SUBLW  2F
05AAA:  BC    5AB2
05AAC:  MOVF   x70,W
05AAE:  SUBLW  39
05AB0:  BC    5AC0
05AB2:  MOVF   x70,W
05AB4:  SUBLW  40
05AB6:  BTFSC  FD8.0
05AB8:  BRA    5BA0
05ABA:  MOVF   x70,W
05ABC:  SUBLW  46
05ABE:  BNC   5BA0
....................          { 
....................             if (c >= '0' && c <= '9') 
05AC0:  MOVF   x70,W
05AC2:  SUBLW  2F
05AC4:  BC    5B22
05AC6:  MOVF   x70,W
05AC8:  SUBLW  39
05ACA:  BNC   5B22
....................                result = (result << 4) + (c - '0'); 
05ACC:  RLCF   x69,W
05ACE:  MOVWF  x72
05AD0:  RLCF   x6A,W
05AD2:  MOVWF  x73
05AD4:  RLCF   x6B,W
05AD6:  MOVWF  x74
05AD8:  RLCF   x6C,W
05ADA:  MOVWF  x75
05ADC:  RLCF   x72,F
05ADE:  RLCF   x73,F
05AE0:  RLCF   x74,F
05AE2:  RLCF   x75,F
05AE4:  RLCF   x72,F
05AE6:  RLCF   x73,F
05AE8:  RLCF   x74,F
05AEA:  RLCF   x75,F
05AEC:  RLCF   x72,F
05AEE:  RLCF   x73,F
05AF0:  RLCF   x74,F
05AF2:  RLCF   x75,F
05AF4:  MOVLW  F0
05AF6:  ANDWF  x72,F
05AF8:  MOVLW  30
05AFA:  SUBWF  x70,W
05AFC:  ADDWF  x72,W
05AFE:  MOVWF  00
05B00:  MOVLW  00
05B02:  ADDWFC x73,W
05B04:  MOVWF  01
05B06:  MOVLW  00
05B08:  ADDWFC x74,W
05B0A:  MOVWF  02
05B0C:  MOVLW  00
05B0E:  ADDWFC x75,W
05B10:  MOVWF  03
05B12:  MOVWF  x6C
05B14:  MOVFF  02,56B
05B18:  MOVFF  01,56A
05B1C:  MOVFF  00,569
05B20:  BRA    5B76
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
05B22:  RLCF   x69,W
05B24:  MOVWF  x72
05B26:  RLCF   x6A,W
05B28:  MOVWF  x73
05B2A:  RLCF   x6B,W
05B2C:  MOVWF  x74
05B2E:  RLCF   x6C,W
05B30:  MOVWF  x75
05B32:  RLCF   x72,F
05B34:  RLCF   x73,F
05B36:  RLCF   x74,F
05B38:  RLCF   x75,F
05B3A:  RLCF   x72,F
05B3C:  RLCF   x73,F
05B3E:  RLCF   x74,F
05B40:  RLCF   x75,F
05B42:  RLCF   x72,F
05B44:  RLCF   x73,F
05B46:  RLCF   x74,F
05B48:  RLCF   x75,F
05B4A:  MOVLW  F0
05B4C:  ANDWF  x72,F
05B4E:  MOVLW  41
05B50:  SUBWF  x70,W
05B52:  ADDLW  0A
05B54:  ADDWF  x72,W
05B56:  MOVWF  00
05B58:  MOVLW  00
05B5A:  ADDWFC x73,W
05B5C:  MOVWF  01
05B5E:  MOVLW  00
05B60:  ADDWFC x74,W
05B62:  MOVWF  02
05B64:  MOVLW  00
05B66:  ADDWFC x75,W
05B68:  MOVWF  x6C
05B6A:  MOVFF  02,56B
05B6E:  MOVFF  01,56A
05B72:  MOVFF  00,569
....................  
....................             c = s[index++];c = toupper(c); 
05B76:  MOVF   x6F,W
05B78:  INCF   x6F,F
05B7A:  ADDWF  x67,W
05B7C:  MOVWF  FE9
05B7E:  MOVLW  00
05B80:  ADDWFC x68,W
05B82:  MOVWF  FEA
05B84:  MOVFF  FEF,570
05B88:  MOVF   x70,W
05B8A:  SUBLW  60
05B8C:  BC    5B9A
05B8E:  MOVF   x70,W
05B90:  SUBLW  7A
05B92:  BNC   5B9A
05B94:  MOVF   x70,W
05B96:  ANDLW  DF
05B98:  BRA    5B9C
05B9A:  MOVF   x70,W
05B9C:  MOVWF  x70
05B9E:  BRA    5AA6
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
05BA0:  MOVF   x6E,W
05BA2:  SUBLW  0A
05BA4:  BNZ   5BC0
05BA6:  DECFSZ x6D,W
05BA8:  BRA    5BC0
....................       result = -result; 
05BAA:  COMF   x69,F
05BAC:  COMF   x6A,F
05BAE:  COMF   x6B,F
05BB0:  COMF   x6C,F
05BB2:  INCF   x69,F
05BB4:  BTFSC  FD8.2
05BB6:  INCF   x6A,F
05BB8:  BTFSC  FD8.2
05BBA:  INCF   x6B,F
05BBC:  BTFSC  FD8.2
05BBE:  INCF   x6C,F
....................  
....................    return(result); 
05BC0:  MOVFF  569,00
05BC4:  MOVFF  56A,01
05BC8:  MOVFF  56B,02
05BCC:  MOVFF  56C,03
05BD0:  MOVLB  0
05BD2:  GOTO   62C6 (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //media library, a compatable media library is required for FAT. 
.................... #use fast_io(c) 
.................... #define MMCSD_PIN_SCL     PIN_C3 //o 
.................... #define MMCSD_PIN_SDI     PIN_C4 //i 
.................... #define MMCSD_PIN_SDO     PIN_C5 //o 
.................... #define MMCSD_PIN_SELECT  PIN_C2 //o 
.................... #include "mmcsd.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           MMCSD.c                               //// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_SPI_XFER 
....................    #if defined(MMCSD_SPI_HW) 
....................       #use spi(MASTER, MMCSD_SPI_HW, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
....................    #else 
....................       #ifndef MMCSD_PIN_SCL 
....................          #define MMCSD_PIN_SCL     PIN_C3 //o 
....................          #define MMCSD_PIN_SDI     PIN_C4 //i 
....................          #define MMCSD_PIN_SDO     PIN_C5 //o 
....................          #define MMCSD_PIN_SELECT  PIN_C2 //o 
....................       #endif 
....................     
....................       #use spi(MASTER, DI=MMCSD_PIN_SDI, DO=MMCSD_PIN_SDO, CLK=MMCSD_PIN_SCL, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
*
0051E:  MOVF   FC9,W
00520:  MOVFF  706,FC9
00524:  RRCF   FC7,W
00526:  BNC   0524
00528:  MOVFF  FC9,01
0052C:  RETURN 0
....................    #endif 
....................     
....................    #define MMCSD_SPI_XFER(x)  spi_xfer(mmcsd_spi, x) 
.................... #endif 
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
....................  
.................... enum _card_type{SD, MMC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length); 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1; 
....................  
....................    g_CRC_enabled = TRUE; 
*
008F8:  MOVLB  2
008FA:  BSF    x0B.0
....................    g_mmcsdBufferAddress = 0; 
008FC:  CLRF   x0F
008FE:  CLRF   x0E
00900:  CLRF   x0D
00902:  CLRF   x0C
....................  
....................   #if defined(MMCSD_PIN_SCL) 
....................    output_drive(MMCSD_PIN_SCL); 
00904:  BCF    F94.3
....................   #endif 
....................   #if defined(MMCSD_PIN_SDO) 
....................    output_drive(MMCSD_PIN_SDO); 
00906:  BCF    F94.5
....................   #endif 
....................    output_drive(MMCSD_PIN_SELECT); 
00908:  BCF    F94.2
....................   #if defined(MMCSD_PIN_SDI) 
....................    output_float(MMCSD_PIN_SDI); 
0090A:  BSF    F94.4
....................   #endif 
....................  
....................    mmcsd_deselect(); 
0090C:  MOVLB  0
0090E:  RCALL  052E
....................    delay_ms(15); 
00910:  MOVLW  0F
00912:  MOVLB  6
00914:  MOVWF  x24
00916:  MOVLB  0
00918:  RCALL  053A
....................        
....................    /* begin initialization */ 
....................    i = 0; 
0091A:  MOVLB  6
0091C:  CLRF   x22
....................    do 
....................    { 
....................       delay_ms(1); 
0091E:  MOVLW  01
00920:  MOVWF  x24
00922:  MOVLB  0
00924:  RCALL  053A
....................       mmcsd_select();       
00926:  RCALL  0564
....................       r1=mmcsd_go_idle_state(); 
00928:  BRA    065E
0092A:  MOVFF  01,623
....................       mmcsd_deselect(); 
0092E:  RCALL  052E
....................       i++; 
00930:  MOVLB  6
00932:  INCF   x22,F
....................       if(i == 0xFF) 
00934:  INCFSZ x22,W
00936:  BRA    0944
....................       { 
....................          mmcsd_deselect(); 
00938:  MOVLB  0
0093A:  RCALL  052E
....................          return r1; 
0093C:  MOVLB  6
0093E:  MOVFF  623,01
00942:  BRA    09F8
....................       } 
....................    } while(!bit_test(r1, 0)); 
00944:  BTFSS  x23.0
00946:  BRA    091E
....................  
....................    i = 0; 
00948:  CLRF   x22
....................    do 
....................    { 
....................       delay_ms(1); 
0094A:  MOVLW  01
0094C:  MOVWF  x24
0094E:  MOVLB  0
00950:  RCALL  053A
....................       mmcsd_select(); 
00952:  RCALL  0564
....................       r1=mmcsd_send_op_cond(); 
00954:  BRA    0676
00956:  MOVFF  01,623
....................       mmcsd_deselect(); 
0095A:  RCALL  052E
....................       i++; 
0095C:  MOVLB  6
0095E:  INCF   x22,F
....................       if(i == 0xFF) 
00960:  INCFSZ x22,W
00962:  BRA    0970
....................       { 
....................          mmcsd_deselect(); 
00964:  MOVLB  0
00966:  RCALL  052E
....................          return r1; 
00968:  MOVLB  6
0096A:  MOVFF  623,01
0096E:  BRA    09F8
....................       } 
....................    } while(r1 & MMCSD_IDLE); 
00970:  BTFSC  x23.0
00972:  BRA    094A
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    mmcsd_select(); 
00974:  MOVLB  0
00976:  RCALL  0564
....................    r1=mmcsd_app_cmd(); 
00978:  BRA    0690
0097A:  MOVFF  01,623
....................    r1=mmcsd_sd_send_op_cond(); 
0097E:  BRA    06AA
00980:  MOVFF  01,623
....................    mmcsd_deselect(); 
00984:  RCALL  052E
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
00986:  MOVLB  6
00988:  MOVF   x23,W
0098A:  SUBLW  04
0098C:  BNZ   0996
....................       g_card_type = MMC; 
0098E:  MOVLB  2
00990:  BSF    x0B.2
00992:  BRA    099A
00994:  MOVLB  6
....................    else 
....................       g_card_type = SD; 
00996:  MOVLB  2
00998:  BCF    x0B.2
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
0099A:  MOVLB  0
0099C:  RCALL  0564
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
0099E:  MOVLB  6
009A0:  CLRF   x27
009A2:  CLRF   x26
009A4:  MOVLW  02
009A6:  MOVWF  x25
009A8:  CLRF   x24
009AA:  MOVLB  0
009AC:  BRA    06C4
009AE:  MOVFF  01,623
....................    if(r1 != MMCSD_GOODEC) 
009B2:  MOVLB  6
009B4:  MOVF   x23,F
009B6:  BZ    09C4
....................    { 
....................       mmcsd_deselect(); 
009B8:  MOVLB  0
009BA:  RCALL  052E
....................       return r1; 
009BC:  MOVLB  6
009BE:  MOVFF  623,01
009C2:  BRA    09F8
....................    } 
....................    mmcsd_deselect(); 
009C4:  MOVLB  0
009C6:  RCALL  052E
....................  
.................... /// this would be a good time to set a higher clock speed, 20MHz 
.................... #if defined(MMCSD_SPI_HW) 
....................    #if (getenv("CLOCK") <= 80000000) 
....................       #define MMC_SPI_CLK_DIV SPI_CLK_DIV_4 
....................    #else 
....................       #if defined(SPI_CLK_DIV_8) 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_8 
....................       #else 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_16 
....................       #endif 
....................    #endif 
....................    #error/warning the next line will only work if using SPI1 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | MMC_SPI_CLK_DIV); 
.................... #endif 
....................  
....................    /* turn CRCs off to speed up reading/writing */ 
....................    mmcsd_select(); 
009C8:  RCALL  0564
....................    r1 = mmcsd_crc_on_off(0); 
009CA:  MOVLB  6
009CC:  CLRF   x24
009CE:  MOVLB  0
009D0:  BRA    06E6
009D2:  MOVFF  01,623
....................    if(r1 != MMCSD_GOODEC) 
009D6:  MOVLB  6
009D8:  MOVF   x23,F
009DA:  BZ    09E8
....................    { 
....................       mmcsd_deselect(); 
009DC:  MOVLB  0
009DE:  RCALL  052E
....................       return r1; 
009E0:  MOVLB  6
009E2:  MOVFF  623,01
009E6:  BRA    09F8
....................    } 
....................    mmcsd_deselect(); 
009E8:  MOVLB  0
009EA:  RCALL  052E
....................  
....................    r1 = mmcsd_load_buffer(); 
009EC:  RCALL  08CE
009EE:  MOVFF  01,623
....................  
....................    return r1; 
009F2:  MOVLB  6
009F4:  MOVFF  623,01
009F8:  MOVLB  0
009FA:  GOTO   0D1E (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
00C10:  MOVLB  6
00C12:  CLRF   xBE
00C14:  CLRF   xBD
00C16:  MOVF   xBE,W
00C18:  SUBWF  xB9,W
00C1A:  BNC   0C90
00C1C:  BNZ   0C24
00C1E:  MOVF   xB8,W
00C20:  SUBWF  xBD,W
00C22:  BC    0C90
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
00C24:  MOVFF  6B7,6C8
00C28:  MOVFF  6B6,02
00C2C:  MOVFF  6B5,01
00C30:  MOVFF  6B4,00
00C34:  MOVLW  01
00C36:  ADDWF  xB4,F
00C38:  BTFSC  FD8.0
00C3A:  INCF   xB5,F
00C3C:  BTFSC  FD8.2
00C3E:  INCF   xB6,F
00C40:  BTFSC  FD8.2
00C42:  INCF   xB7,F
00C44:  MOVFF  02,6C1
00C48:  MOVFF  01,6C0
00C4C:  MOVFF  00,6BF
00C50:  MOVFF  6BB,03
00C54:  MOVF   xBA,W
00C56:  INCF   xBA,F
00C58:  BTFSC  FD8.2
00C5A:  INCF   xBB,F
00C5C:  MOVWF  xC3
00C5E:  MOVFF  03,6C4
00C62:  MOVFF  02,6C7
00C66:  MOVFF  01,6C6
00C6A:  MOVFF  00,6C5
00C6E:  MOVFF  03,6CA
00C72:  MOVWF  xC9
00C74:  MOVLB  0
00C76:  BRA    0BBE
00C78:  MOVFF  01,6BC
....................       if(r1 != MMCSD_GOODEC) 
00C7C:  MOVLB  6
00C7E:  MOVF   xBC,F
00C80:  BZ    0C88
....................          return r1; 
00C82:  MOVFF  6BC,01
00C86:  BRA    0C94
00C88:  INCF   xBD,F
00C8A:  BTFSC  FD8.2
00C8C:  INCF   xBE,F
00C8E:  BRA    0C16
....................    } 
....................     
....................    return MMCSD_GOODEC; 
00C90:  MOVLW  00
00C92:  MOVWF  01
00C94:  MOVLB  0
00C96:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
007D2:  RCALL  0564
....................    ec = mmcsd_read_single_block(address); 
007D4:  MOVFF  6EF,6FA
007D8:  MOVFF  6EE,6F9
007DC:  MOVFF  6ED,6F8
007E0:  MOVFF  6EC,6F7
007E4:  BRA    0714
007E6:  MOVFF  01,6F4
....................    if(ec != MMCSD_GOODEC) 
007EA:  MOVLB  6
007EC:  MOVF   xF4,F
007EE:  BZ    07FC
....................    { 
....................       mmcsd_deselect(); 
007F0:  MOVLB  0
007F2:  RCALL  052E
....................       return ec; 
007F4:  MOVLB  6
007F6:  MOVFF  6F4,01
007FA:  BRA    08C8
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
007FC:  MOVLW  FE
007FE:  MOVWF  xF7
00800:  MOVLB  0
00802:  BRA    0736
00804:  MOVFF  01,6F4
....................    if(ec != MMCSD_GOODEC) 
00808:  MOVLB  6
0080A:  MOVF   xF4,F
0080C:  BZ    081A
....................    { 
....................       mmcsd_deselect(); 
0080E:  MOVLB  0
00810:  RCALL  052E
....................       return ec; 
00812:  MOVLB  6
00814:  MOVFF  6F4,01
00818:  BRA    08C8
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
0081A:  CLRF   xF6
0081C:  CLRF   xF5
0081E:  MOVF   xF6,W
00820:  SUBWF  xF1,W
00822:  BNC   0852
00824:  BNZ   082C
00826:  MOVF   xF0,W
00828:  SUBWF  xF5,W
0082A:  BC    0852
....................       ptr[i] = MMCSD_SPI_XFER(0xFF); 
0082C:  MOVF   xF2,W
0082E:  ADDWF  xF5,W
00830:  MOVWF  FE9
00832:  MOVF   xF3,W
00834:  ADDWFC xF6,W
00836:  MOVWF  FEA
00838:  MOVLB  7
0083A:  SETF   x06
0083C:  MOVLB  0
0083E:  RCALL  051E
00840:  MOVF   01,W
00842:  MOVFF  01,FEF
00846:  MOVLW  01
00848:  MOVLB  6
0084A:  ADDWF  xF5,F
0084C:  MOVLW  00
0084E:  ADDWFC xF6,F
00850:  BRA    081E
....................  
....................    if(g_CRC_enabled) 
00852:  MOVLB  2
00854:  BTFSS  x0B.0
00856:  BRA    08AC
....................    { 
....................       /* check the crc */ 
....................       if(make16(MMCSD_SPI_XFER(0xFF), MMCSD_SPI_XFER(0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
00858:  MOVLB  7
0085A:  SETF   x06
0085C:  MOVLB  0
0085E:  RCALL  051E
00860:  MOVF   01,W
00862:  MOVFF  01,6F7
00866:  MOVLB  7
00868:  SETF   x06
0086A:  MOVLB  0
0086C:  RCALL  051E
0086E:  MOVF   01,W
00870:  MOVFF  01,6F8
00874:  MOVFF  6F7,6FA
00878:  MOVFF  01,6F9
0087C:  MOVLB  6
0087E:  CLRF   xFC
00880:  MOVLW  0B
00882:  MOVWF  xFB
00884:  CLRF   xFD
00886:  MOVLB  0
00888:  RCALL  0754
0088A:  MOVFF  02,03
0088E:  MOVF   01,W
00890:  MOVLB  6
00892:  SUBWF  xF9,W
00894:  BNZ   089C
00896:  MOVF   03,W
00898:  SUBWF  xFA,W
0089A:  BZ    08A8
....................       { 
....................          mmcsd_deselect(); 
0089C:  MOVLB  0
0089E:  RCALL  052E
....................          return MMCSD_CRC_ERR; 
008A0:  MOVLW  08
008A2:  MOVWF  01
008A4:  MOVLB  6
008A6:  BRA    08C8
....................       } 
....................    } 
008A8:  BRA    08BE
008AA:  MOVLB  2
....................    else 
....................    { 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       MMCSD_SPI_XFER(0xFF); 
008AC:  MOVLB  7
008AE:  SETF   x06
008B0:  MOVLB  0
008B2:  RCALL  051E
....................       MMCSD_SPI_XFER(0xFF); 
008B4:  MOVLB  7
008B6:  SETF   x06
008B8:  MOVLB  0
008BA:  RCALL  051E
008BC:  MOVLB  6
....................    } 
....................    mmcsd_deselect(); 
008BE:  MOVLB  0
008C0:  RCALL  052E
....................  
....................    return MMCSD_GOODEC; 
008C2:  MOVLW  00
008C4:  MOVWF  01
008C6:  MOVLB  6
008C8:  MOVLB  0
008CA:  GOTO   08F4 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
01D02:  MOVLB  6
01D04:  CLRF   xD7
01D06:  CLRF   xD6
01D08:  MOVF   xD7,W
01D0A:  SUBWF  xD2,W
01D0C:  BNC   1D80
01D0E:  BNZ   1D16
01D10:  MOVF   xD1,W
01D12:  SUBWF  xD6,W
01D14:  BC    1D80
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
01D16:  MOVFF  6D0,6E0
01D1A:  MOVFF  6CF,02
01D1E:  MOVFF  6CE,01
01D22:  MOVFF  6CD,00
01D26:  MOVLW  01
01D28:  ADDWF  xCD,F
01D2A:  BTFSC  FD8.0
01D2C:  INCF   xCE,F
01D2E:  BTFSC  FD8.2
01D30:  INCF   xCF,F
01D32:  BTFSC  FD8.2
01D34:  INCF   xD0,F
01D36:  MOVFF  02,6DA
01D3A:  MOVFF  01,6D9
01D3E:  MOVFF  00,6D8
01D42:  MOVFF  6D4,03
01D46:  MOVF   xD3,W
01D48:  INCF   xD3,F
01D4A:  BTFSC  FD8.2
01D4C:  INCF   xD4,F
01D4E:  MOVWF  FE9
01D50:  MOVFF  03,FEA
01D54:  MOVFF  FEF,6E1
01D58:  MOVFF  02,6DF
01D5C:  MOVFF  01,6DE
01D60:  MOVFF  00,6DD
01D64:  MOVLB  0
01D66:  BRA    1CB4
01D68:  MOVFF  01,6D5
....................       if(ec != MMCSD_GOODEC) 
01D6C:  MOVLB  6
01D6E:  MOVF   xD5,F
01D70:  BZ    1D78
....................          return ec; 
01D72:  MOVFF  6D5,01
01D76:  BRA    1D84
01D78:  INCF   xD6,F
01D7A:  BTFSC  FD8.2
01D7C:  INCF   xD7,F
01D7E:  BRA    1D08
....................    } 
....................     
....................    return MMCSD_GOODEC; 
01D80:  MOVLW  00
01D82:  MOVWF  01
01D84:  MOVLB  0
01D86:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
00A20:  RCALL  0564
....................    ec = mmcsd_write_single_block(address); 
00A22:  MOVFF  6EF,6FA
00A26:  MOVFF  6EE,6F9
00A2A:  MOVFF  6ED,6F8
00A2E:  MOVFF  6EC,6F7
00A32:  BRA    09FE
00A34:  MOVFF  01,6F4
....................    if(ec != MMCSD_GOODEC) 
00A38:  MOVLB  6
00A3A:  MOVF   xF4,F
00A3C:  BZ    0A4A
....................    { 
....................       mmcsd_deselect(); 
00A3E:  MOVLB  0
00A40:  RCALL  052E
....................       return ec; 
00A42:  MOVLB  6
00A44:  MOVFF  6F4,01
00A48:  BRA    0AF4
....................    } 
....................     
....................    // send a data start token 
....................    MMCSD_SPI_XFER(DATA_START_TOKEN); 
00A4A:  MOVLW  FE
00A4C:  MOVLB  7
00A4E:  MOVWF  x06
00A50:  MOVLB  0
00A52:  RCALL  051E
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
00A54:  MOVLB  6
00A56:  CLRF   xF6
00A58:  CLRF   xF5
00A5A:  MOVF   xF6,W
00A5C:  SUBWF  xF1,W
00A5E:  BNC   0A88
00A60:  BNZ   0A68
00A62:  MOVF   xF0,W
00A64:  SUBWF  xF5,W
00A66:  BC    0A88
....................    { 
....................       MMCSD_SPI_XFER(ptr[i]); 
00A68:  MOVF   xF2,W
00A6A:  ADDWF  xF5,W
00A6C:  MOVWF  FE9
00A6E:  MOVF   xF3,W
00A70:  ADDWFC xF6,W
00A72:  MOVWF  FEA
00A74:  MOVFF  FEF,706
00A78:  MOVLB  0
00A7A:  RCALL  051E
00A7C:  MOVLW  01
00A7E:  MOVLB  6
00A80:  ADDWF  xF5,F
00A82:  MOVLW  00
00A84:  ADDWFC xF6,F
00A86:  BRA    0A5A
....................    } 
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
....................    if(g_CRC_enabled) 
00A88:  MOVLB  2
00A8A:  BTFSS  x0B.0
00A8C:  BRA    0AB0
....................       MMCSD_SPI_XFER(mmcsd_crc16(ptr, size)); 
00A8E:  MOVFF  6F3,6FC
00A92:  MOVFF  6F2,6FB
00A96:  MOVFF  6F0,6FD
00A9A:  MOVLB  0
00A9C:  RCALL  0754
00A9E:  MOVFF  02,6F8
00AA2:  MOVFF  01,6F7
00AA6:  MOVFF  01,706
00AAA:  RCALL  051E
00AAC:  BRA    0AC0
00AAE:  MOVLB  2
....................    else 
....................    { 
....................       MMCSD_SPI_XFER(0xFF); 
00AB0:  MOVLB  7
00AB2:  SETF   x06
00AB4:  MOVLB  0
00AB6:  RCALL  051E
....................       MMCSD_SPI_XFER(0xFF); 
00AB8:  MOVLB  7
00ABA:  SETF   x06
00ABC:  MOVLB  0
00ABE:  RCALL  051E
....................    } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
00AC0:  RCALL  062C
00AC2:  MOVFF  01,6F4
....................    if(ec & 0x0A) 
00AC6:  MOVLB  6
00AC8:  MOVF   xF4,W
00ACA:  ANDLW  0A
00ACC:  BZ    0ADA
....................    { 
....................       mmcsd_deselect(); 
00ACE:  MOVLB  0
00AD0:  RCALL  052E
....................       return ec; 
00AD2:  MOVLB  6
00AD4:  MOVFF  6F4,01
00AD8:  BRA    0AF4
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(MMCSD_SPI_XFER(0xFF) == 0); 
00ADA:  MOVLB  7
00ADC:  SETF   x06
00ADE:  MOVLB  0
00AE0:  RCALL  051E
00AE2:  MOVF   01,W
00AE4:  BTFSS  FD8.2
00AE6:  BRA    0AEC
00AE8:  MOVLB  6
00AEA:  BRA    0ADA
....................    mmcsd_deselect(); 
00AEC:  RCALL  052E
....................  
....................    return MMCSD_GOODEC; 
00AEE:  MOVLW  00
00AF0:  MOVWF  01
00AF2:  MOVLB  6
00AF4:  MOVLB  0
00AF6:  GOTO   0B24 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
0065E:  MOVLB  6
00660:  CLRF   xFB
00662:  CLRF   xFF
00664:  CLRF   xFE
00666:  CLRF   xFD
00668:  CLRF   xFC
0066A:  MOVLB  0
0066C:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
0066E:  RCALL  062C
00670:  MOVF   01,W
00672:  GOTO   092A (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
00676:  MOVLW  01
00678:  MOVLB  6
0067A:  MOVWF  xFB
0067C:  CLRF   xFF
0067E:  CLRF   xFE
00680:  CLRF   xFD
00682:  CLRF   xFC
00684:  MOVLB  0
00686:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
00688:  RCALL  062C
0068A:  MOVF   01,W
0068C:  GOTO   0956 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x45A); 
....................  
....................    return mmcsd_get_r7(r7); 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       MMCSD_SPI_XFER(0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
006C4:  MOVLW  10
006C6:  MOVLB  6
006C8:  MOVWF  xFB
006CA:  MOVFF  627,6FF
006CE:  MOVFF  626,6FE
006D2:  MOVFF  625,6FD
006D6:  MOVFF  624,6FC
006DA:  MOVLB  0
006DC:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
006DE:  RCALL  062C
006E0:  MOVF   01,W
006E2:  GOTO   09AE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
00714:  MOVLW  11
00716:  MOVLB  6
00718:  MOVWF  xFB
0071A:  MOVFF  6FA,6FF
0071E:  MOVFF  6F9,6FE
00722:  MOVFF  6F8,6FD
00726:  MOVFF  6F7,6FC
0072A:  MOVLB  0
0072C:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
0072E:  RCALL  062C
00730:  MOVF   01,W
00732:  GOTO   07E6 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
009FE:  MOVLW  18
00A00:  MOVLB  6
00A02:  MOVWF  xFB
00A04:  MOVFF  6FA,6FF
00A08:  MOVFF  6F9,6FE
00A0C:  MOVFF  6F8,6FD
00A10:  MOVFF  6F7,6FC
00A14:  MOVLB  0
00A16:  RCALL  05BC
....................    
....................    return mmcsd_get_r1(); 
00A18:  RCALL  062C
00A1A:  MOVF   01,W
00A1C:  GOTO   0A34 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0); 
*
006AA:  MOVLW  29
006AC:  MOVLB  6
006AE:  MOVWF  xFB
006B0:  CLRF   xFF
006B2:  CLRF   xFE
006B4:  CLRF   xFD
006B6:  CLRF   xFC
006B8:  MOVLB  0
006BA:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
006BC:  RCALL  062C
006BE:  MOVF   01,W
006C0:  GOTO   0980 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
00690:  MOVLW  37
00692:  MOVLB  6
00694:  MOVWF  xFB
00696:  CLRF   xFF
00698:  CLRF   xFE
0069A:  CLRF   xFD
0069C:  CLRF   xFC
0069E:  MOVLB  0
006A0:  RCALL  05BC
....................     
....................    return mmcsd_get_r1(); 
006A2:  RCALL  062C
006A4:  MOVF   01,W
006A6:  GOTO   097A (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
....................     
....................    return mmcsd_get_r3(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
006E6:  MOVLW  3B
006E8:  MOVLB  6
006EA:  MOVWF  xFB
006EC:  CLRF   xFF
006EE:  CLRF   xFE
006F0:  CLRF   xFD
006F2:  MOVFF  624,6FC
006F6:  MOVLB  0
006F8:  RCALL  05BC
....................     
....................    g_CRC_enabled = crc_enabled; 
006FA:  MOVLB  2
006FC:  BCF    x0B.0
006FE:  MOVLB  6
00700:  BTFSS  x24.0
00702:  BRA    070A
00704:  MOVLB  2
00706:  BSF    x0B.0
00708:  MOVLB  6
....................     
....................    return mmcsd_get_r1(); 
0070A:  MOVLB  0
0070C:  RCALL  062C
0070E:  MOVF   01,W
00710:  GOTO   09D2 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................    
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
005BC:  MOVLB  6
005BE:  MOVF   xFB,W
005C0:  IORLW  40
005C2:  MOVLB  7
005C4:  MOVWF  x00
....................    packet[1] = make8(arg, 3); 
005C6:  MOVFF  6FF,701
005CA:  MOVLB  7
....................    packet[2] = make8(arg, 2); 
005CC:  MOVFF  6FE,702
005D0:  MOVLB  7
....................    packet[3] = make8(arg, 1); 
005D2:  MOVFF  6FD,703
005D6:  MOVLB  7
....................    packet[4] = make8(arg, 0); 
005D8:  MOVFF  6FC,704
005DC:  MOVLB  7
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
005DE:  MOVLB  2
005E0:  BTFSS  x0B.0
005E2:  BRA    05FC
....................       packet[5] = mmcsd_crc7(packet, 5); 
005E4:  MOVLW  07
005E6:  MOVLB  7
005E8:  MOVWF  x07
005EA:  CLRF   x06
005EC:  MOVLW  05
005EE:  MOVWF  x08
005F0:  MOVLB  0
005F2:  BRA    0568
005F4:  MOVFF  01,705
005F8:  BRA    0602
005FA:  MOVLB  2
....................    else 
....................       packet[5] = 0xFF; 
005FC:  MOVLB  7
005FE:  SETF   x05
00600:  MOVLB  0
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    MMCSD_SPI_XFER(packet[0]); 
00602:  MOVFF  700,706
00606:  RCALL  051E
....................    MMCSD_SPI_XFER(packet[1]); 
00608:  MOVFF  701,706
0060C:  RCALL  051E
....................    MMCSD_SPI_XFER(packet[2]); 
0060E:  MOVFF  702,706
00612:  RCALL  051E
....................    MMCSD_SPI_XFER(packet[3]); 
00614:  MOVFF  703,706
00618:  RCALL  051E
....................    MMCSD_SPI_XFER(packet[4]); 
0061A:  MOVFF  704,706
0061E:  RCALL  051E
....................    MMCSD_SPI_XFER(packet[5]); 
00620:  MOVFF  705,706
00624:  RCALL  051E
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
00626:  MOVLW  00
00628:  MOVWF  01
0062A:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
0062C:  MOVLB  6
0062E:  CLRF   xFB
00630:  SETF   xFC
.................... { 
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
00632:  MOVF   xFC,F
00634:  BZ    0656
....................    { 
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = MMCSD_SPI_XFER(0xFF); 
00636:  MOVLB  7
00638:  SETF   x06
0063A:  MOVLB  0
0063C:  RCALL  051E
0063E:  MOVF   01,W
00640:  MOVFF  01,6FB
....................       //response = MMCSD_SPI_XFER(0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
00644:  MOVLB  6
00646:  INCFSZ xFB,W
00648:  BRA    064C
0064A:  BRA    0652
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
0064C:  MOVFF  6FB,01
00650:  BRA    065A
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
00652:  DECF   xFC,F
00654:  BRA    0632
....................    } 
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
00656:  MOVLW  80
00658:  MOVWF  01
0065A:  MOVLB  0
0065C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = MMCSD_SPI_XFER(0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
....................       r7[3 - i] = MMCSD_SPI_XFER(0xFF); 
....................  
....................    return r7[4]; 
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
00736:  RCALL  062C
00738:  MOVFF  01,6F8
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
0073C:  MOVLB  6
0073E:  MOVF   xF7,W
00740:  SUBWF  xF8,W
00742:  BNZ   074A
....................       return MMCSD_GOODEC; 
00744:  MOVLW  00
00746:  MOVWF  01
00748:  BRA    074E
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
0074A:  MOVFF  6F8,01
0074E:  MOVLB  0
00750:  GOTO   0804 (RETURN)
.................... } 
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
00568:  MOVLB  7
0056A:  CLRF   x0C
....................  
....................    for (i = 0; i < length; i++, data++) 
0056C:  CLRF   x09
0056E:  MOVF   x08,W
00570:  SUBWF  x09,W
00572:  BC    05AE
....................    { 
....................       c = *data; 
00574:  MOVFF  706,FE9
00578:  MOVFF  707,FEA
0057C:  MOVFF  FEF,70B
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
00580:  CLRF   x0A
00582:  MOVF   x0A,W
00584:  SUBLW  07
00586:  BNC   05A0
....................       { 
....................          crc = crc << 1; 
00588:  BCF    FD8.0
0058A:  RLCF   x0C,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
0058C:  MOVF   x0B,W
0058E:  XORWF  x0C,W
00590:  ANDLW  80
00592:  BZ    0598
00594:  MOVLW  09
00596:  XORWF  x0C,F
....................          c = c << 1; 
00598:  BCF    FD8.0
0059A:  RLCF   x0B,F
0059C:  INCF   x0A,F
0059E:  BRA    0582
....................       } 
....................  
....................        crc = crc & 0x7F; 
005A0:  BCF    x0C.7
005A2:  MOVF   x09,W
005A4:  INCF   x09,F
005A6:  INCF   x06,F
005A8:  BTFSC  FD8.2
005AA:  INCF   x07,F
005AC:  BRA    056E
....................    } 
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
005AE:  BSF    FD8.0
005B0:  RLCF   x0C,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
005B2:  MOVFF  70C,01
005B6:  MOVLB  0
005B8:  GOTO   05F4 (RETURN)
.................... } 
....................  
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
*
00754:  MOVLB  7
00756:  CLRF   x02
00758:  CLRF   x01
....................  
....................    for (i = 0; i < length; i++, data++) 
0075A:  MOVLB  6
0075C:  CLRF   xFE
0075E:  MOVF   xFD,W
00760:  SUBWF  xFE,W
00762:  BC    07BE
....................    { 
....................       c = *data; 
00764:  MOVFF  6FB,FE9
00768:  MOVFF  6FC,FEA
0076C:  MOVFF  FEF,700
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
00770:  CLRF   xFF
00772:  MOVF   xFF,W
00774:  SUBLW  07
00776:  BNC   07AC
....................       { 
....................          crc = crc << 1; 
00778:  BCF    FD8.0
0077A:  MOVLB  7
0077C:  RLCF   x01,F
0077E:  RLCF   x02,F
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
00780:  MOVF   x00,W
00782:  XORWF  x01,W
00784:  MOVWF  x03
00786:  MOVF   x02,W
00788:  MOVWF  x04
0078A:  ANDLW  00
0078C:  MOVWF  00
0078E:  MOVF   x04,W
00790:  ANDLW  80
00792:  MOVWF  03
00794:  MOVF   00,W
00796:  IORWF  03,W
00798:  BZ    07A2
0079A:  MOVLW  21
0079C:  XORWF  x01,F
0079E:  MOVLW  10
007A0:  XORWF  x02,F
....................          c = c << 1; 
007A2:  BCF    FD8.0
007A4:  RLCF   x00,F
007A6:  MOVLB  6
007A8:  INCF   xFF,F
007AA:  BRA    0772
....................       } 
....................  
....................        crc = crc & 0x7FFF; 
007AC:  MOVLB  7
007AE:  BCF    x02.7
007B0:  MOVLB  6
007B2:  MOVF   xFE,W
007B4:  INCF   xFE,F
007B6:  INCF   xFB,F
007B8:  BTFSC  FD8.2
007BA:  INCF   xFC,F
007BC:  BRA    075E
....................    } 
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
007BE:  BSF    FD8.0
007C0:  MOVLB  7
007C2:  RLCF   x01,F
007C4:  RLCF   x02,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
007C6:  MOVFF  701,01
007CA:  MOVFF  702,02
007CE:  MOVLB  0
007D0:  RETURN 0
.................... } 
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
00564:  BCF    F8B.2
00566:  RETURN 0
.................... } 
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    MMCSD_SPI_XFER(0xFF); 
*
0052E:  MOVLB  7
00530:  SETF   x06
00532:  MOVLB  0
00534:  RCALL  051E
....................    output_high(MMCSD_PIN_SELECT); 
00536:  BSF    F8B.2
00538:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
008CE:  MOVLB  2
008D0:  BCF    x0B.1
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
008D2:  MOVFF  20F,6EF
008D6:  MOVFF  20E,6EE
008DA:  MOVFF  20D,6ED
008DE:  MOVFF  20C,6EC
008E2:  MOVLW  02
008E4:  MOVLB  6
008E6:  MOVWF  xF1
008E8:  CLRF   xF0
008EA:  CLRF   xF3
008EC:  MOVLW  0B
008EE:  MOVWF  xF2
008F0:  MOVLB  0
008F2:  BRA    07D2
008F4:  MOVF   01,W
008F6:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
00AFA:  MOVLB  2
00AFC:  BTFSS  x0B.1
00AFE:  BRA    0B2A
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
00B00:  BCF    x0B.1
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
00B02:  MOVFF  20F,6EF
00B06:  MOVFF  20E,6EE
00B0A:  MOVFF  20D,6ED
00B0E:  MOVFF  20C,6EC
00B12:  MOVLW  02
00B14:  MOVLB  6
00B16:  MOVWF  xF1
00B18:  CLRF   xF0
00B1A:  CLRF   xF3
00B1C:  MOVLW  0B
00B1E:  MOVWF  xF2
00B20:  MOVLB  0
00B22:  BRA    0A20
00B24:  MOVF   01,W
00B26:  BRA    0B30
00B28:  MOVLB  2
....................    } 
....................    return(0);  //ok 
00B2A:  MOVLW  00
00B2C:  MOVWF  01
00B2E:  MOVLB  0
00B30:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
00B32:  MOVLB  6
00B34:  CLRF   xE7
.................... { 
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
00B36:  MOVF   xE4,W
00B38:  ANDLW  01
00B3A:  MOVWF  01
00B3C:  CLRF   02
00B3E:  CLRF   03
00B40:  MOVF   xE3,W
00B42:  SUBWF  xE3,W
00B44:  MOVWF  xE8
00B46:  MOVF   01,W
00B48:  SUBWFB xE4,W
00B4A:  MOVWF  xE9
00B4C:  MOVF   02,W
00B4E:  SUBWFB xE5,W
00B50:  MOVWF  xEA
00B52:  MOVF   03,W
00B54:  SUBWFB xE6,W
00B56:  MOVWF  xEB
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
00B58:  MOVF   xE8,W
00B5A:  MOVLB  2
00B5C:  SUBWF  x0C,W
00B5E:  BNZ   0B7E
00B60:  MOVLB  6
00B62:  MOVF   xE9,W
00B64:  MOVLB  2
00B66:  SUBWF  x0D,W
00B68:  BNZ   0B7E
00B6A:  MOVLB  6
00B6C:  MOVF   xEA,W
00B6E:  MOVLB  2
00B70:  SUBWF  x0E,W
00B72:  BNZ   0B7E
00B74:  MOVLB  6
00B76:  MOVF   xEB,W
00B78:  MOVLB  2
00B7A:  SUBWF  x0F,W
00B7C:  BZ    0BB4
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
00B7E:  BTFSS  x0B.1
00B80:  BRA    0B9A
....................       { 
....................          ec = mmcsd_flush_buffer(); 
00B82:  MOVLB  0
00B84:  RCALL  0AFA
00B86:  MOVFF  01,6E7
....................          if(ec != MMCSD_GOODEC) 
00B8A:  MOVLB  6
00B8C:  MOVF   xE7,F
00B8E:  BZ    0B96
....................             return ec; 
00B90:  MOVFF  6E7,01
00B94:  BRA    0BBA
....................          g_MMCSDBufferChanged = FALSE; 
00B96:  MOVLB  2
00B98:  BCF    x0B.1
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
00B9A:  MOVFF  6EB,20F
00B9E:  MOVFF  6EA,20E
00BA2:  MOVFF  6E9,20D
00BA6:  MOVFF  6E8,20C
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
00BAA:  MOVLB  0
00BAC:  RCALL  08CE
00BAE:  MOVFF  01,6E7
00BB2:  MOVLB  2
....................    } 
....................     
....................    return ec; 
00BB4:  MOVLB  6
00BB6:  MOVFF  6E7,01
00BBA:  MOVLB  0
00BBC:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
00BBE:  MOVFF  6C8,6E6
00BC2:  MOVFF  6C7,6E5
00BC6:  MOVFF  6C6,6E4
00BCA:  MOVFF  6C5,6E3
00BCE:  RCALL  0B32
00BD0:  MOVFF  01,6CB
....................    if(ec != MMCSD_GOODEC) 
00BD4:  MOVLB  6
00BD6:  MOVF   xCB,F
00BD8:  BZ    0BE0
....................    { 
....................      return ec; 
00BDA:  MOVFF  6CB,01
00BDE:  BRA    0C0A
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
00BE0:  MOVF   xC6,W
00BE2:  ANDLW  01
00BE4:  MOVWF  xCF
00BE6:  CLRF   xD0
00BE8:  CLRF   xD1
00BEA:  MOVLW  0B
00BEC:  ADDWF  xC5,W
00BEE:  MOVWF  FE9
00BF0:  MOVLW  00
00BF2:  ADDWFC xCF,W
00BF4:  MOVWF  FEA
00BF6:  MOVFF  FEF,6D2
00BFA:  MOVFF  6CA,FEA
00BFE:  MOVFF  6C9,FE9
00C02:  MOVFF  6D2,FEF
....................  
....................    return MMCSD_GOODEC; 
00C06:  MOVLW  00
00C08:  MOVWF  01
00C0A:  MOVLB  0
00C0C:  GOTO   0C78 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
01CB4:  MOVFF  6E0,6E6
01CB8:  MOVFF  6DF,6E5
01CBC:  MOVFF  6DE,6E4
01CC0:  MOVFF  6DD,6E3
01CC4:  CALL   0B32
01CC8:  MOVFF  01,6E2
....................    if(ec != MMCSD_GOODEC) 
01CCC:  MOVLB  6
01CCE:  MOVF   xE2,F
01CD0:  BZ    1CD8
....................      return ec; 
01CD2:  MOVFF  6E2,01
01CD6:  BRA    1CFC
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
01CD8:  MOVF   xDE,W
01CDA:  ANDLW  01
01CDC:  MOVWF  xE4
01CDE:  CLRF   xE5
01CE0:  CLRF   xE6
01CE2:  MOVLW  0B
01CE4:  ADDWF  xDD,W
01CE6:  MOVWF  FE9
01CE8:  MOVLW  00
01CEA:  ADDWFC xE4,W
01CEC:  MOVWF  FEA
01CEE:  MOVFF  6E1,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
01CF2:  MOVLB  2
01CF4:  BSF    x0B.1
....................  
....................    return MMCSD_GOODEC; 
01CF6:  MOVLW  00
01CF8:  MOVWF  01
01CFA:  MOVLB  6
01CFC:  MOVLB  0
01CFE:  GOTO   1D68 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //FAT library. 
.................... #include "fat.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          FAT_PIC.C                              //// 
.................... ////                                                                 //// 
.................... //// Driver/Library for a FAT filesystem with a PIC                  //// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... //#define FAT16 
.................... #define FAT32 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster,   // number of addressable bytes per cluster 
....................    FAT_Start;           // when the first FAT begins 
....................  
.................... int32 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... //signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... #ORG 0x00010000 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
*
10000:  MOVLW  01
10002:  MOVLB  5
10004:  MOVWF  xF0
10006:  MOVLB  6
10008:  CLRF   x4B
.................... { 
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
1000A:  MOVLB  5
1000C:  MOVF   xEC,W
1000E:  MOVWF  FE9
10010:  MOVF   xED,W
10012:  MOVWF  FEA
10014:  MOVF   FEF,W
10016:  XORLW  72
10018:  MOVLB  0
1001A:  BZ    10026
1001C:  XORLW  05
1001E:  BZ    1002E
10020:  XORLW  16
10022:  BZ    10036
10024:  BRA    10040
....................    { 
....................       case 'r': 
....................          cur_stream.Flags = Read; 
10026:  MOVLW  01
10028:  MOVLB  6
1002A:  MOVWF  x2A
....................          break; 
1002C:  BRA    10048
....................       case 'w': 
....................          cur_stream.Flags = Write; 
1002E:  MOVLW  02
10030:  MOVLB  6
10032:  MOVWF  x2A
....................          break; 
10034:  BRA    10048
....................       case 'a': 
....................          cur_stream.Flags = Append; 
10036:  MOVLW  04
10038:  MOVLB  6
1003A:  MOVWF  x2A
....................          break; 
1003C:  BRA    10048
1003E:  MOVLB  0
....................       default: 
....................          return EOF; 
10040:  MOVLW  FF
10042:  MOVWF  01
10044:  BRA    102A4
10046:  MOVLB  6
....................    } 
....................  
....................    if(mode[1] == 'b') 
10048:  MOVLW  01
1004A:  MOVLB  5
1004C:  ADDWF  xEC,W
1004E:  MOVWF  FE9
10050:  MOVLW  00
10052:  ADDWFC xED,W
10054:  MOVWF  FEA
10056:  MOVF   FEF,W
10058:  SUBLW  62
1005A:  BNZ   10062
....................       cur_stream.Flags |= Binary; 
1005C:  MOVLB  6
1005E:  BSF    x2A.3
10060:  MOVLB  5
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
10062:  MOVFF  223,620
10066:  MOVFF  222,61F
1006A:  MOVFF  221,61E
1006E:  MOVFF  220,61D
10072:  MOVFF  620,628
10076:  MOVFF  61F,627
1007A:  MOVFF  61E,626
1007E:  MOVFF  61D,625
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
10082:  MOVF   xF0,W
10084:  ADDWF  xEA,W
10086:  MOVWF  FE9
10088:  MOVLW  00
1008A:  ADDWFC xEB,W
1008C:  MOVWF  FEA
1008E:  MOVF   FEF,F
10090:  BZ    100B0
....................    { 
....................       if(fname[fname_parse_pos] == '/') 
10092:  MOVF   xF0,W
10094:  ADDWF  xEA,W
10096:  MOVWF  FE9
10098:  MOVLW  00
1009A:  ADDWFC xEB,W
1009C:  MOVWF  FEA
1009E:  MOVF   FEF,W
100A0:  SUBLW  2F
100A2:  BNZ   100AA
....................          depth++; 
100A4:  MOVLB  6
100A6:  INCF   x4B,F
100A8:  MOVLB  5
....................       fname_parse_pos += 1; 
100AA:  MOVLW  01
100AC:  ADDWF  xF0,F
100AE:  BRA    10082
....................    } 
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
100B0:  MOVLW  01
100B2:  MOVWF  xF0
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
100B4:  MOVLB  6
100B6:  MOVF   x4B,F
100B8:  BZ    10190
....................    { 
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
100BA:  CLRF   x4C
....................       while(fname[fname_parse_pos] != '/') 
100BC:  MOVLB  5
100BE:  MOVF   xF0,W
100C0:  ADDWF  xEA,W
100C2:  MOVWF  FE9
100C4:  MOVLW  00
100C6:  ADDWFC xEB,W
100C8:  MOVWF  FEA
100CA:  MOVF   FEF,W
100CC:  SUBLW  2F
100CE:  BZ    10126
....................       { 
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
100D0:  MOVF   xF0,W
100D2:  ADDWF  xEA,W
100D4:  MOVWF  FE9
100D6:  MOVLW  00
100D8:  ADDWFC xEB,W
100DA:  MOVWF  FEA
100DC:  MOVF   FEF,F
100DE:  BNZ   100EA
....................             return EOF; 
100E0:  MOVLW  FF
100E2:  MOVWF  01
100E4:  MOVLB  0
100E6:  BRA    102A4
100E8:  MOVLB  5
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
100EA:  CLRF   03
100EC:  MOVLB  6
100EE:  MOVF   x4C,W
100F0:  ADDLW  F1
100F2:  MOVWF  01
100F4:  MOVLW  05
100F6:  ADDWFC 03,F
100F8:  MOVLB  5
100FA:  MOVF   xF0,W
100FC:  ADDWF  xEA,W
100FE:  MOVWF  FE9
10100:  MOVLW  00
10102:  ADDWFC xEB,W
10104:  MOVWF  FEA
10106:  MOVFF  FEF,64F
1010A:  MOVLB  6
1010C:  MOVFF  03,FEA
10110:  MOVFF  01,FE9
10114:  MOVFF  64F,FEF
....................          fname_parse_pos += 1; 
10118:  MOVLW  01
1011A:  MOVLB  5
1011C:  ADDWF  xF0,F
....................          target_file_parse_pos += 1; 
1011E:  MOVLB  6
10120:  ADDWF  x4C,F
10122:  BRA    100BC
10124:  MOVLB  5
....................       } 
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
10126:  MOVLW  01
10128:  ADDWF  xF0,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
1012A:  CLRF   03
1012C:  MOVLB  6
1012E:  MOVF   x4C,W
10130:  ADDLW  F1
10132:  MOVWF  FE9
10134:  MOVLW  05
10136:  ADDWFC 03,W
10138:  MOVWF  FEA
1013A:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
1013C:  MOVLW  05
1013E:  MOVWF  x4E
10140:  MOVLW  F1
10142:  MOVWF  x4D
10144:  MOVLW  10
10146:  MOVWF  x4F
10148:  MOVLW  06
1014A:  MOVWF  x51
1014C:  MOVLW  11
1014E:  MOVWF  x50
10150:  MOVLB  0
10152:  CALL   2C5A
10156:  MOVF   01,F
10158:  BZ    10188
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
1015A:  MOVLB  6
1015C:  BSF    x2A.7
....................          *stream = cur_stream; 
1015E:  MOVFF  5EF,03
10162:  MOVLB  5
10164:  MOVFF  5EE,FE9
10168:  MOVFF  5EF,FEA
1016C:  MOVLW  06
1016E:  MOVWF  FE2
10170:  MOVLW  11
10172:  MOVWF  FE1
10174:  MOVLW  3A
10176:  MOVWF  01
10178:  MOVFF  FE6,FEE
1017C:  DECFSZ 01,F
1017E:  BRA    10178
....................          return EOF; 
10180:  MOVLW  FF
10182:  MOVWF  01
10184:  MOVLB  0
10186:  BRA    102A4
....................       } 
....................       depth -= 1; 
10188:  MOVLW  01
1018A:  MOVLB  6
1018C:  SUBWF  x4B,F
1018E:  BRA    100B6
....................    } 
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
10190:  MOVLB  5
10192:  MOVF   xF0,W
10194:  ADDWF  xEA,W
10196:  MOVWF  FE9
10198:  MOVLW  00
1019A:  ADDWFC xEB,W
1019C:  MOVWF  FEA
1019E:  MOVF   FEF,F
101A0:  BNZ   101CC
....................    { 
....................       *stream = cur_stream; 
101A2:  MOVFF  5EF,03
101A6:  MOVFF  5EE,FE9
101AA:  MOVFF  5EF,FEA
101AE:  MOVLW  06
101B0:  MOVWF  FE2
101B2:  MOVLW  11
101B4:  MOVWF  FE1
101B6:  MOVLW  3A
101B8:  MOVWF  01
101BA:  MOVFF  FE6,FEE
101BE:  DECFSZ 01,F
101C0:  BRA    101BA
....................       return GOODEC; 
101C2:  MOVLW  00
101C4:  MOVWF  01
101C6:  MOVLB  0
101C8:  BRA    102A4
101CA:  MOVLB  5
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
101CC:  MOVLB  6
101CE:  CLRF   x4C
....................    while(fname[fname_parse_pos] != '\0') 
101D0:  MOVLB  5
101D2:  MOVF   xF0,W
101D4:  ADDWF  xEA,W
101D6:  MOVWF  FE9
101D8:  MOVLW  00
101DA:  ADDWFC xEB,W
101DC:  MOVWF  FEA
101DE:  MOVF   FEF,F
101E0:  BZ    1021E
....................    { 
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
101E2:  CLRF   03
101E4:  MOVLB  6
101E6:  MOVF   x4C,W
101E8:  ADDLW  F1
101EA:  MOVWF  01
101EC:  MOVLW  05
101EE:  ADDWFC 03,F
101F0:  MOVLB  5
101F2:  MOVF   xF0,W
101F4:  ADDWF  xEA,W
101F6:  MOVWF  FE9
101F8:  MOVLW  00
101FA:  ADDWFC xEB,W
101FC:  MOVWF  FEA
101FE:  MOVFF  FEF,64F
10202:  MOVLB  6
10204:  MOVFF  03,FEA
10208:  MOVFF  01,FE9
1020C:  MOVFF  64F,FEF
....................       fname_parse_pos += 1; 
10210:  MOVLW  01
10212:  MOVLB  5
10214:  ADDWF  xF0,F
....................       target_file_parse_pos += 1; 
10216:  MOVLB  6
10218:  ADDWF  x4C,F
1021A:  BRA    101D0
1021C:  MOVLB  5
....................    } 
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
1021E:  CLRF   03
10220:  MOVLB  6
10222:  MOVF   x4C,W
10224:  ADDLW  F1
10226:  MOVWF  FE9
10228:  MOVLW  05
1022A:  ADDWFC 03,W
1022C:  MOVWF  FEA
1022E:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
10230:  MOVLW  05
10232:  MOVWF  x4E
10234:  MOVLW  F1
10236:  MOVWF  x4D
10238:  MOVLW  20
1023A:  MOVWF  x4F
1023C:  MOVLW  06
1023E:  MOVWF  x51
10240:  MOVLW  11
10242:  MOVWF  x50
10244:  MOVLB  0
10246:  CALL   2C5A
1024A:  MOVF   01,F
1024C:  BZ    1027C
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
1024E:  MOVLB  6
10250:  BSF    x2A.7
....................       *stream = cur_stream; 
10252:  MOVFF  5EF,03
10256:  MOVLB  5
10258:  MOVFF  5EE,FE9
1025C:  MOVFF  5EF,FEA
10260:  MOVLW  06
10262:  MOVWF  FE2
10264:  MOVLW  11
10266:  MOVWF  FE1
10268:  MOVLW  3A
1026A:  MOVWF  01
1026C:  MOVFF  FE6,FEE
10270:  DECFSZ 01,F
10272:  BRA    1026C
....................       return EOF; 
10274:  MOVLW  FF
10276:  MOVWF  01
10278:  MOVLB  0
1027A:  BRA    102A4
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
1027C:  MOVFF  5EF,03
10280:  MOVLB  5
10282:  MOVFF  5EE,FE9
10286:  MOVFF  5EF,FEA
1028A:  MOVLW  06
1028C:  MOVWF  FE2
1028E:  MOVLW  11
10290:  MOVWF  FE1
10292:  MOVLW  3A
10294:  MOVWF  01
10296:  MOVFF  FE6,FEE
1029A:  DECFSZ 01,F
1029C:  BRA    10296
....................    return GOODEC; 
1029E:  MOVLW  00
102A0:  MOVWF  01
102A2:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
102A4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
*
034C6:  MOVLB  5
034C8:  CLRF   xE9
.................... { 
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
034CA:  MOVLW  19
034CC:  ADDWF  xE7,W
034CE:  MOVWF  FE9
034D0:  MOVLW  00
034D2:  ADDWFC xE8,W
034D4:  MOVWF  FEA
034D6:  BTFSC  FEF.1
034D8:  BRA    34EA
034DA:  MOVLW  19
034DC:  ADDWF  xE7,W
034DE:  MOVWF  FE9
034E0:  MOVLW  00
034E2:  ADDWFC xE8,W
034E4:  MOVWF  FEA
034E6:  BTFSS  FEF.2
034E8:  BRA    375A
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
034EA:  MOVLW  08
034EC:  ADDWF  xE7,W
034EE:  MOVWF  FE9
034F0:  MOVLW  00
034F2:  ADDWFC xE8,W
034F4:  MOVWF  FEA
034F6:  MOVFF  FEF,5EE
034FA:  MOVFF  FEC,5EF
034FE:  MOVFF  FEC,5F0
03502:  MOVFF  FEC,5F1
03506:  MOVLW  1C
03508:  ADDWF  xEE,F
0350A:  MOVLW  00
0350C:  ADDWFC xEF,F
0350E:  ADDWFC xF0,F
03510:  ADDWFC xF1,F
03512:  MOVLW  10
03514:  ADDWF  xE7,W
03516:  MOVWF  01
03518:  MOVLW  00
0351A:  ADDWFC xE8,W
0351C:  MOVWF  03
0351E:  MOVFF  01,5F2
03522:  MOVWF  xF3
03524:  MOVFF  5F1,6D0
03528:  MOVFF  5F0,6CF
0352C:  MOVFF  5EF,6CE
03530:  MOVFF  5EE,6CD
03534:  MOVLB  6
03536:  CLRF   xD2
03538:  MOVLW  04
0353A:  MOVWF  xD1
0353C:  MOVFF  03,6D4
03540:  MOVFF  01,6D3
03544:  MOVLB  0
03546:  CALL   1D02
0354A:  MOVF   01,F
0354C:  BZ    356A
....................       { 
....................          stream->Flags |= Write_Error; 
0354E:  MOVLW  19
03550:  MOVLB  5
03552:  ADDWF  xE7,W
03554:  MOVWF  FE9
03556:  MOVLW  00
03558:  ADDWFC xE8,W
0355A:  MOVWF  FEA
0355C:  MOVF   FEF,W
0355E:  IORLW  40
03560:  MOVWF  FEF
....................          return EOF; 
03562:  MOVLW  FF
03564:  MOVWF  01
03566:  BRA    37E8
03568:  MOVLB  0
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
0356A:  MOVLW  08
0356C:  MOVLB  5
0356E:  ADDWF  xE7,W
03570:  MOVWF  FE9
03572:  MOVLW  00
03574:  ADDWFC xE8,W
03576:  MOVWF  FEA
03578:  MOVFF  FEF,5EE
0357C:  MOVFF  FEC,5EF
03580:  MOVFF  FEC,5F0
03584:  MOVFF  FEC,5F1
03588:  MOVLW  14
0358A:  ADDWF  xEE,F
0358C:  MOVLW  00
0358E:  ADDWFC xEF,F
03590:  ADDWFC xF0,F
03592:  ADDWFC xF1,F
03594:  MOVFF  5F1,6B7
03598:  MOVFF  5F0,6B6
0359C:  MOVFF  5EF,6B5
035A0:  MOVFF  5EE,6B4
035A4:  MOVLB  6
035A6:  CLRF   xB9
035A8:  MOVLW  02
035AA:  MOVWF  xB8
035AC:  MOVLW  05
035AE:  MOVWF  xBB
035B0:  MOVLW  EC
035B2:  MOVWF  xBA
035B4:  MOVLB  0
035B6:  CALL   0C10
035BA:  MOVF   01,W
035BC:  MOVLB  5
035BE:  ADDWF  xE9,F
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
035C0:  MOVLW  08
035C2:  ADDWF  xE7,W
035C4:  MOVWF  FE9
035C6:  MOVLW  00
035C8:  ADDWFC xE8,W
035CA:  MOVWF  FEA
035CC:  MOVFF  FEF,5EE
035D0:  MOVFF  FEC,5EF
035D4:  MOVFF  FEC,5F0
035D8:  MOVFF  FEC,5F1
035DC:  MOVLW  1A
035DE:  ADDWF  xEE,F
035E0:  MOVLW  00
035E2:  ADDWFC xEF,F
035E4:  ADDWFC xF0,F
035E6:  ADDWFC xF1,F
035E8:  MOVFF  5F1,6B7
035EC:  MOVFF  5F0,6B6
035F0:  MOVFF  5EF,6B5
035F4:  MOVFF  5EE,6B4
035F8:  MOVLB  6
035FA:  CLRF   xB9
035FC:  MOVLW  02
035FE:  MOVWF  xB8
03600:  MOVLW  05
03602:  MOVWF  xBB
03604:  MOVLW  EA
03606:  MOVWF  xBA
03608:  MOVLB  0
0360A:  CALL   0C10
0360E:  MOVF   01,W
03610:  MOVLB  5
03612:  ADDWF  xE9,F
....................  
....................       if(ec != GOODEC) 
03614:  MOVF   xE9,F
03616:  BZ    3630
....................       { 
....................          stream->Flags |= Read_Error; 
03618:  MOVLW  19
0361A:  ADDWF  xE7,W
0361C:  MOVWF  FE9
0361E:  MOVLW  00
03620:  ADDWFC xE8,W
03622:  MOVWF  FEA
03624:  MOVF   FEF,W
03626:  IORLW  20
03628:  MOVWF  FEF
....................          return EOF; 
0362A:  MOVLW  FF
0362C:  MOVWF  01
0362E:  BRA    37E8
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
03630:  MOVF   xEA,F
03632:  BTFSS  FD8.2
03634:  BRA    3740
03636:  MOVF   xEB,F
03638:  BTFSS  FD8.2
0363A:  BRA    3740
0363C:  MOVF   xEC,F
0363E:  BTFSS  FD8.2
03640:  BRA    3740
03642:  MOVF   xED,F
03644:  BTFSS  FD8.2
03646:  BRA    3740
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
03648:  MOVLW  14
0364A:  ADDWF  xE7,W
0364C:  MOVWF  FE9
0364E:  MOVLW  00
03650:  ADDWFC xE8,W
03652:  MOVWF  FEA
03654:  MOVFF  FEF,697
03658:  MOVFF  FEC,698
0365C:  MOVFF  FEC,699
03660:  MOVFF  FEC,69A
03664:  MOVLB  0
03666:  CALL   1676
0366A:  MOVFF  03,5ED
0366E:  MOVFF  02,5EC
03672:  MOVFF  01,5EB
03676:  MOVFF  00,5EA
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
0367A:  MOVLW  08
0367C:  MOVLB  5
0367E:  ADDWF  xE7,W
03680:  MOVWF  FE9
03682:  MOVLW  00
03684:  ADDWFC xE8,W
03686:  MOVWF  FEA
03688:  MOVFF  FEF,5EE
0368C:  MOVFF  FEC,5EF
03690:  MOVFF  FEC,5F0
03694:  MOVFF  FEC,5F1
03698:  MOVLW  14
0369A:  ADDWF  xEE,F
0369C:  MOVLW  00
0369E:  ADDWFC xEF,F
036A0:  ADDWFC xF0,F
036A2:  ADDWFC xF1,F
036A4:  MOVFF  5F1,6D0
036A8:  MOVFF  5F0,6CF
036AC:  MOVFF  5EF,6CE
036B0:  MOVFF  5EE,6CD
036B4:  MOVLB  6
036B6:  CLRF   xD2
036B8:  MOVLW  02
036BA:  MOVWF  xD1
036BC:  MOVLW  05
036BE:  MOVWF  xD4
036C0:  MOVLW  EC
036C2:  MOVWF  xD3
036C4:  MOVLB  0
036C6:  CALL   1D02
036CA:  MOVF   01,W
036CC:  MOVLB  5
036CE:  ADDWF  xE9,F
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
036D0:  MOVLW  08
036D2:  ADDWF  xE7,W
036D4:  MOVWF  FE9
036D6:  MOVLW  00
036D8:  ADDWFC xE8,W
036DA:  MOVWF  FEA
036DC:  MOVFF  FEF,5EE
036E0:  MOVFF  FEC,5EF
036E4:  MOVFF  FEC,5F0
036E8:  MOVFF  FEC,5F1
036EC:  MOVLW  1A
036EE:  ADDWF  xEE,F
036F0:  MOVLW  00
036F2:  ADDWFC xEF,F
036F4:  ADDWFC xF0,F
036F6:  ADDWFC xF1,F
036F8:  MOVFF  5F1,6D0
036FC:  MOVFF  5F0,6CF
03700:  MOVFF  5EF,6CE
03704:  MOVFF  5EE,6CD
03708:  MOVLB  6
0370A:  CLRF   xD2
0370C:  MOVLW  02
0370E:  MOVWF  xD1
03710:  MOVLW  05
03712:  MOVWF  xD4
03714:  MOVLW  EA
03716:  MOVWF  xD3
03718:  MOVLB  0
0371A:  CALL   1D02
0371E:  MOVF   01,W
03720:  MOVLB  5
03722:  ADDWF  xE9,F
....................  
....................          if(ec != GOODEC) 
03724:  MOVF   xE9,F
03726:  BZ    3740
....................          { 
....................             stream->Flags |= Write_Error; 
03728:  MOVLW  19
0372A:  ADDWF  xE7,W
0372C:  MOVWF  FE9
0372E:  MOVLW  00
03730:  ADDWFC xE8,W
03732:  MOVWF  FEA
03734:  MOVF   FEF,W
03736:  IORLW  40
03738:  MOVWF  FEF
....................             return EOF; 
0373A:  MOVLW  FF
0373C:  MOVWF  01
0373E:  BRA    37E8
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
03740:  MOVFF  5E8,5EF
03744:  MOVFF  5E7,5EE
03748:  MOVLB  0
0374A:  BRA    332A
0374C:  MOVF   01,W
0374E:  SUBLW  FF
03750:  BNZ   375C
....................          return EOF; 
03752:  MOVLW  FF
03754:  MOVWF  01
03756:  MOVLB  5
03758:  BRA    37E8
0375A:  MOVLB  0
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
0375C:  MOVLW  04
0375E:  MOVLB  5
03760:  ADDWF  xE7,W
03762:  MOVWF  FE9
03764:  MOVLW  00
03766:  ADDWFC xE8,W
03768:  MOVWF  FEA
0376A:  MOVF   FEE,F
0376C:  MOVF   FEE,F
0376E:  CLRF   FEC
03770:  MOVF   FED,F
03772:  CLRF   FEF
03774:  MOVF   FED,F
03776:  CLRF   FEF
03778:  MOVF   FED,F
0377A:  CLRF   FEF
....................    stream->Entry_Addr = 0; 
0377C:  MOVLW  08
0377E:  ADDWF  xE7,W
03780:  MOVWF  FE9
03782:  MOVLW  00
03784:  ADDWFC xE8,W
03786:  MOVWF  FEA
03788:  MOVF   FEE,F
0378A:  MOVF   FEE,F
0378C:  CLRF   FEC
0378E:  MOVF   FED,F
03790:  CLRF   FEF
03792:  MOVF   FED,F
03794:  CLRF   FEF
03796:  MOVF   FED,F
03798:  CLRF   FEF
....................    stream->Size = 0; 
0379A:  MOVLW  10
0379C:  ADDWF  xE7,W
0379E:  MOVWF  FE9
037A0:  MOVLW  00
037A2:  ADDWFC xE8,W
037A4:  MOVWF  FEA
037A6:  MOVF   FEE,F
037A8:  MOVF   FEE,F
037AA:  CLRF   FEC
037AC:  MOVF   FED,F
037AE:  CLRF   FEF
037B0:  MOVF   FED,F
037B2:  CLRF   FEF
037B4:  MOVF   FED,F
037B6:  CLRF   FEF
....................    stream->Start_Addr = 0; 
037B8:  MOVLW  14
037BA:  ADDWF  xE7,W
037BC:  MOVWF  FE9
037BE:  MOVLW  00
037C0:  ADDWFC xE8,W
037C2:  MOVWF  FEA
037C4:  MOVF   FEE,F
037C6:  MOVF   FEE,F
037C8:  CLRF   FEC
037CA:  MOVF   FED,F
037CC:  CLRF   FEF
037CE:  MOVF   FED,F
037D0:  CLRF   FEF
037D2:  MOVF   FED,F
037D4:  CLRF   FEF
....................    stream->Flags = 0; 
037D6:  MOVLW  19
037D8:  ADDWF  xE7,W
037DA:  MOVWF  FE9
037DC:  MOVLW  00
037DE:  ADDWFC xE8,W
037E0:  MOVWF  FEA
037E2:  CLRF   FEF
....................    return 0; 
037E4:  MOVLW  00
037E6:  MOVWF  01
037E8:  MOVLB  0
037EA:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
*
0511A:  MOVLW  19
0511C:  MOVLB  5
0511E:  ADDWF  xA3,W
05120:  MOVWF  FE9
05122:  MOVLW  00
05124:  ADDWFC xA4,W
05126:  MOVWF  FEA
05128:  BTFSS  FEF.0
0512A:  BRA    5228
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
0512C:  MOVFF  5A3,FE9
05130:  MOVFF  5A4,FEA
05134:  MOVFF  FEF,5A6
05138:  MOVFF  FEC,5A7
0513C:  MOVFF  FEC,5A8
05140:  MOVFF  FEC,5A9
05144:  MOVF   xA6,F
05146:  BNZ   516C
05148:  MOVF   xA7,F
0514A:  BNZ   516C
0514C:  MOVF   xA8,F
0514E:  BNZ   516C
05150:  MOVF   xA9,F
05152:  BNZ   516C
....................       { 
....................          stream->Flags |= EOF_Reached; 
05154:  MOVLW  19
05156:  ADDWF  xA3,W
05158:  MOVWF  FE9
0515A:  MOVLW  00
0515C:  ADDWFC xA4,W
0515E:  MOVWF  FEA
05160:  MOVF   FEF,W
05162:  IORLW  10
05164:  MOVWF  FEF
....................          return EOF; 
05166:  MOVLW  FF
05168:  MOVWF  01
0516A:  BRA    522C
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
0516C:  MOVFF  5A4,5A7
05170:  MOVFF  5A3,5A6
05174:  MOVLW  05
05176:  MOVWF  xA9
05178:  MOVLW  A5
0517A:  MOVWF  xA8
0517C:  MOVLB  0
0517E:  BRA    5016
05180:  MOVF   01,W
05182:  SUBLW  FF
05184:  BNZ   5190
....................          return EOF; 
05186:  MOVLW  FF
05188:  MOVWF  01
0518A:  MOVLB  5
0518C:  BRA    522C
0518E:  MOVLB  0
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
05190:  MOVLB  5
05192:  MOVF   xA5,F
05194:  BNZ   51BE
05196:  MOVLW  19
05198:  ADDWF  xA3,W
0519A:  MOVWF  FE9
0519C:  MOVLW  00
0519E:  ADDWFC xA4,W
051A0:  MOVWF  FEA
051A2:  BTFSC  FEF.3
051A4:  BRA    51BE
....................       { 
....................          stream->Flags |= EOF_Reached; 
051A6:  MOVLW  19
051A8:  ADDWF  xA3,W
051AA:  MOVWF  FE9
051AC:  MOVLW  00
051AE:  ADDWFC xA4,W
051B0:  MOVWF  FEA
051B2:  MOVF   FEF,W
051B4:  IORLW  10
051B6:  MOVWF  FEF
....................          return EOF; 
051B8:  MOVLW  FF
051BA:  MOVWF  01
051BC:  BRA    522C
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
051BE:  MOVLW  04
051C0:  ADDWF  xA3,W
051C2:  MOVWF  01
051C4:  MOVLW  00
051C6:  ADDWFC xA4,W
051C8:  MOVWF  03
051CA:  MOVFF  01,5A6
051CE:  MOVWF  xA7
051D0:  MOVFF  FE8,68D
051D4:  MOVFF  01,68C
051D8:  MOVLB  0
051DA:  CALL   22AA
051DE:  MOVF   01,F
051E0:  BZ    51EC
....................          return EOF; 
051E2:  MOVLW  FF
051E4:  MOVWF  01
051E6:  MOVLB  5
051E8:  BRA    522C
051EA:  MOVLB  0
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
051EC:  MOVLB  5
051EE:  MOVFF  5A3,FE9
051F2:  MOVFF  5A4,FEA
051F6:  MOVLW  01
051F8:  SUBWF  FEF,W
051FA:  MOVWF  00
051FC:  MOVLW  00
051FE:  SUBWFB FEC,W
05200:  MOVWF  01
05202:  MOVLW  00
05204:  SUBWFB FEC,W
05206:  MOVWF  02
05208:  MOVLW  00
0520A:  SUBWFB FEC,W
0520C:  MOVF   FED,F
0520E:  MOVF   FED,F
05210:  MOVF   FED,F
05212:  MOVFF  00,FEF
05216:  MOVFF  01,FEC
0521A:  MOVFF  02,FEC
0521E:  MOVWF  FEC
....................       return ch; 
05220:  MOVFF  5A5,01
05224:  BRA    522C
....................    } 
05226:  BRA    522C
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
....................       return EOF; 
05228:  MOVLW  FF
0522A:  MOVWF  01
0522C:  MOVLB  0
0522E:  GOTO   523C (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
0252A:  MOVLW  19
0252C:  MOVLB  6
0252E:  ADDWF  x88,W
02530:  MOVWF  FE9
02532:  MOVLW  00
02534:  ADDWFC x89,W
02536:  MOVWF  FEA
02538:  BTFSC  FEF.1
0253A:  BRA    254C
0253C:  MOVLW  19
0253E:  ADDWF  x88,W
02540:  MOVWF  FE9
02542:  MOVLW  00
02544:  ADDWFC x89,W
02546:  MOVWF  FEA
02548:  BTFSS  FEF.2
0254A:  BRA    27FE
0254C:  MOVLW  18
0254E:  ADDWF  x88,W
02550:  MOVWF  FE9
02552:  MOVLW  00
02554:  ADDWFC x89,W
02556:  MOVWF  FEA
02558:  MOVF   FEF,F
0255A:  BTFSS  FD8.2
0255C:  BRA    27FE
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
0255E:  MOVLW  04
02560:  ADDWF  x88,W
02562:  MOVWF  FE9
02564:  MOVLW  00
02566:  ADDWFC x89,W
02568:  MOVWF  FEA
0256A:  MOVFF  FEF,68A
0256E:  MOVFF  FEC,68B
02572:  MOVFF  FEC,68C
02576:  MOVFF  FEC,68D
0257A:  MOVF   x8D,W
0257C:  MOVLB  2
0257E:  SUBWF  x17,W
02580:  BTFSS  FD8.0
02582:  BRA    2686
02584:  BNZ   25B2
02586:  MOVLB  6
02588:  MOVF   x8C,W
0258A:  MOVLB  2
0258C:  SUBWF  x16,W
0258E:  BTFSS  FD8.0
02590:  BRA    2686
02592:  BNZ   25B2
02594:  MOVLB  6
02596:  MOVF   x8B,W
02598:  MOVLB  2
0259A:  SUBWF  x15,W
0259C:  BTFSS  FD8.0
0259E:  BRA    2686
025A0:  BNZ   25B2
025A2:  MOVF   x14,W
025A4:  MOVLB  6
025A6:  SUBWF  x8A,W
025A8:  BTFSS  FD8.0
025AA:  BRA    25B0
025AC:  MOVLB  2
025AE:  BRA    2686
025B0:  MOVLB  2
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
025B2:  MOVLW  02
025B4:  MOVLB  6
025B6:  MOVWF  x9F
025B8:  MOVLW  1C
025BA:  MOVWF  x9E
025BC:  MOVLB  0
025BE:  RCALL  1F18
025C0:  MOVF   01,W
025C2:  SUBLW  FF
025C4:  BNZ   25CC
....................             return EOF; 
025C6:  MOVLW  FF
025C8:  MOVWF  01
025CA:  BRA    2804
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
025CC:  MOVFF  21F,6A1
025D0:  MOVFF  21E,6A0
025D4:  MOVFF  21D,69F
025D8:  MOVFF  21C,69E
025DC:  MOVLW  0F
025DE:  MOVLB  6
025E0:  MOVWF  xA5
025E2:  SETF   xA4
025E4:  SETF   xA3
025E6:  SETF   xA2
025E8:  MOVLB  0
025EA:  CALL   1D88
025EE:  MOVF   01,W
025F0:  SUBLW  FF
025F2:  BNZ   25FA
....................             return EOF; 
025F4:  MOVLW  FF
025F6:  MOVWF  01
025F8:  BRA    2804
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................             return EOF; 
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
025FA:  MOVFF  21F,6A1
025FE:  MOVFF  21E,6A0
02602:  MOVFF  21D,69F
02606:  MOVFF  21C,69E
0260A:  RCALL  2094
0260C:  MOVF   01,W
0260E:  SUBLW  FF
02610:  BNZ   2618
....................             return EOF; 
02612:  MOVLW  FF
02614:  MOVWF  01
02616:  BRA    2804
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
02618:  MOVLW  04
0261A:  MOVLB  6
0261C:  ADDWF  x88,W
0261E:  MOVWF  01
02620:  MOVLW  00
02622:  ADDWFC x89,W
02624:  MOVWF  03
02626:  MOVFF  01,68A
0262A:  MOVWF  x8B
0262C:  MOVLW  14
0262E:  ADDWF  x88,W
02630:  MOVWF  01
02632:  MOVLW  00
02634:  ADDWFC x89,W
02636:  MOVWF  03
02638:  MOVFF  01,68C
0263C:  MOVWF  x8D
0263E:  MOVFF  21F,6CC
02642:  MOVFF  21E,6CB
02646:  MOVFF  21D,6CA
0264A:  MOVFF  21C,6C9
0264E:  MOVLB  0
02650:  CALL   17C2
02654:  MOVFF  68D,FEA
02658:  MOVFF  68C,FE9
0265C:  MOVFF  00,FEF
02660:  MOVFF  01,FEC
02664:  MOVFF  02,FEC
02668:  MOVFF  03,FEC
0266C:  MOVFF  68B,FEA
02670:  MOVFF  68A,FE9
02674:  MOVFF  00,FEF
02678:  MOVFF  01,FEC
0267C:  MOVFF  02,FEC
02680:  MOVFF  03,FEC
02684:  MOVLB  2
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
02686:  MOVFF  689,68B
0268A:  MOVFF  688,68A
0268E:  MOVFF  687,68C
02692:  MOVLB  0
02694:  BRA    2150
02696:  MOVF   01,W
02698:  SUBLW  FF
0269A:  BNZ   26A2
....................          return EOF; 
0269C:  MOVLW  FF
0269E:  MOVWF  01
026A0:  BRA    2804
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
026A2:  MOVLW  04
026A4:  MOVLB  6
026A6:  ADDWF  x88,W
026A8:  MOVWF  01
026AA:  MOVLW  00
026AC:  ADDWFC x89,W
026AE:  MOVWF  03
026B0:  MOVFF  01,68A
026B4:  MOVWF  x8B
026B6:  MOVWF  x8D
026B8:  MOVFF  01,68C
026BC:  MOVLB  0
026BE:  RCALL  22AA
026C0:  MOVF   01,W
026C2:  SUBLW  FF
026C4:  BTFSS  FD8.2
026C6:  BRA    27BA
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
026C8:  MOVLW  04
026CA:  MOVLB  6
026CC:  ADDWF  x88,W
026CE:  MOVWF  FE9
026D0:  MOVLW  00
026D2:  ADDWFC x89,W
026D4:  MOVWF  FEA
026D6:  MOVFF  FEF,68A
026DA:  MOVFF  FEC,68B
026DE:  MOVFF  FEC,68C
026E2:  MOVFF  FEC,68D
026E6:  MOVLW  20
026E8:  SUBWF  x8A,F
026EA:  MOVLW  00
026EC:  SUBWFB x8B,F
026EE:  SUBWFB x8C,F
026F0:  SUBWFB x8D,F
026F2:  MOVLW  01
026F4:  ADDWF  x8A,F
026F6:  MOVLW  00
026F8:  ADDWFC x8B,F
026FA:  ADDWFC x8C,F
026FC:  ADDWFC x8D,F
026FE:  MOVLW  1A
02700:  ADDWF  x88,W
02702:  MOVWF  01
02704:  MOVLW  00
02706:  ADDWFC x89,W
02708:  MOVWF  03
0270A:  MOVFF  01,68E
0270E:  MOVWF  x8F
02710:  MOVFF  68D,6D0
02714:  MOVFF  68C,6CF
02718:  MOVFF  68B,6CE
0271C:  MOVFF  68A,6CD
02720:  CLRF   xD2
02722:  MOVLW  20
02724:  MOVWF  xD1
02726:  MOVFF  03,6D4
0272A:  MOVFF  01,6D3
0272E:  MOVLB  0
02730:  CALL   1D02
02734:  MOVF   01,F
02736:  BZ    2754
....................          { 
....................             stream->Flags |= Write_Error; 
02738:  MOVLW  19
0273A:  MOVLB  6
0273C:  ADDWF  x88,W
0273E:  MOVWF  FE9
02740:  MOVLW  00
02742:  ADDWFC x89,W
02744:  MOVWF  FEA
02746:  MOVF   FEF,W
02748:  IORLW  40
0274A:  MOVWF  FEF
....................             return EOF; 
0274C:  MOVLW  FF
0274E:  MOVWF  01
02750:  MOVLB  0
02752:  BRA    2804
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
02754:  MOVLW  04
02756:  MOVLB  6
02758:  ADDWF  x88,W
0275A:  MOVWF  FE9
0275C:  MOVLW  00
0275E:  ADDWFC x89,W
02760:  MOVWF  FEA
02762:  MOVFF  FEF,697
02766:  MOVFF  FEC,698
0276A:  MOVFF  FEC,699
0276E:  MOVFF  FEC,69A
02772:  MOVLB  0
02774:  CALL   1676
02778:  MOVFF  03,693
0277C:  MOVFF  02,68C
02780:  MOVFF  01,691
02784:  MOVFF  00,68A
02788:  MOVLW  04
0278A:  MOVLB  6
0278C:  ADDWF  x88,W
0278E:  MOVWF  01
02790:  MOVLW  00
02792:  ADDWFC x89,W
02794:  MOVWF  03
02796:  MOVFF  01,68E
0279A:  MOVWF  x8F
0279C:  MOVFF  02,692
027A0:  MOVFF  00,690
027A4:  MOVWF  x95
027A6:  MOVFF  01,694
027AA:  MOVLB  0
027AC:  RCALL  2438
027AE:  MOVF   01,W
027B0:  SUBLW  FF
027B2:  BNZ   27BA
....................             return EOF; 
027B4:  MOVLW  FF
027B6:  MOVWF  01
027B8:  BRA    2804
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
027BA:  MOVLW  10
027BC:  MOVLB  6
027BE:  ADDWF  x88,W
027C0:  MOVWF  FE9
027C2:  MOVLW  00
027C4:  ADDWFC x89,W
027C6:  MOVWF  FEA
027C8:  MOVLW  01
027CA:  ADDWF  FEF,W
027CC:  MOVWF  00
027CE:  MOVLW  00
027D0:  ADDWFC FEC,W
027D2:  MOVWF  01
027D4:  MOVLW  00
027D6:  ADDWFC FEC,W
027D8:  MOVWF  02
027DA:  MOVLW  00
027DC:  ADDWFC FEC,W
027DE:  MOVF   FED,F
027E0:  MOVF   FED,F
027E2:  MOVF   FED,F
027E4:  MOVFF  00,FEF
027E8:  MOVFF  01,FEC
027EC:  MOVFF  02,FEC
027F0:  MOVWF  FEC
....................  
....................       return ch; 
027F2:  MOVFF  687,01
027F6:  MOVLB  0
027F8:  BRA    2804
....................    } 
027FA:  BRA    2804
027FC:  MOVLB  6
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
....................       return EOF; 
027FE:  MOVLW  FF
02800:  MOVWF  01
02802:  MOVLB  0
02804:  RETURN 0
.................... } 
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
*
04808:  MOVLB  5
0480A:  CLRF   xA8
.................... { 
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
0480C:  MOVF   xA8,W
0480E:  ADDWF  xA4,W
04810:  MOVWF  FE9
04812:  MOVLW  00
04814:  ADDWFC xA5,W
04816:  MOVWF  FEA
04818:  MOVF   FEF,F
0481A:  BZ    484E
....................    { 
....................       if(fatputc(str[i], stream) == EOF) 
0481C:  MOVF   xA8,W
0481E:  ADDWF  xA4,W
04820:  MOVWF  FE9
04822:  MOVLW  00
04824:  ADDWFC xA5,W
04826:  MOVWF  FEA
04828:  MOVFF  FEF,687
0482C:  MOVFF  5A7,689
04830:  MOVFF  5A6,688
04834:  MOVLB  0
04836:  CALL   252A
0483A:  MOVF   01,W
0483C:  SUBLW  FF
0483E:  BNZ   4846
....................         return EOF; 
04840:  MOVLW  FF
04842:  MOVWF  01
04844:  BRA    4854
....................       i += 1; 
04846:  MOVLW  01
04848:  MOVLB  5
0484A:  ADDWF  xA8,F
0484C:  BRA    480C
....................    } 
....................  
....................    return GOODEC; 
0484E:  MOVLW  00
04850:  MOVWF  01
04852:  MOVLB  0
04854:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
*
05232:  MOVFF  5A1,5A4
05236:  MOVFF  5A0,5A3
0523A:  BRA    511A
0523C:  MOVFF  01,5A2
....................       printf("%c", ch); 
05240:  MOVLB  5
05242:  MOVF   xA2,W
05244:  BTFSS  F9E.4
05246:  BRA    5244
05248:  MOVWF  FAD
....................    } while(ch != EOF); 
0524A:  MOVF   xA2,W
0524C:  SUBLW  FF
0524E:  BTFSC  FD8.2
05250:  BRA    5256
05252:  MOVLB  0
05254:  BRA    5232
....................  
....................    return ch; 
05256:  MOVFF  5A2,01
0525A:  MOVLB  0
0525C:  GOTO   52DA (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
*
02806:  MOVFF  67E,03
0280A:  MOVLB  6
0280C:  MOVFF  67D,FE9
02810:  MOVFF  67E,FEA
02814:  MOVFF  FEF,687
02818:  MOVFF  FEC,688
0281C:  MOVFF  FEC,689
02820:  MOVFF  FEC,68A
02824:  MOVF   x87,F
02826:  BNZ   284A
02828:  MOVF   x88,F
0282A:  BNZ   284A
0282C:  MOVF   x89,F
0282E:  BNZ   284A
02830:  MOVF   x8A,F
02832:  BNZ   284A
....................    { 
....................       rewind(stream); 
02834:  MOVFF  67C,688
02838:  MOVFF  67B,687
0283C:  MOVLB  0
0283E:  GOTO   1E96
....................       return GOODEC; 
02842:  MOVLW  00
02844:  MOVWF  01
02846:  BRA    2BF6
02848:  MOVLB  6
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
0284A:  MOVLW  19
0284C:  ADDWF  x7B,W
0284E:  MOVWF  FE9
02850:  MOVLW  00
02852:  ADDWFC x7C,W
02854:  MOVWF  FEA
02856:  BTFSC  FEF.1
02858:  BRA    286A
0285A:  MOVLW  19
0285C:  ADDWF  x7B,W
0285E:  MOVWF  FE9
02860:  MOVLW  00
02862:  ADDWFC x7C,W
02864:  MOVWF  FEA
02866:  BTFSS  FEF.2
02868:  BRA    2936
0286A:  MOVLW  10
0286C:  ADDWF  x7B,W
0286E:  MOVWF  FE9
02870:  MOVLW  00
02872:  ADDWFC x7C,W
02874:  MOVWF  FEA
02876:  MOVFF  FEF,687
0287A:  MOVFF  FEC,688
0287E:  MOVFF  FEC,689
02882:  MOVFF  FEC,68A
02886:  MOVFF  67D,FE9
0288A:  MOVFF  67E,FEA
0288E:  MOVFF  FEF,00
02892:  MOVFF  FEC,01
02896:  MOVFF  FEC,02
0289A:  MOVFF  FEC,03
0289E:  MOVF   x8A,W
028A0:  SUBWF  03,W
028A2:  BNC   2936
028A4:  BNZ   28BC
028A6:  MOVF   x89,W
028A8:  SUBWF  02,W
028AA:  BNC   2936
028AC:  BNZ   28BC
028AE:  MOVF   x88,W
028B0:  SUBWF  01,W
028B2:  BNC   2936
028B4:  BNZ   28BC
028B6:  MOVF   00,W
028B8:  SUBWF  x87,W
028BA:  BC    2936
....................    { 
....................       while(stream->Size < *position) 
028BC:  MOVLW  10
028BE:  ADDWF  x7B,W
028C0:  MOVWF  FE9
028C2:  MOVLW  00
028C4:  ADDWFC x7C,W
028C6:  MOVWF  FEA
028C8:  MOVFF  FEF,687
028CC:  MOVFF  FEC,688
028D0:  MOVFF  FEC,689
028D4:  MOVFF  FEC,68A
028D8:  MOVFF  67D,FE9
028DC:  MOVFF  67E,FEA
028E0:  MOVFF  FEF,00
028E4:  MOVFF  FEC,01
028E8:  MOVFF  FEC,02
028EC:  MOVFF  FEC,03
028F0:  MOVF   x8A,W
028F2:  SUBWF  03,W
028F4:  BNC   292C
028F6:  BNZ   290E
028F8:  MOVF   x89,W
028FA:  SUBWF  02,W
028FC:  BNC   292C
028FE:  BNZ   290E
02900:  MOVF   x88,W
02902:  SUBWF  01,W
02904:  BNC   292C
02906:  BNZ   290E
02908:  MOVF   00,W
0290A:  SUBWF  x87,W
0290C:  BC    292C
....................          if(fatputc('\0', stream) == EOF) 
0290E:  CLRF   x87
02910:  MOVFF  67C,689
02914:  MOVFF  67B,688
02918:  MOVLB  0
0291A:  RCALL  252A
0291C:  MOVF   01,W
0291E:  SUBLW  FF
02920:  BNZ   2928
....................             return EOF; 
02922:  MOVLW  FF
02924:  MOVWF  01
02926:  BRA    2BF6
02928:  MOVLB  6
0292A:  BRA    28BC
....................        
....................       return 0; 
0292C:  MOVLW  00
0292E:  MOVWF  01
02930:  MOVLB  0
02932:  BRA    2BF6
02934:  MOVLB  6
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
02936:  MOVFF  67E,03
0293A:  MOVFF  67D,FE9
0293E:  MOVFF  67E,FEA
02942:  MOVFF  FEF,69F
02946:  MOVFF  FEC,6A0
0294A:  MOVFF  FEC,6A1
0294E:  MOVFF  FEC,6A2
02952:  MOVFF  FEA,68C
02956:  MOVFF  FE9,68B
0295A:  BCF    FD8.1
0295C:  CLRF   xA6
0295E:  CLRF   xA5
02960:  MOVFF  211,6A4
02964:  MOVFF  210,6A3
02968:  MOVLB  0
0296A:  CALL   15E2
0296E:  MOVFF  68C,FEA
02972:  MOVFF  68B,FE9
02976:  MOVFF  03,686
0297A:  MOVFF  02,685
0297E:  MOVFF  01,684
02982:  MOVFF  00,683
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
02986:  MOVLW  14
02988:  MOVLB  6
0298A:  ADDWF  x7B,W
0298C:  MOVWF  FE9
0298E:  MOVLW  00
02990:  ADDWFC x7C,W
02992:  MOVWF  FEA
02994:  MOVFF  FEF,697
02998:  MOVFF  FEC,698
0299C:  MOVFF  FEC,699
029A0:  MOVFF  FEC,69A
029A4:  MOVLB  0
029A6:  CALL   1676
029AA:  MOVFF  03,682
029AE:  MOVFF  02,681
029B2:  MOVFF  01,680
029B6:  MOVFF  00,67F
....................  
....................    // head to that cluster 
....................    while(i > 0) 
029BA:  MOVLB  6
029BC:  MOVF   x83,F
029BE:  BNZ   29CC
029C0:  MOVF   x84,F
029C2:  BNZ   29CC
029C4:  MOVF   x85,F
029C6:  BNZ   29CC
029C8:  MOVF   x86,F
029CA:  BZ    29F4
....................    { 
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
029CC:  MOVLW  06
029CE:  MOVWF  x93
029D0:  MOVLW  7F
029D2:  MOVWF  x92
029D4:  MOVLB  0
029D6:  CALL   1C38
029DA:  MOVF   01,F
029DC:  BZ    29E4
....................          return EOF; 
029DE:  MOVLW  FF
029E0:  MOVWF  01
029E2:  BRA    2BF6
....................       i -= 1; 
029E4:  MOVLW  01
029E6:  MOVLB  6
029E8:  SUBWF  x83,F
029EA:  MOVLW  00
029EC:  SUBWFB x84,F
029EE:  SUBWFB x85,F
029F0:  SUBWFB x86,F
029F2:  BRA    29BC
....................    } 
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
029F4:  MOVLW  04
029F6:  ADDWF  x7B,W
029F8:  MOVWF  01
029FA:  MOVLW  00
029FC:  ADDWFC x7C,W
029FE:  MOVWF  03
02A00:  MOVFF  01,687
02A04:  MOVWF  x88
02A06:  MOVFF  682,6CC
02A0A:  MOVFF  681,6CB
02A0E:  MOVFF  680,6CA
02A12:  MOVFF  67F,6C9
02A16:  MOVLB  0
02A18:  CALL   17C2
02A1C:  MOVFF  688,FEA
02A20:  MOVFF  687,FE9
02A24:  MOVFF  00,FEF
02A28:  MOVFF  01,FEC
02A2C:  MOVFF  02,FEC
02A30:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
02A34:  MOVLW  04
02A36:  MOVLB  6
02A38:  ADDWF  x7B,W
02A3A:  MOVWF  01
02A3C:  MOVLW  00
02A3E:  ADDWFC x7C,W
02A40:  MOVFF  01,687
02A44:  MOVWF  x88
02A46:  MOVWF  FEA
02A48:  MOVFF  01,FE9
02A4C:  MOVFF  FEF,689
02A50:  MOVFF  FEC,68A
02A54:  MOVFF  FEC,68B
02A58:  MOVFF  FEC,68C
02A5C:  MOVFF  67E,03
02A60:  MOVFF  67D,FE9
02A64:  MOVFF  67E,FEA
02A68:  MOVFF  FEF,69F
02A6C:  MOVFF  FEC,6A0
02A70:  MOVFF  FEC,6A1
02A74:  MOVFF  FEC,6A2
02A78:  MOVFF  FEA,692
02A7C:  MOVFF  FE9,691
02A80:  BSF    FD8.1
02A82:  MOVLW  06
02A84:  MOVWF  FEA
02A86:  MOVLW  93
02A88:  MOVWF  FE9
02A8A:  CLRF   xA6
02A8C:  CLRF   xA5
02A8E:  MOVFF  211,6A4
02A92:  MOVFF  210,6A3
02A96:  MOVLB  0
02A98:  CALL   15E2
02A9C:  MOVFF  693,00
02AA0:  MOVFF  694,01
02AA4:  MOVFF  695,02
02AA8:  MOVFF  696,03
02AAC:  MOVFF  692,FEA
02AB0:  MOVFF  691,FE9
02AB4:  MOVLB  6
02AB6:  MOVF   x89,W
02AB8:  ADDWF  00,F
02ABA:  MOVF   x8A,W
02ABC:  ADDWFC 01,F
02ABE:  MOVF   x8B,W
02AC0:  ADDWFC 02,F
02AC2:  MOVF   x8C,W
02AC4:  ADDWFC 03,F
02AC6:  MOVFF  688,FEA
02ACA:  MOVFF  687,FE9
02ACE:  MOVFF  00,FEF
02AD2:  MOVFF  01,FEC
02AD6:  MOVFF  02,FEC
02ADA:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
02ADE:  MOVLW  19
02AE0:  ADDWF  x7B,W
02AE2:  MOVWF  FE9
02AE4:  MOVLW  00
02AE6:  ADDWFC x7C,W
02AE8:  MOVWF  FEA
02AEA:  BTFSS  FEF.0
02AEC:  BRA    2BB4
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
02AEE:  MOVLW  10
02AF0:  ADDWF  x7B,W
02AF2:  MOVWF  FE9
02AF4:  MOVLW  00
02AF6:  ADDWFC x7C,W
02AF8:  MOVWF  FEA
02AFA:  MOVFF  FEF,689
02AFE:  MOVFF  FEC,68A
02B02:  MOVFF  FEC,68B
02B06:  MOVFF  FEC,68C
02B0A:  MOVFF  67D,FE9
02B0E:  MOVFF  67E,FEA
02B12:  MOVFF  FEF,00
02B16:  MOVFF  FEC,01
02B1A:  MOVFF  FEC,02
02B1E:  MOVFF  FEC,03
02B22:  MOVF   00,W
02B24:  SUBWF  x89,W
02B26:  MOVWF  00
02B28:  MOVF   01,W
02B2A:  SUBWFB x8A,W
02B2C:  MOVWF  01
02B2E:  MOVF   02,W
02B30:  SUBWFB x8B,W
02B32:  MOVWF  02
02B34:  MOVF   03,W
02B36:  SUBWFB x8C,W
02B38:  MOVFF  67C,FEA
02B3C:  MOVFF  67B,FE9
02B40:  MOVFF  00,FEF
02B44:  MOVFF  01,FEC
02B48:  MOVFF  02,FEC
02B4C:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
02B4E:  MOVLW  04
02B50:  ADDWF  x7B,W
02B52:  MOVWF  FE9
02B54:  MOVLW  00
02B56:  ADDWFC x7C,W
02B58:  MOVWF  FEA
02B5A:  MOVFF  FEF,6B4
02B5E:  MOVFF  FEC,6B5
02B62:  MOVFF  FEC,6B6
02B66:  MOVFF  FEC,6B7
02B6A:  MOVLW  1A
02B6C:  ADDWF  x7B,W
02B6E:  MOVWF  01
02B70:  MOVLW  00
02B72:  ADDWFC x7C,W
02B74:  MOVWF  03
02B76:  MOVFF  01,68B
02B7A:  MOVWF  x8C
02B7C:  CLRF   xB9
02B7E:  MOVLW  20
02B80:  MOVWF  xB8
02B82:  MOVFF  03,6BB
02B86:  MOVFF  01,6BA
02B8A:  MOVLB  0
02B8C:  CALL   0C10
02B90:  MOVF   01,F
02B92:  BZ    2BB0
....................       { 
....................          stream->Flags |= Read_Error; 
02B94:  MOVLW  19
02B96:  MOVLB  6
02B98:  ADDWF  x7B,W
02B9A:  MOVWF  FE9
02B9C:  MOVLW  00
02B9E:  ADDWFC x7C,W
02BA0:  MOVWF  FEA
02BA2:  MOVF   FEF,W
02BA4:  IORLW  20
02BA6:  MOVWF  FEF
....................          return EOF; 
02BA8:  MOVLW  FF
02BAA:  MOVWF  01
02BAC:  MOVLB  0
02BAE:  BRA    2BF6
....................       } 
....................    } 
02BB0:  BRA    2BF2
02BB2:  MOVLB  6
....................  
....................    else 
....................       stream->Size = *position; 
02BB4:  MOVLW  10
02BB6:  ADDWF  x7B,W
02BB8:  MOVWF  01
02BBA:  MOVLW  00
02BBC:  ADDWFC x7C,W
02BBE:  MOVFF  01,687
02BC2:  MOVFF  67D,FE9
02BC6:  MOVFF  67E,FEA
02BCA:  MOVFF  FEF,00
02BCE:  MOVFF  FEC,01
02BD2:  MOVFF  FEC,02
02BD6:  MOVFF  FEC,03
02BDA:  MOVWF  FEA
02BDC:  MOVFF  687,FE9
02BE0:  MOVFF  00,FEF
02BE4:  MOVFF  01,FEC
02BE8:  MOVFF  02,FEC
02BEC:  MOVFF  03,FEC
02BF0:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
02BF2:  MOVLW  00
02BF4:  MOVWF  01
02BF6:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
*
04EF6:  MOVLB  5
04EF8:  MOVF   xA6,W
04EFA:  XORLW  00
04EFC:  MOVLB  0
04EFE:  BZ    4F0A
04F00:  XORLW  01
04F02:  BZ    4F64
04F04:  XORLW  03
04F06:  BZ    4FBE
04F08:  BRA    4FF2
....................    { 
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
04F0A:  MOVLW  04
04F0C:  MOVLB  5
04F0E:  ADDWF  xA0,W
04F10:  MOVWF  FE9
04F12:  MOVLW  00
04F14:  ADDWFC xA1,W
04F16:  MOVWF  FEA
04F18:  MOVFF  FEF,5AB
04F1C:  MOVFF  FEC,5AC
04F20:  MOVFF  FEC,5AD
04F24:  MOVFF  FEC,5AE
04F28:  MOVF   xA2,W
04F2A:  ADDWF  xAB,W
04F2C:  MOVWF  xA7
04F2E:  MOVF   xA3,W
04F30:  ADDWFC xAC,W
04F32:  MOVWF  xA8
04F34:  MOVF   xA4,W
04F36:  ADDWFC xAD,W
04F38:  MOVWF  xA9
04F3A:  MOVF   xA5,W
04F3C:  ADDWFC xAE,W
04F3E:  MOVWF  xAA
....................          if(fatsetpos(stream, &myoffset) != 0) 
04F40:  MOVFF  5A1,67C
04F44:  MOVFF  5A0,67B
04F48:  MOVLW  05
04F4A:  MOVLB  6
04F4C:  MOVWF  x7E
04F4E:  MOVLW  A7
04F50:  MOVWF  x7D
04F52:  MOVLB  0
04F54:  CALL   2806
04F58:  MOVF   01,F
04F5A:  BZ    4F62
....................             return EOF; 
04F5C:  MOVLW  FF
04F5E:  MOVWF  01
04F60:  BRA    5010
....................          break; 
04F62:  BRA    4FF8
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
04F64:  MOVLW  10
04F66:  MOVLB  5
04F68:  ADDWF  xA0,W
04F6A:  MOVWF  FE9
04F6C:  MOVLW  00
04F6E:  ADDWFC xA1,W
04F70:  MOVWF  FEA
04F72:  MOVFF  FEF,5AB
04F76:  MOVFF  FEC,5AC
04F7A:  MOVFF  FEC,5AD
04F7E:  MOVFF  FEC,5AE
04F82:  MOVF   xA2,W
04F84:  SUBWF  xAB,W
04F86:  MOVWF  xA7
04F88:  MOVF   xA3,W
04F8A:  SUBWFB xAC,W
04F8C:  MOVWF  xA8
04F8E:  MOVF   xA4,W
04F90:  SUBWFB xAD,W
04F92:  MOVWF  xA9
04F94:  MOVF   xA5,W
04F96:  SUBWFB xAE,W
04F98:  MOVWF  xAA
....................          if(fatsetpos(stream, &myoffset) != 0) 
04F9A:  MOVFF  5A1,67C
04F9E:  MOVFF  5A0,67B
04FA2:  MOVLW  05
04FA4:  MOVLB  6
04FA6:  MOVWF  x7E
04FA8:  MOVLW  A7
04FAA:  MOVWF  x7D
04FAC:  MOVLB  0
04FAE:  CALL   2806
04FB2:  MOVF   01,F
04FB4:  BZ    4FBC
....................             return EOF; 
04FB6:  MOVLW  FF
04FB8:  MOVWF  01
04FBA:  BRA    5010
....................          break; 
04FBC:  BRA    4FF8
....................       case SEEK_SET: 
....................          myoffset = offset; 
04FBE:  MOVFF  5A5,5AA
04FC2:  MOVFF  5A4,5A9
04FC6:  MOVFF  5A3,5A8
04FCA:  MOVFF  5A2,5A7
....................          if(fatsetpos(stream, &myoffset) != 0) 
04FCE:  MOVFF  5A1,67C
04FD2:  MOVFF  5A0,67B
04FD6:  MOVLW  05
04FD8:  MOVLB  6
04FDA:  MOVWF  x7E
04FDC:  MOVLW  A7
04FDE:  MOVWF  x7D
04FE0:  MOVLB  0
04FE2:  CALL   2806
04FE6:  MOVF   01,F
04FE8:  BZ    4FF0
....................             return EOF; 
04FEA:  MOVLW  FF
04FEC:  MOVWF  01
04FEE:  BRA    5010
....................          break; 
04FF0:  BRA    4FF8
....................       default: 
....................          return EOF; 
04FF2:  MOVLW  FF
04FF4:  MOVWF  01
04FF6:  BRA    5010
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
04FF8:  MOVLW  19
04FFA:  MOVLB  5
04FFC:  ADDWF  xA0,W
04FFE:  MOVWF  FE9
05000:  MOVLW  00
05002:  ADDWFC xA1,W
05004:  MOVWF  FEA
05006:  MOVF   FEF,W
05008:  ANDLW  EF
0500A:  MOVWF  FEF
....................  
....................    return GOODEC; 
0500C:  MOVLW  00
0500E:  MOVWF  01
05010:  MOVLB  0
05012:  GOTO   52CC (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
*
0332A:  MOVLW  19
0332C:  MOVLB  5
0332E:  ADDWF  xEE,W
03330:  MOVWF  FE9
03332:  MOVLW  00
03334:  ADDWFC xEF,W
03336:  MOVWF  FEA
03338:  BTFSC  FEF.1
0333A:  BRA    334C
0333C:  MOVLW  19
0333E:  ADDWF  xEE,W
03340:  MOVWF  FE9
03342:  MOVLW  00
03344:  ADDWFC xEF,W
03346:  MOVWF  FEA
03348:  BTFSS  FEF.2
0334A:  BRA    34BC
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
0334C:  MOVLW  04
0334E:  ADDWF  xEE,W
03350:  MOVWF  FE9
03352:  MOVLW  00
03354:  ADDWFC xEF,W
03356:  MOVWF  FEA
03358:  MOVFF  FEF,5F0
0335C:  MOVFF  FEC,5F1
03360:  MOVFF  FEC,5F2
03364:  MOVFF  FEC,5F3
03368:  MOVLW  1F
0336A:  ANDWF  xF0,F
0336C:  CLRF   xF1
0336E:  CLRF   xF2
03370:  CLRF   xF3
03372:  MOVF   xF0,F
03374:  BNZ   3406
03376:  MOVF   xF1,F
03378:  BNZ   3406
0337A:  MOVF   xF2,F
0337C:  BNZ   3406
0337E:  MOVF   xF3,F
03380:  BNZ   3406
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
03382:  MOVLW  04
03384:  ADDWF  xEE,W
03386:  MOVWF  FE9
03388:  MOVLW  00
0338A:  ADDWFC xEF,W
0338C:  MOVWF  FEA
0338E:  MOVFF  FEF,5F0
03392:  MOVFF  FEC,5F1
03396:  MOVFF  FEC,5F2
0339A:  MOVFF  FEC,5F3
0339E:  MOVLW  20
033A0:  SUBWF  xF0,F
033A2:  MOVLW  00
033A4:  SUBWFB xF1,F
033A6:  SUBWFB xF2,F
033A8:  SUBWFB xF3,F
033AA:  MOVLW  1A
033AC:  ADDWF  xEE,W
033AE:  MOVWF  01
033B0:  MOVLW  00
033B2:  ADDWFC xEF,W
033B4:  MOVWF  03
033B6:  MOVFF  01,5F4
033BA:  MOVWF  xF5
033BC:  MOVFF  5F3,6D0
033C0:  MOVFF  5F2,6CF
033C4:  MOVFF  5F1,6CE
033C8:  MOVFF  5F0,6CD
033CC:  MOVLB  6
033CE:  CLRF   xD2
033D0:  MOVLW  20
033D2:  MOVWF  xD1
033D4:  MOVFF  03,6D4
033D8:  MOVFF  01,6D3
033DC:  MOVLB  0
033DE:  CALL   1D02
033E2:  MOVF   01,F
033E4:  BZ    3402
....................          { 
....................             stream->Flags |= Write_Error; 
033E6:  MOVLW  19
033E8:  MOVLB  5
033EA:  ADDWF  xEE,W
033EC:  MOVWF  FE9
033EE:  MOVLW  00
033F0:  ADDWFC xEF,W
033F2:  MOVWF  FEA
033F4:  MOVF   FEF,W
033F6:  IORLW  40
033F8:  MOVWF  FEF
....................             return EOF; 
033FA:  MOVLW  FF
033FC:  MOVWF  01
033FE:  BRA    34C0
03400:  MOVLB  0
....................          } 
....................       } 
03402:  BRA    34B2
03404:  MOVLB  5
....................       else 
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
03406:  MOVLW  04
03408:  ADDWF  xEE,W
0340A:  MOVWF  FE9
0340C:  MOVLW  00
0340E:  ADDWFC xEF,W
03410:  MOVWF  FEA
03412:  MOVFF  FEF,5F0
03416:  MOVFF  FEC,5F1
0341A:  MOVFF  FEC,5F2
0341E:  MOVFF  FEC,5F3
03422:  MOVLW  04
03424:  ADDWF  xEE,W
03426:  MOVWF  FE9
03428:  MOVLW  00
0342A:  ADDWFC xEF,W
0342C:  MOVWF  FEA
0342E:  MOVFF  FEF,5F4
03432:  MOVFF  FEC,5F5
03436:  MOVFF  FEC,5F6
0343A:  MOVFF  FEC,5F7
0343E:  MOVF   xF4,W
03440:  ANDLW  1F
03442:  MOVWF  00
03444:  CLRF   01
03446:  CLRF   02
03448:  CLRF   03
0344A:  MOVF   00,W
0344C:  SUBWF  xF0,F
0344E:  MOVF   01,W
03450:  SUBWFB xF1,F
03452:  MOVF   02,W
03454:  SUBWFB xF2,F
03456:  MOVF   03,W
03458:  SUBWFB xF3,F
0345A:  MOVLW  1A
0345C:  ADDWF  xEE,W
0345E:  MOVWF  01
03460:  MOVLW  00
03462:  ADDWFC xEF,W
03464:  MOVWF  03
03466:  MOVFF  01,5F4
0346A:  MOVWF  xF5
0346C:  MOVFF  5F3,6D0
03470:  MOVFF  5F2,6CF
03474:  MOVFF  5F1,6CE
03478:  MOVFF  5F0,6CD
0347C:  MOVLB  6
0347E:  CLRF   xD2
03480:  MOVLW  20
03482:  MOVWF  xD1
03484:  MOVFF  03,6D4
03488:  MOVFF  01,6D3
0348C:  MOVLB  0
0348E:  CALL   1D02
03492:  MOVF   01,F
03494:  BZ    34B2
....................          { 
....................             stream->Flags |= Write_Error; 
03496:  MOVLW  19
03498:  MOVLB  5
0349A:  ADDWF  xEE,W
0349C:  MOVWF  FE9
0349E:  MOVLW  00
034A0:  ADDWFC xEF,W
034A2:  MOVWF  FEA
034A4:  MOVF   FEF,W
034A6:  IORLW  40
034A8:  MOVWF  FEF
....................             return EOF; 
034AA:  MOVLW  FF
034AC:  MOVWF  01
034AE:  BRA    34C0
034B0:  MOVLB  0
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
034B2:  CALL   0AFA
034B6:  MOVF   01,W
034B8:  MOVLB  5
034BA:  BRA    34C0
....................    } 
....................    return 0; 
034BC:  MOVLW  00
034BE:  MOVWF  01
034C0:  MOVLB  0
034C2:  GOTO   374C (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
01E96:  MOVLW  04
01E98:  MOVLB  6
01E9A:  ADDWF  x87,W
01E9C:  MOVWF  01
01E9E:  MOVLW  00
01EA0:  ADDWFC x88,W
01EA2:  MOVWF  03
01EA4:  MOVFF  01,689
01EA8:  MOVWF  x8A
01EAA:  MOVLW  14
01EAC:  ADDWF  x87,W
01EAE:  MOVWF  FE9
01EB0:  MOVLW  00
01EB2:  ADDWFC x88,W
01EB4:  MOVWF  FEA
01EB6:  MOVFF  FEF,00
01EBA:  MOVFF  FEC,01
01EBE:  MOVFF  FEC,02
01EC2:  MOVFF  FEC,03
01EC6:  MOVFF  68A,FEA
01ECA:  MOVFF  689,FE9
01ECE:  MOVFF  00,FEF
01ED2:  MOVFF  01,FEC
01ED6:  MOVFF  02,FEC
01EDA:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
01EDE:  MOVLW  10
01EE0:  ADDWF  x87,W
01EE2:  MOVWF  FE9
01EE4:  MOVLW  00
01EE6:  ADDWFC x88,W
01EE8:  MOVWF  FEA
01EEA:  MOVFF  FEF,00
01EEE:  MOVFF  FEC,01
01EF2:  MOVFF  FEC,02
01EF6:  MOVFF  FEC,03
01EFA:  MOVFF  688,FEA
01EFE:  MOVFF  687,FE9
01F02:  MOVFF  00,FEF
01F06:  MOVFF  01,FEC
01F0A:  MOVFF  02,FEC
01F0E:  MOVFF  03,FEC
01F12:  MOVLB  0
01F14:  GOTO   2842 (RETURN)
.................... } 
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
*
037EC:  MOVLW  E5
037EE:  MOVLB  5
037F0:  MOVWF  xA6
.................... { 
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
037F2:  MOVLW  72
037F4:  MOVWF  xAB
037F6:  CLRF   xAC
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
037F8:  MOVFF  5A4,5EB
037FC:  MOVFF  5A3,5EA
03800:  MOVLW  05
03802:  MOVWF  xED
03804:  MOVLW  AB
03806:  MOVWF  xEC
03808:  MOVLW  05
0380A:  MOVWF  xEF
0380C:  MOVLW  AD
0380E:  MOVWF  xEE
03810:  MOVLB  0
03812:  CALL   10000
03816:  MOVF   01,W
03818:  SUBLW  FF
0381A:  BNZ   3822
....................       return EOF; 
0381C:  MOVLW  FF
0381E:  MOVWF  01
03820:  BRA    39FE
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
03822:  MOVLB  2
03824:  MOVF   x23,W
03826:  MOVLB  5
03828:  SUBWF  xC4,W
0382A:  BNC   389E
0382C:  BNZ   3856
0382E:  MOVLB  2
03830:  MOVF   x22,W
03832:  MOVLB  5
03834:  SUBWF  xC3,W
03836:  BNC   389E
03838:  BNZ   3856
0383A:  MOVLB  2
0383C:  MOVF   x21,W
0383E:  MOVLB  5
03840:  SUBWF  xC2,W
03842:  BNC   389E
03844:  BNZ   3856
03846:  MOVF   xC1,W
03848:  MOVLB  2
0384A:  SUBWF  x20,W
0384C:  BTFSS  FD8.0
0384E:  BRA    3854
03850:  MOVLB  5
03852:  BRA    389E
03854:  MOVLB  5
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
03856:  MOVFF  5C4,69A
0385A:  MOVFF  5C3,699
0385E:  MOVFF  5C2,698
03862:  MOVFF  5C1,697
03866:  MOVLB  0
03868:  CALL   1676
0386C:  MOVFF  03,5EA
03870:  MOVFF  02,5E9
03874:  MOVFF  01,5E8
03878:  MOVFF  00,5E7
0387C:  MOVFF  03,680
03880:  MOVFF  02,67F
03884:  MOVFF  01,67E
03888:  MOVFF  00,67D
0388C:  CALL   1DEE
03890:  MOVF   01,W
03892:  SUBLW  FF
03894:  BNZ   389C
....................          return EOF; 
03896:  MOVLW  FF
03898:  MOVWF  01
0389A:  BRA    39FE
0389C:  MOVLB  5
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
0389E:  MOVFF  5B8,5AA
038A2:  MOVFF  5B7,5A9
038A6:  MOVFF  5B6,5A8
038AA:  MOVFF  5B5,5A7
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
038AE:  MOVFF  5AA,6D0
038B2:  MOVFF  5A9,6CF
038B6:  MOVFF  5A8,6CE
038BA:  MOVFF  5A7,6CD
038BE:  MOVLB  6
038C0:  CLRF   xD2
038C2:  MOVLW  01
038C4:  MOVWF  xD1
038C6:  MOVLW  05
038C8:  MOVWF  xD4
038CA:  MOVLW  A6
038CC:  MOVWF  xD3
038CE:  MOVLB  0
038D0:  CALL   1D02
038D4:  MOVF   01,W
038D6:  SUBLW  FF
038D8:  BNZ   38E0
....................       return EOF; 
038DA:  MOVLW  FF
038DC:  MOVWF  01
038DE:  BRA    39FE
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
038E0:  MOVLW  05
038E2:  MOVLB  6
038E4:  MOVWF  x88
038E6:  MOVLW  A7
038E8:  MOVWF  x87
038EA:  MOVLB  0
038EC:  CALL   19E4
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
038F0:  MOVLW  0B
038F2:  MOVLB  5
038F4:  ADDWF  xA7,W
038F6:  MOVWF  xE7
038F8:  MOVLW  00
038FA:  ADDWFC xA8,W
038FC:  MOVWF  xE8
038FE:  MOVLW  00
03900:  ADDWFC xA9,W
03902:  MOVWF  xE9
03904:  MOVLW  00
03906:  ADDWFC xAA,W
03908:  MOVWF  xEA
0390A:  MOVFF  FE8,6B7
0390E:  MOVFF  5E9,6B6
03912:  MOVFF  5E8,6B5
03916:  MOVFF  5E7,6B4
0391A:  MOVLB  6
0391C:  CLRF   xB9
0391E:  MOVLW  01
03920:  MOVWF  xB8
03922:  MOVLW  05
03924:  MOVWF  xBB
03926:  MOVLW  A5
03928:  MOVWF  xBA
0392A:  MOVLB  0
0392C:  CALL   0C10
03930:  MOVF   01,W
03932:  SUBLW  FF
03934:  BNZ   393C
....................       return EOF; 
03936:  MOVLW  FF
03938:  MOVWF  01
0393A:  BRA    39FE
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
0393C:  MOVLB  5
0393E:  MOVF   xA5,W
03940:  SUBLW  0F
03942:  BNZ   39E2
....................    { 
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
03944:  MOVFF  5AA,6D0
03948:  MOVFF  5A9,6CF
0394C:  MOVFF  5A8,6CE
03950:  MOVFF  5A7,6CD
03954:  MOVLB  6
03956:  CLRF   xD2
03958:  MOVLW  01
0395A:  MOVWF  xD1
0395C:  MOVLW  05
0395E:  MOVWF  xD4
03960:  MOVLW  A6
03962:  MOVWF  xD3
03964:  MOVLB  0
03966:  CALL   1D02
0396A:  MOVF   01,W
0396C:  SUBLW  FF
0396E:  BNZ   3976
....................          return EOF; 
03970:  MOVLW  FF
03972:  MOVWF  01
03974:  BRA    39FE
....................  
....................       if(get_prev_entry(&i) == EOF) 
03976:  MOVLW  05
03978:  MOVLB  6
0397A:  MOVWF  x88
0397C:  MOVLW  A7
0397E:  MOVWF  x87
03980:  MOVLB  0
03982:  CALL   19E4
03986:  MOVF   01,W
03988:  SUBLW  FF
0398A:  BNZ   3992
....................          return EOF; 
0398C:  MOVLW  FF
0398E:  MOVWF  01
03990:  BRA    39FE
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
03992:  MOVLW  0B
03994:  MOVLB  5
03996:  ADDWF  xA7,W
03998:  MOVWF  xE7
0399A:  MOVLW  00
0399C:  ADDWFC xA8,W
0399E:  MOVWF  xE8
039A0:  MOVLW  00
039A2:  ADDWFC xA9,W
039A4:  MOVWF  xE9
039A6:  MOVLW  00
039A8:  ADDWFC xAA,W
039AA:  MOVWF  xEA
039AC:  MOVFF  FE8,6B7
039B0:  MOVFF  5E9,6B6
039B4:  MOVFF  5E8,6B5
039B8:  MOVFF  5E7,6B4
039BC:  MOVLB  6
039BE:  CLRF   xB9
039C0:  MOVLW  01
039C2:  MOVWF  xB8
039C4:  MOVLW  05
039C6:  MOVWF  xBB
039C8:  MOVLW  A5
039CA:  MOVWF  xBA
039CC:  MOVLB  0
039CE:  CALL   0C10
039D2:  MOVF   01,W
039D4:  SUBLW  FF
039D6:  BNZ   39DE
....................          return EOF; 
039D8:  MOVLW  FF
039DA:  MOVWF  01
039DC:  BRA    39FE
039DE:  BRA    393C
039E0:  MOVLB  5
....................    } 
....................     
....................    if(fatclose(&stream) == EOF) 
039E2:  MOVLW  05
039E4:  MOVWF  xE8
039E6:  MOVLW  AD
039E8:  MOVWF  xE7
039EA:  MOVLB  0
039EC:  RCALL  34C6
039EE:  MOVF   01,W
039F0:  SUBLW  FF
039F2:  BNZ   39FA
....................       return EOF; 
039F4:  MOVLW  FF
039F6:  MOVWF  01
039F8:  BRA    39FE
....................  
....................    return GOODEC; 
039FA:  MOVLW  00
039FC:  MOVWF  01
039FE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
*
057FA:  MOVLW  72
057FC:  MOVLB  5
057FE:  MOVWF  x67
05800:  CLRF   x68
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
05802:  MOVFF  566,5EB
05806:  MOVFF  565,5EA
0580A:  MOVLW  05
0580C:  MOVWF  xED
0580E:  MOVLW  67
05810:  MOVWF  xEC
05812:  MOVLW  05
05814:  MOVWF  xEF
05816:  MOVLW  69
05818:  MOVWF  xEE
0581A:  MOVLB  0
0581C:  CALL   10000
05820:  MOVF   01,W
05822:  SUBLW  FF
05824:  BNZ   582C
....................       return EOF; 
05826:  MOVLW  FF
05828:  MOVWF  01
0582A:  BRA    587C
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
0582C:  MOVLW  40
0582E:  MOVLB  5
05830:  ADDWF  x7D,W
05832:  MOVWF  x71
05834:  MOVLW  00
05836:  ADDWFC x7E,W
05838:  MOVWF  x72
0583A:  MOVLW  00
0583C:  ADDWFC x7F,W
0583E:  MOVWF  x73
05840:  MOVLW  00
05842:  ADDWFC x80,W
05844:  MOVWF  x74
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
05846:  MOVLW  05
05848:  MOVWF  xC2
0584A:  MOVLW  69
0584C:  MOVWF  xC1
0584E:  MOVLB  0
05850:  CALL   4B60
05854:  MOVF   01,W
05856:  SUBLW  FF
05858:  BZ    5860
....................       return EOF; 
0585A:  MOVLW  FF
0585C:  MOVWF  01
0585E:  BRA    587C
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
05860:  MOVFF  566,5A4
05864:  MOVFF  565,5A3
05868:  CALL   37EC
0586C:  MOVF   01,W
0586E:  SUBLW  FF
05870:  BNZ   5878
....................       return EOF; 
05872:  MOVLW  FF
05874:  MOVWF  01
05876:  BRA    587C
....................  
....................    return GOODEC; 
05878:  MOVLW  00
0587A:  MOVWF  01
0587C:  GOTO   5916 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
*
04622:  CLRF   xA8
.................... { 
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
0461A:  MOVLW  72
0461C:  MOVLB  5
0461E:  MOVWF  x85
04620:  CLRF   x86
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
*
04624:  MOVFF  564,5EB
04628:  MOVFF  563,5EA
0462C:  MOVLW  05
0462E:  MOVWF  xED
04630:  MOVLW  85
04632:  MOVWF  xEC
04634:  MOVLW  05
04636:  MOVWF  xEF
04638:  MOVLW  AE
0463A:  MOVWF  xEE
0463C:  MOVLB  0
0463E:  CALL   10000
04642:  MOVF   01,F
04644:  BNZ   464C
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
04646:  MOVLW  FF
04648:  MOVWF  01
0464A:  BRA    4794
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
0464C:  MOVLB  5
0464E:  BTFSC  xC7.7
04650:  BRA    465C
....................       return EOF; 
04652:  MOVLW  FF
04654:  MOVWF  01
04656:  MOVLB  0
04658:  BRA    4794
0465A:  MOVLB  5
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
0465C:  MOVFF  564,5EB
04660:  MOVFF  563,5EA
04664:  MOVLW  2F
04666:  MOVWF  xEC
04668:  MOVLB  0
0466A:  CALL   3A70
0466E:  MOVFF  02,5E9
04672:  MOVFF  01,5E8
04676:  MOVLB  5
04678:  MOVF   x63,W
0467A:  SUBWF  xE8,F
0467C:  MOVF   x64,W
0467E:  SUBWFB xE9,F
04680:  MOVLW  01
04682:  ADDWF  xE8,W
04684:  MOVWF  xA9
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
04686:  MOVF   xA9,W
04688:  ADDWF  x63,W
0468A:  MOVWF  FE9
0468C:  MOVLW  00
0468E:  ADDWFC x64,W
04690:  MOVWF  FEA
04692:  MOVF   FEF,F
04694:  BZ    46CC
04696:  MOVF   xA8,W
04698:  SUBLW  1F
0469A:  BNC   46CC
....................    { 
....................       filename[filename_pos] = fname[fname_pos]; 
0469C:  CLRF   03
0469E:  MOVF   xA8,W
046A0:  ADDLW  65
046A2:  MOVWF  01
046A4:  MOVLW  05
046A6:  ADDWFC 03,F
046A8:  MOVF   xA9,W
046AA:  ADDWF  x63,W
046AC:  MOVWF  FE9
046AE:  MOVLW  00
046B0:  ADDWFC x64,W
046B2:  MOVWF  FEA
046B4:  MOVFF  FEF,5EA
046B8:  MOVFF  03,FEA
046BC:  MOVFF  01,FE9
046C0:  MOVFF  5EA,FEF
....................       fname_pos += 1; 
046C4:  MOVLW  01
046C6:  ADDWF  xA9,F
....................       filename_pos += 1; 
046C8:  ADDWF  xA8,F
046CA:  BRA    4686
....................    } 
....................    filename[filename_pos] = '\0'; 
046CC:  CLRF   03
046CE:  MOVF   xA8,W
046D0:  ADDLW  65
046D2:  MOVWF  FE9
046D4:  MOVLW  05
046D6:  ADDWFC 03,W
046D8:  MOVWF  FEA
046DA:  CLRF   FEF
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
046DC:  MOVFF  5C5,5ED
046E0:  MOVFF  5C4,5EC
046E4:  MOVFF  5C3,5EB
046E8:  MOVFF  5C2,5EA
046EC:  MOVLW  05
046EE:  MOVWF  xEF
046F0:  MOVLW  AA
046F2:  MOVWF  xEE
046F4:  MOVLW  05
046F6:  MOVWF  xF1
046F8:  MOVLW  65
046FA:  MOVWF  xF0
046FC:  MOVLB  0
046FE:  RCALL  4306
04700:  MOVF   01,W
04702:  SUBLW  FF
04704:  BNZ   470C
....................       return EOF; 
04706:  MOVLW  FF
04708:  MOVWF  01
0470A:  BRA    4794
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
0470C:  MOVLB  5
0470E:  CLRF   x87
04710:  MOVF   x87,W
04712:  SUBLW  1F
04714:  BNC   472C
....................       entire_entry[buf] = 0; 
04716:  CLRF   03
04718:  MOVF   x87,W
0471A:  ADDLW  88
0471C:  MOVWF  FE9
0471E:  MOVLW  05
04720:  ADDWFC 03,W
04722:  MOVWF  FEA
04724:  CLRF   FEF
04726:  MOVLW  01
04728:  ADDWF  x87,F
0472A:  BRA    4710
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
0472C:  MOVLW  20
0472E:  MOVWF  x93
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
04730:  MOVFF  5AD,6B7
04734:  MOVFF  5AC,6B6
04738:  MOVFF  5AB,6B5
0473C:  MOVFF  5AA,6B4
04740:  MOVLB  6
04742:  CLRF   xB9
04744:  MOVLW  0B
04746:  MOVWF  xB8
04748:  MOVLW  05
0474A:  MOVWF  xBB
0474C:  MOVLW  88
0474E:  MOVWF  xBA
04750:  MOVLB  0
04752:  CALL   0C10
04756:  MOVF   01,F
04758:  BZ    4760
....................       return EOF; 
0475A:  MOVLW  FF
0475C:  MOVWF  01
0475E:  BRA    4794
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
04760:  MOVFF  5AD,6D0
04764:  MOVFF  5AC,6CF
04768:  MOVFF  5AB,6CE
0476C:  MOVFF  5AA,6CD
04770:  MOVLB  6
04772:  CLRF   xD2
04774:  MOVLW  20
04776:  MOVWF  xD1
04778:  MOVLW  05
0477A:  MOVWF  xD4
0477C:  MOVLW  88
0477E:  MOVWF  xD3
04780:  MOVLB  0
04782:  CALL   1D02
04786:  MOVF   01,F
04788:  BZ    4790
....................       return EOF; 
0478A:  MOVLW  FF
0478C:  MOVWF  01
0478E:  BRA    4794
....................  
....................    return GOODEC; 
04790:  MOVLW  00
04792:  MOVWF  01
04794:  GOTO   47DE (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
*
052F4:  CLRF   xA9
.................... { 
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
052EC:  MOVLW  72
052EE:  MOVLB  5
052F0:  MOVWF  xA7
052F2:  CLRF   xA8
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
*
052F6:  MOVFF  566,5EB
052FA:  MOVFF  565,5EA
052FE:  MOVLW  05
05300:  MOVWF  xED
05302:  MOVLW  A7
05304:  MOVWF  xEC
05306:  MOVLW  05
05308:  MOVWF  xEF
0530A:  MOVLW  B0
0530C:  MOVWF  xEE
0530E:  MOVLB  0
05310:  CALL   10000
05314:  MOVF   01,F
05316:  BNZ   531E
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
05318:  MOVLW  FF
0531A:  MOVWF  01
0531C:  BRA    573A
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
0531E:  MOVLB  5
05320:  BTFSC  xC9.7
05322:  BRA    532E
....................       return EOF; 
05324:  MOVLW  FF
05326:  MOVWF  01
05328:  MOVLB  0
0532A:  BRA    573A
0532C:  MOVLB  5
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
0532E:  MOVFF  566,5EB
05332:  MOVFF  565,5EA
05336:  MOVLW  2F
05338:  MOVWF  xEC
0533A:  MOVLB  0
0533C:  CALL   3A70
05340:  MOVLB  5
05342:  MOVF   x65,W
05344:  SUBWF  01,W
05346:  MOVWF  xAA
....................    dname[dname_pos] = '\0'; 
05348:  MOVF   xAA,W
0534A:  ADDWF  x65,W
0534C:  MOVWF  FE9
0534E:  MOVLW  00
05350:  ADDWFC x66,W
05352:  MOVWF  FEA
05354:  CLRF   FEF
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
05356:  MOVFF  566,5EB
0535A:  MOVFF  565,5EA
0535E:  MOVLW  2F
05360:  MOVWF  xEC
05362:  MOVLB  0
05364:  CALL   3A70
05368:  MOVFF  02,5EB
0536C:  MOVFF  01,5EA
05370:  MOVLB  5
05372:  MOVF   x65,W
05374:  SUBWF  xEA,F
05376:  MOVF   x66,W
05378:  SUBWFB xEB,F
0537A:  MOVLW  01
0537C:  ADDWF  xEA,W
0537E:  MOVWF  xAA
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
05380:  MOVF   xAA,W
05382:  ADDWF  x65,W
05384:  MOVWF  FE9
05386:  MOVLW  00
05388:  ADDWFC x66,W
0538A:  MOVWF  FEA
0538C:  MOVF   FEF,F
0538E:  BZ    53C6
05390:  MOVF   xA9,W
05392:  SUBLW  1F
05394:  BNC   53C6
....................    { 
....................       dirname[dirname_pos] = dname[dname_pos]; 
05396:  CLRF   03
05398:  MOVF   xA9,W
0539A:  ADDLW  67
0539C:  MOVWF  01
0539E:  MOVLW  05
053A0:  ADDWFC 03,F
053A2:  MOVF   xAA,W
053A4:  ADDWF  x65,W
053A6:  MOVWF  FE9
053A8:  MOVLW  00
053AA:  ADDWFC x66,W
053AC:  MOVWF  FEA
053AE:  MOVFF  FEF,5EC
053B2:  MOVFF  03,FEA
053B6:  MOVFF  01,FE9
053BA:  MOVFF  5EC,FEF
....................       dname_pos += 1; 
053BE:  MOVLW  01
053C0:  ADDWF  xAA,F
....................       dirname_pos += 1; 
053C2:  ADDWF  xA9,F
053C4:  BRA    5380
....................    } 
....................    dirname[dirname_pos] = '\0'; 
053C6:  CLRF   03
053C8:  MOVF   xA9,W
053CA:  ADDLW  67
053CC:  MOVWF  FE9
053CE:  MOVLW  05
053D0:  ADDWFC 03,W
053D2:  MOVWF  FEA
053D4:  CLRF   FEF
....................    dname[dname_pos] = '/'; 
053D6:  MOVF   xAA,W
053D8:  ADDWF  x65,W
053DA:  MOVWF  FE9
053DC:  MOVLW  00
053DE:  ADDWFC x66,W
053E0:  MOVWF  FEA
053E2:  MOVLW  2F
053E4:  MOVWF  FEF
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
053E6:  MOVFF  5C7,5ED
053EA:  MOVFF  5C6,5EC
053EE:  MOVFF  5C5,5EB
053F2:  MOVFF  5C4,5EA
053F6:  MOVLW  05
053F8:  MOVWF  xEF
053FA:  MOVLW  AC
053FC:  MOVWF  xEE
053FE:  MOVLW  05
05400:  MOVWF  xF1
05402:  MOVLW  67
05404:  MOVWF  xF0
05406:  MOVLB  0
05408:  CALL   4306
0540C:  MOVF   01,W
0540E:  SUBLW  FF
05410:  BNZ   5418
....................       return EOF; 
05412:  MOVLW  FF
05414:  MOVWF  01
05416:  BRA    573A
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
05418:  MOVLW  02
0541A:  MOVLB  6
0541C:  MOVWF  x9F
0541E:  MOVLW  1C
05420:  MOVWF  x9E
05422:  MOVLB  0
05424:  CALL   1F18
05428:  MOVF   01,W
0542A:  SUBLW  FF
0542C:  BNZ   5434
....................       return EOF; 
0542E:  MOVLW  FF
05430:  MOVWF  01
05432:  BRA    573A
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
05434:  MOVFF  21F,6A1
05438:  MOVFF  21E,6A0
0543C:  MOVFF  21D,69F
05440:  MOVFF  21C,69E
05444:  CALL   2094
05448:  MOVF   01,W
0544A:  SUBLW  FF
0544C:  BNZ   5454
....................       return EOF; 
0544E:  MOVLW  FF
05450:  MOVWF  01
05452:  BRA    573A
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
05454:  MOVFF  21F,6A1
05458:  MOVFF  21E,6A0
0545C:  MOVFF  21D,69F
05460:  MOVFF  21C,69E
05464:  MOVLW  0F
05466:  MOVLB  6
05468:  MOVWF  xA5
0546A:  SETF   xA4
0546C:  SETF   xA3
0546E:  SETF   xA2
05470:  MOVLB  0
05472:  CALL   1D88
05476:  MOVF   01,W
05478:  SUBLW  FF
0547A:  BNZ   5482
....................       return EOF; 
0547C:  MOVLW  FF
0547E:  MOVWF  01
05480:  BRA    573A
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
05482:  MOVLB  5
05484:  CLRF   xAB
05486:  MOVF   xAB,W
05488:  SUBLW  1F
0548A:  BNC   54A2
....................       entire_entry[j] = 0; 
0548C:  CLRF   03
0548E:  MOVF   xAB,W
05490:  ADDLW  87
05492:  MOVWF  FE9
05494:  MOVLW  05
05496:  ADDWFC 03,W
05498:  MOVWF  FEA
0549A:  CLRF   FEF
0549C:  MOVLW  01
0549E:  ADDWF  xAB,F
054A0:  BRA    5486
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
054A2:  MOVLW  10
054A4:  MOVWF  x92
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
054A6:  MOVFF  21C,5A1
054AA:  MOVLB  5
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
054AC:  MOVFF  21D,5A2
054B0:  MOVLB  5
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
054B2:  MOVFF  21E,59B
054B6:  MOVLB  5
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
054B8:  MOVFF  21F,59C
054BC:  MOVLB  5
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
054BE:  MOVFF  5AF,6B7
054C2:  MOVFF  5AE,6B6
054C6:  MOVFF  5AD,6B5
054CA:  MOVFF  5AC,6B4
054CE:  MOVLB  6
054D0:  CLRF   xB9
054D2:  MOVLW  0B
054D4:  MOVWF  xB8
054D6:  MOVLW  05
054D8:  MOVWF  xBB
054DA:  MOVLW  87
054DC:  MOVWF  xBA
054DE:  MOVLB  0
054E0:  CALL   0C10
054E4:  MOVF   01,F
054E6:  BZ    54EE
....................       return EOF; 
054E8:  MOVLW  FF
054EA:  MOVWF  01
054EC:  BRA    573A
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
054EE:  MOVFF  5AF,6D0
054F2:  MOVFF  5AE,6CF
054F6:  MOVFF  5AD,6CE
054FA:  MOVFF  5AC,6CD
054FE:  MOVLB  6
05500:  CLRF   xD2
05502:  MOVLW  20
05504:  MOVWF  xD1
05506:  MOVLW  05
05508:  MOVWF  xD4
0550A:  MOVLW  87
0550C:  MOVWF  xD3
0550E:  MOVLB  0
05510:  CALL   1D02
05514:  MOVF   01,F
05516:  BZ    551E
....................       return EOF; 
05518:  MOVLW  FF
0551A:  MOVWF  01
0551C:  BRA    573A
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
0551E:  MOVFF  21F,6CC
05522:  MOVFF  21E,6CB
05526:  MOVFF  21D,6CA
0552A:  MOVFF  21C,6C9
0552E:  CALL   17C2
05532:  MOVFF  03,5AF
05536:  MOVFF  02,5AE
0553A:  MOVFF  01,5AD
0553E:  MOVFF  00,5AC
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
05542:  MOVLB  5
05544:  CLRF   xAB
05546:  MOVF   xAB,W
05548:  SUBLW  1F
0554A:  BNC   55AE
....................    { 
....................       if(j < 0x01) 
0554C:  MOVF   xAB,F
0554E:  BNZ   5564
....................          entire_entry[j] = '.'; 
05550:  CLRF   03
05552:  MOVF   xAB,W
05554:  ADDLW  87
05556:  MOVWF  FE9
05558:  MOVLW  05
0555A:  ADDWFC 03,W
0555C:  MOVWF  FEA
0555E:  MOVLW  2E
05560:  MOVWF  FEF
05562:  BRA    55A8
....................       else if(j < 0x0B) 
05564:  MOVF   xAB,W
05566:  SUBLW  0A
05568:  BNC   557E
....................          entire_entry[j] = 0x20; 
0556A:  CLRF   03
0556C:  MOVF   xAB,W
0556E:  ADDLW  87
05570:  MOVWF  FE9
05572:  MOVLW  05
05574:  ADDWFC 03,W
05576:  MOVWF  FEA
05578:  MOVLW  20
0557A:  MOVWF  FEF
0557C:  BRA    55A8
....................       else if(j == 0x0B) 
0557E:  MOVF   xAB,W
05580:  SUBLW  0B
05582:  BNZ   5598
....................          entire_entry[j] = 0x10; 
05584:  CLRF   03
05586:  MOVF   xAB,W
05588:  ADDLW  87
0558A:  MOVWF  FE9
0558C:  MOVLW  05
0558E:  ADDWFC 03,W
05590:  MOVWF  FEA
05592:  MOVLW  10
05594:  MOVWF  FEF
05596:  BRA    55A8
....................       else 
....................          entire_entry[j] = 0x00; 
05598:  CLRF   03
0559A:  MOVF   xAB,W
0559C:  ADDLW  87
0559E:  MOVWF  FE9
055A0:  MOVLW  05
055A2:  ADDWFC 03,W
055A4:  MOVWF  FEA
055A6:  CLRF   FEF
055A8:  MOVLW  01
055AA:  ADDWF  xAB,F
055AC:  BRA    5546
....................    } 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
055AE:  MOVFF  21C,5A1
055B2:  MOVLB  5
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
055B4:  MOVFF  21D,5A2
055B8:  MOVLB  5
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
055BA:  MOVFF  21E,59B
055BE:  MOVLB  5
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
055C0:  MOVFF  21F,59C
055C4:  MOVLB  5
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
055C6:  MOVFF  5AF,6D0
055CA:  MOVFF  5AE,6CF
055CE:  MOVFF  5AD,6CE
055D2:  MOVFF  5AC,6CD
055D6:  MOVLB  6
055D8:  CLRF   xD2
055DA:  MOVLW  20
055DC:  MOVWF  xD1
055DE:  MOVLW  05
055E0:  MOVWF  xD4
055E2:  MOVLW  87
055E4:  MOVWF  xD3
055E6:  MOVLB  0
055E8:  CALL   1D02
055EC:  MOVF   01,F
055EE:  BZ    55F6
....................       return EOF; 
055F0:  MOVLW  FF
055F2:  MOVWF  01
055F4:  BRA    573A
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
055F6:  MOVLB  5
055F8:  CLRF   xAB
055FA:  MOVF   xAB,W
055FC:  SUBLW  0B
055FE:  BNC   564C
....................    { 
....................       if(j < 0x02) 
05600:  MOVF   xAB,W
05602:  SUBLW  01
05604:  BNC   561A
....................          entire_entry[j] = '.'; 
05606:  CLRF   03
05608:  MOVF   xAB,W
0560A:  ADDLW  87
0560C:  MOVWF  FE9
0560E:  MOVLW  05
05610:  ADDWFC 03,W
05612:  MOVWF  FEA
05614:  MOVLW  2E
05616:  MOVWF  FEF
05618:  BRA    5646
....................       else if(j < 0x0B) 
0561A:  MOVF   xAB,W
0561C:  SUBLW  0A
0561E:  BNC   5634
....................          entire_entry[j] = 0x20; 
05620:  CLRF   03
05622:  MOVF   xAB,W
05624:  ADDLW  87
05626:  MOVWF  FE9
05628:  MOVLW  05
0562A:  ADDWFC 03,W
0562C:  MOVWF  FEA
0562E:  MOVLW  20
05630:  MOVWF  FEF
05632:  BRA    5646
....................       else 
....................          entire_entry[j] = 0x10; 
05634:  CLRF   03
05636:  MOVF   xAB,W
05638:  ADDLW  87
0563A:  MOVWF  FE9
0563C:  MOVLW  05
0563E:  ADDWFC 03,W
05640:  MOVWF  FEA
05642:  MOVLW  10
05644:  MOVWF  FEF
05646:  MOVLW  01
05648:  ADDWF  xAB,F
0564A:  BRA    55FA
....................    } 
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
0564C:  MOVLB  2
0564E:  MOVF   x20,W
05650:  MOVLB  5
05652:  SUBWF  xBC,W
05654:  BNZ   567E
05656:  MOVLB  2
05658:  MOVF   x21,W
0565A:  MOVLB  5
0565C:  SUBWF  xBD,W
0565E:  BNZ   567E
05660:  MOVLB  2
05662:  MOVF   x22,W
05664:  MOVLB  5
05666:  SUBWF  xBE,W
05668:  BNZ   567E
0566A:  MOVLB  2
0566C:  MOVF   x23,W
0566E:  MOVLB  5
05670:  SUBWF  xBF,W
05672:  BNZ   567E
....................    { 
....................       entire_entry[0x14] = 0x00; 
05674:  CLRF   x9B
....................       entire_entry[0x15] = 0x00; 
05676:  CLRF   x9C
....................       entire_entry[0x1A] = 0x00; 
05678:  CLRF   xA1
....................       entire_entry[0x1B] = 0x00; 
0567A:  CLRF   xA2
....................    } 
0567C:  BRA    56EE
....................    else 
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
0567E:  MOVFF  5BF,69A
05682:  MOVFF  5BE,699
05686:  MOVFF  5BD,698
0568A:  MOVFF  5BC,697
0568E:  MOVLB  0
05690:  CALL   1676
05694:  MOVLB  5
05696:  MOVFF  00,5A1
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
0569A:  MOVFF  5BF,69A
0569E:  MOVFF  5BE,699
056A2:  MOVFF  5BD,698
056A6:  MOVFF  5BC,697
056AA:  MOVLB  0
056AC:  CALL   1676
056B0:  MOVLB  5
056B2:  MOVFF  01,5A2
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
056B6:  MOVFF  5BF,69A
056BA:  MOVFF  5BE,699
056BE:  MOVFF  5BD,698
056C2:  MOVFF  5BC,697
056C6:  MOVLB  0
056C8:  CALL   1676
056CC:  MOVLB  5
056CE:  MOVFF  02,59B
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
056D2:  MOVFF  5BF,69A
056D6:  MOVFF  5BE,699
056DA:  MOVFF  5BD,698
056DE:  MOVFF  5BC,697
056E2:  MOVLB  0
056E4:  CALL   1676
056E8:  MOVLB  5
056EA:  MOVFF  03,59C
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
056EE:  MOVLW  20
056F0:  ADDWF  xAC,W
056F2:  MOVWF  xEA
056F4:  MOVLW  00
056F6:  ADDWFC xAD,W
056F8:  MOVWF  xEB
056FA:  MOVLW  00
056FC:  ADDWFC xAE,W
056FE:  MOVWF  xEC
05700:  MOVLW  00
05702:  ADDWFC xAF,W
05704:  MOVWF  xED
05706:  MOVFF  FE8,6D0
0570A:  MOVFF  5EC,6CF
0570E:  MOVFF  5EB,6CE
05712:  MOVFF  5EA,6CD
05716:  MOVLB  6
05718:  CLRF   xD2
0571A:  MOVLW  20
0571C:  MOVWF  xD1
0571E:  MOVLW  05
05720:  MOVWF  xD4
05722:  MOVLW  87
05724:  MOVWF  xD3
05726:  MOVLB  0
05728:  CALL   1D02
0572C:  MOVF   01,F
0572E:  BZ    5736
....................       return EOF; 
05730:  MOVLW  FF
05732:  MOVWF  01
05734:  BRA    573A
....................  
....................    return GOODEC; 
05736:  MOVLW  00
05738:  MOVWF  01
0573A:  GOTO   57D0 (RETURN)
.................... } 
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
*
02C5A:  MOVLB  6
02C5C:  CLRF   x54
.................... { 
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
02C5E:  MOVLW  14
02C60:  ADDWF  x50,W
02C62:  MOVWF  FE9
02C64:  MOVLW  00
02C66:  ADDWFC x51,W
02C68:  MOVWF  FEA
02C6A:  MOVFF  FEF,655
02C6E:  MOVFF  FEC,656
02C72:  MOVFF  FEC,657
02C76:  MOVFF  FEC,658
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
02C7A:  MOVFF  658,6B7
02C7E:  MOVFF  657,6B6
02C82:  MOVFF  656,6B5
02C86:  MOVFF  655,6B4
02C8A:  CLRF   xB9
02C8C:  MOVLW  01
02C8E:  MOVWF  xB8
02C90:  MOVLW  06
02C92:  MOVWF  xBB
02C94:  MOVLW  53
02C96:  MOVWF  xBA
02C98:  MOVLB  0
02C9A:  CALL   0C10
02C9E:  MOVF   01,W
02CA0:  MOVLB  6
02CA2:  ADDWF  x54,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
02CA4:  MOVLW  0B
02CA6:  ADDWF  x55,W
02CA8:  MOVWF  x79
02CAA:  MOVLW  00
02CAC:  ADDWFC x56,W
02CAE:  MOVWF  x7A
02CB0:  MOVLW  00
02CB2:  ADDWFC x57,W
02CB4:  MOVWF  x7B
02CB6:  MOVLW  00
02CB8:  ADDWFC x58,W
02CBA:  MOVWF  x7C
02CBC:  MOVWF  xB7
02CBE:  MOVFF  67B,6B6
02CC2:  MOVFF  67A,6B5
02CC6:  MOVFF  679,6B4
02CCA:  CLRF   xB9
02CCC:  MOVLW  01
02CCE:  MOVWF  xB8
02CD0:  MOVLW  06
02CD2:  MOVWF  xBB
02CD4:  MOVLW  52
02CD6:  MOVWF  xBA
02CD8:  MOVLB  0
02CDA:  CALL   0C10
02CDE:  MOVF   01,W
02CE0:  MOVLB  6
02CE2:  ADDWF  x54,F
....................       if(ec != GOODEC) 
02CE4:  MOVF   x54,F
02CE6:  BZ    2D00
....................       { 
....................          stream->Flags |= Read_Error; 
02CE8:  MOVLW  19
02CEA:  ADDWF  x50,W
02CEC:  MOVWF  FE9
02CEE:  MOVLW  00
02CF0:  ADDWFC x51,W
02CF2:  MOVWF  FEA
02CF4:  MOVF   FEF,W
02CF6:  IORLW  20
02CF8:  MOVWF  FEF
....................          return EOF; 
02CFA:  MOVLW  FF
02CFC:  MOVWF  01
02CFE:  BRA    3326
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
02D00:  MOVF   x53,W
02D02:  SUBLW  E5
02D04:  BTFSC  FD8.2
02D06:  BRA    32E8
02D08:  MOVF   x4F,W
02D0A:  SUBWF  x52,W
02D0C:  BTFSS  FD8.2
02D0E:  BRA    32E8
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
02D10:  MOVFF  658,67C
02D14:  MOVFF  657,67B
02D18:  MOVFF  656,67A
02D1C:  MOVFF  655,679
02D20:  MOVLW  06
02D22:  MOVWF  x7E
02D24:  MOVLW  59
02D26:  MOVWF  x7D
02D28:  MOVLB  0
02D2A:  CALL   1A44
02D2E:  MOVF   01,W
02D30:  SUBLW  FF
02D32:  BNZ   2D3E
....................             return EOF; 
02D34:  MOVLW  FF
02D36:  MOVWF  01
02D38:  MOVLB  6
02D3A:  BRA    3326
02D3C:  MOVLB  0
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
02D3E:  MOVFF  64E,67A
02D42:  MOVFF  64D,679
02D46:  MOVLW  06
02D48:  MOVLB  6
02D4A:  MOVWF  x7C
02D4C:  MOVLW  59
02D4E:  MOVWF  x7B
02D50:  MOVLB  0
02D52:  CALL   1BC0
02D56:  MOVF   01,F
02D58:  BTFSS  FD8.2
02D5A:  BRA    32EA
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
02D5C:  MOVLW  0C
02D5E:  MOVLB  6
02D60:  ADDWF  x50,W
02D62:  MOVWF  01
02D64:  MOVLW  00
02D66:  ADDWFC x51,W
02D68:  MOVWF  03
02D6A:  MOVFF  01,679
02D6E:  MOVWF  x7A
02D70:  MOVLW  14
02D72:  ADDWF  x50,W
02D74:  MOVWF  FE9
02D76:  MOVLW  00
02D78:  ADDWFC x51,W
02D7A:  MOVWF  FEA
02D7C:  MOVFF  FEF,00
02D80:  MOVFF  FEC,01
02D84:  MOVFF  FEC,02
02D88:  MOVFF  FEC,03
02D8C:  MOVFF  67A,FEA
02D90:  MOVFF  679,FE9
02D94:  MOVFF  00,FEF
02D98:  MOVFF  01,FEC
02D9C:  MOVFF  02,FEC
02DA0:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
02DA4:  MOVLW  1C
02DA6:  ADDWF  x55,W
02DA8:  MOVWF  x79
02DAA:  MOVLW  00
02DAC:  ADDWFC x56,W
02DAE:  MOVWF  x7A
02DB0:  MOVLW  00
02DB2:  ADDWFC x57,W
02DB4:  MOVWF  x7B
02DB6:  MOVLW  00
02DB8:  ADDWFC x58,W
02DBA:  MOVWF  x7C
02DBC:  MOVLW  10
02DBE:  ADDWF  x50,W
02DC0:  MOVWF  01
02DC2:  MOVLW  00
02DC4:  ADDWFC x51,W
02DC6:  MOVWF  03
02DC8:  MOVFF  01,67D
02DCC:  MOVWF  x7E
02DCE:  MOVFF  67C,6B7
02DD2:  MOVFF  67B,6B6
02DD6:  MOVFF  67A,6B5
02DDA:  MOVFF  679,6B4
02DDE:  CLRF   xB9
02DE0:  MOVLW  04
02DE2:  MOVWF  xB8
02DE4:  MOVFF  03,6BB
02DE8:  MOVFF  01,6BA
02DEC:  MOVLB  0
02DEE:  CALL   0C10
02DF2:  MOVF   01,W
02DF4:  MOVLB  6
02DF6:  ADDWF  x54,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
02DF8:  MOVLW  14
02DFA:  ADDWF  x55,W
02DFC:  MOVWF  x79
02DFE:  MOVLW  00
02E00:  ADDWFC x56,W
02E02:  MOVWF  x7A
02E04:  MOVLW  00
02E06:  ADDWFC x57,W
02E08:  MOVWF  x7B
02E0A:  MOVLW  00
02E0C:  ADDWFC x58,W
02E0E:  MOVWF  x7C
02E10:  MOVLW  14
02E12:  ADDWF  x50,W
02E14:  MOVWF  01
02E16:  MOVLW  00
02E18:  ADDWFC x51,W
02E1A:  MOVWF  03
02E1C:  MOVFF  01,67D
02E20:  MOVWF  x7E
02E22:  MOVLW  02
02E24:  ADDWF  x7D,F
02E26:  MOVLW  00
02E28:  ADDWFC x7E,F
02E2A:  MOVFF  67C,6B7
02E2E:  MOVFF  67B,6B6
02E32:  MOVFF  67A,6B5
02E36:  MOVFF  679,6B4
02E3A:  CLRF   xB9
02E3C:  MOVLW  02
02E3E:  MOVWF  xB8
02E40:  MOVFF  67E,6BB
02E44:  MOVFF  67D,6BA
02E48:  MOVLB  0
02E4A:  CALL   0C10
02E4E:  MOVF   01,W
02E50:  MOVLB  6
02E52:  ADDWF  x54,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
02E54:  MOVLW  1A
02E56:  ADDWF  x55,W
02E58:  MOVWF  x79
02E5A:  MOVLW  00
02E5C:  ADDWFC x56,W
02E5E:  MOVWF  x7A
02E60:  MOVLW  00
02E62:  ADDWFC x57,W
02E64:  MOVWF  x7B
02E66:  MOVLW  00
02E68:  ADDWFC x58,W
02E6A:  MOVWF  x7C
02E6C:  MOVLW  14
02E6E:  ADDWF  x50,W
02E70:  MOVWF  01
02E72:  MOVLW  00
02E74:  ADDWFC x51,W
02E76:  MOVWF  03
02E78:  MOVFF  01,67D
02E7C:  MOVWF  x7E
02E7E:  MOVFF  67C,6B7
02E82:  MOVFF  67B,6B6
02E86:  MOVFF  67A,6B5
02E8A:  MOVFF  679,6B4
02E8E:  CLRF   xB9
02E90:  MOVLW  02
02E92:  MOVWF  xB8
02E94:  MOVFF  03,6BB
02E98:  MOVFF  01,6BA
02E9C:  MOVLB  0
02E9E:  CALL   0C10
02EA2:  MOVF   01,W
02EA4:  MOVLB  6
02EA6:  ADDWF  x54,F
....................  
....................             if(ec != GOODEC) 
02EA8:  MOVF   x54,F
02EAA:  BZ    2EC4
....................             { 
....................                stream->Flags |= Read_Error; 
02EAC:  MOVLW  19
02EAE:  ADDWF  x50,W
02EB0:  MOVWF  FE9
02EB2:  MOVLW  00
02EB4:  ADDWFC x51,W
02EB6:  MOVWF  FEA
02EB8:  MOVF   FEF,W
02EBA:  IORLW  20
02EBC:  MOVWF  FEF
....................                return EOF; 
02EBE:  MOVLW  FF
02EC0:  MOVWF  01
02EC2:  BRA    3326
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
02EC4:  MOVLW  14
02EC6:  ADDWF  x50,W
02EC8:  MOVWF  01
02ECA:  MOVLW  00
02ECC:  ADDWFC x51,W
02ECE:  MOVWF  03
02ED0:  MOVFF  01,679
02ED4:  MOVWF  x7A
02ED6:  MOVLW  14
02ED8:  ADDWF  x50,W
02EDA:  MOVWF  FE9
02EDC:  MOVLW  00
02EDE:  ADDWFC x51,W
02EE0:  MOVWF  FEA
02EE2:  MOVFF  FEF,6C9
02EE6:  MOVFF  FEC,6CA
02EEA:  MOVFF  FEC,6CB
02EEE:  MOVFF  FEC,6CC
02EF2:  MOVLB  0
02EF4:  CALL   17C2
02EF8:  MOVFF  67A,FEA
02EFC:  MOVFF  679,FE9
02F00:  MOVFF  00,FEF
02F04:  MOVFF  01,FEC
02F08:  MOVFF  02,FEC
02F0C:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
02F10:  MOVLW  08
02F12:  MOVLB  6
02F14:  ADDWF  x50,W
02F16:  MOVWF  FE9
02F18:  MOVLW  00
02F1A:  ADDWFC x51,W
02F1C:  MOVWF  FEA
02F1E:  MOVFF  655,FEF
02F22:  MOVFF  656,FEC
02F26:  MOVFF  657,FEC
02F2A:  MOVFF  658,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
02F2E:  MOVLW  10
02F30:  ADDWF  x50,W
02F32:  MOVWF  FE9
02F34:  MOVLW  00
02F36:  ADDWFC x51,W
02F38:  MOVWF  FEA
02F3A:  MOVFF  FEF,00
02F3E:  MOVFF  FEC,01
02F42:  MOVFF  FEC,02
02F46:  MOVFF  FEC,03
02F4A:  MOVFF  651,FEA
02F4E:  MOVFF  650,FE9
02F52:  MOVFF  00,FEF
02F56:  MOVFF  01,FEC
02F5A:  MOVFF  02,FEC
02F5E:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
02F62:  MOVF   x4F,W
02F64:  SUBLW  20
02F66:  BTFSS  FD8.2
02F68:  BRA    32D2
....................             { 
....................                stream->File_Type = Data_File; 
02F6A:  MOVLW  18
02F6C:  ADDWF  x50,W
02F6E:  MOVWF  FE9
02F70:  MOVLW  00
02F72:  ADDWFC x51,W
02F74:  MOVWF  FEA
02F76:  CLRF   FEF
....................                if(stream->Flags & Write) 
02F78:  MOVLW  19
02F7A:  ADDWF  x50,W
02F7C:  MOVWF  FE9
02F7E:  MOVLW  00
02F80:  ADDWFC x51,W
02F82:  MOVWF  FEA
02F84:  BTFSS  FEF.1
02F86:  BRA    3080
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
02F88:  MOVLW  10
02F8A:  ADDWF  x50,W
02F8C:  MOVWF  FE9
02F8E:  MOVLW  00
02F90:  ADDWFC x51,W
02F92:  MOVWF  FEA
02F94:  MOVF   FEE,F
02F96:  MOVF   FEE,F
02F98:  CLRF   FEC
02F9A:  MOVF   FED,F
02F9C:  CLRF   FEF
02F9E:  MOVF   FED,F
02FA0:  CLRF   FEF
02FA2:  MOVF   FED,F
02FA4:  CLRF   FEF
02FA6:  MOVLW  00
02FA8:  MOVFF  651,FEA
02FAC:  MOVFF  650,FE9
02FB0:  MOVFF  00,FEF
02FB4:  MOVFF  650,FEC
02FB8:  MOVFF  02,FEC
02FBC:  MOVFF  651,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
02FC0:  MOVLW  14
02FC2:  ADDWF  x50,W
02FC4:  MOVWF  FE9
02FC6:  MOVLW  00
02FC8:  ADDWFC x51,W
02FCA:  MOVWF  FEA
02FCC:  MOVFF  FEF,679
02FD0:  MOVFF  FEC,67A
02FD4:  MOVFF  FEC,67B
02FD8:  MOVFF  FEC,67C
02FDC:  MOVLB  2
02FDE:  MOVF   x17,W
02FE0:  MOVLB  6
02FE2:  SUBWF  x7C,W
02FE4:  BNC   305E
02FE6:  BNZ   300A
02FE8:  MOVLB  2
02FEA:  MOVF   x16,W
02FEC:  MOVLB  6
02FEE:  SUBWF  x7B,W
02FF0:  BNC   305E
02FF2:  BNZ   300A
02FF4:  MOVLB  2
02FF6:  MOVF   x15,W
02FF8:  MOVLB  6
02FFA:  SUBWF  x7A,W
02FFC:  BNC   305E
02FFE:  BNZ   300A
03000:  MOVLB  2
03002:  MOVF   x14,W
03004:  MOVLB  6
03006:  SUBWF  x79,W
03008:  BNC   305E
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
0300A:  MOVLW  14
0300C:  ADDWF  x50,W
0300E:  MOVWF  FE9
03010:  MOVLW  00
03012:  ADDWFC x51,W
03014:  MOVWF  FEA
03016:  MOVFF  FEF,697
0301A:  MOVFF  FEC,698
0301E:  MOVFF  FEC,699
03022:  MOVFF  FEC,69A
03026:  MOVLB  0
03028:  CALL   1676
0302C:  MOVFF  03,67C
03030:  MOVFF  02,67B
03034:  MOVFF  01,67A
03038:  MOVFF  00,679
0303C:  MOVFF  03,680
03040:  MOVFF  02,67F
03044:  MOVFF  01,67E
03048:  MOVFF  00,67D
0304C:  CALL   1DEE
03050:  MOVF   01,W
03052:  SUBLW  FF
03054:  BNZ   3060
....................                         return EOF; 
03056:  MOVLW  FF
03058:  MOVWF  01
0305A:  MOVLB  6
0305C:  BRA    3326
0305E:  MOVLB  0
....................                   stream->Cur_Char = 0; 
03060:  MOVLW  04
03062:  MOVLB  6
03064:  ADDWF  x50,W
03066:  MOVWF  FE9
03068:  MOVLW  00
0306A:  ADDWFC x51,W
0306C:  MOVWF  FEA
0306E:  MOVF   FEE,F
03070:  MOVF   FEE,F
03072:  CLRF   FEC
03074:  MOVF   FED,F
03076:  CLRF   FEF
03078:  MOVF   FED,F
0307A:  CLRF   FEF
0307C:  MOVF   FED,F
0307E:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
03080:  MOVLW  19
03082:  ADDWF  x50,W
03084:  MOVWF  FE9
03086:  MOVLW  00
03088:  ADDWFC x51,W
0308A:  MOVWF  FEA
0308C:  BTFSS  FEF.2
0308E:  BRA    3216
03090:  MOVLW  10
03092:  ADDWF  x50,W
03094:  MOVWF  FE9
03096:  MOVLW  00
03098:  ADDWFC x51,W
0309A:  MOVWF  FEA
0309C:  MOVFF  FEF,679
030A0:  MOVFF  FEC,67A
030A4:  MOVFF  FEC,67B
030A8:  MOVFF  FEC,67C
030AC:  MOVF   x79,F
030AE:  BNZ   30BE
030B0:  MOVF   x7A,F
030B2:  BNZ   30BE
030B4:  MOVF   x7B,F
030B6:  BNZ   30BE
030B8:  MOVF   x7C,F
030BA:  BTFSC  FD8.2
030BC:  BRA    3216
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
030BE:  MOVLW  10
030C0:  ADDWF  x50,W
030C2:  MOVWF  01
030C4:  MOVLW  00
030C6:  ADDWFC x51,W
030C8:  MOVWF  03
030CA:  MOVFF  01,679
030CE:  MOVWF  x7A
030D0:  MOVFF  651,67C
030D4:  MOVFF  650,67B
030D8:  MOVWF  x7E
030DA:  MOVFF  01,67D
030DE:  MOVLB  0
030E0:  CALL   2806
030E4:  MOVFF  01,654
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
030E8:  MOVLW  04
030EA:  MOVLB  6
030EC:  ADDWF  x50,W
030EE:  MOVWF  FE9
030F0:  MOVLW  00
030F2:  ADDWFC x51,W
030F4:  MOVWF  FEA
030F6:  MOVFF  FEF,679
030FA:  MOVFF  FEC,67A
030FE:  MOVFF  FEC,67B
03102:  MOVFF  FEC,67C
03106:  MOVLW  1F
03108:  ANDWF  x79,F
0310A:  CLRF   x7A
0310C:  CLRF   x7B
0310E:  CLRF   x7C
03110:  MOVF   x79,F
03112:  BNZ   3186
03114:  MOVF   x7A,F
03116:  BNZ   3186
03118:  MOVF   x7B,F
0311A:  BNZ   3186
0311C:  MOVF   x7C,F
0311E:  BNZ   3186
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
03120:  MOVLW  04
03122:  ADDWF  x50,W
03124:  MOVWF  FE9
03126:  MOVLW  00
03128:  ADDWFC x51,W
0312A:  MOVWF  FEA
0312C:  MOVFF  FEF,679
03130:  MOVFF  FEC,67A
03134:  MOVFF  FEC,67B
03138:  MOVFF  FEC,67C
0313C:  MOVLW  20
0313E:  SUBWF  x79,F
03140:  MOVLW  00
03142:  SUBWFB x7A,F
03144:  SUBWFB x7B,F
03146:  SUBWFB x7C,F
03148:  MOVLW  1A
0314A:  ADDWF  x50,W
0314C:  MOVWF  01
0314E:  MOVLW  00
03150:  ADDWFC x51,W
03152:  MOVWF  03
03154:  MOVFF  01,67D
03158:  MOVWF  x7E
0315A:  MOVFF  67C,6B7
0315E:  MOVFF  67B,6B6
03162:  MOVFF  67A,6B5
03166:  MOVFF  679,6B4
0316A:  CLRF   xB9
0316C:  MOVLW  20
0316E:  MOVWF  xB8
03170:  MOVFF  03,6BB
03174:  MOVFF  01,6BA
03178:  MOVLB  0
0317A:  CALL   0C10
0317E:  MOVF   01,W
03180:  MOVLB  6
03182:  ADDWF  x54,F
03184:  BRA    3216
....................                   else 
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
03186:  MOVLW  04
03188:  ADDWF  x50,W
0318A:  MOVWF  FE9
0318C:  MOVLW  00
0318E:  ADDWFC x51,W
03190:  MOVWF  FEA
03192:  MOVFF  FEF,679
03196:  MOVFF  FEC,67A
0319A:  MOVFF  FEC,67B
0319E:  MOVFF  FEC,67C
031A2:  MOVLW  04
031A4:  ADDWF  x50,W
031A6:  MOVWF  FE9
031A8:  MOVLW  00
031AA:  ADDWFC x51,W
031AC:  MOVWF  FEA
031AE:  MOVFF  FEF,67D
031B2:  MOVFF  FEC,67E
031B6:  MOVFF  FEC,67F
031BA:  MOVFF  FEC,680
031BE:  MOVF   x7D,W
031C0:  ANDLW  1F
031C2:  MOVWF  00
031C4:  CLRF   01
031C6:  CLRF   02
031C8:  CLRF   03
031CA:  MOVF   00,W
031CC:  SUBWF  x79,F
031CE:  MOVF   01,W
031D0:  SUBWFB x7A,F
031D2:  MOVF   02,W
031D4:  SUBWFB x7B,F
031D6:  MOVF   03,W
031D8:  SUBWFB x7C,F
031DA:  MOVLW  1A
031DC:  ADDWF  x50,W
031DE:  MOVWF  01
031E0:  MOVLW  00
031E2:  ADDWFC x51,W
031E4:  MOVWF  03
031E6:  MOVFF  01,67D
031EA:  MOVWF  x7E
031EC:  MOVFF  67C,6B7
031F0:  MOVFF  67B,6B6
031F4:  MOVFF  67A,6B5
031F8:  MOVFF  679,6B4
031FC:  CLRF   xB9
031FE:  MOVLW  20
03200:  MOVWF  xB8
03202:  MOVFF  03,6BB
03206:  MOVFF  01,6BA
0320A:  MOVLB  0
0320C:  CALL   0C10
03210:  MOVF   01,W
03212:  MOVLB  6
03214:  ADDWF  x54,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
03216:  MOVLW  19
03218:  ADDWF  x50,W
0321A:  MOVWF  FE9
0321C:  MOVLW  00
0321E:  ADDWFC x51,W
03220:  MOVWF  FEA
03222:  BTFSS  FEF.0
03224:  BRA    32B4
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
03226:  MOVLW  04
03228:  ADDWF  x50,W
0322A:  MOVWF  01
0322C:  MOVLW  00
0322E:  ADDWFC x51,W
03230:  MOVWF  03
03232:  MOVFF  01,679
03236:  MOVWF  x7A
03238:  MOVLW  14
0323A:  ADDWF  x50,W
0323C:  MOVWF  FE9
0323E:  MOVLW  00
03240:  ADDWFC x51,W
03242:  MOVWF  FEA
03244:  MOVFF  FEF,00
03248:  MOVFF  FEC,01
0324C:  MOVFF  FEC,02
03250:  MOVFF  FEC,03
03254:  MOVFF  67A,FEA
03258:  MOVFF  679,FE9
0325C:  MOVFF  00,FEF
03260:  MOVFF  01,FEC
03264:  MOVFF  02,FEC
03268:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
0326C:  MOVLW  04
0326E:  ADDWF  x50,W
03270:  MOVWF  FE9
03272:  MOVLW  00
03274:  ADDWFC x51,W
03276:  MOVWF  FEA
03278:  MOVFF  FEF,6B4
0327C:  MOVFF  FEC,6B5
03280:  MOVFF  FEC,6B6
03284:  MOVFF  FEC,6B7
03288:  MOVLW  1A
0328A:  ADDWF  x50,W
0328C:  MOVWF  01
0328E:  MOVLW  00
03290:  ADDWFC x51,W
03292:  MOVWF  03
03294:  MOVFF  01,67D
03298:  MOVWF  x7E
0329A:  CLRF   xB9
0329C:  MOVLW  20
0329E:  MOVWF  xB8
032A0:  MOVFF  03,6BB
032A4:  MOVFF  01,6BA
032A8:  MOVLB  0
032AA:  CALL   0C10
032AE:  MOVFF  01,654
032B2:  MOVLB  6
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
032B4:  MOVF   x54,F
032B6:  BZ    32D0
....................                { 
....................                   stream->Flags |= Read_Error; 
032B8:  MOVLW  19
032BA:  ADDWF  x50,W
032BC:  MOVWF  FE9
032BE:  MOVLW  00
032C0:  ADDWFC x51,W
032C2:  MOVWF  FEA
032C4:  MOVF   FEF,W
032C6:  IORLW  20
032C8:  MOVWF  FEF
....................                   return EOF; 
032CA:  MOVLW  FF
032CC:  MOVWF  01
032CE:  BRA    3326
....................                }                
....................             } 
032D0:  BRA    32E2
....................             else 
....................                stream->File_Type = Directory; 
032D2:  MOVLW  18
032D4:  ADDWF  x50,W
032D6:  MOVWF  FE9
032D8:  MOVLW  00
032DA:  ADDWFC x51,W
032DC:  MOVWF  FEA
032DE:  MOVLW  01
032E0:  MOVWF  FEF
....................             return GOODEC; 
032E2:  MOVLW  00
032E4:  MOVWF  01
032E6:  BRA    3326
032E8:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
032EA:  MOVLW  06
032EC:  MOVLB  6
032EE:  MOVWF  x7A
032F0:  MOVLW  55
032F2:  MOVWF  x79
032F4:  MOVLB  0
032F6:  RCALL  2BF8
032F8:  MOVF   01,W
032FA:  SUBLW  FF
032FC:  BNZ   3308
....................          return EOF; 
032FE:  MOVLW  FF
03300:  MOVWF  01
03302:  MOVLB  6
03304:  BRA    3326
03306:  MOVLB  0
....................  
....................    } while(cur_state != 0x00); 
03308:  MOVLB  6
0330A:  MOVF   x53,F
0330C:  BTFSS  FD8.2
0330E:  BRA    2C7A
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
03310:  MOVLW  19
03312:  ADDWF  x50,W
03314:  MOVWF  FE9
03316:  MOVLW  00
03318:  ADDWFC x51,W
0331A:  MOVWF  FEA
0331C:  MOVF   FEF,W
0331E:  IORLW  80
03320:  MOVWF  FEF
....................    return EOF; 
03322:  MOVLW  FF
03324:  MOVWF  01
03326:  MOVLB  0
03328:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
*
01A44:  MOVLB  6
01A46:  CLRF   x80
.................... { 
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
01A48:  MOVFF  67C,686
01A4C:  MOVFF  67B,685
01A50:  MOVFF  67A,684
01A54:  MOVFF  679,683
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
01A58:  MOVLW  15
01A5A:  SUBWF  x83,W
01A5C:  MOVWF  x87
01A5E:  MOVLW  00
01A60:  SUBWFB x84,W
01A62:  MOVWF  x88
01A64:  MOVLW  00
01A66:  SUBWFB x85,W
01A68:  MOVWF  x89
01A6A:  MOVLW  00
01A6C:  SUBWFB x86,W
01A6E:  MOVWF  x8A
01A70:  MOVWF  xB7
01A72:  MOVFF  689,6B6
01A76:  MOVFF  688,6B5
01A7A:  MOVFF  687,6B4
01A7E:  CLRF   xB9
01A80:  MOVLW  01
01A82:  MOVWF  xB8
01A84:  MOVLW  06
01A86:  MOVWF  xBB
01A88:  MOVLW  82
01A8A:  MOVWF  xBA
01A8C:  MOVLB  0
01A8E:  CALL   0C10
01A92:  MOVF   01,F
01A94:  BZ    1A9C
....................       return EOF; 
01A96:  MOVLW  FF
01A98:  MOVWF  01
01A9A:  BRA    1BBE
....................  
....................    if(type != 0x0F) 
01A9C:  MOVLB  6
01A9E:  MOVF   x82,W
01AA0:  SUBLW  0F
01AA2:  BZ    1AD8
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
01AA4:  MOVFF  686,68A
01AA8:  MOVFF  685,689
01AAC:  MOVFF  684,688
01AB0:  MOVFF  683,687
01AB4:  MOVFF  67E,68C
01AB8:  MOVFF  67D,68B
01ABC:  MOVFF  682,68D
01AC0:  MOVLB  0
01AC2:  BRA    14A8
01AC4:  MOVF   01,W
01AC6:  SUBLW  FF
01AC8:  BNZ   1AD0
....................          return EOF; 
01ACA:  MOVLW  FF
01ACC:  MOVWF  01
01ACE:  BRA    1BBE
....................       return GOODEC; 
01AD0:  MOVLW  00
01AD2:  MOVWF  01
01AD4:  BRA    1BBE
01AD6:  MOVLB  6
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
01AD8:  MOVLW  06
01ADA:  MOVWF  x88
01ADC:  MOVLW  83
01ADE:  MOVWF  x87
01AE0:  MOVLB  0
01AE2:  RCALL  19E4
01AE4:  MOVF   01,W
01AE6:  SUBLW  FF
01AE8:  BNZ   1AF0
....................          return EOF; 
01AEA:  MOVLW  FF
01AEC:  MOVWF  01
01AEE:  BRA    1BBE
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
01AF0:  MOVLW  01
01AF2:  MOVLB  6
01AF4:  MOVWF  x7F
01AF6:  MOVF   x7F,W
01AF8:  SUBLW  1F
01AFA:  BNC   1B76
....................       { 
....................          if(j == 11) 
01AFC:  MOVF   x7F,W
01AFE:  SUBLW  0B
01B00:  BNZ   1B08
....................             j = 14; 
01B02:  MOVLW  0E
01B04:  MOVWF  x7F
01B06:  BRA    1B12
....................          else if(j == 26) 
01B08:  MOVF   x7F,W
01B0A:  SUBLW  1A
01B0C:  BNZ   1B12
....................             j = 28; 
01B0E:  MOVLW  1C
01B10:  MOVWF  x7F
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
01B12:  MOVF   x7F,W
01B14:  ADDWF  x83,W
01B16:  MOVWF  x87
01B18:  MOVLW  00
01B1A:  ADDWFC x84,W
01B1C:  MOVWF  x88
01B1E:  MOVLW  00
01B20:  ADDWFC x85,W
01B22:  MOVWF  x89
01B24:  MOVLW  00
01B26:  ADDWFC x86,W
01B28:  MOVWF  x8A
01B2A:  MOVF   x80,W
01B2C:  ADDWF  x7D,W
01B2E:  MOVWF  01
01B30:  MOVLW  00
01B32:  ADDWFC x7E,W
01B34:  MOVWF  03
01B36:  MOVFF  01,68B
01B3A:  MOVWF  x8C
01B3C:  MOVFF  68A,6B7
01B40:  MOVFF  689,6B6
01B44:  MOVFF  688,6B5
01B48:  MOVFF  687,6B4
01B4C:  CLRF   xB9
01B4E:  MOVLW  01
01B50:  MOVWF  xB8
01B52:  MOVFF  03,6BB
01B56:  MOVFF  01,6BA
01B5A:  MOVLB  0
01B5C:  CALL   0C10
01B60:  MOVF   01,F
01B62:  BZ    1B6A
....................             return EOF; 
01B64:  MOVLW  FF
01B66:  MOVWF  01
01B68:  BRA    1BBE
01B6A:  MOVLW  02
01B6C:  MOVLB  6
01B6E:  ADDWF  x7F,F
01B70:  MOVLW  01
01B72:  ADDWF  x80,F
01B74:  BRA    1AF6
....................       } 
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
01B76:  MOVFF  686,6B7
01B7A:  MOVFF  685,6B6
01B7E:  MOVFF  684,6B5
01B82:  MOVFF  683,6B4
01B86:  CLRF   xB9
01B88:  MOVLW  01
01B8A:  MOVWF  xB8
01B8C:  MOVLW  06
01B8E:  MOVWF  xBB
01B90:  MOVLW  81
01B92:  MOVWF  xBA
01B94:  MOVLB  0
01B96:  CALL   0C10
01B9A:  MOVF   01,F
01B9C:  BZ    1BA4
....................          return EOF; 
01B9E:  MOVLW  FF
01BA0:  MOVWF  01
01BA2:  BRA    1BBE
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
01BA4:  MOVLB  6
01BA6:  BTFSS  x81.6
01BA8:  BRA    1AD8
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
01BAA:  MOVF   x80,W
01BAC:  ADDWF  x7D,W
01BAE:  MOVWF  FE9
01BB0:  MOVLW  00
01BB2:  ADDWFC x7E,W
01BB4:  MOVWF  FEA
01BB6:  CLRF   FEF
....................  
....................    return GOODEC; 
01BB8:  MOVLW  00
01BBA:  MOVWF  01
01BBC:  MOVLB  0
01BBE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
*
04306:  MOVLB  5
04308:  CLRF   xFE
0430A:  MOVLW  01
0430C:  MOVLB  6
0430E:  MOVWF  x21
.................... { 
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
04310:  MOVFF  5F1,627
04314:  MOVFF  5F0,626
04318:  MOVLB  0
0431A:  GOTO   3AB6
0431E:  MOVF   01,W
04320:  SUBLW  FF
04322:  BNZ   432A
....................       return EOF; 
04324:  MOVLW  FF
04326:  MOVWF  01
04328:  BRA    4618
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
0432A:  MOVFF  5ED,629
0432E:  MOVFF  5EC,628
04332:  MOVFF  5EB,627
04336:  MOVFF  5EA,626
0433A:  MOVFF  5F1,62B
0433E:  MOVFF  5F0,62A
04342:  MOVLW  05
04344:  MOVLB  6
04346:  MOVWF  x2D
04348:  MOVLW  F2
0434A:  MOVWF  x2C
0434C:  MOVLB  0
0434E:  BRA    3C56
04350:  MOVF   01,W
04352:  SUBLW  FF
04354:  BNZ   435C
....................       return EOF; 
04356:  MOVLW  FF
04358:  MOVWF  01
0435A:  BRA    4618
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
0435C:  MOVLW  05
0435E:  MOVLB  6
04360:  MOVWF  x27
04362:  MOVLW  F2
04364:  MOVWF  x26
04366:  MOVLB  0
04368:  BRA    40C4
0436A:  MOVFF  01,5FF
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
0436E:  MOVLB  6
04370:  CLRF   x20
04372:  MOVF   x20,W
04374:  SUBLW  1F
04376:  BNC   4388
....................       entire_entry[entry_pos] = 0;    
04378:  MOVFF  620,FE9
0437C:  MOVLW  06
0437E:  MOVWF  FEA
04380:  CLRF   FEF
04382:  MOVLW  01
04384:  ADDWF  x20,F
04386:  BRA    4372
....................  
....................    i = parent_dir_addr; 
04388:  MOVFF  5ED,625
0438C:  MOVFF  5EC,624
04390:  MOVFF  5EB,623
04394:  MOVFF  5EA,622
....................    if(get_next_free_entry(&i) == EOF) 
04398:  MOVLW  06
0439A:  MOVWF  x27
0439C:  MOVLW  22
0439E:  MOVWF  x26
043A0:  MOVLB  0
043A2:  RCALL  410A
043A4:  MOVF   01,W
043A6:  SUBLW  FF
043A8:  BNZ   43B0
....................       return EOF; 
043AA:  MOVLW  FF
043AC:  MOVWF  01
043AE:  BRA    4618
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
043B0:  MOVLW  0F
043B2:  MOVLB  6
043B4:  MOVWF  x0B
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
043B6:  MOVFF  5F1,692
043BA:  MOVFF  5F0,691
043BE:  MOVLB  0
043C0:  CALL   1120
043C4:  MOVFF  01,5FE
....................    name_pos %= 13; 
043C8:  MOVFF  5FE,626
043CC:  MOVLW  0D
043CE:  MOVLB  6
043D0:  MOVWF  x27
043D2:  MOVLB  0
043D4:  RCALL  421C
043D6:  MOVFF  00,5FE
....................  
....................    if(name_pos != 0) 
043DA:  MOVLB  5
043DC:  MOVF   xFE,F
043DE:  BZ    43F8
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
043E0:  MOVLW  01
043E2:  ADDWF  xFE,F
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
043E4:  MOVLW  06
043E6:  MOVLB  6
043E8:  MOVWF  x27
043EA:  CLRF   x26
043EC:  SETF   x28
043EE:  MOVFF  5FE,629
043F2:  MOVLB  0
043F4:  RCALL  4268
043F6:  MOVLB  5
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
043F8:  MOVFF  5F1,692
043FC:  MOVFF  5F0,691
04400:  MOVLB  0
04402:  CALL   1120
04406:  MOVFF  01,5FE
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
0440A:  MOVFF  5FE,626
0440E:  MOVLW  0D
04410:  MOVLB  6
04412:  MOVWF  x27
04414:  MOVLB  0
04416:  RCALL  421C
04418:  MOVLW  01
0441A:  ADDWF  01,W
0441C:  MOVLB  6
0441E:  MOVWF  x21
....................  
....................    if(name_pos % 13 == 0) 
04420:  MOVFF  5FE,626
04424:  MOVLW  0D
04426:  MOVWF  x27
04428:  MOVLB  0
0442A:  RCALL  421C
0442C:  MOVF   00,F
0442E:  BNZ   4438
....................       long_entry -= 1; 
04430:  MOVLW  01
04432:  MOVLB  6
04434:  SUBWF  x21,F
04436:  MOVLB  0
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
04438:  MOVLB  6
0443A:  BSF    x21.6
....................  
....................    while(name_pos >= 0) 
0443C:  MOVLB  5
0443E:  BTFSC  xFE.7
04440:  BRA    45C8
....................    { 
....................       entry_pos = name_pos % 13; 
04442:  MOVFF  5FE,626
04446:  MOVLW  0D
04448:  MOVLB  6
0444A:  MOVWF  x27
0444C:  MOVLB  0
0444E:  RCALL  421C
04450:  MOVFF  00,620
04454:  MOVLB  6
....................  
....................       if(entry_pos < 5) 
04456:  MOVF   x20,W
04458:  SUBLW  04
0445A:  BNC   449C
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
0445C:  BCF    FD8.0
0445E:  RLCF   x20,W
04460:  ADDLW  01
04462:  CLRF   03
04464:  MOVWF  01
04466:  MOVLW  06
04468:  ADDWF  03,F
0446A:  MOVFF  01,626
0446E:  MOVFF  03,627
04472:  CLRF   03
04474:  MOVLB  5
04476:  MOVF   xFE,W
04478:  MOVWF  00
0447A:  BTFSC  FE8.7
0447C:  DECF   03,F
0447E:  ADDWF  xF0,W
04480:  MOVWF  FE9
04482:  MOVF   xF1,W
04484:  ADDWFC 03,W
04486:  MOVWF  FEA
04488:  MOVFF  FEF,628
0448C:  MOVLB  6
0448E:  MOVFF  627,FEA
04492:  MOVFF  01,FE9
04496:  MOVFF  628,FEF
0449A:  BRA    451A
....................  
....................       else if(entry_pos < 11) 
0449C:  MOVF   x20,W
0449E:  SUBLW  0A
044A0:  BNC   44E2
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
044A2:  BCF    FD8.0
044A4:  RLCF   x20,W
044A6:  ADDLW  04
044A8:  CLRF   03
044AA:  MOVWF  01
044AC:  MOVLW  06
044AE:  ADDWF  03,F
044B0:  MOVFF  01,626
044B4:  MOVFF  03,627
044B8:  CLRF   03
044BA:  MOVLB  5
044BC:  MOVF   xFE,W
044BE:  MOVWF  00
044C0:  BTFSC  FE8.7
044C2:  DECF   03,F
044C4:  ADDWF  xF0,W
044C6:  MOVWF  FE9
044C8:  MOVF   xF1,W
044CA:  ADDWFC 03,W
044CC:  MOVWF  FEA
044CE:  MOVFF  FEF,628
044D2:  MOVLB  6
044D4:  MOVFF  627,FEA
044D8:  MOVFF  01,FE9
044DC:  MOVFF  628,FEF
044E0:  BRA    451A
....................  
....................       else 
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
044E2:  BCF    FD8.0
044E4:  RLCF   x20,W
044E6:  ADDLW  06
044E8:  CLRF   03
044EA:  MOVWF  01
044EC:  MOVLW  06
044EE:  ADDWF  03,F
044F0:  MOVFF  03,627
044F4:  CLRF   03
044F6:  MOVLB  5
044F8:  MOVF   xFE,W
044FA:  BTFSC  FE8.7
044FC:  DECF   03,F
044FE:  ADDWF  xF0,W
04500:  MOVWF  FE9
04502:  MOVF   xF1,W
04504:  ADDWFC 03,W
04506:  MOVWF  FEA
04508:  MOVFF  FEF,628
0450C:  MOVLB  6
0450E:  MOVFF  627,FEA
04512:  MOVFF  01,FE9
04516:  MOVFF  628,FEF
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
0451A:  MOVF   x20,F
0451C:  BNZ   45C0
0451E:  MOVFF  5F1,692
04522:  MOVFF  5F0,691
04526:  MOVLB  0
04528:  CALL   1120
0452C:  MOVLB  6
0452E:  CLRF   x27
04530:  MOVFF  01,626
04534:  CLRF   03
04536:  MOVLB  5
04538:  MOVF   xFE,W
0453A:  MOVWF  00
0453C:  BTFSC  FE8.7
0453E:  DECF   03,F
04540:  MOVLB  6
04542:  SUBWF  01,W
04544:  BNZ   454C
04546:  MOVF   x27,W
04548:  SUBWF  03,W
0454A:  BZ    45C0
....................       { 
....................          entire_entry[0] = long_entry; 
0454C:  MOVFF  621,600
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
04550:  MOVLB  5
04552:  MOVF   xFE,F
04554:  BZ    455E
....................             long_entry &= 0x3F; 
04556:  MOVLW  3F
04558:  MOVLB  6
0455A:  ANDWF  x21,F
0455C:  MOVLB  5
....................  
....................          long_entry -= 1; 
0455E:  MOVLW  01
04560:  MOVLB  6
04562:  SUBWF  x21,F
....................  
....................          entire_entry[13] = chksum; 
04564:  MOVFF  5FF,60D
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
04568:  MOVFF  625,6D0
0456C:  MOVFF  624,6CF
04570:  MOVFF  623,6CE
04574:  MOVFF  622,6CD
04578:  CLRF   xD2
0457A:  MOVLW  20
0457C:  MOVWF  xD1
0457E:  MOVLW  06
04580:  MOVWF  xD4
04582:  CLRF   xD3
04584:  MOVLB  0
04586:  CALL   1D02
0458A:  MOVF   01,F
0458C:  BZ    4594
....................             return EOF; 
0458E:  MOVLW  FF
04590:  MOVWF  01
04592:  BRA    4618
....................          if(get_next_free_entry(&i) == EOF) 
04594:  MOVLW  06
04596:  MOVLB  6
04598:  MOVWF  x27
0459A:  MOVLW  22
0459C:  MOVWF  x26
0459E:  MOVLB  0
045A0:  RCALL  410A
045A2:  MOVF   01,W
045A4:  SUBLW  FF
045A6:  BNZ   45AE
....................             return EOF; 
045A8:  MOVLW  FF
045AA:  MOVWF  01
045AC:  BRA    4618
....................          fill_entry(entire_entry, 0x00, 0); 
045AE:  MOVLW  06
045B0:  MOVLB  6
045B2:  MOVWF  x27
045B4:  CLRF   x26
045B6:  CLRF   x28
045B8:  CLRF   x29
045BA:  MOVLB  0
045BC:  RCALL  4268
045BE:  MOVLB  6
....................       } 
....................       name_pos -= 1; 
045C0:  MOVLW  01
045C2:  MOVLB  5
045C4:  SUBWF  xFE,F
045C6:  BRA    443E
....................    } 
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
045C8:  MOVFF  625,6D0
045CC:  MOVFF  624,6CF
045D0:  MOVFF  623,6CE
045D4:  MOVFF  622,6CD
045D8:  MOVLB  6
045DA:  CLRF   xD2
045DC:  MOVLW  0B
045DE:  MOVWF  xD1
045E0:  MOVLW  05
045E2:  MOVWF  xD4
045E4:  MOVLW  F2
045E6:  MOVWF  xD3
045E8:  MOVLB  0
045EA:  CALL   1D02
045EE:  MOVF   01,F
045F0:  BZ    45F8
....................       return EOF; 
045F2:  MOVLW  FF
045F4:  MOVWF  01
045F6:  BRA    4618
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
045F8:  MOVLB  5
045FA:  MOVFF  5EE,FE9
045FE:  MOVFF  5EF,FEA
04602:  MOVFF  622,FEF
04606:  MOVFF  623,FEC
0460A:  MOVFF  624,FEC
0460E:  MOVFF  625,FEC
....................  
....................    return GOODEC; 
04612:  MOVLW  00
04614:  MOVWF  01
04616:  MOVLB  0
04618:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
*
014A8:  MOVLB  6
014AA:  CLRF   x90
.................... { 
....................    int 
....................       buf, 
....................       i, 
....................       j = 0; 
....................  
....................    // one short file name has, at the most, 11 characters 
....................    for(i = 0; i < 11; i += 1) 
014AC:  CLRF   x8F
014AE:  MOVF   x8F,W
014B0:  SUBLW  0A
014B2:  BNC   152C
....................    {       
....................       // read in a character 
....................       if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
014B4:  MOVF   x8F,W
014B6:  ADDWF  x87,W
014B8:  MOVWF  x91
014BA:  MOVLW  00
014BC:  ADDWFC x88,W
014BE:  MOVWF  x92
014C0:  MOVLW  00
014C2:  ADDWFC x89,W
014C4:  MOVWF  x93
014C6:  MOVLW  00
014C8:  ADDWFC x8A,W
014CA:  MOVWF  x94
014CC:  MOVWF  xB7
014CE:  MOVFF  693,6B6
014D2:  MOVFF  692,6B5
014D6:  MOVFF  691,6B4
014DA:  CLRF   xB9
014DC:  MOVLW  01
014DE:  MOVWF  xB8
014E0:  MOVLW  06
014E2:  MOVWF  xBB
014E4:  MOVLW  8E
014E6:  MOVWF  xBA
014E8:  MOVLB  0
014EA:  CALL   0C10
014EE:  MOVF   01,F
014F0:  BZ    14F8
....................          return EOF; 
014F2:  MOVLW  FF
014F4:  MOVWF  01
014F6:  BRA    15DC
....................        
....................       // convert the character 
....................       if(buf != ' ') 
014F8:  MOVLB  6
014FA:  MOVF   x8E,W
014FC:  SUBLW  20
014FE:  BZ    1526
....................       {          
....................          sname[j] = tolower(buf); 
01500:  MOVF   x90,W
01502:  ADDWF  x8B,W
01504:  MOVWF  FE9
01506:  MOVLW  00
01508:  ADDWFC x8C,W
0150A:  MOVWF  FEA
0150C:  MOVF   x8E,W
0150E:  SUBLW  40
01510:  BC    151E
01512:  MOVF   x8E,W
01514:  SUBLW  5A
01516:  BNC   151E
01518:  MOVF   x8E,W
0151A:  IORLW  20
0151C:  BRA    1520
0151E:  MOVF   x8E,W
01520:  MOVWF  FEF
....................          j += 1; 
01522:  MOVLW  01
01524:  ADDWF  x90,F
....................       } 
01526:  MOVLW  01
01528:  ADDWF  x8F,F
0152A:  BRA    14AE
....................        
....................    }    
....................  
....................    // tack on a null terminator 
....................    sname[j] = '\0'; 
0152C:  MOVF   x90,W
0152E:  ADDWF  x8B,W
01530:  MOVWF  FE9
01532:  MOVLW  00
01534:  ADDWFC x8C,W
01536:  MOVWF  FEA
01538:  CLRF   FEF
....................     
....................    //printf("\r\n%s, %u\r\n",sname, strlen(sname)); 
....................  
....................    if(type != 0x10 && strlen(sname) > 3) 
0153A:  MOVF   x8D,W
0153C:  SUBLW  10
0153E:  BZ    15C8
01540:  MOVFF  68C,692
01544:  MOVFF  68B,691
01548:  MOVLB  0
0154A:  RCALL  1120
0154C:  MOVFF  02,692
01550:  MOVFF  01,691
01554:  MOVLB  6
01556:  MOVF   x92,F
01558:  BNZ   1560
0155A:  MOVF   x91,W
0155C:  SUBLW  03
0155E:  BC    15C8
....................    { 
....................       j = strlen(sname); 
01560:  MOVFF  68C,692
01564:  MOVFF  68B,691
01568:  MOVLB  0
0156A:  RCALL  1120
0156C:  MOVFF  01,690
....................       for(i=j; i > j-3; --i) 
01570:  MOVFF  690,68F
01574:  MOVLW  03
01576:  MOVLB  6
01578:  SUBWF  x90,W
0157A:  SUBWF  x8F,W
0157C:  BZ    15B8
0157E:  BNC   15B8
....................          sname[i] = sname[i-1]; 
01580:  MOVF   x8F,W
01582:  ADDWF  x8B,W
01584:  MOVWF  01
01586:  MOVLW  00
01588:  ADDWFC x8C,W
0158A:  MOVWF  03
0158C:  MOVFF  01,691
01590:  MOVWF  x92
01592:  MOVLW  01
01594:  SUBWF  x8F,W
01596:  ADDWF  x8B,W
01598:  MOVWF  FE9
0159A:  MOVLW  00
0159C:  ADDWFC x8C,W
0159E:  MOVWF  FEA
015A0:  MOVFF  FEF,693
015A4:  MOVFF  03,FEA
015A8:  MOVFF  01,FE9
015AC:  MOVFF  693,FEF
015B0:  DECF   x8F,F
015B2:  MOVLB  0
015B4:  BRA    1574
015B6:  MOVLB  6
....................       sname[i] = '.'; 
015B8:  MOVF   x8F,W
015BA:  ADDWF  x8B,W
015BC:  MOVWF  FE9
015BE:  MOVLW  00
015C0:  ADDWFC x8C,W
015C2:  MOVWF  FEA
015C4:  MOVLW  2E
015C6:  MOVWF  FEF
....................    } 
....................     
....................    sname[j+1] = '\0'; 
015C8:  MOVLW  01
015CA:  ADDWF  x90,W
015CC:  ADDWF  x8B,W
015CE:  MOVWF  FE9
015D0:  MOVLW  00
015D2:  ADDWFC x8C,W
015D4:  MOVWF  FEA
015D6:  CLRF   FEF
....................  
....................    return GOODEC; 
015D8:  MOVLW  00
015DA:  MOVWF  01
015DC:  MOVLB  0
015DE:  GOTO   1AC4 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
*
03C98:  CLRF   x4F
03C9A:  CLRF   x50
03C9C:  CLRF   x54
03C9E:  CLRF   x53
03CA0:  CLRF   x52
03CA2:  CLRF   x51
.................... { 
....................    char 
....................       val[12] = "           ", 
*
03C56:  MOVLW  20
03C58:  MOVLB  6
03C5A:  MOVWF  x2E
03C5C:  MOVWF  x2F
03C5E:  MOVWF  x30
03C60:  MOVWF  x31
03C62:  MOVWF  x32
03C64:  MOVWF  x33
03C66:  MOVWF  x34
03C68:  MOVWF  x35
03C6A:  MOVWF  x36
03C6C:  MOVWF  x37
03C6E:  MOVWF  x38
03C70:  CLRF   x39
....................       cur_fname[12] = "           ", 
03C72:  MOVWF  x3A
03C74:  MOVWF  x3B
03C76:  MOVWF  x3C
03C78:  MOVWF  x3D
03C7A:  MOVWF  x3E
03C7C:  MOVWF  x3F
03C7E:  MOVWF  x40
03C80:  MOVWF  x41
03C82:  MOVWF  x42
03C84:  MOVWF  x43
03C86:  MOVWF  x44
03C88:  CLRF   x45
....................       cur_fnum[7] = "      "; 
03C8A:  MOVWF  x46
03C8C:  MOVWF  x47
03C8E:  MOVWF  x48
03C90:  MOVWF  x49
03C92:  MOVWF  x4A
03C94:  MOVWF  x4B
03C96:  CLRF   x4C
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
*
03CA4:  MOVFF  62B,65A
03CA8:  MOVFF  62A,659
03CAC:  MOVLW  2E
03CAE:  MOVWF  x5B
03CB0:  MOVLB  0
03CB2:  RCALL  3B2C
03CB4:  MOVFF  01,64E
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
03CB8:  MOVLB  6
03CBA:  MOVF   x4E,F
03CBC:  BNZ   3D4A
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
03CBE:  MOVF   x50,W
03CC0:  SUBLW  07
03CC2:  BNC   3D48
03CC4:  MOVF   x4F,W
03CC6:  ADDWF  x2A,W
03CC8:  MOVWF  FE9
03CCA:  MOVLW  00
03CCC:  ADDWFC x2B,W
03CCE:  MOVWF  FEA
03CD0:  MOVF   FEF,F
03CD2:  BZ    3D48
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
03CD4:  CLRF   03
03CD6:  MOVF   x50,W
03CD8:  ADDLW  2E
03CDA:  MOVWF  01
03CDC:  MOVLW  06
03CDE:  ADDWFC 03,F
03CE0:  MOVFF  01,659
03CE4:  MOVFF  03,65A
03CE8:  MOVF   x4F,W
03CEA:  ADDWF  x2A,W
03CEC:  MOVWF  FE9
03CEE:  MOVLW  00
03CF0:  ADDWFC x2B,W
03CF2:  MOVWF  FEA
03CF4:  MOVFF  FEF,65B
03CF8:  MOVF   x5B,W
03CFA:  SUBLW  60
03CFC:  BC    3D0A
03CFE:  MOVF   x5B,W
03D00:  SUBLW  7A
03D02:  BNC   3D0A
03D04:  MOVF   x5B,W
03D06:  ANDLW  DF
03D08:  BRA    3D0C
03D0A:  MOVF   x5B,W
03D0C:  MOVFF  65A,FEA
03D10:  MOVFF  659,FE9
03D14:  MOVWF  FEF
....................          val_parse_pos += 1; 
03D16:  MOVLW  01
03D18:  ADDWF  x50,F
....................          fname_parse_pos += 1; 
03D1A:  ADDWF  x4F,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
03D1C:  MOVF   x4F,W
03D1E:  ADDWF  x2A,W
03D20:  MOVWF  FE9
03D22:  MOVLW  00
03D24:  ADDWFC x2B,W
03D26:  MOVWF  FEA
03D28:  MOVF   FEF,W
03D2A:  SUBLW  2E
03D2C:  BZ    3D40
03D2E:  MOVF   x4F,W
03D30:  ADDWF  x2A,W
03D32:  MOVWF  FE9
03D34:  MOVLW  00
03D36:  ADDWFC x2B,W
03D38:  MOVWF  FEA
03D3A:  MOVF   FEF,W
03D3C:  SUBLW  20
03D3E:  BNZ   3D46
....................             fname_parse_pos += 1; 
03D40:  MOVLW  01
03D42:  ADDWF  x4F,F
03D44:  BRA    3D1C
03D46:  BRA    3CBE
....................       } 
....................    } 
03D48:  BRA    3DF8
....................    else 
....................    { 
....................       ext_pos -= fname - 1; 
03D4A:  MOVLW  01
03D4C:  SUBWF  x2A,W
03D4E:  MOVWF  00
03D50:  MOVLW  00
03D52:  SUBWFB x2B,W
03D54:  MOVF   00,W
03D56:  SUBWF  x4E,F
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
03D58:  MOVF   x50,W
03D5A:  SUBLW  0A
03D5C:  BNC   3DF8
03D5E:  MOVF   x4F,W
03D60:  ADDWF  x2A,W
03D62:  MOVWF  FE9
03D64:  MOVLW  00
03D66:  ADDWFC x2B,W
03D68:  MOVWF  FEA
03D6A:  MOVF   FEF,F
03D6C:  BZ    3DF8
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
03D6E:  CLRF   03
03D70:  MOVF   x50,W
03D72:  ADDLW  2E
03D74:  MOVWF  01
03D76:  MOVLW  06
03D78:  ADDWFC 03,F
03D7A:  MOVFF  01,659
03D7E:  MOVFF  03,65A
03D82:  MOVF   x4F,W
03D84:  ADDWF  x2A,W
03D86:  MOVWF  FE9
03D88:  MOVLW  00
03D8A:  ADDWFC x2B,W
03D8C:  MOVWF  FEA
03D8E:  MOVFF  FEF,65B
03D92:  MOVF   x5B,W
03D94:  SUBLW  60
03D96:  BC    3DA4
03D98:  MOVF   x5B,W
03D9A:  SUBLW  7A
03D9C:  BNC   3DA4
03D9E:  MOVF   x5B,W
03DA0:  ANDLW  DF
03DA2:  BRA    3DA6
03DA4:  MOVF   x5B,W
03DA6:  MOVFF  65A,FEA
03DAA:  MOVFF  659,FE9
03DAE:  MOVWF  FEF
....................          val_parse_pos += 1; 
03DB0:  MOVLW  01
03DB2:  ADDWF  x50,F
....................          fname_parse_pos += 1; 
03DB4:  ADDWF  x4F,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
03DB6:  MOVF   x4F,W
03DB8:  ADDWF  x2A,W
03DBA:  MOVWF  FE9
03DBC:  MOVLW  00
03DBE:  ADDWFC x2B,W
03DC0:  MOVWF  FEA
03DC2:  MOVF   FEF,W
03DC4:  SUBLW  2E
03DC6:  BZ    3DDA
03DC8:  MOVF   x4F,W
03DCA:  ADDWF  x2A,W
03DCC:  MOVWF  FE9
03DCE:  MOVLW  00
03DD0:  ADDWFC x2B,W
03DD2:  MOVWF  FEA
03DD4:  MOVF   FEF,W
03DD6:  SUBLW  20
03DD8:  BNZ   3DE0
....................             fname_parse_pos += 1; 
03DDA:  MOVLW  01
03DDC:  ADDWF  x4F,F
03DDE:  BRA    3DB6
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
03DE0:  MOVF   x4E,W
03DE2:  SUBWF  x4F,W
03DE4:  BNZ   3DEC
....................             val_parse_pos = 8; 
03DE6:  MOVLW  08
03DE8:  MOVWF  x50
03DEA:  BRA    3DF6
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
03DEC:  MOVF   x50,W
03DEE:  SUBLW  08
03DF0:  BNZ   3DF6
....................             fname_parse_pos = ext_pos; 
03DF2:  MOVFF  64E,64F
03DF6:  BRA    3D58
....................       } 
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
03DF8:  MOVFF  629,658
03DFC:  MOVFF  628,657
03E00:  MOVFF  627,656
03E04:  MOVFF  626,655
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
03E08:  MOVLW  0B
03E0A:  ADDWF  x55,W
03E0C:  MOVWF  x59
03E0E:  MOVLW  00
03E10:  ADDWFC x56,W
03E12:  MOVWF  x5A
03E14:  MOVLW  00
03E16:  ADDWFC x57,W
03E18:  MOVWF  x5B
03E1A:  MOVLW  00
03E1C:  ADDWFC x58,W
03E1E:  MOVWF  x5C
03E20:  MOVWF  xB7
03E22:  MOVFF  65B,6B6
03E26:  MOVFF  65A,6B5
03E2A:  MOVFF  659,6B4
03E2E:  CLRF   xB9
03E30:  MOVLW  01
03E32:  MOVWF  xB8
03E34:  MOVLW  06
03E36:  MOVWF  xBB
03E38:  MOVLW  4D
03E3A:  MOVWF  xBA
03E3C:  MOVLB  0
03E3E:  CALL   0C10
03E42:  MOVF   01,F
03E44:  BZ    3E4C
....................       return EOF; 
03E46:  MOVLW  FF
03E48:  MOVWF  01
03E4A:  BRA    40BE
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
03E4C:  MOVLB  6
03E4E:  MOVF   x4D,F
03E50:  BTFSC  FD8.2
03E52:  BRA    4064
....................    { 
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
03E54:  MOVF   x4D,W
03E56:  SUBLW  20
03E58:  BZ    3E62
03E5A:  MOVF   x4D,W
03E5C:  SUBLW  10
03E5E:  BTFSS  FD8.2
03E60:  BRA    3FB2
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
03E62:  MOVFF  658,6B7
03E66:  MOVFF  657,6B6
03E6A:  MOVFF  656,6B5
03E6E:  MOVFF  655,6B4
03E72:  CLRF   xB9
03E74:  MOVLW  0B
03E76:  MOVWF  xB8
03E78:  MOVLW  06
03E7A:  MOVWF  xBB
03E7C:  MOVLW  3A
03E7E:  MOVWF  xBA
03E80:  MOVLB  0
03E82:  CALL   0C10
03E86:  MOVF   01,F
03E88:  BZ    3E90
....................             return EOF; 
03E8A:  MOVLW  FF
03E8C:  MOVWF  01
03E8E:  BRA    40BE
....................  
....................          cur_fname[11] = '\0'; 
03E90:  MOVLB  6
03E92:  CLRF   x45
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
03E94:  MOVLW  06
03E96:  MOVWF  x7A
03E98:  MOVLW  3A
03E9A:  MOVWF  x79
03E9C:  MOVLW  06
03E9E:  MOVWF  x7C
03EA0:  MOVLW  2E
03EA2:  MOVWF  x7B
03EA4:  MOVLB  0
03EA6:  CALL   1BC0
03EAA:  MOVF   01,F
03EAC:  BTFSS  FD8.2
03EAE:  BRA    3FB4
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
03EB0:  MOVLW  01
03EB2:  MOVLB  6
03EB4:  ADDWF  x51,F
03EB6:  MOVLW  00
03EB8:  ADDWFC x52,F
03EBA:  ADDWFC x53,F
03EBC:  ADDWFC x54,F
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%lu", fnum); 
03EBE:  MOVLW  06
03EC0:  MOVLB  2
03EC2:  MOVWF  x25
03EC4:  MOVLW  46
03EC6:  MOVWF  x24
03EC8:  MOVLW  41
03ECA:  MOVWF  FE9
03ECC:  MOVFF  654,65C
03ED0:  MOVFF  653,65B
03ED4:  MOVFF  652,65A
03ED8:  MOVFF  651,659
03EDC:  MOVLB  0
03EDE:  BRA    3B92
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
03EE0:  MOVLB  6
03EE2:  CLRF   x4F
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
03EE4:  MOVLW  06
03EE6:  MOVWF  x5A
03EE8:  MOVLW  2E
03EEA:  MOVWF  x59
03EEC:  MOVLW  20
03EEE:  MOVWF  x5B
03EF0:  MOVLB  0
03EF2:  RCALL  3B2C
03EF4:  MOVFF  01,650
....................             if(val_parse_pos == 0) 
03EF8:  MOVLB  6
03EFA:  MOVF   x50,F
03EFC:  BNZ   3F1C
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
03EFE:  MOVLW  06
03F00:  MOVWF  x92
03F02:  MOVLW  46
03F04:  MOVWF  x91
03F06:  MOVLB  0
03F08:  CALL   1120
03F0C:  MOVFF  02,03
03F10:  MOVF   01,W
03F12:  XORLW  FF
03F14:  ADDLW  08
03F16:  MOVLB  6
03F18:  MOVWF  x50
03F1A:  BRA    3F20
....................             else 
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
03F1C:  MOVLW  30
03F1E:  SUBWF  x50,F
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
03F20:  MOVLW  0A
03F22:  MOVWF  x4D
....................             while(fnum >= buf) 
03F24:  MOVF   x54,F
03F26:  BNZ   3F36
03F28:  MOVF   x53,F
03F2A:  BNZ   3F36
03F2C:  MOVF   x52,F
03F2E:  BNZ   3F36
03F30:  MOVF   x4D,W
03F32:  SUBWF  x51,W
03F34:  BNC   3F44
....................             { 
....................                val_parse_pos -= 1; 
03F36:  MOVLW  01
03F38:  SUBWF  x50,F
....................                buf *= 10; 
03F3A:  MOVF   x4D,W
03F3C:  MULLW  0A
03F3E:  MOVFF  FF3,64D
03F42:  BRA    3F24
....................             } 
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
03F44:  CLRF   03
03F46:  MOVF   x50,W
03F48:  ADDLW  2E
03F4A:  MOVWF  FE9
03F4C:  MOVLW  06
03F4E:  ADDWFC 03,W
03F50:  MOVWF  FEA
03F52:  MOVLW  7E
03F54:  MOVWF  FEF
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
03F56:  MOVLW  01
03F58:  ADDWF  x50,F
....................             while(cur_fnum[fname_parse_pos] != '\0') 
03F5A:  CLRF   03
03F5C:  MOVF   x4F,W
03F5E:  ADDLW  46
03F60:  MOVWF  FE9
03F62:  MOVLW  06
03F64:  ADDWFC 03,W
03F66:  MOVWF  FEA
03F68:  MOVF   FEF,F
03F6A:  BZ    3FA2
....................             { 
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
03F6C:  CLRF   03
03F6E:  MOVF   x50,W
03F70:  ADDLW  2E
03F72:  MOVWF  01
03F74:  MOVLW  06
03F76:  ADDWFC 03,F
03F78:  MOVFF  03,65A
03F7C:  CLRF   03
03F7E:  MOVF   x4F,W
03F80:  ADDLW  46
03F82:  MOVWF  FE9
03F84:  MOVLW  06
03F86:  ADDWFC 03,W
03F88:  MOVWF  FEA
03F8A:  MOVFF  FEF,65B
03F8E:  MOVFF  65A,FEA
03F92:  MOVFF  01,FE9
03F96:  MOVFF  65B,FEF
....................                val_parse_pos += 1; 
03F9A:  MOVLW  01
03F9C:  ADDWF  x50,F
....................                fname_parse_pos += 1; 
03F9E:  ADDWF  x4F,F
03FA0:  BRA    3F5A
....................             } 
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
03FA2:  MOVFF  629,658
03FA6:  MOVFF  628,657
03FAA:  MOVFF  627,656
03FAE:  MOVFF  626,655
03FB2:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
03FB4:  MOVLW  06
03FB6:  MOVLB  6
03FB8:  MOVWF  x7A
03FBA:  MOVLW  55
03FBC:  MOVWF  x79
03FBE:  MOVLB  0
03FC0:  CALL   2BF8
03FC4:  MOVF   01,W
03FC6:  SUBLW  FF
03FC8:  BNZ   401A
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
03FCA:  MOVFF  658,69A
03FCE:  MOVFF  657,699
03FD2:  MOVFF  656,698
03FD6:  MOVFF  655,697
03FDA:  CALL   1676
03FDE:  MOVFF  03,65C
03FE2:  MOVFF  02,65B
03FE6:  MOVFF  01,65A
03FEA:  MOVFF  00,659
03FEE:  MOVFF  03,693
03FF2:  MOVFF  02,692
03FF6:  MOVFF  01,691
03FFA:  MOVFF  00,690
03FFE:  MOVLW  06
04000:  MOVLB  6
04002:  MOVWF  x95
04004:  MOVLW  55
04006:  MOVWF  x94
04008:  MOVLB  0
0400A:  CALL   2438
0400E:  MOVF   01,W
04010:  SUBLW  FF
04012:  BNZ   401A
....................             return EOF;          
04014:  MOVLW  FF
04016:  MOVWF  01
04018:  BRA    40BE
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
0401A:  MOVLW  0B
0401C:  MOVLB  6
0401E:  ADDWF  x55,W
04020:  MOVWF  x59
04022:  MOVLW  00
04024:  ADDWFC x56,W
04026:  MOVWF  x5A
04028:  MOVLW  00
0402A:  ADDWFC x57,W
0402C:  MOVWF  x5B
0402E:  MOVLW  00
04030:  ADDWFC x58,W
04032:  MOVWF  x5C
04034:  MOVWF  xB7
04036:  MOVFF  65B,6B6
0403A:  MOVFF  65A,6B5
0403E:  MOVFF  659,6B4
04042:  CLRF   xB9
04044:  MOVLW  01
04046:  MOVWF  xB8
04048:  MOVLW  06
0404A:  MOVWF  xBB
0404C:  MOVLW  4D
0404E:  MOVWF  xBA
04050:  MOVLB  0
04052:  CALL   0C10
04056:  MOVF   01,F
04058:  BZ    4060
....................          return EOF; 
0405A:  MOVLW  FF
0405C:  MOVWF  01
0405E:  BRA    40BE
04060:  BRA    3E4C
04062:  MOVLB  6
....................    } 
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
04064:  CLRF   x58
04066:  CLRF   x57
04068:  CLRF   x56
0406A:  CLRF   x55
0406C:  MOVF   x58,F
0406E:  BNZ   40BA
04070:  MOVF   x57,F
04072:  BNZ   40BA
04074:  MOVF   x56,F
04076:  BNZ   40BA
04078:  MOVF   x55,W
0407A:  SUBLW  0B
0407C:  BNC   40BA
....................       sname[i] = val[i]; 
0407E:  MOVF   x2C,W
04080:  ADDWF  x55,W
04082:  MOVWF  01
04084:  MOVF   x2D,W
04086:  ADDWFC x56,W
04088:  MOVWF  03
0408A:  MOVFF  01,659
0408E:  MOVWF  x5A
04090:  MOVLW  2E
04092:  ADDWF  x55,W
04094:  MOVWF  FE9
04096:  MOVLW  06
04098:  ADDWFC x56,W
0409A:  MOVWF  FEA
0409C:  MOVFF  FEF,65B
040A0:  MOVFF  03,FEA
040A4:  MOVFF  01,FE9
040A8:  MOVFF  65B,FEF
040AC:  MOVLW  01
040AE:  ADDWF  x55,F
040B0:  MOVLW  00
040B2:  ADDWFC x56,F
040B4:  ADDWFC x57,F
040B6:  ADDWFC x58,F
040B8:  BRA    406C
....................  
....................    return GOODEC; 
040BA:  MOVLW  00
040BC:  MOVWF  01
040BE:  MOVLB  0
040C0:  GOTO   4350 (RETURN)
.................... } 
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
040C4:  MOVLB  6
040C6:  CLRF   x29
.................... { 
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
040C8:  MOVLW  0B
040CA:  MOVWF  x28
040CC:  MOVF   x28,F
040CE:  BZ    4100
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
040D0:  BTFSS  x29.0
040D2:  BRA    40D8
040D4:  MOVLW  80
040D6:  BRA    40DA
040D8:  MOVLW  00
040DA:  MOVWF  x2A
040DC:  BCF    FD8.0
040DE:  RRCF   x29,W
040E0:  ADDWF  x2A,F
040E2:  MOVFF  627,03
040E6:  MOVF   x26,W
040E8:  INCF   x26,F
040EA:  BTFSC  FD8.2
040EC:  INCF   x27,F
040EE:  MOVWF  FE9
040F0:  MOVFF  03,FEA
040F4:  MOVF   FEF,W
040F6:  ADDWF  x2A,W
040F8:  MOVWF  x29
040FA:  MOVLW  01
040FC:  SUBWF  x28,F
040FE:  BRA    40CC
....................  
....................    return Sum; 
04100:  MOVFF  629,01
04104:  MOVLB  0
04106:  GOTO   436A (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
*
03AB6:  MOVLB  6
03AB8:  CLRF   x28
03ABA:  MOVF   x28,W
03ABC:  ADDWF  x26,W
03ABE:  MOVWF  FE9
03AC0:  MOVLW  00
03AC2:  ADDWFC x27,W
03AC4:  MOVWF  FEA
03AC6:  MOVF   FEF,F
03AC8:  BZ    3B22
03ACA:  MOVF   x28,W
03ACC:  SUBLW  1F
03ACE:  BNC   3B22
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
03AD0:  MOVF   x28,W
03AD2:  ADDWF  x26,W
03AD4:  MOVWF  FE9
03AD6:  MOVLW  00
03AD8:  ADDWFC x27,W
03ADA:  MOVWF  FEA
03ADC:  MOVFF  FEF,629
03AE0:  MOVF   x29,W
03AE2:  SUBLW  22
03AE4:  BZ    3B16
03AE6:  MOVF   x29,W
03AE8:  SUBLW  2A
03AEA:  BZ    3B16
03AEC:  MOVF   x29,W
03AEE:  SUBLW  2F
03AF0:  BZ    3B16
03AF2:  MOVF   x29,W
03AF4:  SUBLW  3A
03AF6:  BZ    3B16
03AF8:  MOVF   x29,W
03AFA:  SUBLW  3C
03AFC:  BZ    3B16
03AFE:  MOVF   x29,W
03B00:  SUBLW  3D
03B02:  BC    3B0A
03B04:  MOVF   x29,W
03B06:  SUBLW  3F
03B08:  BC    3B16
03B0A:  MOVF   x29,W
03B0C:  SUBLW  5C
03B0E:  BZ    3B16
03B10:  MOVF   x29,W
03B12:  SUBLW  7C
03B14:  BNZ   3B1C
....................          return EOF; 
03B16:  MOVLW  FF
03B18:  MOVWF  01
03B1A:  BRA    3B26
03B1C:  MOVLW  01
03B1E:  ADDWF  x28,F
03B20:  BRA    3ABA
....................  
....................    return GOODEC; 
03B22:  MOVLW  00
03B24:  MOVWF  01
03B26:  MOVLB  0
03B28:  GOTO   431E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
*
01F18:  MOVLB  6
01F1A:  MOVFF  69E,FE9
01F1E:  MOVFF  69F,FEA
01F22:  MOVFF  FEF,6B0
01F26:  MOVFF  FEC,6B1
01F2A:  MOVFF  FEC,6B2
01F2E:  MOVFF  FEC,6B3
01F32:  RLCF   xB0,F
01F34:  RLCF   xB1,F
01F36:  RLCF   xB2,F
01F38:  RLCF   xB3,F
01F3A:  RLCF   xB0,F
01F3C:  RLCF   xB1,F
01F3E:  RLCF   xB2,F
01F40:  RLCF   xB3,F
01F42:  MOVLW  FC
01F44:  ANDWF  xB0,F
01F46:  MOVLB  2
01F48:  MOVF   x12,W
01F4A:  MOVLB  6
01F4C:  ADDWF  xB0,W
01F4E:  MOVWF  xA8
01F50:  MOVLB  2
01F52:  MOVF   x13,W
01F54:  MOVLB  6
01F56:  ADDWFC xB1,W
01F58:  MOVWF  xA9
01F5A:  MOVLW  00
01F5C:  ADDWFC xB2,W
01F5E:  MOVWF  xAA
01F60:  MOVLW  00
01F62:  ADDWFC xB3,W
01F64:  MOVWF  xAB
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
01F66:  CLRF   xAF
01F68:  CLRF   xAE
01F6A:  CLRF   xAD
01F6C:  CLRF   xAC
01F6E:  MOVF   xAF,W
01F70:  MOVLB  2
01F72:  SUBWF  x1B,W
01F74:  BTFSS  FD8.0
01F76:  BRA    208C
01F78:  BNZ   1FA6
01F7A:  MOVLB  6
01F7C:  MOVF   xAE,W
01F7E:  MOVLB  2
01F80:  SUBWF  x1A,W
01F82:  BTFSS  FD8.0
01F84:  BRA    208C
01F86:  BNZ   1FA6
01F88:  MOVLB  6
01F8A:  MOVF   xAD,W
01F8C:  MOVLB  2
01F8E:  SUBWF  x19,W
01F90:  BTFSS  FD8.0
01F92:  BRA    208C
01F94:  BNZ   1FA6
01F96:  MOVF   x18,W
01F98:  MOVLB  6
01F9A:  SUBWF  xAC,W
01F9C:  BTFSS  FD8.0
01F9E:  BRA    1FA4
01FA0:  MOVLB  2
01FA2:  BRA    208C
01FA4:  MOVLB  2
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
01FA6:  MOVLB  6
01FA8:  MOVF   xAC,W
01FAA:  ADDWF  xA8,W
01FAC:  MOVWF  xB0
01FAE:  MOVF   xAD,W
01FB0:  ADDWFC xA9,W
01FB2:  MOVWF  xB1
01FB4:  MOVF   xAE,W
01FB6:  ADDWFC xAA,W
01FB8:  MOVWF  xB2
01FBA:  MOVF   xAF,W
01FBC:  ADDWFC xAB,W
01FBE:  MOVWF  xB3
01FC0:  MOVWF  xB7
01FC2:  MOVFF  6B2,6B6
01FC6:  MOVFF  6B1,6B5
01FCA:  MOVFF  6B0,6B4
01FCE:  CLRF   xB9
01FD0:  MOVLW  04
01FD2:  MOVWF  xB8
01FD4:  MOVLW  06
01FD6:  MOVWF  xBB
01FD8:  MOVLW  A0
01FDA:  MOVWF  xBA
01FDC:  MOVLB  0
01FDE:  CALL   0C10
01FE2:  MOVF   01,F
01FE4:  BZ    1FEC
....................          return EOF; 
01FE6:  MOVLW  FF
01FE8:  MOVWF  01
01FEA:  BRA    2092
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
01FEC:  MOVFF  6A3,6A7
01FF0:  MOVFF  6A2,6A6
01FF4:  MOVFF  6A1,6A5
01FF8:  MOVFF  6A0,6A4
....................  
....................       if(cur_cluster == 0) 
01FFC:  MOVLB  6
01FFE:  MOVF   xA4,F
02000:  BNZ   207C
02002:  MOVF   xA5,F
02004:  BNZ   207C
02006:  MOVF   xA6,F
02008:  BNZ   207C
0200A:  MOVF   xA7,F
0200C:  BNZ   207C
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
0200E:  MOVF   xAC,W
02010:  ADDWF  xA8,F
02012:  MOVF   xAD,W
02014:  ADDWFC xA9,F
02016:  MOVF   xAE,W
02018:  ADDWFC xAA,F
0201A:  MOVF   xAF,W
0201C:  ADDWFC xAB,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
0201E:  MOVFF  69E,FE9
02022:  MOVFF  69F,FEA
02026:  MOVLB  2
02028:  MOVF   x12,W
0202A:  MOVLB  6
0202C:  SUBWF  xA8,W
0202E:  MOVWF  xB2
02030:  MOVLB  2
02032:  MOVF   x13,W
02034:  MOVLB  6
02036:  SUBWFB xA9,W
02038:  MOVWF  xB3
0203A:  MOVLW  00
0203C:  SUBWFB xAA,W
0203E:  MOVWF  xB4
02040:  MOVLW  00
02042:  SUBWFB xAB,W
02044:  MOVWF  xB5
02046:  RRCF   xB5,W
02048:  MOVWF  03
0204A:  RRCF   xB4,W
0204C:  MOVWF  02
0204E:  RRCF   xB3,W
02050:  MOVWF  01
02052:  RRCF   xB2,W
02054:  MOVWF  00
02056:  RRCF   03,F
02058:  RRCF   02,F
0205A:  RRCF   01,F
0205C:  RRCF   00,F
0205E:  MOVLW  3F
02060:  ANDWF  03,F
02062:  MOVFF  00,FEF
02066:  MOVFF  01,FEC
0206A:  MOVFF  02,FEC
0206E:  MOVFF  03,FEC
....................          return GOODEC; 
02072:  MOVLW  00
02074:  MOVWF  01
02076:  MOVLB  0
02078:  BRA    2092
0207A:  MOVLB  6
....................       } 
0207C:  MOVLW  04
0207E:  ADDWF  xAC,F
02080:  MOVLW  00
02082:  ADDWFC xAD,F
02084:  ADDWFC xAE,F
02086:  ADDWFC xAF,F
02088:  BRA    1F6E
0208A:  MOVLB  2
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make16(val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
....................          return GOODEC; 
....................       } 
....................    } 
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
0208C:  MOVLW  FF
0208E:  MOVWF  01
02090:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
02092:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
*
04B60:  MOVLW  08
04B62:  MOVLB  5
04B64:  ADDWF  xC1,W
04B66:  MOVWF  FE9
04B68:  MOVLW  00
04B6A:  ADDWFC xC2,W
04B6C:  MOVWF  FEA
04B6E:  MOVFF  FEF,5C7
04B72:  MOVFF  FEC,5C8
04B76:  MOVFF  FEC,5C9
04B7A:  MOVFF  FEC,5CA
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
04B7E:  MOVLW  05
04B80:  MOVLB  6
04B82:  MOVWF  x7A
04B84:  MOVLW  C7
04B86:  MOVWF  x79
04B88:  MOVLB  0
04B8A:  CALL   2BF8
04B8E:  MOVF   01,W
04B90:  SUBLW  FF
04B92:  BNZ   4BAE
....................       { 
....................          stream->File_Type = None; 
04B94:  MOVLW  18
04B96:  MOVLB  5
04B98:  ADDWF  xC1,W
04B9A:  MOVWF  FE9
04B9C:  MOVLW  00
04B9E:  ADDWFC xC2,W
04BA0:  MOVWF  FEA
04BA2:  MOVLW  02
04BA4:  MOVWF  FEF
....................          return EOF; 
04BA6:  MOVLW  FF
04BA8:  MOVWF  01
04BAA:  BRA    4DEA
04BAC:  MOVLB  0
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
04BAE:  MOVFF  5CA,6B7
04BB2:  MOVFF  5C9,6B6
04BB6:  MOVFF  5C8,6B5
04BBA:  MOVFF  5C7,6B4
04BBE:  MOVLB  6
04BC0:  CLRF   xB9
04BC2:  MOVLW  01
04BC4:  MOVWF  xB8
04BC6:  MOVLW  05
04BC8:  MOVWF  xBB
04BCA:  MOVLW  CF
04BCC:  MOVWF  xBA
04BCE:  MOVLB  0
04BD0:  CALL   0C10
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
04BD4:  MOVLW  0B
04BD6:  MOVLB  5
04BD8:  ADDWF  xC7,W
04BDA:  MOVWF  xD1
04BDC:  MOVLW  00
04BDE:  ADDWFC xC8,W
04BE0:  MOVWF  xD2
04BE2:  MOVLW  00
04BE4:  ADDWFC xC9,W
04BE6:  MOVWF  xD3
04BE8:  MOVLW  00
04BEA:  ADDWFC xCA,W
04BEC:  MOVWF  xD4
04BEE:  MOVFF  FE8,6B7
04BF2:  MOVFF  5D3,6B6
04BF6:  MOVFF  5D2,6B5
04BFA:  MOVFF  5D1,6B4
04BFE:  MOVLB  6
04C00:  CLRF   xB9
04C02:  MOVLW  01
04C04:  MOVWF  xB8
04C06:  MOVLW  05
04C08:  MOVWF  xBB
04C0A:  MOVLW  D0
04C0C:  MOVWF  xBA
04C0E:  MOVLB  0
04C10:  CALL   0C10
....................  
....................       if(fileentry == 0) 
04C14:  MOVLB  5
04C16:  MOVF   xCF,F
04C18:  BNZ   4C30
....................       { 
....................          stream->File_Type = None; 
04C1A:  MOVLW  18
04C1C:  ADDWF  xC1,W
04C1E:  MOVWF  FE9
04C20:  MOVLW  00
04C22:  ADDWFC xC2,W
04C24:  MOVWF  FEA
04C26:  MOVLW  02
04C28:  MOVWF  FEF
....................          return EOF; 
04C2A:  MOVLW  FF
04C2C:  MOVWF  01
04C2E:  BRA    4DEA
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
04C30:  MOVF   xCF,W
04C32:  SUBLW  E5
04C34:  BZ    4B7E
04C36:  MOVF   xD0,W
04C38:  SUBLW  0F
04C3A:  BZ    4B7E
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
04C3C:  MOVF   xD0,W
04C3E:  SUBLW  10
04C40:  BNZ   4C54
....................       stream->File_Type = Directory; 
04C42:  MOVLW  18
04C44:  ADDWF  xC1,W
04C46:  MOVWF  FE9
04C48:  MOVLW  00
04C4A:  ADDWFC xC2,W
04C4C:  MOVWF  FEA
04C4E:  MOVLW  01
04C50:  MOVWF  FEF
04C52:  BRA    4C62
....................    else 
....................       stream->File_Type = Data_File; 
04C54:  MOVLW  18
04C56:  ADDWF  xC1,W
04C58:  MOVWF  FE9
04C5A:  MOVLW  00
04C5C:  ADDWFC xC2,W
04C5E:  MOVWF  FEA
04C60:  CLRF   FEF
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
04C62:  MOVLW  08
04C64:  ADDWF  xC1,W
04C66:  MOVWF  FE9
04C68:  MOVLW  00
04C6A:  ADDWFC xC2,W
04C6C:  MOVWF  FEA
04C6E:  MOVFF  5C7,FEF
04C72:  MOVFF  5C8,FEC
04C76:  MOVFF  5C9,FEC
04C7A:  MOVFF  5CA,FEC
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
04C7E:  MOVLW  1A
04C80:  ADDWF  xC7,W
04C82:  MOVWF  xD1
04C84:  MOVLW  00
04C86:  ADDWFC xC8,W
04C88:  MOVWF  xD2
04C8A:  MOVLW  00
04C8C:  ADDWFC xC9,W
04C8E:  MOVWF  xD3
04C90:  MOVLW  00
04C92:  ADDWFC xCA,W
04C94:  MOVWF  xD4
04C96:  MOVFF  FE8,6B7
04C9A:  MOVFF  5D3,6B6
04C9E:  MOVFF  5D2,6B5
04CA2:  MOVFF  5D1,6B4
04CA6:  MOVLB  6
04CA8:  CLRF   xB9
04CAA:  MOVLW  02
04CAC:  MOVWF  xB8
04CAE:  MOVLW  05
04CB0:  MOVWF  xBB
04CB2:  MOVLW  C3
04CB4:  MOVWF  xBA
04CB6:  MOVLB  0
04CB8:  CALL   0C10
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
04CBC:  MOVLW  14
04CBE:  MOVLB  5
04CC0:  ADDWF  xC7,W
04CC2:  MOVWF  xD1
04CC4:  MOVLW  00
04CC6:  ADDWFC xC8,W
04CC8:  MOVWF  xD2
04CCA:  MOVLW  00
04CCC:  ADDWFC xC9,W
04CCE:  MOVWF  xD3
04CD0:  MOVLW  00
04CD2:  ADDWFC xCA,W
04CD4:  MOVWF  xD4
04CD6:  MOVFF  FE8,6B7
04CDA:  MOVFF  5D3,6B6
04CDE:  MOVFF  5D2,6B5
04CE2:  MOVFF  5D1,6B4
04CE6:  MOVLB  6
04CE8:  CLRF   xB9
04CEA:  MOVLW  02
04CEC:  MOVWF  xB8
04CEE:  MOVLW  05
04CF0:  MOVWF  xBB
04CF2:  MOVLW  C5
04CF4:  MOVWF  xBA
04CF6:  MOVLB  0
04CF8:  CALL   0C10
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
04CFC:  MOVLW  14
04CFE:  MOVLB  5
04D00:  ADDWF  xC1,W
04D02:  MOVWF  01
04D04:  MOVLW  00
04D06:  ADDWFC xC2,W
04D08:  MOVWF  03
04D0A:  MOVFF  01,5D1
04D0E:  MOVWF  xD2
04D10:  MOVLW  04
04D12:  ADDWF  xC1,W
04D14:  MOVWF  01
04D16:  MOVLW  00
04D18:  ADDWFC xC2,W
04D1A:  MOVWF  03
04D1C:  MOVFF  01,5D3
04D20:  MOVWF  xD4
04D22:  MOVFF  5C6,6CC
04D26:  MOVFF  5C5,6CB
04D2A:  MOVFF  5C4,6CA
04D2E:  MOVFF  5C3,6C9
04D32:  MOVLB  0
04D34:  CALL   17C2
04D38:  MOVFF  5D4,FEA
04D3C:  MOVFF  5D3,FE9
04D40:  MOVFF  00,FEF
04D44:  MOVFF  01,FEC
04D48:  MOVFF  02,FEC
04D4C:  MOVFF  03,FEC
04D50:  MOVFF  5D2,FEA
04D54:  MOVFF  5D1,FE9
04D58:  MOVFF  00,FEF
04D5C:  MOVFF  01,FEC
04D60:  MOVFF  02,FEC
04D64:  MOVFF  03,FEC
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
04D68:  MOVLW  1C
04D6A:  MOVLB  5
04D6C:  ADDWF  xC7,W
04D6E:  MOVWF  xD1
04D70:  MOVLW  00
04D72:  ADDWFC xC8,W
04D74:  MOVWF  xD2
04D76:  MOVLW  00
04D78:  ADDWFC xC9,W
04D7A:  MOVWF  xD3
04D7C:  MOVLW  00
04D7E:  ADDWFC xCA,W
04D80:  MOVWF  xD4
04D82:  MOVFF  FE8,6B7
04D86:  MOVFF  5D3,6B6
04D8A:  MOVFF  5D2,6B5
04D8E:  MOVFF  5D1,6B4
04D92:  MOVLB  6
04D94:  CLRF   xB9
04D96:  MOVLW  04
04D98:  MOVWF  xB8
04D9A:  MOVLW  05
04D9C:  MOVWF  xBB
04D9E:  MOVLW  CB
04DA0:  MOVWF  xBA
04DA2:  MOVLB  0
04DA4:  CALL   0C10
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
04DA8:  MOVLW  10
04DAA:  MOVLB  5
04DAC:  ADDWF  xC1,W
04DAE:  MOVWF  01
04DB0:  MOVLW  00
04DB2:  ADDWFC xC2,W
04DB4:  MOVFF  01,5D1
04DB8:  MOVFF  5C1,FE9
04DBC:  MOVFF  5C2,FEA
04DC0:  MOVFF  5CB,FEF
04DC4:  MOVFF  5CC,FEC
04DC8:  MOVFF  5CD,FEC
04DCC:  MOVFF  5CE,FEC
04DD0:  MOVWF  FEA
04DD2:  MOVFF  5D1,FE9
04DD6:  MOVFF  5CB,FEF
04DDA:  MOVFF  5CC,FEC
04DDE:  MOVFF  5CD,FEC
04DE2:  MOVFF  5CE,FEC
....................  
....................    return GOODEC; 
04DE6:  MOVLW  00
04DE8:  MOVWF  01
04DEA:  MOVLB  0
04DEC:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
02BF8:  MOVLB  6
02BFA:  MOVFF  679,FE9
02BFE:  MOVFF  67A,FEA
02C02:  MOVFF  FEF,67B
02C06:  MOVFF  FEC,67C
02C0A:  MOVFF  FEC,67D
02C0E:  MOVFF  FEC,67E
....................     
....................    i += 0x1F; 
02C12:  MOVLW  1F
02C14:  ADDWF  x7B,F
02C16:  MOVLW  00
02C18:  ADDWFC x7C,F
02C1A:  ADDWFC x7D,F
02C1C:  ADDWFC x7E,F
....................     
....................    if(get_next_addr(&i) == EOF) 
02C1E:  MOVLW  06
02C20:  MOVWF  x8D
02C22:  MOVLW  7B
02C24:  MOVWF  x8C
02C26:  MOVLB  0
02C28:  CALL   22AA
02C2C:  MOVF   01,W
02C2E:  SUBLW  FF
02C30:  BNZ   2C38
....................       return EOF; 
02C32:  MOVLW  FF
02C34:  MOVWF  01
02C36:  BRA    2C58
....................     
....................    *start_addr = i; 
02C38:  MOVLB  6
02C3A:  MOVFF  679,FE9
02C3E:  MOVFF  67A,FEA
02C42:  MOVFF  67B,FEF
02C46:  MOVFF  67C,FEC
02C4A:  MOVFF  67D,FEC
02C4E:  MOVFF  67E,FEC
....................     
....................    return GOODEC; 
02C52:  MOVLW  00
02C54:  MOVWF  01
02C56:  MOVLB  0
02C58:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
019E4:  MOVLB  6
019E6:  MOVFF  687,FE9
019EA:  MOVFF  688,FEA
019EE:  MOVFF  FEF,689
019F2:  MOVFF  FEC,68A
019F6:  MOVFF  FEC,68B
019FA:  MOVFF  FEC,68C
....................  
....................    i -= 0x1F; 
019FE:  MOVLW  1F
01A00:  SUBWF  x89,F
01A02:  MOVLW  00
01A04:  SUBWFB x8A,F
01A06:  SUBWFB x8B,F
01A08:  SUBWFB x8C,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
01A0A:  MOVLW  06
01A0C:  MOVWF  x8E
01A0E:  MOVLW  89
01A10:  MOVWF  x8D
01A12:  MOVLB  0
01A14:  BRA    1820
01A16:  MOVF   01,W
01A18:  SUBLW  FF
01A1A:  BNZ   1A22
....................       return EOF; 
01A1C:  MOVLW  FF
01A1E:  MOVWF  01
01A20:  BRA    1A42
....................  
....................    *start_addr = i; 
01A22:  MOVLB  6
01A24:  MOVFF  687,FE9
01A28:  MOVFF  688,FEA
01A2C:  MOVFF  689,FEF
01A30:  MOVFF  68A,FEC
01A34:  MOVFF  68B,FEC
01A38:  MOVFF  68C,FEC
....................     
....................    return GOODEC; 
01A3C:  MOVLW  00
01A3E:  MOVWF  01
01A40:  MOVLB  0
01A42:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
*
0410A:  MOVLB  6
0410C:  MOVFF  626,FE9
04110:  MOVFF  627,FEA
04114:  MOVFF  FEF,629
04118:  MOVFF  FEC,62A
0411C:  MOVFF  FEC,62B
04120:  MOVFF  FEC,62C
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
04124:  MOVFF  62C,6B7
04128:  MOVFF  62B,6B6
0412C:  MOVFF  62A,6B5
04130:  MOVFF  629,6B4
04134:  CLRF   xB9
04136:  MOVLW  01
04138:  MOVWF  xB8
0413A:  MOVLW  06
0413C:  MOVWF  xBB
0413E:  MOVLW  28
04140:  MOVWF  xBA
04142:  MOVLB  0
04144:  CALL   0C10
04148:  MOVF   01,F
0414A:  BZ    4152
....................      return EOF; 
0414C:  MOVLW  FF
0414E:  MOVWF  01
04150:  BRA    421A
....................  
....................    while(buf != 0) 
04152:  MOVLB  6
04154:  MOVF   x28,F
04156:  BZ    41FC
....................    { 
....................       i += 0x1F; 
04158:  MOVLW  1F
0415A:  ADDWF  x29,F
0415C:  MOVLW  00
0415E:  ADDWFC x2A,F
04160:  ADDWFC x2B,F
04162:  ADDWFC x2C,F
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
04164:  MOVLW  06
04166:  MOVWF  x8D
04168:  MOVLW  29
0416A:  MOVWF  x8C
0416C:  MOVLB  0
0416E:  CALL   22AA
04172:  MOVF   01,W
04174:  SUBLW  FF
04176:  BNZ   41C8
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
04178:  MOVFF  62C,69A
0417C:  MOVFF  62B,699
04180:  MOVFF  62A,698
04184:  MOVFF  629,697
04188:  CALL   1676
0418C:  MOVFF  03,630
04190:  MOVFF  02,62F
04194:  MOVFF  01,62E
04198:  MOVFF  00,62D
0419C:  MOVFF  03,693
041A0:  MOVFF  02,692
041A4:  MOVFF  01,691
041A8:  MOVFF  00,690
041AC:  MOVLW  06
041AE:  MOVLB  6
041B0:  MOVWF  x95
041B2:  MOVLW  29
041B4:  MOVWF  x94
041B6:  MOVLB  0
041B8:  CALL   2438
041BC:  MOVF   01,W
041BE:  SUBLW  FF
041C0:  BNZ   41C8
....................             return EOF; 
041C2:  MOVLW  FF
041C4:  MOVWF  01
041C6:  BRA    421A
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
041C8:  MOVFF  62C,6B7
041CC:  MOVFF  62B,6B6
041D0:  MOVFF  62A,6B5
041D4:  MOVFF  629,6B4
041D8:  MOVLB  6
041DA:  CLRF   xB9
041DC:  MOVLW  01
041DE:  MOVWF  xB8
041E0:  MOVLW  06
041E2:  MOVWF  xBB
041E4:  MOVLW  28
041E6:  MOVWF  xBA
041E8:  MOVLB  0
041EA:  CALL   0C10
041EE:  MOVF   01,F
041F0:  BZ    41F8
....................         return EOF; 
041F2:  MOVLW  FF
041F4:  MOVWF  01
041F6:  BRA    421A
041F8:  BRA    4152
041FA:  MOVLB  6
....................    } 
....................  
....................    *start_addr = i; 
041FC:  MOVFF  626,FE9
04200:  MOVFF  627,FEA
04204:  MOVFF  629,FEF
04208:  MOVFF  62A,FEC
0420C:  MOVFF  62B,FEC
04210:  MOVFF  62C,FEC
....................  
....................    return GOODEC; 
04214:  MOVLW  00
04216:  MOVWF  01
04218:  MOVLB  0
0421A:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
02438:  MOVFF  693,699
0243C:  MOVFF  692,698
02440:  MOVFF  691,697
02444:  MOVFF  690,696
02448:  MOVFF  699,69D
0244C:  MOVFF  698,69C
02450:  MOVFF  697,69B
02454:  MOVFF  696,69A
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
02458:  MOVLW  06
0245A:  MOVLB  6
0245C:  MOVWF  x9F
0245E:  MOVLW  9A
02460:  MOVWF  x9E
02462:  MOVLB  0
02464:  RCALL  1F18
02466:  MOVF   01,W
02468:  SUBLW  FF
0246A:  BNZ   2472
....................       return EOF; 
0246C:  MOVLW  FF
0246E:  MOVWF  01
02470:  BRA    2528
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
02472:  MOVFF  699,6A1
02476:  MOVFF  698,6A0
0247A:  MOVFF  697,69F
0247E:  MOVFF  696,69E
02482:  MOVFF  69D,6A5
02486:  MOVFF  69C,6A4
0248A:  MOVFF  69B,6A3
0248E:  MOVFF  69A,6A2
02492:  RCALL  1D88
02494:  MOVF   01,W
02496:  SUBLW  FF
02498:  BNZ   24A0
....................       return EOF; 
0249A:  MOVLW  FF
0249C:  MOVWF  01
0249E:  BRA    2528
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
024A0:  MOVFF  69D,6A1
024A4:  MOVFF  69C,6A0
024A8:  MOVFF  69B,69F
024AC:  MOVFF  69A,69E
024B0:  MOVLW  0F
024B2:  MOVLB  6
024B4:  MOVWF  xA5
024B6:  SETF   xA4
024B8:  SETF   xA3
024BA:  SETF   xA2
024BC:  MOVLB  0
024BE:  RCALL  1D88
024C0:  MOVF   01,W
024C2:  SUBLW  FF
024C4:  BNZ   24CC
....................       return EOF; 
024C6:  MOVLW  FF
024C8:  MOVWF  01
024CA:  BRA    2528
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
024CC:  MOVFF  69D,6A1
024D0:  MOVFF  69C,6A0
024D4:  MOVFF  69B,69F
024D8:  MOVFF  69A,69E
024DC:  RCALL  2094
024DE:  MOVF   01,W
024E0:  SUBLW  FF
024E2:  BNZ   24EA
....................       return EOF; 
024E4:  MOVLW  FF
024E6:  MOVWF  01
024E8:  BRA    2528
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
024EA:  MOVFF  695,03
024EE:  MOVFF  694,69E
024F2:  MOVFF  695,69F
024F6:  MOVFF  69D,6CC
024FA:  MOVFF  69C,6CB
024FE:  MOVFF  69B,6CA
02502:  MOVFF  69A,6C9
02506:  MOVLB  0
02508:  CALL   17C2
0250C:  MOVFF  69F,FEA
02510:  MOVFF  69E,FE9
02514:  MOVFF  00,FEF
02518:  MOVFF  01,FEC
0251C:  MOVFF  02,FEC
02520:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
02524:  MOVLW  00
02526:  MOVWF  01
02528:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
01DEE:  MOVFF  680,684
01DF2:  MOVFF  67F,683
01DF6:  MOVFF  67E,682
01DFA:  MOVFF  67D,681
01DFE:  MOVFF  684,688
01E02:  MOVFF  683,687
01E06:  MOVFF  682,686
01E0A:  MOVFF  681,685
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
01E0E:  MOVLW  06
01E10:  MOVLB  6
01E12:  MOVWF  x93
01E14:  MOVLW  85
01E16:  MOVWF  x92
01E18:  MOVLB  0
01E1A:  RCALL  1C38
01E1C:  MOVF   01,W
01E1E:  SUBLW  FF
01E20:  BNZ   1E28
....................          return EOF; 
01E22:  MOVLW  FF
01E24:  MOVWF  01
01E26:  BRA    1E94
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
01E28:  MOVFF  684,6A1
01E2C:  MOVFF  683,6A0
01E30:  MOVFF  682,69F
01E34:  MOVFF  681,69E
01E38:  MOVLB  6
01E3A:  CLRF   xA5
01E3C:  CLRF   xA4
01E3E:  CLRF   xA3
01E40:  CLRF   xA2
01E42:  MOVLB  0
01E44:  RCALL  1D88
01E46:  MOVF   01,W
01E48:  SUBLW  FF
01E4A:  BNZ   1E52
....................          return EOF; 
01E4C:  MOVLW  FF
01E4E:  MOVWF  01
01E50:  BRA    1E94
....................  
....................       cur_cluster = next_cluster; 
01E52:  MOVFF  688,684
01E56:  MOVFF  687,683
01E5A:  MOVFF  686,682
01E5E:  MOVFF  685,681
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
01E62:  MOVLB  6
01E64:  INCFSZ x81,W
01E66:  BRA    1E6A
01E68:  BRA    1E6E
01E6A:  MOVLB  0
01E6C:  BRA    1E0E
01E6E:  INCFSZ x82,W
01E70:  BRA    1E74
01E72:  BRA    1E78
01E74:  MOVLB  0
01E76:  BRA    1E0E
01E78:  INCFSZ x83,W
01E7A:  BRA    1E7E
01E7C:  BRA    1E82
01E7E:  MOVLB  0
01E80:  BRA    1E0E
01E82:  MOVF   x84,W
01E84:  SUBLW  0F
01E86:  BTFSC  FD8.2
01E88:  BRA    1E8E
01E8A:  MOVLB  0
01E8C:  BRA    1E0E
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
01E8E:  MOVLW  00
01E90:  MOVWF  01
01E92:  MOVLB  0
01E94:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
02094:  MOVFF  6A1,6CC
02098:  MOVFF  6A0,6CB
0209C:  MOVFF  69F,6CA
020A0:  MOVFF  69E,6C9
020A4:  CALL   17C2
020A8:  MOVFF  03,6C8
020AC:  MOVFF  02,6C7
020B0:  MOVFF  01,6C6
020B4:  MOVFF  00,6C5
....................     
....................    for(j = 0; j < 0x20; j += 1) 
020B8:  MOVLB  6
020BA:  CLRF   xC2
020BC:  MOVF   xC2,W
020BE:  SUBLW  1F
020C0:  BNC   20D8
....................       clear_entry[j] = 0; 
020C2:  CLRF   03
020C4:  MOVF   xC2,W
020C6:  ADDLW  A2
020C8:  MOVWF  FE9
020CA:  MOVLW  06
020CC:  ADDWFC 03,W
020CE:  MOVWF  FEA
020D0:  CLRF   FEF
020D2:  MOVLW  01
020D4:  ADDWF  xC2,F
020D6:  BRA    20BC
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
020D8:  CLRF   xC4
020DA:  CLRF   xC3
020DC:  MOVF   xC4,W
020DE:  MOVLB  2
020E0:  SUBWF  x11,W
020E2:  BNC   2148
020E4:  BNZ   20F6
020E6:  MOVF   x10,W
020E8:  MOVLB  6
020EA:  SUBWF  xC3,W
020EC:  BTFSS  FD8.0
020EE:  BRA    20F4
020F0:  MOVLB  2
020F2:  BRA    2148
020F4:  MOVLB  2
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
020F6:  MOVLB  6
020F8:  MOVF   xC3,W
020FA:  ADDWF  xC5,W
020FC:  MOVWF  xC9
020FE:  MOVF   xC4,W
02100:  ADDWFC xC6,W
02102:  MOVWF  xCA
02104:  MOVLW  00
02106:  ADDWFC xC7,W
02108:  MOVWF  xCB
0210A:  MOVLW  00
0210C:  ADDWFC xC8,W
0210E:  MOVWF  xCC
02110:  MOVWF  xD0
02112:  MOVFF  6CB,6CF
02116:  MOVFF  6CA,6CE
0211A:  MOVFF  6C9,6CD
0211E:  CLRF   xD2
02120:  MOVLW  20
02122:  MOVWF  xD1
02124:  MOVLW  06
02126:  MOVWF  xD4
02128:  MOVLW  A2
0212A:  MOVWF  xD3
0212C:  MOVLB  0
0212E:  RCALL  1D02
02130:  MOVF   01,F
02132:  BZ    213A
....................          return EOF; 
02134:  MOVLW  FF
02136:  MOVWF  01
02138:  BRA    214E
0213A:  MOVLW  20
0213C:  MOVLB  6
0213E:  ADDWF  xC3,F
02140:  MOVLW  00
02142:  ADDWFC xC4,F
02144:  BRA    20DC
02146:  MOVLB  2
....................  
....................    return GOODEC; 
02148:  MOVLW  00
0214A:  MOVWF  01
0214C:  MOVLB  0
0214E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
*
01D88:  MOVLB  6
01D8A:  RLCF   x9E,W
01D8C:  MOVWF  xA7
01D8E:  RLCF   x9F,W
01D90:  MOVWF  xA8
01D92:  RLCF   xA0,W
01D94:  MOVWF  xA9
01D96:  RLCF   xA1,W
01D98:  MOVWF  xAA
01D9A:  RLCF   xA7,F
01D9C:  RLCF   xA8,F
01D9E:  RLCF   xA9,F
01DA0:  RLCF   xAA,F
01DA2:  MOVLW  FC
01DA4:  ANDWF  xA7,F
01DA6:  MOVLB  2
01DA8:  MOVF   x12,W
01DAA:  MOVLB  6
01DAC:  ADDWF  xA7,F
01DAE:  MOVLB  2
01DB0:  MOVF   x13,W
01DB2:  MOVLB  6
01DB4:  ADDWFC xA8,F
01DB6:  MOVLW  00
01DB8:  ADDWFC xA9,F
01DBA:  ADDWFC xAA,F
01DBC:  MOVFF  6AA,6D0
01DC0:  MOVFF  6A9,6CF
01DC4:  MOVFF  6A8,6CE
01DC8:  MOVFF  6A7,6CD
01DCC:  CLRF   xD2
01DCE:  MOVLW  04
01DD0:  MOVWF  xD1
01DD2:  MOVLW  06
01DD4:  MOVWF  xD4
01DD6:  MOVLW  A2
01DD8:  MOVWF  xD3
01DDA:  MOVLB  0
01DDC:  RCALL  1D02
01DDE:  MOVF   01,F
01DE0:  BZ    1DE8
....................       return EOF; 
01DE2:  MOVLW  FF
01DE4:  MOVWF  01
01DE6:  BRA    1DEC
....................  
....................    return GOODEC; 
01DE8:  MOVLW  00
01DEA:  MOVWF  01
01DEC:  RETURN 0
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
*
05016:  MOVLW  04
05018:  MOVLB  5
0501A:  ADDWF  xA6,W
0501C:  MOVWF  FE9
0501E:  MOVLW  00
05020:  ADDWFC xA7,W
05022:  MOVWF  FEA
05024:  MOVFF  FEF,5AB
05028:  MOVFF  FEC,5AC
0502C:  MOVFF  FEC,5AD
05030:  MOVFF  FEC,5AE
05034:  MOVLW  1F
05036:  ANDWF  xAB,F
05038:  CLRF   xAC
0503A:  CLRF   xAD
0503C:  CLRF   xAE
0503E:  MOVF   xAB,F
05040:  BNZ   50B0
05042:  MOVF   xAC,F
05044:  BNZ   50B0
05046:  MOVF   xAD,F
05048:  BNZ   50B0
0504A:  MOVF   xAE,F
0504C:  BNZ   50B0
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
0504E:  MOVLW  04
05050:  ADDWF  xA6,W
05052:  MOVWF  FE9
05054:  MOVLW  00
05056:  ADDWFC xA7,W
05058:  MOVWF  FEA
0505A:  MOVFF  FEF,6B4
0505E:  MOVFF  FEC,6B5
05062:  MOVFF  FEC,6B6
05066:  MOVFF  FEC,6B7
0506A:  MOVLW  1A
0506C:  ADDWF  xA6,W
0506E:  MOVWF  01
05070:  MOVLW  00
05072:  ADDWFC xA7,W
05074:  MOVWF  03
05076:  MOVFF  01,5AF
0507A:  MOVWF  xB0
0507C:  MOVLB  6
0507E:  CLRF   xB9
05080:  MOVLW  20
05082:  MOVWF  xB8
05084:  MOVFF  03,6BB
05088:  MOVFF  01,6BA
0508C:  MOVLB  0
0508E:  CALL   0C10
05092:  MOVF   01,F
05094:  BZ    50B2
....................       { 
....................          stream->Flags |= Read_Error; 
05096:  MOVLW  19
05098:  MOVLB  5
0509A:  ADDWF  xA6,W
0509C:  MOVWF  FE9
0509E:  MOVLW  00
050A0:  ADDWFC xA7,W
050A2:  MOVWF  FEA
050A4:  MOVF   FEF,W
050A6:  IORLW  20
050A8:  MOVWF  FEF
....................          return EOF; 
050AA:  MOVLW  FF
050AC:  MOVWF  01
050AE:  BRA    5114
050B0:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
050B2:  MOVLB  5
050B4:  MOVLW  1A
050B6:  ADDWF  xA6,W
050B8:  MOVWF  FE9
050BA:  MOVLW  00
050BC:  ADDWFC xA7,W
050BE:  MOVWF  FEA
050C0:  MOVFF  FEF,5AD
050C4:  MOVFF  5A9,FEA
050C8:  MOVFF  5A8,FE9
050CC:  MOVFF  5AD,FEF
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
050D0:  CLRF   xAA
050D2:  MOVF   xAA,W
050D4:  SUBLW  07
050D6:  BNC   5110
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
050D8:  MOVLW  1A
050DA:  ADDWF  xA6,W
050DC:  MOVWF  01
050DE:  MOVLW  00
050E0:  ADDWFC xA7,W
050E2:  MOVWF  03
050E4:  MOVFF  01,5AB
050E8:  MOVWF  xAC
050EA:  MOVLW  20
050EC:  MOVWF  00
050EE:  MOVFF  03,FEA
050F2:  MOVFF  01,FE9
050F6:  MOVFF  FEF,03
050FA:  MOVLW  1F
050FC:  ADDWF  FE9,F
050FE:  MOVLW  00
05100:  ADDWFC FEA,F
05102:  RRCF   03,W
05104:  RRCF   FED,F
05106:  DECFSZ 00,F
05108:  BRA    5104
0510A:  MOVLW  01
0510C:  ADDWF  xAA,F
0510E:  BRA    50D2
....................  
....................    return GOODEC; 
05110:  MOVLW  00
05112:  MOVWF  01
05114:  MOVLB  0
05116:  GOTO   5180 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
02150:  MOVLW  04
02152:  MOVLB  6
02154:  ADDWF  x8A,W
02156:  MOVWF  FE9
02158:  MOVLW  00
0215A:  ADDWFC x8B,W
0215C:  MOVWF  FEA
0215E:  MOVFF  FEF,68D
02162:  MOVFF  FEC,68E
02166:  MOVFF  FEC,68F
0216A:  MOVFF  FEC,690
0216E:  MOVLW  1F
02170:  ANDWF  x8D,F
02172:  CLRF   x8E
02174:  CLRF   x8F
02176:  CLRF   x90
02178:  MOVF   x8D,F
0217A:  BNZ   2252
0217C:  MOVF   x8E,F
0217E:  BNZ   2252
02180:  MOVF   x8F,F
02182:  BNZ   2252
02184:  MOVF   x90,F
02186:  BNZ   2252
02188:  MOVLW  04
0218A:  ADDWF  x8A,W
0218C:  MOVWF  FE9
0218E:  MOVLW  00
02190:  ADDWFC x8B,W
02192:  MOVWF  FEA
02194:  MOVFF  FEF,68D
02198:  MOVFF  FEC,68E
0219C:  MOVFF  FEC,68F
021A0:  MOVFF  FEC,690
021A4:  MOVLW  14
021A6:  ADDWF  x8A,W
021A8:  MOVWF  FE9
021AA:  MOVLW  00
021AC:  ADDWFC x8B,W
021AE:  MOVWF  FEA
021B0:  MOVFF  FEF,00
021B4:  MOVFF  FEC,01
021B8:  MOVFF  FEC,02
021BC:  MOVFF  FEC,03
021C0:  MOVF   00,W
021C2:  SUBWF  x8D,W
021C4:  BNZ   21D8
021C6:  MOVF   01,W
021C8:  SUBWF  x8E,W
021CA:  BNZ   21D8
021CC:  MOVF   02,W
021CE:  SUBWF  x8F,W
021D0:  BNZ   21D8
021D2:  MOVF   03,W
021D4:  SUBWF  x90,W
021D6:  BZ    2252
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
021D8:  MOVLW  04
021DA:  ADDWF  x8A,W
021DC:  MOVWF  FE9
021DE:  MOVLW  00
021E0:  ADDWFC x8B,W
021E2:  MOVWF  FEA
021E4:  MOVFF  FEF,68D
021E8:  MOVFF  FEC,68E
021EC:  MOVFF  FEC,68F
021F0:  MOVFF  FEC,690
021F4:  MOVLW  20
021F6:  SUBWF  x8D,F
021F8:  MOVLW  00
021FA:  SUBWFB x8E,F
021FC:  SUBWFB x8F,F
021FE:  SUBWFB x90,F
02200:  MOVLW  1A
02202:  ADDWF  x8A,W
02204:  MOVWF  01
02206:  MOVLW  00
02208:  ADDWFC x8B,W
0220A:  MOVWF  03
0220C:  MOVFF  01,691
02210:  MOVWF  x92
02212:  MOVFF  690,6D0
02216:  MOVFF  68F,6CF
0221A:  MOVFF  68E,6CE
0221E:  MOVFF  68D,6CD
02222:  CLRF   xD2
02224:  MOVLW  20
02226:  MOVWF  xD1
02228:  MOVFF  03,6D4
0222C:  MOVFF  01,6D3
02230:  MOVLB  0
02232:  RCALL  1D02
02234:  MOVF   01,F
02236:  BZ    2254
....................       { 
....................          stream->Flags |= Write_Error; 
02238:  MOVLW  19
0223A:  MOVLB  6
0223C:  ADDWF  x8A,W
0223E:  MOVWF  FE9
02240:  MOVLW  00
02242:  ADDWFC x8B,W
02244:  MOVWF  FEA
02246:  MOVF   FEF,W
02248:  IORLW  40
0224A:  MOVWF  FEF
....................          return EOF; 
0224C:  MOVLW  FF
0224E:  MOVWF  01
02250:  BRA    22A4
02252:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
02254:  MOVLW  04
02256:  MOVLB  6
02258:  ADDWF  x8A,W
0225A:  MOVWF  FE9
0225C:  MOVLW  00
0225E:  ADDWFC x8B,W
02260:  MOVWF  FEA
02262:  MOVFF  FEF,68D
02266:  MOVFF  FEC,68E
0226A:  MOVFF  FEC,68F
0226E:  MOVFF  FEC,690
02272:  MOVLW  1F
02274:  ANDWF  x8D,F
02276:  CLRF   x8E
02278:  CLRF   x8F
0227A:  CLRF   x90
0227C:  MOVLW  1A
0227E:  ADDWF  x8D,W
02280:  MOVWF  00
02282:  MOVLW  00
02284:  ADDWFC x8E,W
02286:  MOVWF  01
02288:  MOVLW  00
0228A:  ADDWFC x8F,W
0228C:  MOVLW  00
0228E:  ADDWFC x90,W
02290:  MOVF   x8A,W
02292:  ADDWF  00,W
02294:  MOVWF  FE9
02296:  MOVF   x8B,W
02298:  ADDWFC 01,W
0229A:  MOVWF  FEA
0229C:  MOVFF  68C,FEF
....................  
....................    return GOODEC; 
022A0:  MOVLW  00
022A2:  MOVWF  01
022A4:  MOVLB  0
022A6:  GOTO   2696 (RETURN)
.................... } 
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
*
04268:  MOVFF  629,62A
0426C:  MOVLB  6
0426E:  MOVF   x2A,W
04270:  SUBLW  0C
04272:  BNC   4302
....................    { 
....................       if(i < 5) 
04274:  MOVF   x2A,W
04276:  SUBLW  04
04278:  BNC   42A4
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
0427A:  BCF    FD8.0
0427C:  RLCF   x2A,W
0427E:  ADDLW  01
04280:  ADDWF  x26,W
04282:  MOVWF  FE9
04284:  MOVLW  00
04286:  ADDWFC x27,W
04288:  MOVWF  FEA
0428A:  MOVFF  628,FEF
....................          the_entry[(i << 1) + 2] = val; 
0428E:  BCF    FD8.0
04290:  RLCF   x2A,W
04292:  ADDLW  02
04294:  ADDWF  x26,W
04296:  MOVWF  FE9
04298:  MOVLW  00
0429A:  ADDWFC x27,W
0429C:  MOVWF  FEA
0429E:  MOVFF  628,FEF
....................       } 
042A2:  BRA    42FC
....................  
....................       else if(i < 11) 
042A4:  MOVF   x2A,W
042A6:  SUBLW  0A
042A8:  BNC   42D4
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
042AA:  BCF    FD8.0
042AC:  RLCF   x2A,W
042AE:  ADDLW  04
042B0:  ADDWF  x26,W
042B2:  MOVWF  FE9
042B4:  MOVLW  00
042B6:  ADDWFC x27,W
042B8:  MOVWF  FEA
042BA:  MOVFF  628,FEF
....................          the_entry[(i << 1) + 5] = val; 
042BE:  BCF    FD8.0
042C0:  RLCF   x2A,W
042C2:  ADDLW  05
042C4:  ADDWF  x26,W
042C6:  MOVWF  FE9
042C8:  MOVLW  00
042CA:  ADDWFC x27,W
042CC:  MOVWF  FEA
042CE:  MOVFF  628,FEF
....................       } 
042D2:  BRA    42FC
....................  
....................       else 
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
042D4:  BCF    FD8.0
042D6:  RLCF   x2A,W
042D8:  ADDLW  06
042DA:  ADDWF  x26,W
042DC:  MOVWF  FE9
042DE:  MOVLW  00
042E0:  ADDWFC x27,W
042E2:  MOVWF  FEA
042E4:  MOVFF  628,FEF
....................          the_entry[(i << 1) + 7] = val; 
042E8:  BCF    FD8.0
042EA:  RLCF   x2A,W
042EC:  ADDLW  07
042EE:  ADDWF  x26,W
042F0:  MOVWF  FE9
042F2:  MOVLW  00
042F4:  ADDWFC x27,W
042F6:  MOVWF  FEA
042F8:  MOVFF  628,FEF
....................       } 
042FC:  MOVLW  01
042FE:  ADDWF  x2A,F
04300:  BRA    426E
....................    } 
04302:  MOVLB  0
04304:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
*
00D16:  MOVLB  6
00D18:  CLRF   x0D
.................... { 
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    ec += mmcsd_init(); 
00D1A:  MOVLB  0
00D1C:  BRA    08F8
00D1E:  MOVF   01,W
00D20:  MOVLB  6
00D22:  ADDWF  x0D,F
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(11, 2, &Bytes_Per_Sector); 
00D24:  CLRF   xB7
00D26:  CLRF   xB6
00D28:  CLRF   xB5
00D2A:  MOVLW  0B
00D2C:  MOVWF  xB4
00D2E:  CLRF   xB9
00D30:  MOVLW  02
00D32:  MOVWF  xB8
00D34:  MOVLW  06
00D36:  MOVWF  xBB
00D38:  MOVLW  10
00D3A:  MOVWF  xBA
00D3C:  MOVLB  0
00D3E:  RCALL  0C10
00D40:  MOVF   01,W
00D42:  MOVLB  6
00D44:  ADDWF  x0D,F
....................    ec += mmcsd_read_data(13, 1, &Sectors_Per_Cluster); 
00D46:  CLRF   xB7
00D48:  CLRF   xB6
00D4A:  CLRF   xB5
00D4C:  MOVLW  0D
00D4E:  MOVWF  xB4
00D50:  CLRF   xB9
00D52:  MOVLW  01
00D54:  MOVWF  xB8
00D56:  MOVLW  06
00D58:  MOVWF  xBB
00D5A:  MOVLW  0F
00D5C:  MOVWF  xBA
00D5E:  MOVLB  0
00D60:  RCALL  0C10
00D62:  MOVF   01,W
00D64:  MOVLB  6
00D66:  ADDWF  x0D,F
....................    ec += mmcsd_read_data(14, 2, &Reserved_Sectors); 
00D68:  CLRF   xB7
00D6A:  CLRF   xB6
00D6C:  CLRF   xB5
00D6E:  MOVLW  0E
00D70:  MOVWF  xB4
00D72:  CLRF   xB9
00D74:  MOVLW  02
00D76:  MOVWF  xB8
00D78:  MOVLW  06
00D7A:  MOVWF  xBB
00D7C:  MOVLW  12
00D7E:  MOVWF  xBA
00D80:  MOVLB  0
00D82:  RCALL  0C10
00D84:  MOVF   01,W
00D86:  MOVLB  6
00D88:  ADDWF  x0D,F
....................    ec += mmcsd_read_data(16, 1, &FATs); 
00D8A:  CLRF   xB7
00D8C:  CLRF   xB6
00D8E:  CLRF   xB5
00D90:  MOVLW  10
00D92:  MOVWF  xB4
00D94:  CLRF   xB9
00D96:  MOVLW  01
00D98:  MOVWF  xB8
00D9A:  MOVLW  06
00D9C:  MOVWF  xBB
00D9E:  MOVLW  0E
00DA0:  MOVWF  xBA
00DA2:  MOVLB  0
00DA4:  RCALL  0C10
00DA6:  MOVF   01,W
00DA8:  MOVLB  6
00DAA:  ADDWF  x0D,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(17, 2, &Root_Entries); 
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(19, 2, &Small_Sectors); 
00DAC:  CLRF   xB7
00DAE:  CLRF   xB6
00DB0:  CLRF   xB5
00DB2:  MOVLW  13
00DB4:  MOVWF  xB4
00DB6:  CLRF   xB9
00DB8:  MOVLW  02
00DBA:  MOVWF  xB8
00DBC:  MOVLW  06
00DBE:  MOVWF  xBB
00DC0:  MOVLW  14
00DC2:  MOVWF  xBA
00DC4:  MOVLB  0
00DC6:  RCALL  0C10
00DC8:  MOVF   01,W
00DCA:  MOVLB  6
00DCC:  ADDWF  x0D,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(36, 4, &Sectors_Per_FAT); 
00DCE:  CLRF   xB7
00DD0:  CLRF   xB6
00DD2:  CLRF   xB5
00DD4:  MOVLW  24
00DD6:  MOVWF  xB4
00DD8:  CLRF   xB9
00DDA:  MOVLW  04
00DDC:  MOVWF  xB8
00DDE:  MOVLW  06
00DE0:  MOVWF  xBB
00DE2:  MOVLW  1E
00DE4:  MOVWF  xBA
00DE6:  MOVLB  0
00DE8:  RCALL  0C10
00DEA:  MOVF   01,W
00DEC:  MOVLB  6
00DEE:  ADDWF  x0D,F
.................... #else // FAT16 
....................    ec += mmcsd_read_data(22, 2, &Sectors_Per_FAT); 
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(28, 4, &Hidden_Sectors); 
00DF0:  CLRF   xB7
00DF2:  CLRF   xB6
00DF4:  CLRF   xB5
00DF6:  MOVLW  1C
00DF8:  MOVWF  xB4
00DFA:  CLRF   xB9
00DFC:  MOVLW  04
00DFE:  MOVWF  xB8
00E00:  MOVLW  06
00E02:  MOVWF  xBB
00E04:  MOVLW  16
00E06:  MOVWF  xBA
00E08:  MOVLB  0
00E0A:  RCALL  0C10
00E0C:  MOVF   01,W
00E0E:  MOVLB  6
00E10:  ADDWF  x0D,F
....................    ec += mmcsd_read_data(32, 4, &Large_Sectors); 
00E12:  CLRF   xB7
00E14:  CLRF   xB6
00E16:  CLRF   xB5
00E18:  MOVLW  20
00E1A:  MOVWF  xB4
00E1C:  CLRF   xB9
00E1E:  MOVLW  04
00E20:  MOVWF  xB8
00E22:  MOVLW  06
00E24:  MOVWF  xBB
00E26:  MOVLW  1A
00E28:  MOVWF  xBA
00E2A:  MOVLB  0
00E2C:  RCALL  0C10
00E2E:  MOVF   01,W
00E30:  MOVLB  6
00E32:  ADDWF  x0D,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
.................... #else 
....................    ec += mmcsd_read_data(0x3EC, 4, &Next_Free_Clust); 
00E34:  CLRF   xB7
00E36:  CLRF   xB6
00E38:  MOVLW  03
00E3A:  MOVWF  xB5
00E3C:  MOVLW  EC
00E3E:  MOVWF  xB4
00E40:  CLRF   xB9
00E42:  MOVLW  04
00E44:  MOVWF  xB8
00E46:  MOVLW  02
00E48:  MOVWF  xBB
00E4A:  MOVLW  1C
00E4C:  MOVWF  xBA
00E4E:  MOVLB  0
00E50:  RCALL  0C10
00E52:  MOVF   01,W
00E54:  MOVLB  6
00E56:  ADDWF  x0D,F
.................... #endif 
....................    if(ec != GOODEC) 
00E58:  MOVF   x0D,F
00E5A:  BZ    0E62
....................       return EOF; 
00E5C:  MOVLW  FF
00E5E:  MOVWF  01
00E60:  BRA    0F3C
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
00E62:  CLRF   x23
00E64:  MOVFF  60F,622
00E68:  MOVFF  611,625
00E6C:  MOVFF  610,624
00E70:  MOVLB  0
00E72:  RCALL  0C98
00E74:  MOVFF  02,211
00E78:  MOVFF  01,210
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
00E7C:  MOVFF  610,00
00E80:  MOVFF  611,01
00E84:  CLRF   02
00E86:  CLRF   03
00E88:  MOVFF  03,625
00E8C:  MOVFF  02,624
00E90:  MOVFF  611,623
00E94:  MOVFF  610,622
00E98:  MOVFF  621,6D4
00E9C:  MOVFF  620,6D3
00EA0:  MOVFF  61F,6D2
00EA4:  MOVFF  61E,6D1
00EA8:  MOVFF  03,6D8
00EAC:  MOVFF  02,6D7
00EB0:  MOVFF  611,6D6
00EB4:  MOVFF  610,6D5
00EB8:  RCALL  0CBA
00EBA:  MOVFF  03,21B
00EBE:  MOVFF  02,21A
00EC2:  MOVFF  01,219
00EC6:  MOVFF  00,218
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = Reserved_Sectors * Bytes_Per_Sector; 
00ECA:  MOVFF  613,623
00ECE:  MOVFF  612,622
00ED2:  MOVFF  611,625
00ED6:  MOVFF  610,624
00EDA:  RCALL  0C98
00EDC:  MOVFF  02,213
00EE0:  MOVFF  01,212
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
00EE4:  MOVLB  6
00EE6:  CLRF   xD4
00EE8:  CLRF   xD3
00EEA:  CLRF   xD2
00EEC:  MOVFF  60E,6D1
00EF0:  MOVFF  21B,6D8
00EF4:  MOVFF  21A,6D7
00EF8:  MOVFF  219,6D6
00EFC:  MOVFF  218,6D5
00F00:  MOVLB  0
00F02:  RCALL  0CBA
00F04:  MOVF   00,W
00F06:  MOVLB  2
00F08:  ADDWF  x12,W
00F0A:  MOVWF  x20
00F0C:  MOVF   01,W
00F0E:  ADDWFC x13,W
00F10:  MOVWF  x21
00F12:  MOVLW  00
00F14:  ADDWFC 02,W
00F16:  MOVWF  x22
00F18:  MOVLW  00
00F1A:  ADDWFC 03,W
00F1C:  MOVWF  x23
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Bytes_Per_Cluster + Root_Dir; 
00F1E:  MOVF   x10,W
00F20:  ADDWF  x20,W
00F22:  MOVWF  x14
00F24:  MOVF   x11,W
00F26:  ADDWFC x21,W
00F28:  MOVWF  x15
00F2A:  MOVLW  00
00F2C:  ADDWFC x22,W
00F2E:  MOVWF  x16
00F30:  MOVLW  00
00F32:  ADDWFC x23,W
00F34:  MOVWF  x17
.................... #else // FAT16 
....................    Data_Start = (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
....................    Data_Start /= Bytes_Per_Sector; 
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
....................    Data_Start *= Bytes_Per_Sector; 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
00F36:  MOVLW  00
00F38:  MOVWF  01
00F3A:  MOVLB  6
00F3C:  MOVLB  0
00F3E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
*
01C38:  MOVFF  693,03
01C3C:  MOVLB  6
01C3E:  MOVFF  692,FE9
01C42:  MOVFF  693,FEA
01C46:  MOVFF  FEF,694
01C4A:  MOVFF  FEC,695
01C4E:  MOVFF  FEC,696
01C52:  MOVFF  FEC,697
01C56:  RLCF   x94,F
01C58:  RLCF   x95,F
01C5A:  RLCF   x96,F
01C5C:  RLCF   x97,F
01C5E:  RLCF   x94,F
01C60:  RLCF   x95,F
01C62:  RLCF   x96,F
01C64:  RLCF   x97,F
01C66:  MOVLW  FC
01C68:  ANDWF  x94,F
01C6A:  MOVLB  2
01C6C:  MOVF   x12,W
01C6E:  MOVLB  6
01C70:  ADDWF  x94,F
01C72:  MOVLB  2
01C74:  MOVF   x13,W
01C76:  MOVLB  6
01C78:  ADDWFC x95,F
01C7A:  MOVLW  00
01C7C:  ADDWFC x96,F
01C7E:  ADDWFC x97,F
01C80:  MOVFF  697,6B7
01C84:  MOVFF  696,6B6
01C88:  MOVFF  695,6B5
01C8C:  MOVFF  694,6B4
01C90:  CLRF   xB9
01C92:  MOVLW  04
01C94:  MOVWF  xB8
01C96:  MOVFF  693,6BB
01C9A:  MOVFF  692,6BA
01C9E:  MOVLB  0
01CA0:  CALL   0C10
01CA4:  MOVF   01,F
01CA6:  BZ    1CAE
....................       return EOF; 
01CA8:  MOVLW  FF
01CAA:  MOVWF  01
01CAC:  BRA    1CB2
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
01CAE:  MOVLW  00
01CB0:  MOVWF  01
01CB2:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
*
016EC:  MOVLB  6
016EE:  CLRF   x98
016F0:  CLRF   x97
016F2:  CLRF   x96
016F4:  MOVLW  01
016F6:  MOVWF  x95
016F8:  CLRF   x9C
016FA:  CLRF   x9B
016FC:  CLRF   x9A
016FE:  CLRF   x99
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
01700:  MOVFF  693,FE9
01704:  MOVFF  694,FEA
01708:  MOVFF  FEF,00
0170C:  MOVFF  FEC,01
01710:  MOVFF  FEC,02
01714:  MOVFF  FEC,03
01718:  MOVF   00,W
0171A:  SUBWF  x99,W
0171C:  BNZ   1730
0171E:  MOVF   01,W
01720:  SUBWF  x9A,W
01722:  BNZ   1730
01724:  MOVF   02,W
01726:  SUBWF  x9B,W
01728:  BNZ   1730
0172A:  MOVF   03,W
0172C:  SUBWF  x9C,W
0172E:  BZ    17A0
....................    {    
....................       cur_cluster += 1; 
01730:  MOVLW  01
01732:  ADDWF  x95,F
01734:  MOVLW  00
01736:  ADDWFC x96,F
01738:  ADDWFC x97,F
0173A:  ADDWFC x98,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
0173C:  RLCF   x95,W
0173E:  MOVWF  x9E
01740:  RLCF   x96,W
01742:  MOVWF  x9F
01744:  RLCF   x97,W
01746:  MOVWF  xA0
01748:  RLCF   x98,W
0174A:  MOVWF  xA1
0174C:  RLCF   x9E,F
0174E:  RLCF   x9F,F
01750:  RLCF   xA0,F
01752:  RLCF   xA1,F
01754:  MOVLW  FC
01756:  ANDWF  x9E,F
01758:  MOVLB  2
0175A:  MOVF   x12,W
0175C:  MOVLB  6
0175E:  ADDWF  x9E,F
01760:  MOVLB  2
01762:  MOVF   x13,W
01764:  MOVLB  6
01766:  ADDWFC x9F,F
01768:  MOVLW  00
0176A:  ADDWFC xA0,F
0176C:  ADDWFC xA1,F
0176E:  MOVFF  6A1,6B7
01772:  MOVFF  6A0,6B6
01776:  MOVFF  69F,6B5
0177A:  MOVFF  69E,6B4
0177E:  CLRF   xB9
01780:  MOVLW  04
01782:  MOVWF  xB8
01784:  MOVLW  06
01786:  MOVWF  xBB
01788:  MOVLW  99
0178A:  MOVWF  xBA
0178C:  MOVLB  0
0178E:  CALL   0C10
01792:  MOVF   01,F
01794:  BZ    179C
....................          return EOF; 
01796:  MOVLW  FF
01798:  MOVWF  01
0179A:  BRA    17BC
.................... #else // FAT16 
0179C:  MOVLB  6
0179E:  BRA    1700
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................    } 
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
017A0:  MOVFF  693,FE9
017A4:  MOVFF  694,FEA
017A8:  MOVFF  695,FEF
017AC:  MOVFF  696,FEC
017B0:  MOVFF  697,FEC
017B4:  MOVFF  698,FEC
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
017B8:  MOVLW  00
017BA:  MOVWF  01
017BC:  MOVLB  0
017BE:  GOTO   1928 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if((*my_addr + 1) % Bytes_Per_Cluster == 0) 
*
022AA:  MOVFF  68D,03
022AE:  MOVLB  6
022B0:  MOVFF  68C,FE9
022B4:  MOVFF  68D,FEA
022B8:  MOVFF  FEF,692
022BC:  MOVFF  FEC,693
022C0:  MOVFF  FEC,694
022C4:  MOVFF  FEC,695
022C8:  MOVLW  01
022CA:  ADDWF  x92,F
022CC:  MOVLW  00
022CE:  ADDWFC x93,F
022D0:  ADDWFC x94,F
022D2:  ADDWFC x95,F
022D4:  MOVFF  FEA,697
022D8:  MOVFF  FE9,696
022DC:  BSF    FD8.1
022DE:  MOVLW  06
022E0:  MOVWF  FEA
022E2:  MOVLW  98
022E4:  MOVWF  FE9
022E6:  MOVFF  695,6A2
022EA:  MOVFF  694,6A1
022EE:  MOVFF  693,6A0
022F2:  MOVFF  692,69F
022F6:  CLRF   xA6
022F8:  CLRF   xA5
022FA:  MOVFF  211,6A4
022FE:  MOVFF  210,6A3
02302:  MOVLB  0
02304:  CALL   15E2
02308:  MOVFF  698,00
0230C:  MOVFF  699,01
02310:  MOVFF  69A,02
02314:  MOVFF  69B,03
02318:  MOVFF  697,FEA
0231C:  MOVFF  696,FE9
02320:  MOVFF  69B,695
02324:  MOVFF  69A,694
02328:  MOVFF  699,693
0232C:  MOVFF  698,692
02330:  MOVLB  6
02332:  MOVF   x92,F
02334:  BNZ   23FC
02336:  MOVF   x93,F
02338:  BNZ   23FC
0233A:  MOVF   x94,F
0233C:  BNZ   23FC
0233E:  MOVF   x95,F
02340:  BNZ   23FC
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if(((*my_addr + 1) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       // convert the current address into the address of where information about 
....................       //  the address is stored in the FAT, and put this value into the current address 
....................       temp = addr_to_cluster(*my_addr); 
02342:  MOVFF  68D,03
02346:  MOVFF  68C,FE9
0234A:  MOVFF  68D,FEA
0234E:  MOVFF  FEF,697
02352:  MOVFF  FEC,698
02356:  MOVFF  FEC,699
0235A:  MOVFF  FEC,69A
0235E:  MOVLB  0
02360:  CALL   1676
02364:  MOVFF  03,691
02368:  MOVFF  02,690
0236C:  MOVFF  01,68F
02370:  MOVFF  00,68E
....................       if(get_next_cluster(&temp) == EOF) 
02374:  MOVLW  06
02376:  MOVLB  6
02378:  MOVWF  x93
0237A:  MOVLW  8E
0237C:  MOVWF  x92
0237E:  MOVLB  0
02380:  RCALL  1C38
02382:  MOVF   01,W
02384:  SUBLW  FF
02386:  BNZ   238E
....................          return EOF; 
02388:  MOVLW  FF
0238A:  MOVWF  01
0238C:  BRA    2436
.................... #ifdef FAT32 
....................       if((temp == 0xFFFFFFFF) 
....................          || (temp == 0x0FFFFFFF)) // WinXP will format the root directory's FAT entry to 0x0FFFFFFF. 
0238E:  MOVLB  6
02390:  INCFSZ x8E,W
02392:  BRA    23A2
02394:  INCFSZ x8F,W
02396:  BRA    23A2
02398:  INCFSZ x90,W
0239A:  BRA    23A2
0239C:  INCFSZ x91,W
0239E:  BRA    23A2
023A0:  BRA    23B4
023A2:  INCFSZ x8E,W
023A4:  BRA    23BE
023A6:  INCFSZ x8F,W
023A8:  BRA    23BE
023AA:  INCFSZ x90,W
023AC:  BRA    23BE
023AE:  MOVF   x91,W
023B0:  SUBLW  0F
023B2:  BNZ   23BE
....................          return EOF; 
023B4:  MOVLW  FF
023B6:  MOVWF  01
023B8:  MOVLB  0
023BA:  BRA    2436
023BC:  MOVLB  6
.................... #else // FAT16 
....................       if(temp == 0xFFFF) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................       *my_addr = cluster_to_addr(temp); 
023BE:  MOVFF  68D,03
023C2:  MOVFF  68C,692
023C6:  MOVFF  68D,693
023CA:  MOVFF  691,6CC
023CE:  MOVFF  690,6CB
023D2:  MOVFF  68F,6CA
023D6:  MOVFF  68E,6C9
023DA:  MOVLB  0
023DC:  CALL   17C2
023E0:  MOVFF  693,FEA
023E4:  MOVFF  692,FE9
023E8:  MOVFF  00,FEF
023EC:  MOVFF  01,FEC
023F0:  MOVFF  02,FEC
023F4:  MOVFF  03,FEC
....................    } 
023F8:  BRA    2432
023FA:  MOVLB  6
....................    else 
....................       *my_addr += 1; 
023FC:  MOVFF  68C,FE9
02400:  MOVFF  68D,FEA
02404:  MOVLW  01
02406:  ADDWF  FEF,W
02408:  MOVWF  00
0240A:  MOVLW  00
0240C:  ADDWFC FEC,W
0240E:  MOVWF  01
02410:  MOVLW  00
02412:  ADDWFC FEC,W
02414:  MOVWF  02
02416:  MOVLW  00
02418:  ADDWFC FEC,W
0241A:  MOVWF  03
0241C:  MOVF   FED,F
0241E:  MOVF   FED,F
02420:  MOVF   FED,F
02422:  MOVFF  00,FEF
02426:  MOVFF  01,FEC
0242A:  MOVFF  02,FEC
0242E:  MOVWF  FEC
02430:  MOVLB  0
....................  
....................    return GOODEC; 
02432:  MOVLW  00
02434:  MOVWF  01
02436:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're trying to go backwards one entry from the beginning of the root, 
....................    //  we won't be able to... 
....................    if(*my_addr <= Root_Dir) 
*
01820:  MOVFF  68E,03
01824:  MOVLB  6
01826:  MOVFF  68D,FE9
0182A:  MOVFF  68E,FEA
0182E:  MOVFF  FEF,693
01832:  MOVFF  FEC,694
01836:  MOVFF  FEC,695
0183A:  MOVFF  FEC,696
0183E:  MOVF   x96,W
01840:  MOVLB  2
01842:  SUBWF  x23,W
01844:  BNC   1870
01846:  BNZ   186A
01848:  MOVLB  6
0184A:  MOVF   x95,W
0184C:  MOVLB  2
0184E:  SUBWF  x22,W
01850:  BNC   1870
01852:  BNZ   186A
01854:  MOVLB  6
01856:  MOVF   x94,W
01858:  MOVLB  2
0185A:  SUBWF  x21,W
0185C:  BNC   1870
0185E:  BNZ   186A
01860:  MOVLB  6
01862:  MOVF   x93,W
01864:  MOVLB  2
01866:  SUBWF  x20,W
01868:  BNC   1870
....................       return GOODEC; 
0186A:  MOVLW  00
0186C:  MOVWF  01
0186E:  BRA    19DE
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if(*my_addr % Bytes_Per_Cluster == 0) 
01870:  MOVFF  68E,03
01874:  MOVLB  6
01876:  MOVFF  68D,FE9
0187A:  MOVFF  68E,FEA
0187E:  MOVFF  FEF,69F
01882:  MOVFF  FEC,6A0
01886:  MOVFF  FEC,6A1
0188A:  MOVFF  FEC,6A2
0188E:  MOVFF  FEA,698
01892:  MOVFF  FE9,697
01896:  BSF    FD8.1
01898:  MOVLW  06
0189A:  MOVWF  FEA
0189C:  MOVLW  99
0189E:  MOVWF  FE9
018A0:  CLRF   xA6
018A2:  CLRF   xA5
018A4:  MOVFF  211,6A4
018A8:  MOVFF  210,6A3
018AC:  MOVLB  0
018AE:  RCALL  15E2
018B0:  MOVFF  699,00
018B4:  MOVFF  69A,01
018B8:  MOVFF  69B,02
018BC:  MOVFF  69C,03
018C0:  MOVFF  698,FEA
018C4:  MOVFF  697,FE9
018C8:  MOVFF  69C,696
018CC:  MOVFF  69B,695
018D0:  MOVFF  69A,694
018D4:  MOVFF  699,693
018D8:  MOVLB  6
018DA:  MOVF   x93,F
018DC:  BNZ   19A6
018DE:  MOVF   x94,F
018E0:  BNZ   19A6
018E2:  MOVF   x95,F
018E4:  BNZ   19A6
018E6:  MOVF   x96,F
018E8:  BNZ   19A6
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if((*my_addr % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       temp = addr_to_cluster(*my_addr); 
018EA:  MOVFF  68E,03
018EE:  MOVFF  68D,FE9
018F2:  MOVFF  68E,FEA
018F6:  MOVFF  FEF,697
018FA:  MOVFF  FEC,698
018FE:  MOVFF  FEC,699
01902:  MOVFF  FEC,69A
01906:  MOVLB  0
01908:  RCALL  1676
0190A:  MOVFF  03,692
0190E:  MOVFF  02,691
01912:  MOVFF  01,690
01916:  MOVFF  00,68F
....................       if(get_prev_cluster(&temp) == EOF) 
0191A:  MOVLW  06
0191C:  MOVLB  6
0191E:  MOVWF  x94
01920:  MOVLW  8F
01922:  MOVWF  x93
01924:  MOVLB  0
01926:  BRA    16EC
01928:  MOVF   01,W
0192A:  SUBLW  FF
0192C:  BNZ   1938
....................          return EOF; 
0192E:  MOVLW  FF
01930:  MOVWF  01
01932:  MOVLB  2
01934:  BRA    19DE
01936:  MOVLB  0
....................  
....................       *my_addr = cluster_to_addr(temp) + (Bytes_Per_Cluster - 1); 
01938:  MOVFF  68E,03
0193C:  MOVFF  68D,693
01940:  MOVFF  68E,694
01944:  MOVFF  692,6CC
01948:  MOVFF  691,6CB
0194C:  MOVFF  690,6CA
01950:  MOVFF  68F,6C9
01954:  MOVLB  0
01956:  RCALL  17C2
01958:  MOVFF  03,698
0195C:  MOVFF  02,697
01960:  MOVFF  01,696
01964:  MOVFF  00,695
01968:  MOVLW  01
0196A:  MOVLB  2
0196C:  SUBWF  x10,W
0196E:  MOVWF  00
01970:  MOVLW  00
01972:  SUBWFB x11,W
01974:  MOVWF  03
01976:  MOVF   00,W
01978:  MOVLB  6
0197A:  ADDWF  x95,W
0197C:  MOVWF  00
0197E:  MOVF   03,W
01980:  ADDWFC 01,W
01982:  MOVWF  01
01984:  MOVLW  00
01986:  ADDWFC 02,W
01988:  MOVWF  02
0198A:  MOVLW  00
0198C:  ADDWFC x98,W
0198E:  MOVFF  694,FEA
01992:  MOVFF  693,FE9
01996:  MOVFF  00,FEF
0199A:  MOVFF  01,FEC
0199E:  MOVFF  02,FEC
019A2:  MOVWF  FEC
....................    } 
019A4:  BRA    19D8
....................    else 
....................       *my_addr -= 1; 
019A6:  MOVFF  68D,FE9
019AA:  MOVFF  68E,FEA
019AE:  MOVLW  01
019B0:  SUBWF  FEF,W
019B2:  MOVWF  00
019B4:  MOVLW  00
019B6:  SUBWFB FEC,W
019B8:  MOVWF  01
019BA:  MOVLW  00
019BC:  SUBWFB FEC,W
019BE:  MOVWF  02
019C0:  MOVLW  00
019C2:  SUBWFB FEC,W
019C4:  MOVF   FED,F
019C6:  MOVF   FED,F
019C8:  MOVF   FED,F
019CA:  MOVFF  00,FEF
019CE:  MOVFF  01,FEC
019D2:  MOVFF  02,FEC
019D6:  MOVWF  FEC
....................  
....................    return GOODEC; 
019D8:  MOVLW  00
019DA:  MOVWF  01
019DC:  MOVLB  2
019DE:  MOVLB  0
019E0:  GOTO   1A16 (RETURN)
.................... } 
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
*
017C2:  MOVLW  02
017C4:  MOVLB  6
017C6:  SUBWF  xC9,W
017C8:  MOVWF  00
017CA:  MOVLW  00
017CC:  SUBWFB xCA,W
017CE:  MOVWF  01
017D0:  MOVLW  00
017D2:  SUBWFB xCB,W
017D4:  MOVWF  02
017D6:  MOVLW  00
017D8:  SUBWFB xCC,W
017DA:  MOVWF  03
017DC:  MOVWF  xD0
017DE:  MOVFF  02,6CF
017E2:  MOVFF  01,6CE
017E6:  MOVFF  00,6CD
017EA:  CLRF   xD4
017EC:  CLRF   xD3
017EE:  MOVFF  211,6D2
017F2:  MOVFF  210,6D1
017F6:  MOVWF  xD8
017F8:  MOVFF  02,6D7
017FC:  MOVFF  01,6D6
01800:  MOVFF  00,6D5
01804:  MOVLB  0
01806:  CALL   0CBA
0180A:  MOVLB  2
0180C:  MOVF   x20,W
0180E:  ADDWF  00,F
01810:  MOVF   x21,W
01812:  ADDWFC 01,F
01814:  MOVF   x22,W
01816:  ADDWFC 02,F
01818:  MOVF   x23,W
0181A:  ADDWFC 03,F
0181C:  MOVLB  0
0181E:  RETURN 0
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
....................       return 0; 
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
*
01676:  MOVLB  2
01678:  MOVF   x20,W
0167A:  MOVLB  6
0167C:  SUBWF  x97,W
0167E:  MOVWF  x9B
01680:  MOVLB  2
01682:  MOVF   x21,W
01684:  MOVLB  6
01686:  SUBWFB x98,W
01688:  MOVWF  x9C
0168A:  MOVLB  2
0168C:  MOVF   x22,W
0168E:  MOVLB  6
01690:  SUBWFB x99,W
01692:  MOVWF  x9D
01694:  MOVLB  2
01696:  MOVF   x23,W
01698:  MOVLB  6
0169A:  SUBWFB x9A,W
0169C:  MOVWF  x9E
0169E:  BCF    FD8.1
016A0:  MOVWF  xA2
016A2:  MOVFF  69D,6A1
016A6:  MOVFF  69C,6A0
016AA:  MOVFF  69B,69F
016AE:  CLRF   xA6
016B0:  CLRF   xA5
016B2:  MOVFF  211,6A4
016B6:  MOVFF  210,6A3
016BA:  MOVLB  0
016BC:  RCALL  15E2
016BE:  MOVFF  03,69E
016C2:  MOVFF  02,69D
016C6:  MOVFF  01,69C
016CA:  MOVFF  00,69B
016CE:  MOVLW  02
016D0:  MOVLB  6
016D2:  ADDWF  00,W
016D4:  MOVWF  00
016D6:  MOVLW  00
016D8:  ADDWFC 01,W
016DA:  MOVWF  01
016DC:  MOVLW  00
016DE:  ADDWFC 02,W
016E0:  MOVWF  02
016E2:  MOVLW  00
016E4:  ADDWFC 03,W
016E6:  MOVWF  03
016E8:  MOVLB  0
016EA:  RETURN 0
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
....................       return 0; 
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
*
05D08:  MOVLW  F8
05D0A:  MOVLB  5
05D0C:  MOVWF  x6B
05D0E:  MOVLW  01
05D10:  MOVWF  x6C
05D12:  MOVLW  02
05D14:  MOVWF  x6D
05D16:  MOVLW  20
05D18:  MOVWF  x6F
05D1A:  MOVLW  02
05D1C:  MOVWF  x71
05D1E:  CLRF   x70
05D20:  CLRF   x7B
05D22:  CLRF   x7A
05D24:  CLRF   x79
05D26:  CLRF   x78
*
05D72:  MOVLW  06
05D74:  MOVWF  x9D
05D76:  MOVLW  01
05D78:  MOVWF  x9E
05D7A:  MOVLW  02
05D7C:  MOVWF  x9F
05D7E:  MOVLW  29
05D80:  MOVWF  xA0
05D82:  MOVLW  58
05D84:  MOVWF  xA1
05D86:  CLRF   xFD
05D88:  CLRF   xFC
05D8A:  CLRF   xFF
05D8C:  MOVLW  20
05D8E:  MOVWF  xFE
.................... { 
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
*
05D28:  MOVLW  4D
05D2A:  MOVWF  x88
05D2C:  MOVLW  53
05D2E:  MOVWF  x89
05D30:  MOVLW  44
05D32:  MOVWF  x8A
05D34:  MOVLW  4F
05D36:  MOVWF  x8B
05D38:  MOVLW  53
05D3A:  MOVWF  x8C
05D3C:  MOVLW  35
05D3E:  MOVWF  x8D
05D40:  MOVLW  2E
05D42:  MOVWF  x8E
05D44:  MOVLW  30
05D46:  MOVWF  x8F
05D48:  CLRF   x90
....................       BS_VolLab[] = "NO NAME    "; 
05D4A:  MOVLW  4E
05D4C:  MOVWF  x91
05D4E:  MOVLW  4F
05D50:  MOVWF  x92
05D52:  MOVLW  20
05D54:  MOVWF  x93
05D56:  MOVLW  4E
05D58:  MOVWF  x94
05D5A:  MOVLW  41
05D5C:  MOVWF  x95
05D5E:  MOVLW  4D
05D60:  MOVWF  x96
05D62:  MOVLW  45
05D64:  MOVWF  x97
05D66:  MOVLW  20
05D68:  MOVWF  x98
05D6A:  MOVWF  x99
05D6C:  MOVWF  x9A
05D6E:  MOVWF  x9B
05D70:  CLRF   x9C
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
*
05D90:  MOVLW  46
05D92:  MOVLB  6
05D94:  MOVWF  x04
05D96:  MOVLW  41
05D98:  MOVWF  x05
05D9A:  MOVLW  54
05D9C:  MOVWF  x06
05D9E:  MOVLW  33
05DA0:  MOVWF  x07
05DA2:  MOVLW  32
05DA4:  MOVWF  x08
05DA6:  MOVLW  20
05DA8:  MOVWF  x09
05DAA:  MOVWF  x0A
05DAC:  MOVWF  x0B
05DAE:  CLRF   x0C
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
05DB0:  CLRF   x0D
05DB2:  MOVLB  5
05DB4:  RLCF   x67,W
05DB6:  MOVLB  6
05DB8:  MOVWF  x0E
05DBA:  MOVLB  5
05DBC:  RLCF   x68,W
05DBE:  MOVLB  6
05DC0:  MOVWF  x0F
05DC2:  MOVLB  5
05DC4:  RLCF   x69,W
05DC6:  MOVLB  6
05DC8:  MOVWF  x10
05DCA:  RLCF   x0E,F
05DCC:  RLCF   x0F,F
05DCE:  RLCF   x10,F
05DD0:  MOVLW  FC
05DD2:  ANDWF  x0E,F
05DD4:  BCF    FD8.1
05DD6:  MOVFF  610,6A2
05DDA:  MOVFF  60F,6A1
05DDE:  MOVFF  60E,6A0
05DE2:  MOVFF  60D,69F
05DE6:  CLRF   xA6
05DE8:  CLRF   xA5
05DEA:  MOVFF  571,6A4
05DEE:  MOVFF  570,6A3
05DF2:  MOVLB  0
05DF4:  CALL   15E2
05DF8:  MOVFF  03,577
05DFC:  MOVFF  02,576
05E00:  MOVFF  01,575
05E04:  MOVFF  00,574
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
05E08:  MOVLB  5
05E0A:  MOVF   x6A,F
05E0C:  BNZ   5E20
05E0E:  MOVF   x69,F
05E10:  BNZ   5E20
05E12:  MOVF   x68,W
05E14:  SUBLW  83
05E16:  BNC   5E20
....................       return EOF; 
05E18:  MOVLW  FF
05E1A:  MOVWF  01
05E1C:  BRA    62B4
05E1E:  BRA    5E66
....................    else if(DskSize < 0x41000) // 260 MB 
05E20:  MOVF   x6A,F
05E22:  BNZ   5E38
05E24:  MOVF   x69,W
05E26:  SUBLW  04
05E28:  BNC   5E38
05E2A:  BNZ   5E32
05E2C:  MOVF   x68,W
05E2E:  SUBLW  0F
05E30:  BNC   5E38
....................       BPB_SecPerClus = 1; 
05E32:  MOVLW  01
05E34:  MOVWF  x6E
05E36:  BRA    5E66
....................    else if(DskSize < 0X800000) // 8 GB 
05E38:  MOVF   x6A,F
05E3A:  BNZ   5E48
05E3C:  MOVF   x69,W
05E3E:  SUBLW  7F
05E40:  BNC   5E48
....................       BPB_SecPerClus = 8; 
05E42:  MOVLW  08
05E44:  MOVWF  x6E
05E46:  BRA    5E66
....................    else if(DskSize < 0x1000000) // 16 GB 
05E48:  MOVF   x6A,W
05E4A:  SUBLW  00
05E4C:  BNC   5E54
....................       BPB_SecPerClus = 16; 
05E4E:  MOVLW  10
05E50:  MOVWF  x6E
05E52:  BRA    5E66
....................    else if(DskSize < 0x2000000) // 32 GB 
05E54:  MOVF   x6A,W
05E56:  SUBLW  01
05E58:  BNC   5E60
....................       BPB_SecPerClus = 32; 
05E5A:  MOVLW  20
05E5C:  MOVWF  x6E
05E5E:  BRA    5E66
....................    else // > 32 GB; this is too big 
....................       return EOF; 
05E60:  MOVLW  FF
05E62:  MOVWF  01
05E64:  BRA    62B4
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0x4000) // 16 MB 
....................       BPB_SecPerClus = 2; 
....................    else if(DskSize < 0X20000) // 128 MB 
....................       BPB_SecPerClus = 4; 
....................    else if(DskSize < 0x40000) // 256 MB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x80000) // 512 MB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x100000) // 1 GB 
....................       BPB_SecPerClus = 32; 
....................    else if(DskSize < 0x200000) // 2 GB 
....................       BPB_SecPerClus = 64; 
....................    else // > 2 GB; this is too big 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
05E66:  RLCF   xFC,W
05E68:  MOVLB  6
05E6A:  MOVWF  x0D
05E6C:  MOVLB  5
05E6E:  RLCF   xFD,W
05E70:  MOVLB  6
05E72:  MOVWF  x0E
05E74:  RLCF   x0D,F
05E76:  RLCF   x0E,F
05E78:  RLCF   x0D,F
05E7A:  RLCF   x0E,F
05E7C:  RLCF   x0D,F
05E7E:  RLCF   x0E,F
05E80:  RLCF   x0D,F
05E82:  RLCF   x0E,F
05E84:  MOVLW  E0
05E86:  ANDWF  x0D,F
05E88:  MOVLW  01
05E8A:  MOVLB  5
05E8C:  SUBWF  x70,W
05E8E:  MOVWF  00
05E90:  MOVLW  00
05E92:  SUBWFB x71,W
05E94:  MOVWF  03
05E96:  MOVF   00,W
05E98:  MOVLB  6
05E9A:  ADDWF  x0D,F
05E9C:  MOVF   03,W
05E9E:  ADDWFC x0E,F
05EA0:  MOVFF  60E,610
05EA4:  MOVFF  60D,60F
05EA8:  MOVFF  571,612
05EAC:  MOVFF  570,611
05EB0:  MOVLB  0
05EB2:  BRA    5C9A
05EB4:  MOVLB  5
05EB6:  CLRF   x7F
05EB8:  CLRF   x7E
05EBA:  MOVFF  02,57D
05EBE:  MOVFF  01,57C
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
05EC2:  MOVF   xFE,W
05EC4:  ADDWF  x7C,W
05EC6:  MOVWF  00
05EC8:  MOVF   xFF,W
05ECA:  ADDWFC x7D,W
05ECC:  MOVWF  01
05ECE:  MOVLW  00
05ED0:  ADDWFC x7E,W
05ED2:  MOVWF  02
05ED4:  MOVLW  00
05ED6:  ADDWFC x7F,W
05ED8:  MOVWF  03
05EDA:  MOVF   00,W
05EDC:  SUBWF  x67,W
05EDE:  MOVWF  x80
05EE0:  MOVF   01,W
05EE2:  SUBWFB x68,W
05EE4:  MOVWF  x81
05EE6:  MOVF   02,W
05EE8:  SUBWFB x69,W
05EEA:  MOVWF  x82
05EEC:  MOVF   03,W
05EEE:  SUBWFB x6A,W
05EF0:  MOVWF  x83
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
05EF2:  MOVFF  56E,60E
05EF6:  MOVLB  6
05EF8:  CLRF   x0D
05EFA:  MOVLB  5
05EFC:  MOVF   x6C,W
05EFE:  MOVLB  6
05F00:  ADDWF  x0D,W
05F02:  MOVLB  5
05F04:  MOVWF  x84
05F06:  MOVLW  00
05F08:  MOVLB  6
05F0A:  ADDWFC x0E,W
05F0C:  MOVLB  5
05F0E:  MOVWF  x85
05F10:  CLRF   x86
05F12:  BTFSC  FD8.0
05F14:  INCF   x84,F
05F16:  CLRF   x87
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
05F18:  BCF    FD8.0
05F1A:  RRCF   x87,F
05F1C:  RRCF   x86,F
05F1E:  RRCF   x85,F
05F20:  RRCF   x84,F
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
05F22:  MOVLW  01
05F24:  SUBWF  x84,W
05F26:  MOVWF  00
05F28:  MOVLW  00
05F2A:  SUBWFB x85,W
05F2C:  MOVWF  01
05F2E:  MOVLW  00
05F30:  SUBWFB x86,W
05F32:  MOVWF  02
05F34:  MOVLW  00
05F36:  SUBWFB x87,W
05F38:  MOVWF  03
05F3A:  MOVF   00,W
05F3C:  ADDWF  x80,W
05F3E:  MOVLB  6
05F40:  MOVWF  x0D
05F42:  MOVF   01,W
05F44:  MOVLB  5
05F46:  ADDWFC x81,W
05F48:  MOVLB  6
05F4A:  MOVWF  x0E
05F4C:  MOVF   02,W
05F4E:  MOVLB  5
05F50:  ADDWFC x82,W
05F52:  MOVLB  6
05F54:  MOVWF  x0F
05F56:  MOVF   03,W
05F58:  MOVLB  5
05F5A:  ADDWFC x83,W
05F5C:  MOVLB  6
05F5E:  MOVWF  x10
05F60:  BCF    FD8.1
05F62:  MOVWF  xA2
05F64:  MOVFF  60F,6A1
05F68:  MOVFF  60E,6A0
05F6C:  MOVFF  60D,69F
05F70:  MOVFF  587,6A6
05F74:  MOVFF  586,6A5
05F78:  MOVFF  585,6A4
05F7C:  MOVFF  584,6A3
05F80:  MOVLB  0
05F82:  CALL   15E2
05F86:  MOVFF  03,603
05F8A:  MOVFF  02,602
05F8E:  MOVFF  01,601
05F92:  MOVFF  00,600
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
05F96:  MOVLB  5
05F98:  CLRF   x73
05F9A:  CLRF   x72
05F9C:  MOVF   x73,F
05F9E:  BNZ   5FBE
05FA0:  MOVF   x72,W
05FA2:  SUBLW  59
05FA4:  BNC   5FBE
....................       data[i] = 0; 
05FA6:  MOVLW  A2
05FA8:  ADDWF  x72,W
05FAA:  MOVWF  FE9
05FAC:  MOVLW  05
05FAE:  ADDWFC x73,W
05FB0:  MOVWF  FEA
05FB2:  CLRF   FEF
05FB4:  MOVLW  01
05FB6:  ADDWF  x72,F
05FB8:  MOVLW  00
05FBA:  ADDWFC x73,F
05FBC:  BRA    5F9C
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
05FBE:  MOVLW  EB
05FC0:  MOVWF  xA2
....................    data[1] = BS_jmpBoot; 
05FC2:  MOVFF  5A1,5A3
....................    data[2] = 0x90;    
05FC6:  MOVLW  90
05FC8:  MOVWF  xA4
....................    sprintf(data + 3, "%s", BS_OEMName); 
05FCA:  MOVLW  05
05FCC:  MOVLB  2
05FCE:  MOVWF  x25
05FD0:  MOVLW  A5
05FD2:  MOVWF  x24
05FD4:  MOVFF  225,FEA
05FD8:  MOVFF  224,FE9
05FDC:  CLRF   FEF
05FDE:  MOVLW  05
05FE0:  MOVWF  FEA
05FE2:  MOVLW  88
05FE4:  MOVWF  FE9
05FE6:  MOVLB  0
05FE8:  RCALL  5CE2
....................    data[11] = make8(BPB_BytsPerSec, 0); 
05FEA:  MOVLB  5
05FEC:  MOVFF  570,5AD
....................    data[12] = make8(BPB_BytsPerSec, 1); 
05FF0:  MOVFF  571,5AE
....................    data[13] = BPB_SecPerClus; 
05FF4:  MOVFF  56E,5AF
....................    data[14] = BPB_RsvdSecCnt; 
05FF8:  MOVFF  5FE,5B0
....................    data[16] = BPB_NumFATs; 
05FFC:  MOVFF  56C,5B2
....................    data[21] = BPB_Media; 
06000:  MOVFF  56B,5B7
....................    data[24] = BPB_SecPerTrk;  
06004:  MOVFF  56F,5BA
....................    data[26] = BPB_NumHeads; 
06008:  MOVFF  56D,5BC
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
0600C:  MOVFF  574,5C2
....................    data[33] = make8(BPB_TotSec, 1); 
06010:  MOVFF  575,5C3
....................    data[34] = make8(BPB_TotSec, 2); 
06014:  MOVFF  576,5C4
....................    data[35] = make8(BPB_TotSec, 3); 
06018:  MOVFF  577,5C5
....................    data[36] = make8(BPB_FATSz, 0); 
0601C:  MOVFF  600,5C6
06020:  MOVLB  5
....................    data[37] = make8(BPB_FATSz, 1); 
06022:  MOVFF  601,5C7
06026:  MOVLB  5
....................    data[38] = make8(BPB_FATSz, 2); 
06028:  MOVFF  602,5C8
0602C:  MOVLB  5
....................    data[39] = make8(BPB_FATSz, 3); 
0602E:  MOVFF  603,5C9
06032:  MOVLB  5
....................    data[44] = BPB_RootClus; 
06034:  MOVFF  59F,5CE
....................    data[48] = BPB_FSInfo; 
06038:  MOVFF  59E,5D2
....................    data[50] = BPB_BkBootSec; 
0603C:  MOVFF  59D,5D4
....................    data[66] = BS_BootSig; 
06040:  MOVFF  5A0,5E4
....................    data[67] = make8(BS_VolID, 0); 
06044:  MOVFF  578,5E5
....................    data[68] = make8(BS_VolID, 1); 
06048:  MOVFF  579,5E6
....................    data[69] = make8(BS_VolID, 2); 
0604C:  MOVFF  57A,5E7
....................    data[70] = make8(BS_VolID, 3); 
06050:  MOVFF  57B,5E8
....................    sprintf(data + 71, "%s", BS_VolLab); 
06054:  MOVLW  05
06056:  MOVLB  2
06058:  MOVWF  x25
0605A:  MOVLW  E9
0605C:  MOVWF  x24
0605E:  MOVFF  225,FEA
06062:  MOVFF  224,FE9
06066:  CLRF   FEF
06068:  MOVLW  05
0606A:  MOVWF  FEA
0606C:  MOVLW  91
0606E:  MOVWF  FE9
06070:  MOVLB  0
06072:  RCALL  5CE2
....................    sprintf(data + 82, "%s", BS_FilSysType); 
06074:  MOVLW  05
06076:  MOVLB  2
06078:  MOVWF  x25
0607A:  MOVLW  F4
0607C:  MOVWF  x24
0607E:  MOVFF  225,FEA
06082:  MOVFF  224,FE9
06086:  CLRF   FEF
06088:  MOVLW  06
0608A:  MOVWF  FEA
0608C:  MOVLW  04
0608E:  MOVWF  FE9
06090:  MOVLB  0
06092:  RCALL  5CE2
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
06094:  MOVLB  6
06096:  CLRF   xD0
06098:  CLRF   xCF
0609A:  CLRF   xCE
0609C:  CLRF   xCD
0609E:  CLRF   xD2
060A0:  MOVLW  5A
060A2:  MOVWF  xD1
060A4:  MOVLW  05
060A6:  MOVWF  xD4
060A8:  MOVLW  A2
060AA:  MOVWF  xD3
060AC:  MOVLB  0
060AE:  CALL   1D02
060B2:  MOVF   01,F
060B4:  BZ    60C0
....................       return EOF; 
060B6:  MOVLW  FF
060B8:  MOVWF  01
060BA:  MOVLB  5
060BC:  BRA    62B4
060BE:  MOVLB  0
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
060C0:  MOVFF  571,623
060C4:  MOVFF  570,622
060C8:  MOVFF  5FF,625
060CC:  MOVFF  5FE,624
060D0:  CALL   0C98
060D4:  MOVLB  5
060D6:  CLRF   x83
060D8:  CLRF   x82
060DA:  MOVFF  02,581
060DE:  MOVFF  01,580
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
060E2:  MOVLB  6
060E4:  CLRF   xD4
060E6:  CLRF   xD3
060E8:  CLRF   xD2
060EA:  MOVFF  56C,6D1
060EE:  MOVFF  603,6D8
060F2:  MOVFF  602,6D7
060F6:  MOVFF  601,6D6
060FA:  MOVFF  600,6D5
060FE:  MOVLB  0
06100:  CALL   0CBA
06104:  MOVF   00,W
06106:  MOVLB  5
06108:  ADDWF  x80,W
0610A:  MOVWF  x84
0610C:  MOVF   01,W
0610E:  ADDWFC x81,W
06110:  MOVWF  x85
06112:  MOVF   02,W
06114:  ADDWFC x82,W
06116:  MOVWF  x86
06118:  MOVF   03,W
0611A:  ADDWFC x83,W
0611C:  MOVWF  x87
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
0611E:  CLRF   x73
06120:  CLRF   x72
06122:  MOVF   x73,F
06124:  BNZ   6144
06126:  MOVF   x72,W
06128:  SUBLW  1F
0612A:  BNC   6144
....................       data[i] = 0; 
0612C:  MOVLW  A2
0612E:  ADDWF  x72,W
06130:  MOVWF  FE9
06132:  MOVLW  05
06134:  ADDWFC x73,W
06136:  MOVWF  FEA
06138:  CLRF   FEF
0613A:  MOVLW  01
0613C:  ADDWF  x72,F
0613E:  MOVLW  00
06140:  ADDWFC x73,F
06142:  BRA    6122
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
06144:  MOVLB  6
06146:  CLRF   xA1
06148:  CLRF   xA0
0614A:  CLRF   x9F
0614C:  MOVLW  02
0614E:  MOVWF  x9E
06150:  MOVLB  0
06152:  CALL   2094
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
06156:  MOVLB  5
06158:  CLRF   x73
0615A:  CLRF   x72
0615C:  MOVLB  6
0615E:  MOVF   x03,F
06160:  BNZ   6182
06162:  MOVF   x02,F
06164:  BNZ   6182
06166:  MOVLB  5
06168:  MOVF   x73,W
0616A:  MOVLB  6
0616C:  SUBWF  x01,W
0616E:  BNC   61E6
06170:  BNZ   6182
06172:  MOVF   x00,W
06174:  MOVLB  5
06176:  SUBWF  x72,W
06178:  BTFSS  FD8.0
0617A:  BRA    6180
0617C:  MOVLB  6
0617E:  BRA    61E6
06180:  MOVLB  6
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
06182:  MOVLB  5
06184:  MOVF   x72,W
06186:  ADDWF  x80,W
06188:  MOVLB  6
0618A:  MOVWF  x0D
0618C:  MOVLB  5
0618E:  MOVF   x73,W
06190:  ADDWFC x81,W
06192:  MOVLB  6
06194:  MOVWF  x0E
06196:  MOVLW  00
06198:  MOVLB  5
0619A:  ADDWFC x82,W
0619C:  MOVLB  6
0619E:  MOVWF  x0F
061A0:  MOVLW  00
061A2:  MOVLB  5
061A4:  ADDWFC x83,W
061A6:  MOVLB  6
061A8:  MOVWF  x10
061AA:  MOVWF  xD0
061AC:  MOVFF  60F,6CF
061B0:  MOVFF  60E,6CE
061B4:  MOVFF  60D,6CD
061B8:  CLRF   xD2
061BA:  MOVLW  20
061BC:  MOVWF  xD1
061BE:  MOVLW  05
061C0:  MOVWF  xD4
061C2:  MOVLW  A2
061C4:  MOVWF  xD3
061C6:  MOVLB  0
061C8:  CALL   1D02
061CC:  MOVF   01,F
061CE:  BZ    61D8
....................          return EOF; 
061D0:  MOVLW  FF
061D2:  MOVWF  01
061D4:  MOVLB  5
061D6:  BRA    62B4
061D8:  MOVLW  20
061DA:  MOVLB  5
061DC:  ADDWF  x72,F
061DE:  MOVLW  00
061E0:  ADDWFC x73,F
061E2:  BRA    615C
061E4:  MOVLB  6
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
061E6:  MOVLW  F8
061E8:  MOVLB  5
061EA:  MOVWF  xA2
....................    data[1] = 0xFF; 
061EC:  SETF   xA3
....................    data[2] = 0xFF; 
061EE:  SETF   xA4
....................    data[3] = 0x0F; 
061F0:  MOVLW  0F
061F2:  MOVWF  xA5
....................    data[4] = 0xFF; 
061F4:  SETF   xA6
....................    data[5] = 0xFF; 
061F6:  SETF   xA7
....................    data[6] = 0xFF; 
061F8:  SETF   xA8
....................    data[7] = 0x0F; 
061FA:  MOVWF  xA9
....................    data[8] = 0xFF; 
061FC:  SETF   xAA
....................    data[9] = 0xFF; 
061FE:  SETF   xAB
....................    data[10] = 0xFF; 
06200:  SETF   xAC
....................    data[11] = 0x0F; 
06202:  MOVWF  xAD
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
06204:  MOVFF  583,6D0
06208:  MOVFF  582,6CF
0620C:  MOVFF  581,6CE
06210:  MOVFF  580,6CD
06214:  MOVLB  6
06216:  CLRF   xD2
06218:  MOVLW  20
0621A:  MOVWF  xD1
0621C:  MOVLW  05
0621E:  MOVWF  xD4
06220:  MOVLW  A2
06222:  MOVWF  xD3
06224:  MOVLB  0
06226:  CALL   1D02
0622A:  MOVF   01,F
0622C:  BZ    6238
....................       return EOF; 
0622E:  MOVLW  FF
06230:  MOVWF  01
06232:  MOVLB  5
06234:  BRA    62B4
06236:  MOVLB  0
....................        
....................    // reset the last cluster 
....................    i = 2; 
06238:  MOVLB  5
0623A:  CLRF   x73
0623C:  MOVLW  02
0623E:  MOVWF  x72
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
06240:  MOVLB  6
06242:  CLRF   xD0
06244:  CLRF   xCF
06246:  MOVLW  03
06248:  MOVWF  xCE
0624A:  MOVLW  EC
0624C:  MOVWF  xCD
0624E:  CLRF   xD2
06250:  MOVLW  04
06252:  MOVWF  xD1
06254:  MOVLW  05
06256:  MOVWF  xD4
06258:  MOVLW  72
0625A:  MOVWF  xD3
0625C:  MOVLB  0
0625E:  CALL   1D02
06262:  MOVF   01,F
06264:  BZ    6270
....................       return EOF; 
06266:  MOVLW  FF
06268:  MOVWF  01
0626A:  MOVLB  5
0626C:  BRA    62B4
0626E:  MOVLB  0
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
....................    data[18] = make8(BPB_RootEntCnt, 1); 
....................    data[19] = make8(BPB_TotSec, 0); 
....................    data[20] = make8(BPB_TotSec, 1); 
....................    data[22] = make8(BPB_FATSz, 0); 
....................    data[23] = make8(BPB_FATSz, 1); 
....................    data[38] = BS_BootSig; 
....................    data[39] = make8(BS_VolID, 0); 
....................    data[40] = make8(BS_VolID, 1); 
....................    data[41] = make8(BS_VolID, 2); 
....................    data[42] = make8(BS_VolID, 3); 
....................    sprintf(data + 43, "%s", BS_VolLab); 
....................    sprintf(data + 54, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
06270:  MOVLW  AA
06272:  MOVLB  5
06274:  MOVWF  x73
06276:  MOVLW  55
06278:  MOVWF  x72
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
0627A:  MOVLB  6
0627C:  CLRF   xD0
0627E:  CLRF   xCF
06280:  MOVLW  01
06282:  MOVWF  xCE
06284:  MOVLW  FE
06286:  MOVWF  xCD
06288:  CLRF   xD2
0628A:  MOVLW  02
0628C:  MOVWF  xD1
0628E:  MOVLW  05
06290:  MOVWF  xD4
06292:  MOVLW  72
06294:  MOVWF  xD3
06296:  MOVLB  0
06298:  CALL   1D02
0629C:  MOVF   01,F
0629E:  BZ    62AA
....................       return EOF;    
062A0:  MOVLW  FF
062A2:  MOVWF  01
062A4:  MOVLB  5
062A6:  BRA    62B4
062A8:  MOVLB  0
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
062AA:  CALL   0D16
....................  
....................    return GOODEC; 
062AE:  MOVLW  00
062B0:  MOVWF  01
062B2:  MOVLB  5
062B4:  MOVLB  0
062B6:  GOTO   632E (RETURN)
.................... } 
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
*
04DEE:  MOVLW  72
04DF0:  MOVLB  5
04DF2:  MOVWF  xBF
04DF4:  CLRF   xC0
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
04DF6:  MOVFF  564,5EB
04DFA:  MOVFF  563,5EA
04DFE:  MOVLW  05
04E00:  MOVWF  xED
04E02:  MOVLW  BF
04E04:  MOVWF  xEC
04E06:  MOVLW  05
04E08:  MOVWF  xEF
04E0A:  MOVLW  85
04E0C:  MOVWF  xEE
04E0E:  MOVLB  0
04E10:  CALL   10000
04E14:  MOVF   01,F
04E16:  BZ    4E1E
....................       return EOF; 
04E18:  MOVLW  FF
04E1A:  MOVWF  01
04E1C:  BRA    4EE4
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
04E1E:  MOVLW  08
04E20:  MOVWF  FF6
04E22:  MOVLW  00
04E24:  MOVWF  FF7
04E26:  MOVLW  00
04E28:  MOVWF  FF8
04E2A:  MOVLW  04
04E2C:  MOVLB  5
04E2E:  MOVWF  xC1
04E30:  MOVLB  0
04E32:  CALL   0F6A
04E36:  MOVFF  564,FEA
04E3A:  MOVFF  563,FE9
04E3E:  CALL   0F9C
04E42:  MOVLW  2D
04E44:  BTFSS  F9E.4
04E46:  BRA    4E44
04E48:  MOVWF  FAD
04E4A:  MOVLW  2D
04E4C:  BTFSS  F9E.4
04E4E:  BRA    4E4C
04E50:  MOVWF  FAD
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
04E52:  MOVFF  59C,590
04E56:  MOVFF  59B,58F
04E5A:  MOVFF  59A,58E
04E5E:  MOVFF  599,58D
....................  
....................    while(get_next_file(&stream) != EOF) 
04E62:  MOVLW  05
04E64:  MOVLB  5
04E66:  MOVWF  xC2
04E68:  MOVLW  85
04E6A:  MOVWF  xC1
04E6C:  MOVLB  0
04E6E:  RCALL  4B60
04E70:  MOVF   01,W
04E72:  SUBLW  FF
04E74:  BZ    4ED0
....................    { 
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
04E76:  MOVFF  590,67C
04E7A:  MOVFF  58F,67B
04E7E:  MOVFF  58E,67A
04E82:  MOVFF  58D,679
04E86:  MOVLW  05
04E88:  MOVLB  6
04E8A:  MOVWF  x7E
04E8C:  MOVLW  65
04E8E:  MOVWF  x7D
04E90:  MOVLB  0
04E92:  CALL   1A44
04E96:  MOVF   01,F
04E98:  BZ    4EA0
....................          return EOF; 
04E9A:  MOVLW  FF
04E9C:  MOVWF  01
04E9E:  BRA    4EE4
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
04EA0:  MOVLW  0D
04EA2:  BTFSS  F9E.4
04EA4:  BRA    4EA2
04EA6:  MOVWF  FAD
04EA8:  MOVLW  0A
04EAA:  BTFSS  F9E.4
04EAC:  BRA    4EAA
04EAE:  MOVWF  FAD
04EB0:  MOVLW  05
04EB2:  MOVWF  FEA
04EB4:  MOVLW  65
04EB6:  MOVWF  FE9
04EB8:  CALL   0F9C
....................       if (stream.File_Type == Directory) 
04EBC:  MOVLB  5
04EBE:  DECFSZ x9D,W
04EC0:  BRA    4ECC
....................          putc('/'); 
04EC2:  MOVLW  2F
04EC4:  MOVLB  0
04EC6:  CALL   100E
04ECA:  MOVLB  5
04ECC:  MOVLB  0
04ECE:  BRA    4E62
....................    } 
....................  
....................    fatclose(&stream); 
04ED0:  MOVLW  05
04ED2:  MOVLB  5
04ED4:  MOVWF  xE8
04ED6:  MOVLW  85
04ED8:  MOVWF  xE7
04EDA:  MOVLB  0
04EDC:  CALL   34C6
....................  
....................    return GOODEC; 
04EE0:  MOVLW  00
04EE2:  MOVWF  01
04EE4:  GOTO   4EF2 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... #define COMMAND_SIZE 10 
.................... #define NUM_COMMANDS 11 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... char g_CWD[200] = "/"; //current working directory 
....................  
.................... char commands[NUM_COMMANDS][COMMAND_SIZE]= 
.................... { 
....................    "del",      //option1=filename.  delete file. 
....................    "make",     //option1=filename.  create an empty file, give error if file already exists 
....................    "append",   //option1=filename, option2=string.  append string to end of file 
....................    "cd",    //option1=new cwd.  change working directory.  / is root. 
....................    "dir",    //show files in directory 
....................    "cat",    //option1=filename.  display full contents in ascii 
....................    "tail",  //option1=filename.  display the last 20 lines of file. 
....................    "mkdir", //option1=dir.  create directory.  see 'cd' for rules on dir 
....................    "rmdir",  //option1=dir.  remove directory.  see 'cd' for rules on dir. 
....................    "format",   // option1=media size in bytes. formats the media. 
....................    "help"   // help! 
.................... }; 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Finds a command from the global list of commands. 
.................... Param: A pointer to the command string. 
.................... Returns: The command number if the command is found in the command list. 
....................          0xFF if the command isn't found 
.................... */ 
.................... int FindCommand(char *cmd) 
.................... { 
....................    char buf[COMMAND_SIZE]; 
....................    int i; 
....................     
....................    for (i=0; i<NUM_COMMANDS; i++) 
*
01438:  MOVLB  5
0143A:  CLRF   x6D
0143C:  MOVF   x6D,W
0143E:  SUBLW  0A
01440:  BNC   149E
....................    { 
....................       strcpy(buf, &commands[i][0]); 
01442:  MOVF   x6D,W
01444:  MULLW  0A
01446:  MOVF   FF3,W
01448:  CLRF   x6F
0144A:  MOVWF  x6E
0144C:  MOVLW  EE
0144E:  ADDWF  x6E,W
01450:  MOVWF  01
01452:  MOVLW  02
01454:  ADDWFC x6F,W
01456:  MOVWF  03
01458:  MOVFF  01,570
0145C:  MOVWF  x71
0145E:  MOVLW  05
01460:  MOVWF  FEA
01462:  MOVLW  63
01464:  MOVWF  FE9
01466:  MOVFF  03,FE2
0146A:  MOVFF  01,FE1
0146E:  MOVF   FE7,F
01470:  MOVFF  FE6,FEE
01474:  BNZ   146E
....................       if (stricmp(buf, cmd)==0) 
01476:  MOVLW  05
01478:  MOVWF  x6F
0147A:  MOVLW  63
0147C:  MOVWF  x6E
0147E:  MOVFF  562,571
01482:  MOVFF  561,570
01486:  MOVLB  0
01488:  BRA    132E
0148A:  MOVF   01,F
0148C:  BNZ   1498
....................          return(i); 
0148E:  MOVLB  5
01490:  MOVFF  56D,01
01494:  BRA    14A2
01496:  MOVLB  0
01498:  MOVLB  5
0149A:  INCF   x6D,F
0149C:  BRA    143C
....................    } 
....................     
....................    return(0xFF); 
0149E:  MOVLW  FF
014A0:  MOVWF  01
014A2:  MOVLB  0
014A4:  GOTO   66E8 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Displays the current working directory. 
.................... Param: None. 
.................... Returns: None. 
.................... */ 
.................... void DisplayPrompt(void) 
.................... { 
....................    printf("\r\n\n%s> ", g_CWD); 
*
00FC2:  MOVLW  26
00FC4:  MOVWF  FF6
00FC6:  MOVLW  01
00FC8:  MOVWF  FF7
00FCA:  MOVLW  00
00FCC:  MOVWF  FF8
00FCE:  MOVLW  03
00FD0:  MOVLB  5
00FD2:  MOVWF  xC1
00FD4:  MOVLB  0
00FD6:  RCALL  0F6A
00FD8:  MOVLW  02
00FDA:  MOVWF  FEA
00FDC:  MOVLW  26
00FDE:  MOVWF  FE9
00FE0:  RCALL  0F9C
00FE2:  MOVLW  3E
00FE4:  BTFSS  F9E.4
00FE6:  BRA    0FE4
00FE8:  MOVWF  FAD
00FEA:  MOVLW  20
00FEC:  BTFSS  F9E.4
00FEE:  BRA    0FEC
00FF0:  MOVWF  FAD
00FF2:  GOTO   6538 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
.................... void DeleteFile(char *fileName) 
.................... { 
....................    printf("\r\nDeleting '%s': ", fileName); 
*
03A00:  MOVLW  2E
03A02:  MOVWF  FF6
03A04:  MOVLW  01
03A06:  MOVWF  FF7
03A08:  MOVLW  00
03A0A:  MOVWF  FF8
03A0C:  MOVLW  0C
03A0E:  MOVLB  5
03A10:  MOVWF  xC1
03A12:  MOVLB  0
03A14:  CALL   0F6A
03A18:  MOVFF  562,FEA
03A1C:  MOVFF  561,FE9
03A20:  CALL   0F9C
03A24:  MOVLW  3C
03A26:  MOVWF  FF6
03A28:  MOVLW  01
03A2A:  MOVWF  FF7
03A2C:  MOVLW  00
03A2E:  MOVWF  FF8
03A30:  MOVLW  03
03A32:  MOVLB  5
03A34:  MOVWF  xC1
03A36:  MOVLB  0
03A38:  CALL   0F6A
....................    if(rm_file(fileName) != GOODEC) 
03A3C:  MOVFF  562,5A4
03A40:  MOVFF  561,5A3
03A44:  RCALL  37EC
03A46:  MOVF   01,F
03A48:  BZ    3A5C
....................    { 
....................       printf("Error deleting file"); 
03A4A:  MOVLW  40
03A4C:  MOVWF  FF6
03A4E:  MOVLW  01
03A50:  MOVWF  FF7
03A52:  MOVLW  00
03A54:  MOVWF  FF8
03A56:  CALL   0F40
....................       return; 
03A5A:  BRA    3A6C
....................    } 
....................    printf("OK"); 
03A5C:  MOVLW  4F
03A5E:  BTFSS  F9E.4
03A60:  BRA    3A5E
03A62:  MOVWF  FAD
03A64:  MOVLW  4B
03A66:  BTFSS  F9E.4
03A68:  BRA    3A66
03A6A:  MOVWF  FAD
03A6C:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
.................... { 
....................    printf("\r\nMaking file '%s': ", fileName); 
*
04798:  MOVLW  54
0479A:  MOVWF  FF6
0479C:  MOVLW  01
0479E:  MOVWF  FF7
047A0:  MOVLW  00
047A2:  MOVWF  FF8
047A4:  MOVLW  0F
047A6:  MOVLB  5
047A8:  MOVWF  xC1
047AA:  MOVLB  0
047AC:  CALL   0F6A
047B0:  MOVFF  562,FEA
047B4:  MOVFF  561,FE9
047B8:  CALL   0F9C
047BC:  MOVLW  65
047BE:  MOVWF  FF6
047C0:  MOVLW  01
047C2:  MOVWF  FF7
047C4:  MOVLW  00
047C6:  MOVWF  FF8
047C8:  MOVLW  03
047CA:  MOVLB  5
047CC:  MOVWF  xC1
047CE:  MOVLB  0
047D0:  CALL   0F6A
....................    if(mk_file(fileName) != GOODEC) 
047D4:  MOVFF  562,564
047D8:  MOVFF  561,563
047DC:  BRA    461A
047DE:  MOVF   01,F
047E0:  BZ    47F4
....................    { 
....................       printf("Error creating file"); 
047E2:  MOVLW  6A
047E4:  MOVWF  FF6
047E6:  MOVLW  01
047E8:  MOVWF  FF7
047EA:  MOVLW  00
047EC:  MOVWF  FF8
047EE:  CALL   0F40
....................       return; 
047F2:  BRA    4804
....................    } 
....................    printf("OK"); 
047F4:  MOVLW  4F
047F6:  BTFSS  F9E.4
047F8:  BRA    47F6
047FA:  MOVWF  FAD
047FC:  MOVLW  4B
047FE:  BTFSS  F9E.4
04800:  BRA    47FE
04802:  MOVWF  FAD
04804:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
.................... { 
....................    FILE stream; 
....................    printf("\r\nAppending '%s' to '%s': ", appendString, fileName); 
*
04856:  MOVLW  7E
04858:  MOVWF  FF6
0485A:  MOVLW  01
0485C:  MOVWF  FF7
0485E:  MOVLW  00
04860:  MOVWF  FF8
04862:  MOVLW  0D
04864:  MOVLB  5
04866:  MOVWF  xC1
04868:  MOVLB  0
0486A:  CALL   0F6A
0486E:  MOVFF  564,FEA
04872:  MOVFF  563,FE9
04876:  CALL   0F9C
0487A:  MOVLW  8D
0487C:  MOVWF  FF6
0487E:  MOVLW  01
04880:  MOVWF  FF7
04882:  MOVLW  00
04884:  MOVWF  FF8
04886:  MOVLW  06
04888:  MOVLB  5
0488A:  MOVWF  xC1
0488C:  MOVLB  0
0488E:  CALL   0F6A
04892:  MOVFF  562,FEA
04896:  MOVFF  561,FE9
0489A:  CALL   0F9C
0489E:  MOVLW  95
048A0:  MOVWF  FF6
048A2:  MOVLW  01
048A4:  MOVWF  FF7
048A6:  MOVLW  00
048A8:  MOVWF  FF8
048AA:  MOVLW  03
048AC:  MOVLB  5
048AE:  MOVWF  xC1
048B0:  MOVLB  0
048B2:  CALL   0F6A
....................    if(fatopen(fileName, "a", &stream) != GOODEC) 
048B6:  MOVLW  61
048B8:  MOVLB  5
048BA:  MOVWF  x9F
048BC:  CLRF   xA0
048BE:  MOVFF  562,5EB
048C2:  MOVFF  561,5EA
048C6:  MOVLW  05
048C8:  MOVWF  xED
048CA:  MOVLW  9F
048CC:  MOVWF  xEC
048CE:  MOVLW  05
048D0:  MOVWF  xEF
048D2:  MOVLW  65
048D4:  MOVWF  xEE
048D6:  MOVLB  0
048D8:  CALL   10000
048DC:  MOVF   01,F
048DE:  BZ    48F2
....................    { 
....................       printf("Error opening file"); 
048E0:  MOVLW  9A
048E2:  MOVWF  FF6
048E4:  MOVLW  01
048E6:  MOVWF  FF7
048E8:  MOVLW  00
048EA:  MOVWF  FF8
048EC:  CALL   0F40
....................       return; 
048F0:  BRA    495E
....................    } 
....................     
....................    fatputs(appendString, &stream); 
048F2:  MOVFF  564,5A5
048F6:  MOVFF  563,5A4
048FA:  MOVLW  05
048FC:  MOVLB  5
048FE:  MOVWF  xA7
04900:  MOVLW  65
04902:  MOVWF  xA6
04904:  MOVLB  0
04906:  RCALL  4808
....................    fatputs("\r\n", &stream); 
04908:  MOVLW  0D
0490A:  MOVLB  5
0490C:  MOVWF  x9F
0490E:  MOVLW  0A
04910:  MOVWF  xA0
04912:  CLRF   xA1
04914:  MOVLW  05
04916:  MOVWF  xA5
04918:  MOVLW  9F
0491A:  MOVWF  xA4
0491C:  MOVLW  05
0491E:  MOVWF  xA7
04920:  MOVLW  65
04922:  MOVWF  xA6
04924:  MOVLB  0
04926:  RCALL  4808
....................  
....................    if(fatclose(&stream) != GOODEC) 
04928:  MOVLW  05
0492A:  MOVLB  5
0492C:  MOVWF  xE8
0492E:  MOVLW  65
04930:  MOVWF  xE7
04932:  MOVLB  0
04934:  CALL   34C6
04938:  MOVF   01,F
0493A:  BZ    494E
....................    { 
....................       printf("Error closing file"); 
0493C:  MOVLW  AE
0493E:  MOVWF  FF6
04940:  MOVLW  01
04942:  MOVWF  FF7
04944:  MOVLW  00
04946:  MOVWF  FF8
04948:  CALL   0F40
....................       return; 
0494C:  BRA    495E
....................    } 
....................    printf("OK"); 
0494E:  MOVLW  4F
04950:  BTFSS  F9E.4
04952:  BRA    4950
04954:  MOVWF  FAD
04956:  MOVLW  4B
04958:  BTFSS  F9E.4
0495A:  BRA    4958
0495C:  MOVWF  FAD
0495E:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None. 
.................... Example Usage: \> cd ftp/     -> /ftp/ 
....................                \ftp\> cd files/  -> /ftp/files/ 
....................                \ftp\files> cd..  -> /ftp/ 
....................                \ftp\> cd ..      -> / 
....................                \> cd /ftp/files/ -> /ftp/files/ 
....................                 
.................... Note: Changing the directory to .. will go up a directory. 
.................... */ 
.................... void ChangeDirectory(char *newCWD) 
.................... { 
....................    FILE stream; 
....................     
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (newCWD[strlen(newCWD)-1] != '/') 
*
049F2:  MOVFF  562,692
049F6:  MOVFF  561,691
049FA:  CALL   1120
049FE:  MOVFF  02,5A2
04A02:  MOVFF  01,5A1
04A06:  MOVLW  01
04A08:  MOVLB  5
04A0A:  SUBWF  xA1,F
04A0C:  MOVLW  00
04A0E:  SUBWFB xA2,F
04A10:  MOVF   x61,W
04A12:  ADDWF  xA1,W
04A14:  MOVWF  FE9
04A16:  MOVF   x62,W
04A18:  ADDWFC xA2,W
04A1A:  MOVWF  FEA
04A1C:  MOVF   FEF,W
04A1E:  SUBLW  2F
04A20:  BZ    4A40
....................      strcat(newCWD, "/"); 
04A22:  MOVLW  2F
04A24:  MOVWF  x9D
04A26:  CLRF   x9E
04A28:  MOVFF  562,5A4
04A2C:  MOVFF  561,5A3
04A30:  MOVLW  05
04A32:  MOVWF  xA6
04A34:  MOVLW  9D
04A36:  MOVWF  xA5
04A38:  MOVLB  0
04A3A:  CALL   12BC
04A3E:  MOVLB  5
....................  
....................    if((strstr(newCWD, "../") != 0) && (strcmp(g_CWD, "/") != 0)) 
04A40:  MOVLW  2E
04A42:  MOVWF  x9D
04A44:  MOVWF  x9E
04A46:  MOVLW  2F
04A48:  MOVWF  x9F
04A4A:  CLRF   xA0
04A4C:  MOVFF  562,5A4
04A50:  MOVFF  561,5A3
04A54:  MOVLW  05
04A56:  MOVWF  xA6
04A58:  MOVLW  9D
04A5A:  MOVWF  xA5
04A5C:  MOVLB  0
04A5E:  BRA    4962
04A60:  MOVFF  02,5A4
04A64:  MOVFF  01,5A3
04A68:  MOVLB  5
04A6A:  MOVF   xA3,F
04A6C:  BNZ   4A72
04A6E:  MOVF   xA4,F
04A70:  BZ    4B06
04A72:  MOVLW  2F
04A74:  MOVWF  x9D
04A76:  CLRF   x9E
04A78:  MOVLW  02
04A7A:  MOVLB  6
04A7C:  MOVWF  x7A
04A7E:  MOVLW  26
04A80:  MOVWF  x79
04A82:  MOVLW  05
04A84:  MOVWF  x7C
04A86:  MOVLW  9D
04A88:  MOVWF  x7B
04A8A:  MOVLB  0
04A8C:  CALL   1BC0
04A90:  MOVF   01,F
04A92:  BTFSS  FD8.2
04A94:  BRA    4A9A
04A96:  MOVLB  5
04A98:  BRA    4B06
....................    { 
....................       g_CWD[strlen(g_CWD) - 1] = '\0'; 
04A9A:  MOVLW  02
04A9C:  MOVLB  6
04A9E:  MOVWF  x92
04AA0:  MOVLW  26
04AA2:  MOVWF  x91
04AA4:  MOVLB  0
04AA6:  CALL   1120
04AAA:  MOVFF  02,5A2
04AAE:  MOVFF  01,5A1
04AB2:  MOVLW  01
04AB4:  MOVLB  5
04AB6:  SUBWF  xA1,F
04AB8:  MOVLW  00
04ABA:  SUBWFB xA2,F
04ABC:  MOVLW  26
04ABE:  ADDWF  xA1,W
04AC0:  MOVWF  FE9
04AC2:  MOVLW  02
04AC4:  ADDWFC xA2,W
04AC6:  MOVWF  FEA
04AC8:  CLRF   FEF
....................              
....................       g_CWD[strrchr(g_CWD, '/') - g_CWD + 1] = '\0';       
04ACA:  MOVLW  02
04ACC:  MOVWF  xEB
04ACE:  MOVLW  26
04AD0:  MOVWF  xEA
04AD2:  MOVLW  2F
04AD4:  MOVWF  xEC
04AD6:  MOVLB  0
04AD8:  CALL   3A70
04ADC:  MOVFF  02,5A2
04AE0:  MOVFF  01,5A1
04AE4:  MOVLW  26
04AE6:  MOVLB  5
04AE8:  SUBWF  xA1,F
04AEA:  MOVLW  02
04AEC:  SUBWFB xA2,F
04AEE:  MOVLW  01
04AF0:  ADDWF  xA1,F
04AF2:  MOVLW  00
04AF4:  ADDWFC xA2,F
04AF6:  MOVLW  26
04AF8:  ADDWF  xA1,W
04AFA:  MOVWF  FE9
04AFC:  MOVLW  02
04AFE:  ADDWFC xA2,W
04B00:  MOVWF  FEA
04B02:  CLRF   FEF
....................    } 
04B04:  BRA    4B5A
....................    else 
....................    { 
....................       if(fatopen(newCWD, "r", &stream) != GOODEC) 
04B06:  MOVLW  72
04B08:  MOVWF  x9D
04B0A:  CLRF   x9E
04B0C:  MOVFF  562,5EB
04B10:  MOVFF  561,5EA
04B14:  MOVLW  05
04B16:  MOVWF  xED
04B18:  MOVLW  9D
04B1A:  MOVWF  xEC
04B1C:  MOVLW  05
04B1E:  MOVWF  xEF
04B20:  MOVLW  63
04B22:  MOVWF  xEE
04B24:  MOVLB  0
04B26:  CALL   10000
04B2A:  MOVF   01,F
04B2C:  BZ    4B40
....................       { 
....................          printf("\r\nError changing directory"); 
04B2E:  MOVLW  C2
04B30:  MOVWF  FF6
04B32:  MOVLW  01
04B34:  MOVWF  FF7
04B36:  MOVLW  00
04B38:  MOVWF  FF8
04B3A:  CALL   0F40
....................          return; 
04B3E:  BRA    4B58
....................       } 
....................       strcpy(g_CWD, newCWD); 
04B40:  MOVLW  02
04B42:  MOVWF  FEA
04B44:  MOVLW  26
04B46:  MOVWF  FE9
04B48:  MOVFF  562,FE2
04B4C:  MOVFF  561,FE1
04B50:  MOVF   FE7,F
04B52:  MOVFF  FE6,FEE
04B56:  BNZ   4B50
04B58:  MOVLB  5
....................    } 
04B5A:  MOVLB  0
04B5C:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Display the contents of the working directory. 
.................... Param: The full path of the directory contents to display. 
.................... Returns: None. 
.................... Example Usage: /> dir  
.................... */ 
.................... void DisplayDirectory(char *dir) 
.................... { 
....................    disp_folder_contents(dir); 
*
04EE8:  MOVFF  562,564
04EEC:  MOVFF  561,563
04EF0:  BRA    4DEE
04EF2:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Create a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: None. 
.................... Example Usage: /> mkdir "Backlog" 
.................... */ 
.................... void MakeDirectory(char *dir) 
.................... { 
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (dir[strlen(dir)-1] != '/') 
*
0573E:  MOVFF  562,692
05742:  MOVFF  561,691
05746:  CALL   1120
0574A:  MOVFF  02,566
0574E:  MOVFF  01,565
05752:  MOVLW  01
05754:  MOVLB  5
05756:  SUBWF  x65,F
05758:  MOVLW  00
0575A:  SUBWFB x66,F
0575C:  MOVF   x61,W
0575E:  ADDWF  x65,W
05760:  MOVWF  FE9
05762:  MOVF   x62,W
05764:  ADDWFC x66,W
05766:  MOVWF  FEA
05768:  MOVF   FEF,W
0576A:  SUBLW  2F
0576C:  BZ    578C
....................      strcat(dir, "/"); 
0576E:  MOVLW  2F
05770:  MOVWF  x63
05772:  CLRF   x64
05774:  MOVFF  562,5A4
05778:  MOVFF  561,5A3
0577C:  MOVLW  05
0577E:  MOVWF  xA6
05780:  MOVLW  63
05782:  MOVWF  xA5
05784:  MOVLB  0
05786:  CALL   12BC
0578A:  MOVLB  5
....................  
....................    printf("\r\nMaking directory '%s': ", dir); 
0578C:  MOVLW  DE
0578E:  MOVWF  FF6
05790:  MOVLW  01
05792:  MOVWF  FF7
05794:  MOVLW  00
05796:  MOVWF  FF8
05798:  MOVLW  14
0579A:  MOVWF  xC1
0579C:  MOVLB  0
0579E:  CALL   0F6A
057A2:  MOVFF  562,FEA
057A6:  MOVFF  561,FE9
057AA:  CALL   0F9C
057AE:  MOVLW  F4
057B0:  MOVWF  FF6
057B2:  MOVLW  01
057B4:  MOVWF  FF7
057B6:  MOVLW  00
057B8:  MOVWF  FF8
057BA:  MOVLW  03
057BC:  MOVLB  5
057BE:  MOVWF  xC1
057C0:  MOVLB  0
057C2:  CALL   0F6A
....................  
....................    if(mk_dir(dir) != GOODEC) 
057C6:  MOVFF  562,566
057CA:  MOVFF  561,565
057CE:  BRA    52EC
057D0:  MOVF   01,F
057D2:  BZ    57E6
....................    { 
....................       printf("Error creating directory"); 
057D4:  MOVLW  F8
057D6:  MOVWF  FF6
057D8:  MOVLW  01
057DA:  MOVWF  FF7
057DC:  MOVLW  00
057DE:  MOVWF  FF8
057E0:  CALL   0F40
....................       return; 
057E4:  BRA    57F6
....................    } 
....................    printf("OK"); 
057E6:  MOVLW  4F
057E8:  BTFSS  F9E.4
057EA:  BRA    57E8
057EC:  MOVWF  FAD
057EE:  MOVLW  4B
057F0:  BTFSS  F9E.4
057F2:  BRA    57F0
057F4:  MOVWF  FAD
057F6:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Remove a directory. 
.................... Param: The full path of the directory to remove. 
.................... Returns: None. 
.................... Example Usage: /> rmdir "Backlog" 
.................... Note: The directory needs to be empty in order for this command to work. 
.................... */ 
.................... void RemoveDirectory(char *dir) 
.................... { 
....................    printf("\r\nRemoving directory '%s': ", dir); 
*
05880:  MOVLW  12
05882:  MOVWF  FF6
05884:  MOVLW  02
05886:  MOVWF  FF7
05888:  MOVLW  00
0588A:  MOVWF  FF8
0588C:  MOVLW  16
0588E:  MOVLB  5
05890:  MOVWF  xC1
05892:  MOVLB  0
05894:  CALL   0F6A
05898:  MOVFF  562,FEA
0589C:  MOVFF  561,FE9
058A0:  CALL   0F9C
058A4:  MOVLW  2A
058A6:  MOVWF  FF6
058A8:  MOVLW  02
058AA:  MOVWF  FF7
058AC:  MOVLW  00
058AE:  MOVWF  FF8
058B0:  MOVLW  03
058B2:  MOVLB  5
058B4:  MOVWF  xC1
058B6:  MOVLB  0
058B8:  CALL   0F6A
....................  
....................    //append a / to the end of the filename if it doesn't exist 
....................    //making an assumption here that newCWD can hold 1 more character 
....................    if (dir[strlen(dir)-1] != '/') 
058BC:  MOVFF  562,692
058C0:  MOVFF  561,691
058C4:  CALL   1120
058C8:  MOVFF  02,566
058CC:  MOVFF  01,565
058D0:  MOVLW  01
058D2:  MOVLB  5
058D4:  SUBWF  x65,F
058D6:  MOVLW  00
058D8:  SUBWFB x66,F
058DA:  MOVF   x61,W
058DC:  ADDWF  x65,W
058DE:  MOVWF  FE9
058E0:  MOVF   x62,W
058E2:  ADDWFC x66,W
058E4:  MOVWF  FEA
058E6:  MOVF   FEF,W
058E8:  SUBLW  2F
058EA:  BZ    590A
....................      strcat(dir, "/"); 
058EC:  MOVLW  2F
058EE:  MOVWF  x63
058F0:  CLRF   x64
058F2:  MOVFF  562,5A4
058F6:  MOVFF  561,5A3
058FA:  MOVLW  05
058FC:  MOVWF  xA6
058FE:  MOVLW  63
05900:  MOVWF  xA5
05902:  MOVLB  0
05904:  CALL   12BC
05908:  MOVLB  5
....................  
....................    if(rm_dir(dir) != GOODEC) 
0590A:  MOVFF  562,566
0590E:  MOVFF  561,565
05912:  MOVLB  0
05914:  BRA    57FA
05916:  MOVF   01,F
05918:  BZ    592C
....................    { 
....................       printf("Error removing directory"); 
0591A:  MOVLW  2E
0591C:  MOVWF  FF6
0591E:  MOVLW  02
05920:  MOVWF  FF7
05922:  MOVLW  00
05924:  MOVWF  FF8
05926:  CALL   0F40
....................       return; 
0592A:  BRA    593C
....................    } 
....................    printf("OK"); 
0592C:  MOVLW  4F
0592E:  BTFSS  F9E.4
05930:  BRA    592E
05932:  MOVWF  FAD
05934:  MOVLW  4B
05936:  BTFSS  F9E.4
05938:  BRA    5936
0593A:  MOVWF  FAD
0593C:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
....................        If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
.................... void PrintFile(char *fileName, int1 startFromEnd) 
.................... { 
....................    FILE stream; 
....................  
....................    if(fatopen(fileName, "r", &stream) != GOODEC) 
*
05260:  MOVLW  72
05262:  MOVLB  5
05264:  MOVWF  x9E
05266:  CLRF   x9F
05268:  MOVFF  562,5EB
0526C:  MOVFF  561,5EA
05270:  MOVLW  05
05272:  MOVWF  xED
05274:  MOVLW  9E
05276:  MOVWF  xEC
05278:  MOVLW  05
0527A:  MOVWF  xEF
0527C:  MOVLW  64
0527E:  MOVWF  xEE
05280:  MOVLB  0
05282:  CALL   10000
05286:  MOVF   01,F
05288:  BZ    529C
....................    { 
....................       printf("\r\nError opening file"); 
0528A:  MOVLW  48
0528C:  MOVWF  FF6
0528E:  MOVLW  02
05290:  MOVWF  FF7
05292:  MOVLW  00
05294:  MOVWF  FF8
05296:  CALL   0F40
....................       return; 
0529A:  BRA    52EA
....................    } 
....................  
....................    printf("\r\n"); 
0529C:  MOVLW  0D
0529E:  BTFSS  F9E.4
052A0:  BRA    529E
052A2:  MOVWF  FAD
052A4:  MOVLW  0A
052A6:  BTFSS  F9E.4
052A8:  BRA    52A6
052AA:  MOVWF  FAD
....................  
....................    if(startFromEnd) 
052AC:  MOVLB  5
052AE:  MOVF   x63,F
052B0:  BZ    52CE
....................       fatseek(&stream, 80, SEEK_END); 
052B2:  MOVLW  05
052B4:  MOVWF  xA1
052B6:  MOVLW  64
052B8:  MOVWF  xA0
052BA:  CLRF   xA5
052BC:  CLRF   xA4
052BE:  CLRF   xA3
052C0:  MOVLW  50
052C2:  MOVWF  xA2
052C4:  MOVLW  01
052C6:  MOVWF  xA6
052C8:  MOVLB  0
052CA:  BRA    4EF6
052CC:  MOVLB  5
....................  
....................    fatprintf(&stream); 
052CE:  MOVLW  05
052D0:  MOVWF  xA1
052D2:  MOVLW  64
052D4:  MOVWF  xA0
052D6:  MOVLB  0
052D8:  BRA    5232
....................    fatclose(&stream); 
052DA:  MOVLW  05
052DC:  MOVLB  5
052DE:  MOVWF  xE8
052E0:  MOVLW  64
052E2:  MOVWF  xE7
052E4:  MOVLB  0
052E6:  CALL   34C6
052EA:  RETURN 0
.................... } 
....................  
.................... /* 
.................... Summary: Formats the media to a specified size. 
.................... Param: The size of the media, in kB, in string form. 
.................... Returns: None. 
.................... Example Usage: /> format 524288 (format a 512MB card) 
.................... */ 
.................... void FormatMedia(char *mediaSize) 
.................... { 
....................    int32 size; 
....................     
....................    size = atoi32(mediaSize); 
*
062BA:  MOVFF  562,568
062BE:  MOVFF  561,567
062C2:  GOTO   5940
062C6:  MOVFF  03,566
062CA:  MOVFF  02,565
062CE:  MOVFF  01,564
062D2:  MOVFF  00,563
....................     
....................    printf("\r\nFormatting media (size=%LU): ", size); 
062D6:  MOVLW  5E
062D8:  MOVWF  FF6
062DA:  MOVLW  02
062DC:  MOVWF  FF7
062DE:  MOVLW  00
062E0:  MOVWF  FF8
062E2:  MOVLW  19
062E4:  MOVLB  5
062E6:  MOVWF  xC1
062E8:  MOVLB  0
062EA:  CALL   0F6A
062EE:  MOVLW  41
062F0:  MOVWF  FE9
062F2:  MOVFF  566,56A
062F6:  MOVFF  565,569
062FA:  MOVFF  564,568
062FE:  MOVFF  563,567
06302:  BRA    5BD6
06304:  MOVLW  7A
06306:  MOVWF  FF6
06308:  MOVLW  02
0630A:  MOVWF  FF7
0630C:  MOVLW  00
0630E:  MOVWF  FF8
06310:  MOVLW  03
06312:  MOVLB  5
06314:  MOVWF  xC1
06316:  MOVLB  0
06318:  CALL   0F6A
....................    
....................    if(format(size) != GOODEC) 
0631C:  MOVFF  566,56A
06320:  MOVFF  565,569
06324:  MOVFF  564,568
06328:  MOVFF  563,567
0632C:  BRA    5D08
0632E:  MOVF   01,F
06330:  BZ    6344
....................    { 
....................       printf("Error formatting media"); 
06332:  MOVLW  7E
06334:  MOVWF  FF6
06336:  MOVLW  02
06338:  MOVWF  FF7
0633A:  MOVLW  00
0633C:  MOVWF  FF8
0633E:  CALL   0F40
....................       return; 
06342:  BRA    6354
....................    } 
....................    printf("OK"); 
06344:  MOVLW  4F
06346:  BTFSS  F9E.4
06348:  BRA    6346
0634A:  MOVWF  FAD
0634C:  MOVLW  4B
0634E:  BTFSS  F9E.4
06350:  BRA    634E
06352:  MOVWF  FAD
06354:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... /* 
.................... Summary: Shows a help prompt. 
.................... Param: None. 
.................... Returns: None. 
.................... Example Usage: /> help  
.................... */ 
.................... void ShowHelp() 
.................... { 
....................    printf("\r\nFAT Shell Help"); 
06358:  MOVLW  96
0635A:  MOVWF  FF6
0635C:  MOVLW  02
0635E:  MOVWF  FF7
06360:  MOVLW  00
06362:  MOVWF  FF8
06364:  CALL   0F40
....................    printf("\r\n del filename --- Deletes the file"); 
06368:  MOVLW  A8
0636A:  MOVWF  FF6
0636C:  MOVLW  02
0636E:  MOVWF  FF7
06370:  MOVLW  00
06372:  MOVWF  FF8
06374:  CALL   0F40
....................    printf("\r\n make filename --- Creates an empty file"); 
06378:  MOVLW  CE
0637A:  MOVWF  FF6
0637C:  MOVLW  02
0637E:  MOVWF  FF7
06380:  MOVLW  00
06382:  MOVWF  FF8
06384:  CALL   0F40
....................    printf("\r\n append filename string --- Appends string to the end of the file"); 
06388:  MOVLW  FA
0638A:  MOVWF  FF6
0638C:  MOVLW  02
0638E:  MOVWF  FF7
06390:  MOVLW  00
06392:  MOVWF  FF8
06394:  CALL   0F40
....................    printf("\r\n cd dir --- Change the working directory"); 
06398:  MOVLW  3E
0639A:  MOVWF  FF6
0639C:  MOVLW  03
0639E:  MOVWF  FF7
063A0:  MOVLW  00
063A2:  MOVWF  FF8
063A4:  CALL   0F40
....................    printf("\r\n dir --- Shows the contents of the directory"); 
063A8:  MOVLW  6A
063AA:  MOVWF  FF6
063AC:  MOVLW  03
063AE:  MOVWF  FF7
063B0:  MOVLW  00
063B2:  MOVWF  FF8
063B4:  CALL   0F40
....................    printf("\r\n cat filename --- Displays content of file"); 
063B8:  MOVLW  9A
063BA:  MOVWF  FF6
063BC:  MOVLW  03
063BE:  MOVWF  FF7
063C0:  MOVLW  00
063C2:  MOVWF  FF8
063C4:  CALL   0F40
....................    printf("\r\n tail filename --- Displays the last 80 characters of file"); 
063C8:  MOVLW  C8
063CA:  MOVWF  FF6
063CC:  MOVLW  03
063CE:  MOVWF  FF7
063D0:  MOVLW  00
063D2:  MOVWF  FF8
063D4:  CALL   0F40
....................    printf("\r\n mkdir dir --- Create a directory"); 
063D8:  MOVLW  06
063DA:  MOVWF  FF6
063DC:  MOVLW  04
063DE:  MOVWF  FF7
063E0:  MOVLW  00
063E2:  MOVWF  FF8
063E4:  CALL   0F40
....................    printf("\r\n rmdir dir --- Deletes the directory"); 
063E8:  MOVLW  2A
063EA:  MOVWF  FF6
063EC:  MOVLW  04
063EE:  MOVWF  FF7
063F0:  MOVLW  00
063F2:  MOVWF  FF8
063F4:  CALL   0F40
....................    printf("\r\n format size --- Format card.  (Example: 'format 5524288' formats a 512MB card)"); 
063F8:  MOVLW  52
063FA:  MOVWF  FF6
063FC:  MOVLW  04
063FE:  MOVWF  FF7
06400:  MOVLW  00
06402:  MOVWF  FF8
06404:  CALL   0F40
....................    printf("\r\n help\tYou are here"); 
06408:  MOVLW  A4
0640A:  MOVWF  FF6
0640C:  MOVLW  04
0640E:  MOVWF  FF7
06410:  MOVLW  00
06412:  MOVWF  FF8
06414:  CALL   0F40
....................    printf("\r\n\n Put a parameter in quotes if it has spaces"); 
06418:  MOVLW  BA
0641A:  MOVWF  FF6
0641C:  MOVLW  04
0641E:  MOVWF  FF7
06420:  MOVLW  00
06422:  MOVWF  FF8
06424:  CALL   0F40
06428:  GOTO   6802 (RETURN)
.................... } 
....................  
.................... char * GetCMD(char *in) 
.................... { 
....................    char tokens[]=" \r\n"; 
*
01214:  MOVLW  20
01216:  MOVLB  5
01218:  MOVWF  x63
0121A:  MOVLW  0D
0121C:  MOVWF  x64
0121E:  MOVLW  0A
01220:  MOVWF  x65
01222:  CLRF   x66
....................    return(strtok(in,tokens)); 
01224:  MOVFF  562,56E
01228:  MOVFF  561,56D
0122C:  MOVLW  05
0122E:  MOVWF  x70
01230:  MOVLW  63
01232:  MOVWF  x6F
01234:  MOVLB  0
01236:  RCALL  115C
01238:  MOVF   02,W
0123A:  GOTO   65EC (RETURN)
.................... } 
....................  
.................... char * GetOption(char *in) 
.................... { 
....................    char tokensSpace[]=" \r\n"; 
0123E:  MOVLW  20
01240:  MOVLB  5
01242:  MOVWF  x65
01244:  MOVLW  0D
01246:  MOVWF  x66
01248:  MOVLW  0A
0124A:  MOVWF  x67
0124C:  CLRF   x68
....................    char tokensQuote[]="\"\r\n"; 
0124E:  MOVLW  22
01250:  MOVWF  x69
01252:  MOVLW  0D
01254:  MOVWF  x6A
01256:  MOVLW  0A
01258:  MOVWF  x6B
0125A:  CLRF   x6C
....................     
....................    //trim leading spaces 
....................    while (*in==' ') 
0125C:  MOVFF  564,03
01260:  MOVFF  563,FE9
01264:  MOVFF  564,FEA
01268:  MOVF   FEF,W
0126A:  SUBLW  20
0126C:  BNZ   1276
....................       in++; 
0126E:  INCF   x63,F
01270:  BTFSC  FD8.2
01272:  INCF   x64,F
01274:  BRA    125C
....................     
....................    //if first char is a quote, then end token on a quote.  ELSE end token on a space 
....................    if (*in == '\"') 
01276:  MOVFF  564,03
0127A:  MOVFF  563,FE9
0127E:  MOVFF  564,FEA
01282:  MOVF   FEF,W
01284:  SUBLW  22
01286:  BNZ   12A4
....................       return(strtok(in,tokensQuote)); 
01288:  MOVFF  564,56E
0128C:  MOVFF  563,56D
01290:  MOVLW  05
01292:  MOVWF  x70
01294:  MOVLW  69
01296:  MOVWF  x6F
01298:  MOVLB  0
0129A:  RCALL  115C
0129C:  MOVF   02,W
0129E:  BRA    12BA
012A0:  BRA    12BA
012A2:  MOVLB  5
....................    else 
....................       return(strtok(in,tokensSpace)); 
012A4:  MOVFF  564,56E
012A8:  MOVFF  563,56D
012AC:  MOVLW  05
012AE:  MOVWF  x70
012B0:  MOVLW  65
012B2:  MOVWF  x6F
012B4:  MOVLB  0
012B6:  RCALL  115C
012B8:  MOVF   02,W
012BA:  RETURN 0
.................... } 
....................  
.................... void main(void) 
*
0642C:  CLRF   FF8
0642E:  BCF    FD0.7
06430:  CLRF   04
06432:  BSF    F7E.3
06434:  MOVLW  8A
06436:  MOVWF  FAF
06438:  MOVLW  02
0643A:  MOVWF  F7F
0643C:  MOVLW  A6
0643E:  MOVWF  FAC
06440:  MOVLW  90
06442:  MOVWF  FAB
06444:  BCF    FC6.5
06446:  MOVLW  40
06448:  MOVWF  FC7
0644A:  MOVLW  22
0644C:  MOVWF  FC6
0644E:  MOVLB  2
06450:  CLRF   x25
06452:  CLRF   x24
06454:  MOVF   FC1,W
06456:  ANDLW  C0
06458:  MOVWF  FC1
0645A:  MOVLW  07
0645C:  MOVWF  FB4
0645E:  BRA    64CE
06460:  DATA 02,00
06462:  DATA 05,00
06464:  DATA 00,02
06466:  DATA 02,26
06468:  DATA 2F,00
0646A:  DATA 03,02
0646C:  DATA EE,64
0646E:  DATA 65,6C
06470:  DATA 07,C0
06472:  DATA 00,04
06474:  DATA 80,6D
06476:  DATA 61,6B
06478:  DATA 65,06
0647A:  DATA C0,00
0647C:  DATA 06,80
0647E:  DATA 61,70
06480:  DATA 70,65
06482:  DATA 6E,64
06484:  DATA 04,C0
06486:  DATA 00,02
06488:  DATA 80,63
0648A:  DATA 64,08
0648C:  DATA C0,00
0648E:  DATA 03,80
06490:  DATA 64,69
06492:  DATA 72,07
06494:  DATA C0,00
06496:  DATA 03,80
06498:  DATA 63,61
0649A:  DATA 74,07
0649C:  DATA C0,00
0649E:  DATA 04,80
064A0:  DATA 74,61
064A2:  DATA 69,6C
064A4:  DATA 06,C0
064A6:  DATA 00,05
064A8:  DATA 80,6D
064AA:  DATA 6B,64
064AC:  DATA 69,72
064AE:  DATA 05,C0
064B0:  DATA 00,05
064B2:  DATA 80,72
064B4:  DATA 6D,64
064B6:  DATA 69,72
064B8:  DATA 05,C0
064BA:  DATA 00,06
064BC:  DATA 80,66
064BE:  DATA 6F,72
064C0:  DATA 6D,61
064C2:  DATA 74,04
064C4:  DATA C0,00
064C6:  DATA 05,80
064C8:  DATA 68,65
064CA:  DATA 6C,70
064CC:  DATA 00,00
064CE:  MOVLW  00
064D0:  MOVWF  FF8
064D2:  MOVLW  64
064D4:  MOVWF  FF7
064D6:  MOVLW  60
064D8:  MOVWF  FF6
064DA:  TBLRD*+
064DC:  MOVF   FF5,W
064DE:  MOVWF  00
064E0:  XORLW  00
064E2:  BZ    650A
064E4:  TBLRD*+
064E6:  MOVF   FF5,W
064E8:  MOVWF  01
064EA:  BTFSC  FE8.7
064EC:  BRA    64F8
064EE:  ANDLW  0F
064F0:  MOVWF  FEA
064F2:  TBLRD*+
064F4:  MOVFF  FF5,FE9
064F8:  BTFSC  01.6
064FA:  TBLRD*+
064FC:  BTFSS  01.6
064FE:  TBLRD*+
06500:  MOVFF  FF5,FEE
06504:  DCFSNZ 00,F
06506:  BRA    64DA
06508:  BRA    64FC
0650A:  CLRF   FF8
.................... { 
....................    char buffer[255]; 
....................    char opt_buffer[255]; 
....................    char *cmd, *option1, *option2; 
....................     
....................    int i;   // pointer to the buffer 
....................  
....................    // initialize the FAT 
....................    //  keep in mind that this will automagically initialize the media 
....................    i = fat_init(); 
0650C:  MOVLB  0
0650E:  CALL   0D16
06512:  MOVFF  01,560
....................    if (i) 
06516:  MOVLB  5
06518:  MOVF   x60,F
0651A:  BZ    6530
....................       printf("\r\n\nERROR INITIALIZING FAT\r\n\n"); 
0651C:  MOVLW  EA
0651E:  MOVWF  FF6
06520:  MOVLW  04
06522:  MOVWF  FF7
06524:  MOVLW  00
06526:  MOVWF  FF8
06528:  MOVLB  0
0652A:  CALL   0F40
0652E:  MOVLB  5
....................      
....................    // main loop 
....................    while(TRUE) 
....................    { 
....................       i = 0; 
06530:  CLRF   x60
....................        
....................       DisplayPrompt(); 
06532:  MOVLB  0
06534:  GOTO   0FC2
....................        
....................       do 
....................       { 
....................          buffer[i] = getch(); 
06538:  CLRF   03
0653A:  MOVLB  5
0653C:  MOVF   x60,W
0653E:  ADDLW  5C
06540:  MOVWF  FE9
06542:  MOVLW  03
06544:  ADDWFC 03,W
06546:  MOVWF  FEA
06548:  MOVFF  FEA,564
0654C:  MOVFF  FE9,563
06550:  MOVLB  0
06552:  GOTO   0FF6
06556:  MOVFF  564,FEA
0655A:  MOVFF  563,FE9
0655E:  MOVFF  01,FEF
....................           
....................          // check for a backspace 
....................          if(buffer[i] != 8) 
06562:  CLRF   03
06564:  MOVLB  5
06566:  MOVF   x60,W
06568:  ADDLW  5C
0656A:  MOVWF  FE9
0656C:  MOVLW  03
0656E:  ADDWFC 03,W
06570:  MOVWF  FEA
06572:  MOVF   FEF,W
06574:  SUBLW  08
06576:  BZ    6596
....................          { 
....................             printf("%c", buffer[i]); 
06578:  CLRF   03
0657A:  MOVF   x60,W
0657C:  ADDLW  5C
0657E:  MOVWF  FE9
06580:  MOVLW  03
06582:  ADDWFC 03,W
06584:  MOVWF  FEA
06586:  MOVFF  FEF,561
0658A:  MOVF   x61,W
0658C:  BTFSS  F9E.4
0658E:  BRA    658C
06590:  MOVWF  FAD
....................             i++; 
06592:  INCF   x60,F
....................          } 
06594:  BRA    65B2
....................          else if(i > 0) 
06596:  MOVF   x60,F
06598:  BZ    65B2
....................          { 
....................             // delete the last character 
....................             i--; 
0659A:  DECF   x60,F
....................             putc(8); 
0659C:  MOVLW  08
0659E:  MOVLB  0
065A0:  CALL   100E
....................             putc(' '); 
065A4:  MOVLW  20
065A6:  CALL   100E
....................             putc(8); 
065AA:  MOVLW  08
065AC:  CALL   100E
065B0:  MOVLB  5
....................          } 
....................          buffer[i] = '\0'; 
065B2:  CLRF   03
065B4:  MOVF   x60,W
065B6:  ADDLW  5C
065B8:  MOVWF  FE9
065BA:  MOVLW  03
065BC:  ADDWFC 03,W
065BE:  MOVWF  FEA
065C0:  CLRF   FEF
....................       } while(buffer[i - 1] != '\r'); 
065C2:  MOVLW  01
065C4:  SUBWF  x60,W
065C6:  CLRF   03
065C8:  ADDLW  5C
065CA:  MOVWF  FE9
065CC:  MOVLW  03
065CE:  ADDWFC 03,W
065D0:  MOVWF  FEA
065D2:  MOVF   FEF,W
065D4:  SUBLW  0D
065D6:  BTFSC  FD8.2
065D8:  BRA    65DE
065DA:  MOVLB  0
065DC:  BRA    6538
....................        
....................       // parse the command and options 
....................       cmd = GetCMD(buffer); 
065DE:  MOVLW  03
065E0:  MOVWF  x62
065E2:  MOVLW  5C
065E4:  MOVWF  x61
065E6:  MOVLB  0
065E8:  GOTO   1214
065EC:  MOVFF  02,55B
065F0:  MOVFF  01,55A
....................       option1 = GetOption(cmd + strlen(cmd) + 1); 
065F4:  MOVFF  55B,692
065F8:  MOVFF  55A,691
065FC:  CALL   1120
06600:  MOVFF  02,03
06604:  MOVF   01,W
06606:  MOVLB  5
06608:  ADDWF  x5A,W
0660A:  MOVWF  x61
0660C:  MOVF   02,W
0660E:  ADDWFC x5B,W
06610:  MOVWF  x62
06612:  MOVLW  01
06614:  ADDWF  x61,F
06616:  MOVLW  00
06618:  ADDWFC x62,F
0661A:  MOVFF  562,564
0661E:  MOVFF  561,563
06622:  MOVLB  0
06624:  CALL   123E
06628:  MOVFF  02,55D
0662C:  MOVFF  01,55C
....................       option2 = GetOption(option1 + strlen(option1) + 1); 
06630:  MOVFF  55D,692
06634:  MOVFF  55C,691
06638:  CALL   1120
0663C:  MOVFF  02,03
06640:  MOVF   01,W
06642:  MOVLB  5
06644:  ADDWF  x5C,W
06646:  MOVWF  x61
06648:  MOVF   02,W
0664A:  ADDWFC x5D,W
0664C:  MOVWF  x62
0664E:  MOVLW  01
06650:  ADDWF  x61,F
06652:  MOVLW  00
06654:  ADDWFC x62,F
06656:  MOVFF  562,564
0665A:  MOVFF  561,563
0665E:  MOVLB  0
06660:  CALL   123E
06664:  MOVFF  02,55F
06668:  MOVFF  01,55E
....................  
....................       //if option1 starts with a '/', that means the file in the option includes 
....................       //the full path to the file.  if the file doesn't start with a '/', the  
....................       //current working directory must be added. 
....................       if (option1 && (option1[0]=='/')) 
0666C:  MOVLB  5
0666E:  MOVF   x5C,W
06670:  IORWF  x5D,W
06672:  BZ    669C
06674:  MOVFF  55C,FE9
06678:  MOVFF  55D,FEA
0667C:  MOVF   FEF,W
0667E:  SUBLW  2F
06680:  BNZ   669C
....................       { 
....................          //option1 is a full path 
....................          strcpy(opt_buffer, option1); 
06682:  MOVLW  04
06684:  MOVWF  FEA
06686:  MOVLW  5B
06688:  MOVWF  FE9
0668A:  MOVFF  55D,FE2
0668E:  MOVFF  55C,FE1
06692:  MOVF   FE7,F
06694:  MOVFF  FE6,FEE
06698:  BNZ   6692
....................       } 
0669A:  BRA    66D2
....................       else if (option1) 
0669C:  MOVF   x5C,W
0669E:  IORWF  x5D,W
066A0:  BZ    66D2
....................       { 
....................          // tack on the current working directory to option1 
....................          strcpy(opt_buffer, g_CWD); 
066A2:  MOVLW  04
066A4:  MOVWF  FEA
066A6:  MOVLW  5B
066A8:  MOVWF  FE9
066AA:  MOVLW  02
066AC:  MOVWF  FE2
066AE:  MOVLW  26
066B0:  MOVWF  FE1
066B2:  MOVF   FE7,F
066B4:  MOVFF  FE6,FEE
066B8:  BNZ   66B2
....................          strcat(opt_buffer, option1); 
066BA:  MOVLW  04
066BC:  MOVWF  xA4
066BE:  MOVLW  5B
066C0:  MOVWF  xA3
066C2:  MOVFF  55D,5A6
066C6:  MOVFF  55C,5A5
066CA:  MOVLB  0
066CC:  CALL   12BC
066D0:  MOVLB  5
....................       }          
....................        
....................       if (cmd) 
066D2:  MOVF   x5A,W
066D4:  IORWF  x5B,W
066D6:  BTFSC  FD8.2
066D8:  BRA    6804
....................       { 
....................          switch(FindCommand(cmd)) 
066DA:  MOVFF  55B,562
066DE:  MOVFF  55A,561
066E2:  MOVLB  0
066E4:  GOTO   1438
066E8:  MOVF   01,W
066EA:  BZ    6716
066EC:  XORLW  01
066EE:  BZ    6728
066F0:  XORLW  03
066F2:  BZ    673A
066F4:  XORLW  01
066F6:  BZ    6754
066F8:  XORLW  07
066FA:  BZ    6766
066FC:  XORLW  01
066FE:  BZ    6778
06700:  XORLW  03
06702:  BZ    678C
06704:  XORLW  01
06706:  BZ    67A2
06708:  XORLW  0F
0670A:  BZ    67B4
0670C:  XORLW  01
0670E:  BZ    67C6
06710:  XORLW  03
06712:  BZ    67D2
06714:  BRA    67D6
....................          { 
....................             case 0:  //del 
....................                DeleteFile(opt_buffer); 
06716:  MOVLW  04
06718:  MOVLB  5
0671A:  MOVWF  x62
0671C:  MOVLW  5B
0671E:  MOVWF  x61
06720:  MOVLB  0
06722:  GOTO   3A00
....................                break; 
06726:  BRA    6802
....................              
....................             case 1:  //make 
....................                MakeFile(opt_buffer); 
06728:  MOVLW  04
0672A:  MOVLB  5
0672C:  MOVWF  x62
0672E:  MOVLW  5B
06730:  MOVWF  x61
06732:  MOVLB  0
06734:  GOTO   4798
....................                break; 
06738:  BRA    6802
....................              
....................             case 2:  //append 
....................                AppendFile(opt_buffer, option2); 
0673A:  MOVLW  04
0673C:  MOVLB  5
0673E:  MOVWF  x62
06740:  MOVLW  5B
06742:  MOVWF  x61
06744:  MOVFF  55F,564
06748:  MOVFF  55E,563
0674C:  MOVLB  0
0674E:  GOTO   4856
....................                break; 
06752:  BRA    6802
....................              
....................             case 3:  //change directory 
....................                ChangeDirectory(opt_buffer); 
06754:  MOVLW  04
06756:  MOVLB  5
06758:  MOVWF  x62
0675A:  MOVLW  5B
0675C:  MOVWF  x61
0675E:  MOVLB  0
06760:  GOTO   49F2
....................                break; 
06764:  BRA    6802
....................              
....................             case 4:  //show directory contents 
....................                DisplayDirectory(g_CWD); 
06766:  MOVLW  02
06768:  MOVLB  5
0676A:  MOVWF  x62
0676C:  MOVLW  26
0676E:  MOVWF  x61
06770:  MOVLB  0
06772:  GOTO   4EE8
....................                break; 
06776:  BRA    6802
....................                 
....................             case 5:  //cat, display file 
....................                PrintFile(opt_buffer, CAT_FROM_START); 
06778:  MOVLW  04
0677A:  MOVLB  5
0677C:  MOVWF  x62
0677E:  MOVLW  5B
06780:  MOVWF  x61
06782:  CLRF   x63
06784:  MOVLB  0
06786:  CALL   5260
....................                break; 
0678A:  BRA    6802
....................              
....................             case 6:  //tail, display last 80 charachters 
....................                PrintFile(opt_buffer, CAT_FROM_END); 
0678C:  MOVLW  04
0678E:  MOVLB  5
06790:  MOVWF  x62
06792:  MOVLW  5B
06794:  MOVWF  x61
06796:  MOVLW  01
06798:  MOVWF  x63
0679A:  MOVLB  0
0679C:  CALL   5260
....................                break; 
067A0:  BRA    6802
....................              
....................             case 7: //mkdir, make a directory 
....................                MakeDirectory(opt_buffer); 
067A2:  MOVLW  04
067A4:  MOVLB  5
067A6:  MOVWF  x62
067A8:  MOVLW  5B
067AA:  MOVWF  x61
067AC:  MOVLB  0
067AE:  GOTO   573E
....................                break; 
067B2:  BRA    6802
....................  
....................             case 8: //rmdir, make a directory 
....................                RemoveDirectory(opt_buffer); 
067B4:  MOVLW  04
067B6:  MOVLB  5
067B8:  MOVWF  x62
067BA:  MOVLW  5B
067BC:  MOVWF  x61
067BE:  MOVLB  0
067C0:  GOTO   5880
....................                break; 
067C4:  BRA    6802
....................  
....................             case 9: //format, format the card 
....................                FormatMedia(option1); 
067C6:  MOVFF  55D,562
067CA:  MOVFF  55C,561
067CE:  BRA    62BA
....................                break; 
067D0:  BRA    6802
....................  
....................             case 10: //help, display help 
....................                ShowHelp(); 
067D2:  BRA    6358
....................                break; 
067D4:  BRA    6802
....................  
....................             default: 
....................                printf("\r\nUnkown Command '%s'", cmd); 
067D6:  MOVLW  08
067D8:  MOVWF  FF6
067DA:  MOVLW  05
067DC:  MOVWF  FF7
067DE:  MOVLW  00
067E0:  MOVWF  FF8
067E2:  MOVLW  12
067E4:  MOVLB  5
067E6:  MOVWF  xC1
067E8:  MOVLB  0
067EA:  CALL   0F6A
067EE:  MOVFF  55B,FEA
067F2:  MOVFF  55A,FE9
067F6:  CALL   0F9C
067FA:  MOVLW  27
067FC:  BTFSS  F9E.4
067FE:  BRA    67FC
06800:  MOVWF  FAD
....................                break; 
06802:  MOVLB  5
....................          } 
....................       } 
06804:  BRA    6530
....................    } 
.................... } 
....................  
06806:  SLEEP 
....................  

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: FFC4   HS PRIMARY FCMEN IESO WDT32768
   Word  3: F7F8   ETHLED
