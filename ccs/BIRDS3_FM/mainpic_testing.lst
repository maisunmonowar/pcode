CCS PCH C Compiler, Version 5.050, 5967               15-11-18 15:50

               Filename:   C:\Users\kakimoto\Documents\CCS C Projects\main pic v1.10.3.1_for_ADCS\mainpic_testing.lst

               ROM used:   4246 bytes (3%)
                           Largest free fragment is 65520
               RAM used:   509 (14%) at main() level
                           540 (15%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   0DDC
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   082E
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVFF  18,FF8
000BE:  MOVFF  19,FFB
000C2:  MOVF   04,W
000C4:  MOVFF  06,FE0
000C8:  MOVFF  05,FD8
000CC:  RETFIE 0
.................... #include <main pic1.h> 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
000CE:  DATA 67,69
000D0:  DATA 76,65
000D2:  DATA 20,61
000D4:  DATA 63,63
000D6:  DATA 65,73
000D8:  DATA 73,20
000DA:  DATA 74,6F
000DC:  DATA 20,43
000DE:  DATA 4F,4D
000E0:  DATA 0D,0A
000E2:  DATA 00,00
000E4:  DATA 42,61
000E6:  DATA 63,6B
000E8:  DATA 20,74
000EA:  DATA 6F,20
000EC:  DATA 4E,6F
000EE:  DATA 6D,61
000F0:  DATA 6C,20
000F2:  DATA 4F,70
000F4:  DATA 65,72
000F6:  DATA 61,74
000F8:  DATA 69,6F
000FA:  DATA 6E,0D
000FC:  DATA 0A,00
000FE:  DATA 64,61
00100:  DATA 74,61
00102:  DATA 5F,6C
00104:  DATA 3A,25
00106:  DATA 78,20
00108:  DATA 0D,0A
0010A:  DATA 00,00
0010C:  DATA 64,61
0010E:  DATA 74,61
00110:  DATA 5F,68
00112:  DATA 3A,25
00114:  DATA 78,20
00116:  DATA 0D,0A
00118:  DATA 00,00
0011A:  DATA 43,75
0011C:  DATA 72,72
0011E:  DATA 65,6E
00120:  DATA 74,20
00122:  DATA 54,65
00124:  DATA 6D,70
00126:  DATA 3A,20
00128:  DATA 25,31
0012A:  DATA 2E,31
0012C:  DATA 66,0D
0012E:  DATA 0A,00
00130:  DATA 54,75
00132:  DATA 72,6E
00134:  DATA 65,64
00136:  DATA 20,4F
00138:  DATA 4E,20
0013A:  DATA 42,43
0013C:  DATA 0D,0A
0013E:  DATA 00,00
00140:  DATA 55,4E
00142:  DATA 4C,45
00144:  DATA 47,32
00146:  DATA 20,43
00148:  DATA 55,52
0014A:  DATA 52,45
0014C:  DATA 4E,54
0014E:  DATA 20,69
00150:  DATA 73,20
00152:  DATA 25,78
00154:  DATA 0D,0A
00156:  DATA 00,00
00158:  DATA 4D,41
0015A:  DATA 58,49
0015C:  DATA 4D,55
0015E:  DATA 4D,20
00160:  DATA 54,45
00162:  DATA 4D,50
00164:  DATA 45,52
00166:  DATA 41,54
00168:  DATA 55,52
0016A:  DATA 45,20
0016C:  DATA 69,73
0016E:  DATA 20,25
00170:  DATA 31,2E
00172:  DATA 31,66
00174:  DATA 0D,0A
00176:  DATA 0D,0A
00178:  DATA 00,00
0017A:  DATA 0D,0A
0017C:  DATA 46,6C
0017E:  DATA 61,67
00180:  DATA 20,64
00182:  DATA 65,6C
00184:  DATA 65,74
00186:  DATA 65,20
00188:  DATA 64,6F
0018A:  DATA 6E,65
0018C:  DATA 0D,0A
0018E:  DATA 00,00
00190:  DATA 0D,0A
00192:  DATA 46,6C
00194:  DATA 61,67
00196:  DATA 3A,31
00198:  DATA 0D,0A
0019A:  DATA 00,00
0019C:  DATA 0D,0A
0019E:  DATA 46,6C
001A0:  DATA 61,67
001A2:  DATA 3A,32
001A4:  DATA 0D,0A
001A6:  DATA 00,00
001A8:  DATA 0D,0A
001AA:  DATA 46,6C
001AC:  DATA 61,67
001AE:  DATA 3A,33
001B0:  DATA 0D,0A
001B2:  DATA 00,00
001B4:  DATA 0D,0A
001B6:  DATA 46,6C
001B8:  DATA 61,67
001BA:  DATA 3A,34
001BC:  DATA 0D,0A
001BE:  DATA 00,00
001C0:  DATA 48,45
001C2:  DATA 41,44
001C4:  DATA 45,52
001C6:  DATA 3D,25
001C8:  DATA 78,0D
001CA:  DATA 0A,00
001CC:  DATA 4E,4F
001CE:  DATA 20,44
001D0:  DATA 41,54
001D2:  DATA 41,0D
001D4:  DATA 0A,00
001D6:  DATA 4E,4F
001D8:  DATA 20,44
001DA:  DATA 41,54
001DC:  DATA 41,0D
001DE:  DATA 0A,00
001E0:  DATA 57,72
001E2:  DATA 69,74
001E4:  DATA 65,20
001E6:  DATA 44,41
001E8:  DATA 54,41
001EA:  DATA 20,74
001EC:  DATA 6F,20
001EE:  DATA 4D,69
001F0:  DATA 73,73
001F2:  DATA 69,6F
001F4:  DATA 6E,20
001F6:  DATA 46,6C
001F8:  DATA 61,73
001FA:  DATA 68,20
001FC:  DATA 44,4F
001FE:  DATA 4E,45
00200:  DATA 0D,0A
00202:  DATA 00,00
00204:  DATA 54,72
00206:  DATA 61,6E
00208:  DATA 73,66
0020A:  DATA 65,72
0020C:  DATA 20,44
0020E:  DATA 4F,4E
00210:  DATA 45,0D
00212:  DATA 0A,00
00214:  DATA 44,4F
00216:  DATA 4E,45
00218:  DATA 0D,0A
0021A:  DATA 00,00
0021C:  DATA 0D,0A
0021E:  DATA 4D,54
00220:  DATA 51,20
00222:  DATA 57,4F
00224:  DATA 52,4B
00226:  DATA 49,4E
00228:  DATA 47,0D
0022A:  DATA 0A,00
0022C:  DATA 0D,0A
0022E:  DATA 4D,54
00230:  DATA 51,20
00232:  DATA 4E,4F
00234:  DATA 54,20
00236:  DATA 57,4F
00238:  DATA 52,4B
0023A:  DATA 49,4E
0023C:  DATA 47,0D
0023E:  DATA 0A,00
00240:  DATA 54,75
00242:  DATA 72,6E
00244:  DATA 20,4F
00246:  DATA 6E,20
00248:  DATA 41,44
0024A:  DATA 43,53
0024C:  DATA 0D,0A
0024E:  DATA 00,00
00250:  DATA 53,65
00252:  DATA 6E,64
00254:  DATA 20,43
00256:  DATA 6F,6D
00258:  DATA 6D,61
0025A:  DATA 6E,64
0025C:  DATA 20,74
0025E:  DATA 6F,20
00260:  DATA 41,44
00262:  DATA 43,53
00264:  DATA 0D,0A
00266:  DATA 00,00
00268:  DATA 47,45
0026A:  DATA 54,20
0026C:  DATA 41,43
0026E:  DATA 4B,3A
00270:  DATA 25,78
00272:  DATA 0D,0A
00274:  DATA 00,00
00276:  DATA 41,43
00278:  DATA 4B,20
0027A:  DATA 4E,4F
0027C:  DATA 54,20
0027E:  DATA 43,4F
00280:  DATA 4D,45
00282:  DATA 0D,0A
00284:  DATA 00,00
00286:  DATA 41,43
00288:  DATA 4B,20
0028A:  DATA 4E,4F
0028C:  DATA 54,20
0028E:  DATA 43,4F
00290:  DATA 4D,45
00292:  DATA 0D,0A
00294:  DATA 00,00
00296:  DATA 41,43
00298:  DATA 4B,20
0029A:  DATA 4E,4F
0029C:  DATA 54,20
0029E:  DATA 43,4F
002A0:  DATA 4D,45
002A2:  DATA 20,66
002A4:  DATA 72,6F
002A6:  DATA 6D,20
002A8:  DATA 41,44
002AA:  DATA 43,53
002AC:  DATA 0D,0A
002AE:  DATA 00,00
002B0:  DATA 41,43
002B2:  DATA 4B,20
002B4:  DATA 4E,4F
002B6:  DATA 54,20
002B8:  DATA 43,4F
002BA:  DATA 4D,45
002BC:  DATA 20,66
002BE:  DATA 72,6F
002C0:  DATA 6D,20
002C2:  DATA 41,44
002C4:  DATA 43,53
002C6:  DATA 0D,0A
002C8:  DATA 00,00
002CA:  DATA 53,65
002CC:  DATA 6E,64
002CE:  DATA 69,6E
002D0:  DATA 67,20
002D2:  DATA 44,6F
002D4:  DATA 6E,65
002D6:  DATA 0D,0A
002D8:  DATA 00,00
002DA:  DATA 0D,0A
002DC:  DATA 53,41
002DE:  DATA 56,45
002E0:  DATA 20,43
002E2:  DATA 57,0D
002E4:  DATA 0A,00
002E6:  DATA 47,45
002E8:  DATA 54,20
002EA:  DATA 53,45
002EC:  DATA 4E,53
002EE:  DATA 4F,52
002F0:  DATA 20,44
002F2:  DATA 41,54
002F4:  DATA 41,0D
002F6:  DATA 0A,00
002F8:  DATA 47,45
002FA:  DATA 54,20
002FC:  DATA 52,45
002FE:  DATA 53,45
00300:  DATA 54,0D
00302:  DATA 0A,00
00304:  DATA 4E,4F
00306:  DATA 20,52
00308:  DATA 45,53
0030A:  DATA 45,54
0030C:  DATA 0D,0A
0030E:  DATA 00,00
00310:  DATA 0D,0A
00312:  DATA 43,57
00314:  DATA 3A,0D
00316:  DATA 0A,00
00318:  DATA 46,41
0031A:  DATA 42,20
0031C:  DATA 63,6F
0031E:  DATA 6D,6D
00320:  DATA 75,6E
00322:  DATA 69,63
00324:  DATA 61,74
00326:  DATA 69,6F
00328:  DATA 6E,20
0032A:  DATA 73,74
0032C:  DATA 61,72
0032E:  DATA 74,0D
00330:  DATA 0A,00
00332:  DATA 53,45
00334:  DATA 4E,44
00336:  DATA 49,4E
00338:  DATA 47,20
0033A:  DATA 43,4F
0033C:  DATA 4D,4D
0033E:  DATA 41,4E
00340:  DATA 44,20
00342:  DATA 54,4F
00344:  DATA 20,46
00346:  DATA 41,42
00348:  DATA 0D,0A
0034A:  DATA 00,00
0034C:  DATA 0D,0A
0034E:  DATA 43,6F
00350:  DATA 6C,6C
00352:  DATA 65,63
00354:  DATA 74,69
00356:  DATA 6E,67
00358:  DATA 20,48
0035A:  DATA 4B,20
0035C:  DATA 61,6E
0035E:  DATA 64,20
00360:  DATA 4D,61
00362:  DATA 6B,69
00364:  DATA 6E,67
00366:  DATA 20,43
00368:  DATA 57,46
0036A:  DATA 6F,72
0036C:  DATA 6D,61
0036E:  DATA 74,20
00370:  DATA 44,6F
00372:  DATA 6E,65
00374:  DATA 0D,0A
00376:  DATA 0D,0A
00378:  DATA 00,00
0037A:  DATA 0D,0A
0037C:  DATA 0D,0A
0037E:  DATA 53,65
00380:  DATA 6E,73
00382:  DATA 6F,72
00384:  DATA 3A,00
00386:  DATA 0D,0A
00388:  DATA 53,45
0038A:  DATA 4E,53
0038C:  DATA 4F,52
0038E:  DATA 20,53
00390:  DATA 41,56
00392:  DATA 49,4E
00394:  DATA 47,20
00396:  DATA 44,4F
00398:  DATA 4E,45
0039A:  DATA 0D,0A
0039C:  DATA 00,00
0039E:  DATA 4E,4F
003A0:  DATA 20,52
003A2:  DATA 45,53
003A4:  DATA 50,4F
003A6:  DATA 4E,53
003A8:  DATA 45,20
003AA:  DATA 46,52
003AC:  DATA 4F,4D
003AE:  DATA 20,46
003B0:  DATA 41,42
003B2:  DATA 0D,0A
003B4:  DATA 0D,0A
003B6:  DATA 00,00
003B8:  DATA 47,45
003BA:  DATA 54,20
003BC:  DATA 53,45
003BE:  DATA 4E,53
003C0:  DATA 4F,52
003C2:  DATA 20,44
003C4:  DATA 41,54
003C6:  DATA 41,0D
003C8:  DATA 0A,00
003CA:  DATA 47,45
003CC:  DATA 54,20
003CE:  DATA 52,45
003D0:  DATA 53,45
003D2:  DATA 54,0D
003D4:  DATA 0A,00
003D6:  DATA 4E,4F
003D8:  DATA 20,52
003DA:  DATA 45,53
003DC:  DATA 45,54
003DE:  DATA 0D,0A
003E0:  DATA 00,00
003E2:  DATA 0D,0A
003E4:  DATA 39,30
003E6:  DATA 73,65
003E8:  DATA 63,0D
003EA:  DATA 0A,00
003EC:  DATA 0D,0A
003EE:  DATA 53,75
003F0:  DATA 63,63
003F2:  DATA 65,73
003F4:  DATA 73,25
003F6:  DATA 78,0D
003F8:  DATA 0A,00
003FA:  DATA 0D,0A
003FC:  DATA 53,75
003FE:  DATA 63,63
00400:  DATA 65,73
00402:  DATA 73,25
00404:  DATA 78,0D
00406:  DATA 0A,00
00408:  DATA 43,41
0040A:  DATA 4D,20
0040C:  DATA 53,74
0040E:  DATA 61,72
00410:  DATA 74,0D
00412:  DATA 0A,00
00414:  DATA 44,65
00416:  DATA 6C,65
00418:  DATA 74,65
0041A:  DATA 20,42
0041C:  DATA 75,66
0041E:  DATA 66,65
00420:  DATA 72,0D
00422:  DATA 0A,00
00424:  DATA 54,75
00426:  DATA 72,6E
00428:  DATA 65,64
0042A:  DATA 20,4F
0042C:  DATA 6E,20
0042E:  DATA 4D,55
00430:  DATA 58,20
00432:  DATA 41,6E
00434:  DATA 64,20
00436:  DATA 43,41
00438:  DATA 4D,0D
0043A:  DATA 0A,00
0043C:  DATA 53,65
0043E:  DATA 6E,64
00440:  DATA 20,43
00442:  DATA 6F,6D
00444:  DATA 6D,61
00446:  DATA 6E,64
00448:  DATA 20,74
0044A:  DATA 6F,20
0044C:  DATA 43,41
0044E:  DATA 4D,0D
00450:  DATA 0A,00
00452:  DATA 41,43
00454:  DATA 4B,20
00456:  DATA 47,65
00458:  DATA 74,0D
0045A:  DATA 0A,0D
0045C:  DATA 0A,00
0045E:  DATA 57,61
00460:  DATA 69,74
00462:  DATA 20,4E
00464:  DATA 65,78
00466:  DATA 74,20
00468:  DATA 43,6F
0046A:  DATA 6D,6D
0046C:  DATA 61,6E
0046E:  DATA 64,2E
00470:  DATA 2E,2E
00472:  DATA 0D,0A
00474:  DATA 0D,0A
00476:  DATA 00,00
00478:  DATA 50,48
0047A:  DATA 4F,54
0047C:  DATA 4F,20
0047E:  DATA 53,41
00480:  DATA 56,49
00482:  DATA 4E,47
00484:  DATA 20,44
00486:  DATA 4F,4E
00488:  DATA 45,0D
0048A:  DATA 0A,00
0048C:  DATA 43,6F
0048E:  DATA 70,79
00490:  DATA 20,61
00492:  DATA 6E,64
00494:  DATA 20,52
00496:  DATA 65,61
00498:  DATA 64,20
0049A:  DATA 53,74
0049C:  DATA 61,72
0049E:  DATA 74,0D
004A0:  DATA 0A,00
004A2:  DATA 53,41
004A4:  DATA 56,49
004A6:  DATA 4E,47
004A8:  DATA 20,46
004AA:  DATA 41,49
004AC:  DATA 4C,55
004AE:  DATA 52,45
004B0:  DATA 44,0D
004B2:  DATA 0A,00
004B4:  DATA 41,43
004B6:  DATA 4B,20
004B8:  DATA 46,41
004BA:  DATA 49,4C
004BC:  DATA 55,52
004BE:  DATA 45,44
004C0:  DATA 0D,0A
004C2:  DATA 00,00
004C4:  DATA 54,75
004C6:  DATA 72,6E
004C8:  DATA 65,64
004CA:  DATA 20,4F
004CC:  DATA 46,46
004CE:  DATA 20,43
004D0:  DATA 41,4D
004D2:  DATA 0D,0A
004D4:  DATA 00,00
004D6:  DATA 54,72
004D8:  DATA 75,6E
004DA:  DATA 20,4F
004DC:  DATA 4E,20
004DE:  DATA 44,43
004E0:  DATA 4D,0D
004E2:  DATA 0A,00
004E4:  DATA 47,65
004E6:  DATA 74,20
004E8:  DATA 41,43
004EA:  DATA 4B,20
004EC:  DATA 46,72
004EE:  DATA 6F,6D
004F0:  DATA 20,44
004F2:  DATA 43,0D
004F4:  DATA 0A,00
004F6:  DATA 57,41
004F8:  DATA 49,54
004FA:  DATA 49,4E
004FC:  DATA 47,20
004FE:  DATA 4E,45
00500:  DATA 58,54
00502:  DATA 20,52
00504:  DATA 45,53
00506:  DATA 50,4F
00508:  DATA 4E,53
0050A:  DATA 45,0D
0050C:  DATA 0A,00
0050E:  DATA 44,43
00510:  DATA 20,57
00512:  DATA 4F,52
00514:  DATA 4B,49
00516:  DATA 4E,47
00518:  DATA 0D,0A
0051A:  DATA 00,00
0051C:  DATA 43,4F
0051E:  DATA 4D,20
00520:  DATA 46,4C
00522:  DATA 41,53
00524:  DATA 48,20
00526:  DATA 41,44
00528:  DATA 44,52
0052A:  DATA 45,53
0052C:  DATA 53,3A
0052E:  DATA 25,78
00530:  DATA 2C,20
00532:  DATA 53,74
00534:  DATA 61,74
00536:  DATA 75,73
00538:  DATA 3A,42
0053A:  DATA 42,20
0053C:  DATA 00,00
0053E:  DATA 46,41
00540:  DATA 49,4C
00542:  DATA 55,45
00544:  DATA 44,20
00546:  DATA 47,45
00548:  DATA 54,54
0054A:  DATA 49,4E
0054C:  DATA 47,20
0054E:  DATA 41,43
00550:  DATA 4B,20
00552:  DATA 46,72
00554:  DATA 6F,6D
00556:  DATA 20,44
00558:  DATA 43,0D
0055A:  DATA 0A,00
0055C:  DATA 43,4F
0055E:  DATA 4D,20
00560:  DATA 46,4C
00562:  DATA 41,53
00564:  DATA 48,20
00566:  DATA 41,44
00568:  DATA 44,52
0056A:  DATA 45,53
0056C:  DATA 53,3A
0056E:  DATA 25,78
00570:  DATA 2C,20
00572:  DATA 53,74
00574:  DATA 61,74
00576:  DATA 75,73
00578:  DATA 3A,43
0057A:  DATA 43,20
0057C:  DATA 00,00
0057E:  DATA 46,41
00580:  DATA 49,4C
00582:  DATA 55,45
00584:  DATA 44,20
00586:  DATA 47,45
00588:  DATA 54,54
0058A:  DATA 49,4E
0058C:  DATA 47,20
0058E:  DATA 41,43
00590:  DATA 4B,20
00592:  DATA 46,72
00594:  DATA 6F,6D
00596:  DATA 20,44
00598:  DATA 43,0D
0059A:  DATA 0A,00
0059C:  DATA 54,75
0059E:  DATA 72,6E
005A0:  DATA 20,4F
005A2:  DATA 46,46
005A4:  DATA 2E,2E
005A6:  DATA 2E,0D
005A8:  DATA 0A,00
005AA:  DATA 41,4E
005AC:  DATA 54,45
005AE:  DATA 4E,4E
005B0:  DATA 41,20
005B2:  DATA 44,45
005B4:  DATA 50,4C
005B6:  DATA 4F,59
005B8:  DATA 20,41
005BA:  DATA 54,54
005BC:  DATA 45,4D
005BE:  DATA 50,54
005C0:  DATA 3A,25
005C2:  DATA 78,0D
005C4:  DATA 0A,00
005C6:  DATA 50,41
005C8:  DATA 53,53
005CA:  DATA 45,44
005CC:  DATA 20,44
005CE:  DATA 41,59
005D0:  DATA 53,3A
005D2:  DATA 25,78
005D4:  DATA 0D,0A
005D6:  DATA 00,00
005D8:  DATA 52,45
005DA:  DATA 53,45
005DC:  DATA 52,56
005DE:  DATA 45,20
005E0:  DATA 43,48
005E2:  DATA 45,43
005E4:  DATA 4B,3A
005E6:  DATA 25,78
005E8:  DATA 0D,0A
005EA:  DATA 00,00
005EC:  DATA 0D,0A
005EE:  DATA 46,41
005F0:  DATA 42,20
005F2:  DATA 48,4B
005F4:  DATA 20,41
005F6:  DATA 44,44
005F8:  DATA 52,45
005FA:  DATA 53,53
005FC:  DATA 3A,25
005FE:  DATA 78,25
00600:  DATA 78,25
00602:  DATA 78,25
00604:  DATA 78,0D
00606:  DATA 0A,00
00608:  DATA 46,41
0060A:  DATA 42,20
0060C:  DATA 43,57
0060E:  DATA 20,41
00610:  DATA 44,44
00612:  DATA 52,45
00614:  DATA 53,53
00616:  DATA 3A,25
00618:  DATA 78,25
0061A:  DATA 78,25
0061C:  DATA 78,25
0061E:  DATA 78,0D
00620:  DATA 0A,00
00622:  DATA 41,44
00624:  DATA 43,53
00626:  DATA 20,53
00628:  DATA 45,4E
0062A:  DATA 53,4F
0062C:  DATA 52,20
0062E:  DATA 41,44
00630:  DATA 44,52
00632:  DATA 45,53
00634:  DATA 53,3A
00636:  DATA 25,78
00638:  DATA 25,78
0063A:  DATA 25,78
0063C:  DATA 25,78
0063E:  DATA 0D,0A
00640:  DATA 00,00
00642:  DATA 43,41
00644:  DATA 4D,20
00646:  DATA 41,44
00648:  DATA 44,52
0064A:  DATA 45,53
0064C:  DATA 53,3A
0064E:  DATA 25,78
00650:  DATA 25,78
00652:  DATA 25,78
00654:  DATA 25,78
00656:  DATA 0D,0A
00658:  DATA 00,00
0065A:  DATA 44,43
0065C:  DATA 20,41
0065E:  DATA 44,44
00660:  DATA 52,45
00662:  DATA 53,53
00664:  DATA 3A,25
00666:  DATA 78,25
00668:  DATA 78,25
0066A:  DATA 78,25
0066C:  DATA 78,0D
0066E:  DATA 0A,00
00670:  DATA 4D,41
00672:  DATA 49,4E
00674:  DATA 20,46
00676:  DATA 4C,41
00678:  DATA 53,48
0067A:  DATA 20,43
0067C:  DATA 57,20
0067E:  DATA 41,44
00680:  DATA 44,45
00682:  DATA 52,53
00684:  DATA 53,3A
00686:  DATA 25,78
00688:  DATA 25,78
0068A:  DATA 25,78
0068C:  DATA 25,78
0068E:  DATA 0D,0A
00690:  DATA 00,00
00692:  DATA 48,49
00694:  DATA 47,48
00696:  DATA 20,53
00698:  DATA 41,4D
0069A:  DATA 50,20
0069C:  DATA 48,4B
0069E:  DATA 20,41
006A0:  DATA 44,44
006A2:  DATA 45,52
006A4:  DATA 53,53
006A6:  DATA 3A,25
006A8:  DATA 78,25
006AA:  DATA 78,25
006AC:  DATA 78,25
006AE:  DATA 78,0D
006B0:  DATA 0A,00
006B2:  DATA 41,4E
006B4:  DATA 54,45
006B6:  DATA 4E,4E
006B8:  DATA 41,20
006BA:  DATA 44,45
006BC:  DATA 50,4C
006BE:  DATA 4F,59
006C0:  DATA 20,41
006C2:  DATA 54,54
006C4:  DATA 45,4D
006C6:  DATA 50,54
006C8:  DATA 3A,25
006CA:  DATA 78,0D
006CC:  DATA 0A,00
006CE:  DATA 42,43
006D0:  DATA 3D,25
006D2:  DATA 78,00
006D4:  DATA 53,74
006D6:  DATA 6F,72
006D8:  DATA 65,69
006DA:  DATA 6E,67
006DC:  DATA 20,46
006DE:  DATA 4C,41
006E0:  DATA 47,20
006E2:  DATA 49,4E
006E4:  DATA 46,4F
006E6:  DATA 20,44
006E8:  DATA 4F,4E
006EA:  DATA 45,0D
006EC:  DATA 0A,00
006EE:  DATA 53,74
006F0:  DATA 61,72
006F2:  DATA 74,20
006F4:  DATA 53,74
006F6:  DATA 6F,72
006F8:  DATA 65,69
006FA:  DATA 6E,67
006FC:  DATA 0D,0A
006FE:  DATA 00,00
00700:  DATA 53,74
00702:  DATA 6F,72
00704:  DATA 65,69
00706:  DATA 6E,67
00708:  DATA 20,41
0070A:  DATA 44,44
0070C:  DATA 20,44
0070E:  DATA 4F,4E
00710:  DATA 45,0D
00712:  DATA 0A,00
00714:  DATA 45,52
00716:  DATA 41,53
00718:  DATA 45,20
0071A:  DATA 53,54
0071C:  DATA 41,52
0071E:  DATA 54,0D
00720:  DATA 0A,00
00722:  DATA 44,4F
00724:  DATA 4E,45
00726:  DATA 00,00
00728:  DATA 53,45
0072A:  DATA 4E,44
0072C:  DATA 20,52
0072E:  DATA 45,53
00730:  DATA 45,54
00732:  DATA 20,43
00734:  DATA 4F,4D
00736:  DATA 4D,41
00738:  DATA 4E,44
0073A:  DATA 20,54
0073C:  DATA 4F,20
0073E:  DATA 52,45
00740:  DATA 53,45
00742:  DATA 54,50
00744:  DATA 49,43
00746:  DATA 0D,0A
00748:  DATA 00,00
0074A:  DATA 52,45
0074C:  DATA 53,45
0074E:  DATA 52,56
00750:  DATA 45,5F
00752:  DATA 43,48
00754:  DATA 45,43
00756:  DATA 4B,20
00758:  DATA 3D,20
0075A:  DATA 25,78
0075C:  DATA 0D,0A
0075E:  DATA 00,00
00760:  DATA 4E,45
00762:  DATA 58,54
00764:  DATA 20,4D
00766:  DATA 49,53
00768:  DATA 53,49
0076A:  DATA 4F,4E
0076C:  DATA 5F,43
0076E:  DATA 4F,4E
00770:  DATA 54,45
00772:  DATA 4E,54
00774:  DATA 53,20
00776:  DATA 3D,20
00778:  DATA 25,78
0077A:  DATA 0D,0A
0077C:  DATA 00,00
0077E:  DATA 52,45
00780:  DATA 53,45
00782:  DATA 52,56
00784:  DATA 45,5F
00786:  DATA 54,41
00788:  DATA 52,47
0078A:  DATA 45,54
0078C:  DATA 5F,46
0078E:  DATA 4C,41
00790:  DATA 47,20
00792:  DATA 3D,20
00794:  DATA 25,78
00796:  DATA 0D,0A
00798:  DATA 00,00
0079A:  DATA 52,45
0079C:  DATA 53,45
0079E:  DATA 52,56
007A0:  DATA 45,5F
007A2:  DATA 4D,49
007A4:  DATA 4E,5F
007A6:  DATA 46,4C
007A8:  DATA 41,47
007AA:  DATA 20,3D
007AC:  DATA 20,25
007AE:  DATA 78,0D
007B0:  DATA 0A,00
007B2:  DATA 74,61
007B4:  DATA 62,6C
007B6:  DATA 65,5F
007B8:  DATA 6E,75
007BA:  DATA 6D,20
007BC:  DATA 3D,20
007BE:  DATA 25,64
007C0:  DATA 0D,0A
007C2:  DATA 00,00
007C4:  DATA 52,65
007C6:  DATA 73,65
007C8:  DATA 72,76
007CA:  DATA 61,74
007CC:  DATA 69,6F
007CE:  DATA 6E,20
007D0:  DATA 46,75
007D2:  DATA 6C,6C
007D4:  DATA 21,0D
007D6:  DATA 0A,0D
007D8:  DATA 0A,00
007DA:  DATA 52,65
007DC:  DATA 73,65
007DE:  DATA 72,76
007E0:  DATA 61,74
007E2:  DATA 69,6F
007E4:  DATA 6E,20
007E6:  DATA 46,75
007E8:  DATA 6C,6C
007EA:  DATA 21,0D
007EC:  DATA 0A,0D
007EE:  DATA 0A,00
007F0:  DATA 72,65
007F2:  DATA 6D,6F
007F4:  DATA 76,65
007F6:  DATA 20,66
007F8:  DATA 69,6E
007FA:  DATA 69,73
007FC:  DATA 68,65
007FE:  DATA 64,20
00800:  DATA 63,6F
00802:  DATA 6D,6D
00804:  DATA 61,6E
00806:  DATA 64,3A
00808:  DATA 00,00
0080A:  DATA 72,65
0080C:  DATA 73,65
0080E:  DATA 72,76
00810:  DATA 65,0D
00812:  DATA 0A,00
00814:  DATA 72,65
00816:  DATA 73,65
00818:  DATA 72,76
0081A:  DATA 65,0D
0081C:  DATA 0A,00
0081E:  DATA 72,65
00820:  DATA 73,65
00822:  DATA 72,76
00824:  DATA 65,20
00826:  DATA 6E,65
00828:  DATA 78,74
0082A:  DATA 0D,0A
0082C:  DATA 00,00
*
00852:  DATA 44,6F
00854:  DATA 77,6E
00856:  DATA 6C,6F
00858:  DATA 61,64
0085A:  DATA 20,73
0085C:  DATA 61,74
0085E:  DATA 65,6C
00860:  DATA 6C,69
00862:  DATA 74,65
00864:  DATA 20,64
00866:  DATA 61,74
00868:  DATA 61,20
0086A:  DATA 6D,61
0086C:  DATA 6E,75
0086E:  DATA 61,6C
00870:  DATA 6C,79
00872:  DATA 2E,0D
00874:  DATA 0A,00
00876:  DATA 50,6C
00878:  DATA 65,61
0087A:  DATA 73,65
0087C:  DATA 20,69
0087E:  DATA 6E,70
00880:  DATA 75,74
00882:  DATA 20,61
00884:  DATA 64,64
00886:  DATA 72,65
00888:  DATA 73,73
0088A:  DATA 20,6E
0088C:  DATA 75,6D
0088E:  DATA 62,65
00890:  DATA 72,0D
00892:  DATA 0A,00
00894:  DATA 49,73
00896:  DATA 20,74
00898:  DATA 68,65
0089A:  DATA 20,61
0089C:  DATA 64,64
0089E:  DATA 72,65
008A0:  DATA 73,73
008A2:  DATA 20,63
008A4:  DATA 6F,72
008A6:  DATA 72,65
008A8:  DATA 63,74
008AA:  DATA 3F,28
008AC:  DATA 79,65
008AE:  DATA 73,3A
008B0:  DATA 30,31
008B2:  DATA 2C,20
008B4:  DATA 6E,6F
008B6:  DATA 3A,30
008B8:  DATA 32,29
008BA:  DATA 0D,0A
008BC:  DATA 00,00
008BE:  DATA 50,6C
008C0:  DATA 65,61
008C2:  DATA 73,65
008C4:  DATA 20,69
008C6:  DATA 6E,70
008C8:  DATA 75,74
008CA:  DATA 20,64
008CC:  DATA 61,74
008CE:  DATA 61,20
008D0:  DATA 73,69
008D2:  DATA 7A,65
008D4:  DATA 20,69
008D6:  DATA 6E,66
008D8:  DATA 6F,72
008DA:  DATA 6D,61
008DC:  DATA 74,69
008DE:  DATA 6F,6E
008E0:  DATA 20,0D
008E2:  DATA 0A,00
008E4:  DATA 49,73
008E6:  DATA 20,74
008E8:  DATA 68,65
008EA:  DATA 20,64
008EC:  DATA 61,74
008EE:  DATA 61,20
008F0:  DATA 73,69
008F2:  DATA 7A,65
008F4:  DATA 20,63
008F6:  DATA 6F,72
008F8:  DATA 72,65
008FA:  DATA 63,74
008FC:  DATA 3F,28
008FE:  DATA 79,65
00900:  DATA 73,3A
00902:  DATA 30,31
00904:  DATA 2C,20
00906:  DATA 6E,6F
00908:  DATA 3A,30
0090A:  DATA 32,29
0090C:  DATA 0D,0A
0090E:  DATA 00,00
*
00922:  MOVLB  2
00924:  MOVF   x0D,W
00926:  BTFSC  FD8.2
00928:  BRA    0A0C
0092A:  MOVWF  00
0092C:  MOVF   x11,W
0092E:  BTFSC  FD8.2
00930:  BRA    0A0C
00932:  ADDWF  00,F
00934:  BNC   093E
00936:  MOVLW  81
00938:  ADDWF  00,F
0093A:  BC    0A0C
0093C:  BRA    0946
0093E:  MOVLW  7F
00940:  SUBWF  00,F
00942:  BNC   0A0C
00944:  BZ    0A0C
00946:  MOVFF  20E,215
0094A:  MOVF   x12,W
0094C:  XORWF  x15,F
0094E:  BSF    x0E.7
00950:  BSF    x12.7
00952:  MOVF   x10,W
00954:  MULWF  x14
00956:  MOVFF  FF4,217
0095A:  MOVF   x0F,W
0095C:  MULWF  x13
0095E:  MOVFF  FF4,03
00962:  MOVFF  FF3,216
00966:  MULWF  x14
00968:  MOVF   FF3,W
0096A:  ADDWF  x17,F
0096C:  MOVF   FF4,W
0096E:  ADDWFC x16,F
00970:  MOVLW  00
00972:  ADDWFC 03,F
00974:  MOVF   x10,W
00976:  MULWF  x13
00978:  MOVF   FF3,W
0097A:  ADDWF  x17,F
0097C:  MOVF   FF4,W
0097E:  ADDWFC x16,F
00980:  MOVLW  00
00982:  CLRF   02
00984:  ADDWFC 03,F
00986:  ADDWFC 02,F
00988:  MOVF   x0E,W
0098A:  MULWF  x14
0098C:  MOVF   FF3,W
0098E:  ADDWF  x16,F
00990:  MOVF   FF4,W
00992:  ADDWFC 03,F
00994:  MOVLW  00
00996:  ADDWFC 02,F
00998:  MOVF   x0E,W
0099A:  MULWF  x13
0099C:  MOVF   FF3,W
0099E:  ADDWF  03,F
009A0:  MOVF   FF4,W
009A2:  ADDWFC 02,F
009A4:  MOVLW  00
009A6:  CLRF   01
009A8:  ADDWFC 01,F
009AA:  MOVF   x10,W
009AC:  MULWF  x12
009AE:  MOVF   FF3,W
009B0:  ADDWF  x16,F
009B2:  MOVF   FF4,W
009B4:  ADDWFC 03,F
009B6:  MOVLW  00
009B8:  ADDWFC 02,F
009BA:  ADDWFC 01,F
009BC:  MOVF   x0F,W
009BE:  MULWF  x12
009C0:  MOVF   FF3,W
009C2:  ADDWF  03,F
009C4:  MOVF   FF4,W
009C6:  ADDWFC 02,F
009C8:  MOVLW  00
009CA:  ADDWFC 01,F
009CC:  MOVF   x0E,W
009CE:  MULWF  x12
009D0:  MOVF   FF3,W
009D2:  ADDWF  02,F
009D4:  MOVF   FF4,W
009D6:  ADDWFC 01,F
009D8:  INCF   00,F
009DA:  BTFSC  01.7
009DC:  BRA    09E8
009DE:  RLCF   x16,F
009E0:  RLCF   03,F
009E2:  RLCF   02,F
009E4:  RLCF   01,F
009E6:  DECF   00,F
009E8:  MOVLW  00
009EA:  BTFSS  x16.7
009EC:  BRA    0A02
009EE:  INCF   03,F
009F0:  ADDWFC 02,F
009F2:  ADDWFC 01,F
009F4:  MOVF   01,W
009F6:  BNZ   0A02
009F8:  MOVF   02,W
009FA:  BNZ   0A02
009FC:  MOVF   03,W
009FE:  BNZ   0A02
00A00:  INCF   00,F
00A02:  BTFSC  x15.7
00A04:  BSF    01.7
00A06:  BTFSS  x15.7
00A08:  BCF    01.7
00A0A:  BRA    0A14
00A0C:  CLRF   00
00A0E:  CLRF   01
00A10:  CLRF   02
00A12:  CLRF   03
00A14:  MOVLB  0
00A16:  GOTO   0B1E (RETURN)
00A1A:  MOVLB  2
00A1C:  MOVF   x0D,W
00A1E:  SUBLW  B6
00A20:  MOVWF  x0D
00A22:  CLRF   03
00A24:  MOVFF  20E,211
00A28:  BSF    x0E.7
00A2A:  BCF    FD8.0
00A2C:  RRCF   x0E,F
00A2E:  RRCF   x0F,F
00A30:  RRCF   x10,F
00A32:  RRCF   03,F
00A34:  RRCF   02,F
00A36:  RRCF   01,F
00A38:  RRCF   00,F
00A3A:  DECFSZ x0D,F
00A3C:  BRA    0A2A
00A3E:  BTFSS  x11.7
00A40:  BRA    0A58
00A42:  COMF   00,F
00A44:  COMF   01,F
00A46:  COMF   02,F
00A48:  COMF   03,F
00A4A:  INCF   00,F
00A4C:  BTFSC  FD8.2
00A4E:  INCF   01,F
00A50:  BTFSC  FD8.2
00A52:  INCF   02,F
00A54:  BTFSC  FD8.2
00A56:  INCF   03,F
00A58:  MOVLB  0
00A5A:  GOTO   0B48 (RETURN)
00A5E:  BTFSC  FD8.1
00A60:  BRA    0A6A
00A62:  MOVLW  02
00A64:  MOVWF  FEA
00A66:  MOVLW  15
00A68:  MOVWF  FE9
00A6A:  CLRF   00
00A6C:  CLRF   01
00A6E:  CLRF   02
00A70:  CLRF   03
00A72:  MOVLB  2
00A74:  CLRF   x15
00A76:  CLRF   x16
00A78:  CLRF   x17
00A7A:  CLRF   x18
00A7C:  MOVF   x14,W
00A7E:  IORWF  x13,W
00A80:  IORWF  x12,W
00A82:  IORWF  x11,W
00A84:  BZ    0ADE
00A86:  MOVLW  20
00A88:  MOVWF  x19
00A8A:  BCF    FD8.0
00A8C:  RLCF   x0D,F
00A8E:  RLCF   x0E,F
00A90:  RLCF   x0F,F
00A92:  RLCF   x10,F
00A94:  RLCF   x15,F
00A96:  RLCF   x16,F
00A98:  RLCF   x17,F
00A9A:  RLCF   x18,F
00A9C:  MOVF   x14,W
00A9E:  SUBWF  x18,W
00AA0:  BNZ   0AB2
00AA2:  MOVF   x13,W
00AA4:  SUBWF  x17,W
00AA6:  BNZ   0AB2
00AA8:  MOVF   x12,W
00AAA:  SUBWF  x16,W
00AAC:  BNZ   0AB2
00AAE:  MOVF   x11,W
00AB0:  SUBWF  x15,W
00AB2:  BNC   0AD2
00AB4:  MOVF   x11,W
00AB6:  SUBWF  x15,F
00AB8:  MOVF   x12,W
00ABA:  BTFSS  FD8.0
00ABC:  INCFSZ x12,W
00ABE:  SUBWF  x16,F
00AC0:  MOVF   x13,W
00AC2:  BTFSS  FD8.0
00AC4:  INCFSZ x13,W
00AC6:  SUBWF  x17,F
00AC8:  MOVF   x14,W
00ACA:  BTFSS  FD8.0
00ACC:  INCFSZ x14,W
00ACE:  SUBWF  x18,F
00AD0:  BSF    FD8.0
00AD2:  RLCF   00,F
00AD4:  RLCF   01,F
00AD6:  RLCF   02,F
00AD8:  RLCF   03,F
00ADA:  DECFSZ x19,F
00ADC:  BRA    0A8A
00ADE:  MOVFF  215,FEF
00AE2:  MOVFF  216,FEC
00AE6:  MOVFF  217,FEC
00AEA:  MOVFF  218,FEC
00AEE:  MOVLB  0
00AF0:  RETURN 0
00AF2:  MOVF   FE9,W
00AF4:  MOVLB  2
00AF6:  MOVWF  x01
00AF8:  MOVF   x00,W
00AFA:  MOVWF  x03
00AFC:  BZ    0B34
00AFE:  MOVFF  1FF,210
00B02:  MOVFF  1FE,20F
00B06:  MOVFF  1FD,20E
00B0A:  MOVFF  1FC,20D
00B0E:  CLRF   x14
00B10:  CLRF   x13
00B12:  MOVLW  20
00B14:  MOVWF  x12
00B16:  MOVLW  82
00B18:  MOVWF  x11
00B1A:  MOVLB  0
00B1C:  BRA    0922
00B1E:  MOVFF  03,1FF
00B22:  MOVFF  02,1FE
00B26:  MOVFF  01,1FD
00B2A:  MOVFF  00,1FC
00B2E:  MOVLB  2
00B30:  DECFSZ x03,F
00B32:  BRA    0AFE
00B34:  MOVFF  1FF,210
00B38:  MOVFF  1FE,20F
00B3C:  MOVFF  1FD,20E
00B40:  MOVFF  1FC,20D
00B44:  MOVLB  0
00B46:  BRA    0A1A
00B48:  MOVFF  03,1FF
00B4C:  MOVFF  02,1FE
00B50:  MOVFF  01,1FD
00B54:  MOVFF  00,1FC
00B58:  MOVLB  1
00B5A:  BTFSS  xFF.7
00B5C:  BRA    0B7C
00B5E:  MOVLB  2
00B60:  DECF   x01,F
00B62:  BSF    x01.5
00B64:  MOVLB  1
00B66:  COMF   xFC,F
00B68:  COMF   xFD,F
00B6A:  COMF   xFE,F
00B6C:  COMF   xFF,F
00B6E:  INCF   xFC,F
00B70:  BTFSC  FD8.2
00B72:  INCF   xFD,F
00B74:  BTFSC  FD8.2
00B76:  INCF   xFE,F
00B78:  BTFSC  FD8.2
00B7A:  INCF   xFF,F
00B7C:  MOVLW  3B
00B7E:  MOVLB  2
00B80:  MOVWF  x08
00B82:  MOVLW  9A
00B84:  MOVWF  x07
00B86:  MOVLW  CA
00B88:  MOVWF  x06
00B8A:  CLRF   x05
00B8C:  MOVLW  0A
00B8E:  MOVWF  x03
00B90:  MOVF   x00,W
00B92:  BTFSC  FD8.2
00B94:  INCF   x01,F
00B96:  BSF    FD8.1
00B98:  MOVLW  01
00B9A:  MOVWF  FEA
00B9C:  MOVLW  FC
00B9E:  MOVWF  FE9
00BA0:  MOVFF  1FF,210
00BA4:  MOVFF  1FE,20F
00BA8:  MOVFF  1FD,20E
00BAC:  MOVFF  1FC,20D
00BB0:  MOVFF  208,214
00BB4:  MOVFF  207,213
00BB8:  MOVFF  206,212
00BBC:  MOVFF  205,211
00BC0:  MOVLB  0
00BC2:  RCALL  0A5E
00BC4:  MOVF   01,W
00BC6:  MOVF   00,F
00BC8:  BNZ   0BF0
00BCA:  MOVLB  2
00BCC:  INCF   x00,W
00BCE:  SUBWF  x03,W
00BD0:  BTFSS  FD8.2
00BD2:  BRA    0BD8
00BD4:  MOVLB  0
00BD6:  BRA    0BF0
00BD8:  MOVF   x01,W
00BDA:  BZ    0BF6
00BDC:  ANDLW  0F
00BDE:  SUBWF  x03,W
00BE0:  BZ    0BE4
00BE2:  BC    0C5C
00BE4:  BTFSC  x01.7
00BE6:  BRA    0C5C
00BE8:  BTFSC  x01.6
00BEA:  BRA    0BF6
00BEC:  MOVLW  20
00BEE:  BRA    0C52
00BF0:  MOVLW  20
00BF2:  MOVLB  2
00BF4:  ANDWF  x01,F
00BF6:  BTFSS  x01.5
00BF8:  BRA    0C14
00BFA:  BCF    x01.5
00BFC:  MOVF   x00,W
00BFE:  BTFSS  FD8.2
00C00:  DECF   x01,F
00C02:  MOVF   00,W
00C04:  MOVWF  x01
00C06:  MOVLW  2D
00C08:  BTFSS  F9E.4
00C0A:  BRA    0C08
00C0C:  MOVWF  FAD
00C0E:  MOVF   x01,W
00C10:  MOVWF  00
00C12:  CLRF   x01
00C14:  MOVF   x00,W
00C16:  SUBWF  x03,W
00C18:  BNZ   0C30
00C1A:  MOVF   00,W
00C1C:  MOVWF  x01
00C1E:  MOVLW  2E
00C20:  BTFSS  F9E.4
00C22:  BRA    0C20
00C24:  MOVWF  FAD
00C26:  MOVF   x01,W
00C28:  MOVWF  00
00C2A:  MOVLW  20
00C2C:  ANDWF  x01,F
00C2E:  MOVLW  00
00C30:  MOVLW  30
00C32:  BTFSS  x01.5
00C34:  BRA    0C52
00C36:  BCF    x01.5
00C38:  MOVF   x00,W
00C3A:  BTFSS  FD8.2
00C3C:  DECF   x01,F
00C3E:  MOVF   00,W
00C40:  MOVWF  x01
00C42:  MOVLW  2D
00C44:  BTFSS  F9E.4
00C46:  BRA    0C44
00C48:  MOVWF  FAD
00C4A:  MOVF   x01,W
00C4C:  MOVWF  00
00C4E:  CLRF   x01
00C50:  MOVLW  30
00C52:  ADDWF  00,F
00C54:  MOVF   00,W
00C56:  BTFSS  F9E.4
00C58:  BRA    0C56
00C5A:  MOVWF  FAD
00C5C:  BCF    FD8.1
00C5E:  MOVFF  208,210
00C62:  MOVFF  207,20F
00C66:  MOVFF  206,20E
00C6A:  MOVFF  205,20D
00C6E:  CLRF   x14
00C70:  CLRF   x13
00C72:  CLRF   x12
00C74:  MOVLW  0A
00C76:  MOVWF  x11
00C78:  MOVLB  0
00C7A:  RCALL  0A5E
00C7C:  MOVFF  03,208
00C80:  MOVFF  02,207
00C84:  MOVFF  01,206
00C88:  MOVFF  00,205
00C8C:  MOVLB  2
00C8E:  DECFSZ x03,F
00C90:  BRA    0B96
00C92:  MOVLB  0
00C94:  GOTO   1028 (RETURN)
*
00CC4:  MOVF   FE9,W
00CC6:  MOVLB  2
00CC8:  MOVWF  x00
00CCA:  MOVLB  1
00CCC:  BTFSS  xFF.7
00CCE:  BRA    0CEE
00CD0:  MOVLB  2
00CD2:  DECF   x00,F
00CD4:  BSF    x00.5
00CD6:  MOVLB  1
00CD8:  COMF   xFC,F
00CDA:  COMF   xFD,F
00CDC:  COMF   xFE,F
00CDE:  COMF   xFF,F
00CE0:  INCF   xFC,F
00CE2:  BTFSC  FD8.2
00CE4:  INCF   xFD,F
00CE6:  BTFSC  FD8.2
00CE8:  INCF   xFE,F
00CEA:  BTFSC  FD8.2
00CEC:  INCF   xFF,F
00CEE:  MOVLW  3B
00CF0:  MOVLB  2
00CF2:  MOVWF  x07
00CF4:  MOVLW  9A
00CF6:  MOVWF  x06
00CF8:  MOVLW  CA
00CFA:  MOVWF  x05
00CFC:  CLRF   x04
00CFE:  MOVLW  0A
00D00:  MOVWF  x02
00D02:  BSF    FD8.1
00D04:  MOVLW  01
00D06:  MOVWF  FEA
00D08:  MOVLW  FC
00D0A:  MOVWF  FE9
00D0C:  MOVFF  1FF,210
00D10:  MOVFF  1FE,20F
00D14:  MOVFF  1FD,20E
00D18:  MOVFF  1FC,20D
00D1C:  MOVFF  207,214
00D20:  MOVFF  206,213
00D24:  MOVFF  205,212
00D28:  MOVFF  204,211
00D2C:  MOVLB  0
00D2E:  RCALL  0A5E
00D30:  MOVF   01,W
00D32:  MOVF   00,F
00D34:  BNZ   0D5C
00D36:  MOVLB  2
00D38:  MOVF   x02,W
00D3A:  XORLW  01
00D3C:  BTFSS  FD8.2
00D3E:  BRA    0D44
00D40:  MOVLB  0
00D42:  BRA    0D5C
00D44:  MOVF   x00,W
00D46:  BZ    0D62
00D48:  ANDLW  0F
00D4A:  SUBWF  x02,W
00D4C:  BZ    0D50
00D4E:  BC    0DA0
00D50:  BTFSC  x00.7
00D52:  BRA    0DA0
00D54:  BTFSC  x00.6
00D56:  BRA    0D62
00D58:  MOVLW  20
00D5A:  BRA    0D96
00D5C:  MOVLW  20
00D5E:  MOVLB  2
00D60:  ANDWF  x00,F
00D62:  BTFSS  x00.5
00D64:  BRA    0D7A
00D66:  BCF    x00.5
00D68:  MOVFF  00,200
00D6C:  MOVLW  2D
00D6E:  BTFSS  F9E.4
00D70:  BRA    0D6E
00D72:  MOVWF  FAD
00D74:  MOVFF  200,00
00D78:  CLRF   x00
00D7A:  MOVLW  30
00D7C:  BTFSS  x00.5
00D7E:  BRA    0D96
00D80:  BCF    x00.5
00D82:  MOVFF  00,200
00D86:  MOVLW  2D
00D88:  BTFSS  F9E.4
00D8A:  BRA    0D88
00D8C:  MOVWF  FAD
00D8E:  MOVFF  200,00
00D92:  CLRF   x00
00D94:  MOVLW  30
00D96:  ADDWF  00,F
00D98:  MOVF   00,W
00D9A:  BTFSS  F9E.4
00D9C:  BRA    0D9A
00D9E:  MOVWF  FAD
00DA0:  BCF    FD8.1
00DA2:  MOVFF  207,210
00DA6:  MOVFF  206,20F
00DAA:  MOVFF  205,20E
00DAE:  MOVFF  204,20D
00DB2:  CLRF   x14
00DB4:  CLRF   x13
00DB6:  CLRF   x12
00DB8:  MOVLW  0A
00DBA:  MOVWF  x11
00DBC:  MOVLB  0
00DBE:  RCALL  0A5E
00DC0:  MOVFF  03,207
00DC4:  MOVFF  02,206
00DC8:  MOVFF  01,205
00DCC:  MOVFF  00,204
00DD0:  MOVLB  2
00DD2:  DECFSZ x02,F
00DD4:  BRA    0D02
00DD6:  MOVLB  0
00DD8:  GOTO   1082 (RETURN)
....................  
.................... #list 
....................  
.................... #FUSES NOWDT NOBROWNOUT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
00C98:  MOVLW  01
00C9A:  MOVWF  FEA
00C9C:  MOVLW  FD
00C9E:  MOVWF  FE9
00CA0:  MOVF   FEF,W
00CA2:  BZ    0CC0
00CA4:  MOVLW  05
00CA6:  MOVWF  01
00CA8:  CLRF   00
00CAA:  DECFSZ 00,F
00CAC:  BRA    0CAA
00CAE:  DECFSZ 01,F
00CB0:  BRA    0CA8
00CB2:  MOVLW  2E
00CB4:  MOVWF  00
00CB6:  DECFSZ 00,F
00CB8:  BRA    0CB6
00CBA:  BRA    0CBC
00CBC:  DECFSZ FEF,F
00CBE:  BRA    0CA4
00CC0:  GOTO   1046 (RETURN)
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
....................  
.................... //#include<HAMING_CORRECT.h> 
.................... //#org 0x100, 0x11000 DEFAULT  
.................... //#org DEFAULT  
....................  
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------- 
.................... #pin_select TX1=PIN_C6 
.................... #pin_select RX1=PIN_C7 
.................... //#pin_select TX1=PIN_G0 
.................... //#pin_select RX1=PIN_G1 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc) // MAIN to MISSION BOARD(Now just putted) 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_B7,rcv=PIN_B6,bits=8,stream=pc) 
....................  
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com) // Main to COM PIC 
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab) //MAIN to FAB PIC 
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset) //MAIN to RESET PIC 
....................  
.................... #use rs232(baud=19200,parity=N,xmit=pin_F7,rcv=pin_F6,bits=8,stream=ADCS) //MAIN to ADCS 
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=CAM) //MAIN to CAM 
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC) //MAIN to DCM 
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0) //MAIN flash memory port 
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0) //COM flash memory port 
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0) //MISSION flash memory port 
.................... //-------------PWM Settings---------------------------------------------------- 
....................  
.................... //#pin_select p2a=PIN_c2 //set c2 as ccp2 
.................... //#use pwm(CCP2,TIMER=2,FREQUENCY=1000)//set frequency of ccp2 
....................  
....................  
.................... //-------------mainpic_function.c---------------------------------------------- 
....................  
.................... #include<mainpic_function.h> 
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c> // OBC MAIN FLASH 
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
....................  
....................  
....................  
.................... void WRITE_ENABLE_OF(){ 
....................  output_low(CS_PIN); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);   
....................  return; 
.................... } 
.................... void WRITE_ENABLE_SCF(){ 
....................  output_low(CS_PIN_2); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);   
....................  return; 
.................... } 
.................... void WRITE_ENABLE_SMF(){ 
....................  output_low(CS_PIN_3); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);   
....................  return; 
.................... } 
....................  
.................... void sector_erase_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
....................    output_low(CS_PIN_3);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(100);   
....................     
....................    return; 
.................... } 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(10);   
....................     
....................    return; 
.................... } 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
....................    output_low(CS_PIN_3);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
....................    output_low(CS_PIN_3);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
.................... void ALL_SECTOR_ERASE_OF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_OF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
.................... void ALL_SECTOR_ERASE_SCF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SCF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
.................... void ALL_SECTOR_ERASE_SMF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SMF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE); //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);        //take CS PIN higher back 
....................  
....................    delay_us(5);   
....................     
....................    return; 
.................... } 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);           //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE); //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_2,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);        //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_SMF(); 
....................    output_low(CS_PIN_3);           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE); //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
....................    spi_xfer(SPIPORT_3,adsress[1]);     
....................    spi_xfer(SPIPORT_3,adsress[2]);     
....................    spi_xfer(SPIPORT_3,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_3,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);        //take CS PIN higher back 
....................  
....................    delay_us(10);   
....................     
....................    return; 
.................... } 
....................  
.................... int8 READ_CHIP_ID_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
.................... int8 READ_CHIP_ID_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_2,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_2); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
.................... int8 READ_CHIP_ID_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_3,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_3); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
.................... int8 READ_STATUS_REGISTER_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
.................... int8 READ_STATUS_REGISTER_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_2,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_2); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
.................... int8 READ_STATUS_REGISTER_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_3,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_3); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN);                 //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT,READ_DATA_BYTES);  //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT,adsress[0]); 
....................  spi_xfer(SPIPORT,adsress[1]); 
....................  spi_xfer(SPIPORT,adsress[2]); 
....................  spi_xfer(SPIPORT,adsress[3]); 
....................  data = spi_xfer(SPIPORT); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);               //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_2);                 //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_2,READ_DATA_BYTES);  //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT_2,adsress[0]); 
....................  spi_xfer(SPIPORT_2,adsress[1]); 
....................  spi_xfer(SPIPORT_2,adsress[2]); 
....................  spi_xfer(SPIPORT_2,adsress[3]); 
....................  data = spi_xfer(SPIPORT_2); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);               //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_3);                 //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_3,READ_DATA_BYTES);  //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT_3,adsress[0]); 
....................  spi_xfer(SPIPORT_3,adsress[1]); 
....................  spi_xfer(SPIPORT_3,adsress[2]); 
....................  spi_xfer(SPIPORT_3,adsress[3]); 
....................  data = spi_xfer(SPIPORT_3); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);               //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................    return;  
.................... } 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADDRES,0x77); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADDRES,0x69); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADDRES,0x55); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_SCF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... #include<mainpic_function.c> 
.................... //caution 
.................... //port of kbhit in CAM Mission is PC-- 
.................... //TRANSFER_DATA_NBYTE_TOPC_SCF(65536,65536); is comment out-- 
.................... //adcs address test make32 function-- 
.................... // 
....................  
.................... ////FLAGS 
.................... //BC_ATTEMPT_FLAG 
.................... //PASSED_DAYS 
.................... //RESERVE_CHECK 
.................... //RESERVE_TARGET_FLAG 
.................... //RESERVE_MIN_FLAG 
.................... //MISSION_CONTENTS 
.................... //Kill_Flag 
.................... //FIRST_HSSC_DONE; 
.................... //AUTO_CAM_DONE; 
.................... //AUTO_LDM_DONE; 
.................... //AUTO_ADCS_DONE; 
.................... // 
....................  
.................... void waiting(int32 counterval)//about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
....................    {} 
....................    return; 
.................... } 
....................  
.................... void GIVE_ACCESS_SCF_Nsec(int8 min) 
.................... { 
....................    //disable_interrupts(INT_rda);   // Main to PC 
....................    //disable_interrupts(INT_rda2);  // Main to COM PIC 
....................    //disable_interrupts(INT_rda4);  // Main to RESET PIC 
....................    fprintf(PC,"give access to COM\r\n"); 
....................    fputc(0x35,COM); 
....................    output_high(PIN_C4); 
....................    for(int i = 0; i < min; i++) 
....................    { 
....................       delay_ms(60000); //wait 60 sec 
....................    } 
....................    fprintf(PC,"Back to Nomal Operation\r\n"); 
....................    //enable_interrupts(INT_rda);   // Main to PC 
....................    //enable_interrupts(INT_rda2);  // Main to COM PIC 
....................    //enable_interrupts(INT_rda4);  // Main to RESET PIC 
....................    return; 
.................... } 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... #define HIGH_SAMP_TIMES 50 
....................  
.................... int8 CMD_FROM_PC[3] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
....................  
.................... int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0; 
.................... #define EX_PANEL_THRESHHOLD 0x00000000 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
....................  
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0; //for GS testing 
.................... int16 PASSED_DAYS = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_LDM_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 //RESERVE_SEC_FLAG = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int32 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 RESERVE_CHECK = 0; 
....................  
.................... #define buffer_from_com /* (in_bffr_main[0]==0xAA) && */(in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
....................  
.................... void SerialDataReceive() //get buffer data one by one 
.................... { 
....................    int num = 0; 
....................    for(;num < 16; num++) 
....................    { 
....................     in_bffr_main[num] = fgetc(com); 
....................    }      
....................    return; 
.................... } 
....................  
.................... void DELETE_CMD_FROM_PC() 
.................... { 
....................    for(int num = 0; num < 2; num++) 
....................    { 
....................       CMD_FROM_PC[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Delete_Buffer() //get buffer data one by one 
.................... { 
....................    int num = 0; 
....................    for(;num < 16; num++) 
....................    { 
....................     in_bffr_main[num] = 0x00; 
....................    }      
....................    return; 
.................... } 
....................  
.................... void Transfer_Buffer(int PORT_NUM) //get buffer data one by one 
....................                                    //1:PC 2:COM 3:RESET 
.................... { 
....................    int num = 0; 
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for(;num < 16; num++) 
....................          { 
....................          fputc(in_bffr_main[num],PC); 
....................          } 
....................          break; 
....................       case 2: 
....................          for(;num < 16; num++) 
....................          { 
....................          fputc(in_bffr_main[num],COM); 
....................          } 
....................          break; 
....................       case 3: 
....................          for(;num < 16; num++) 
....................          { 
....................          fputc(in_bffr_main[num],RESET); 
....................          } 
....................          break; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_Buffer_OF(unsigned INT32 TO_ADRESS) //for testing 
.................... { 
....................    for (int i=0 ; i < 16 ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS, in_bffr_main[i]); 
....................       TO_ADRESS++; 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... //void 
....................  
.................... //--------RESET Current Collection--------------------------------------------- 
.................... #define Reset_size 10 //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
....................  
.................... void DELETE_RESET() 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
....................    { 
....................       reset_bffr[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void COLLECT_RESET_DATA() 
.................... { 
....................    DELETE_RESET(); 
....................    RESET_DATA = 0; 
....................    //disable_interrupts(INT_rda2); 
....................    //disable_interrupts(INT_rda3); 
....................    //enable_interrupts(INT_rda4); 
....................    for(int16 num = 0; num < 100; num++) 
....................    { 
....................       fputc(0x28,reset); 
....................    } 
....................    waiting(10000); 
....................    //disable_interrupts(INT_rda4); 
....................    //enable_interrupts(INT_rda2); 
....................    //enable_interrupts(INT_rda3); 
....................    return; 
.................... } 
....................  
.................... //--------BC Function---------------------------------------------------------- 
.................... //unsigned int8 BC_temp_data[2] = {}; 
.................... unsigned int16 BC_temp_data_h = 0; 
.................... unsigned int16 BC_temp_data_l = 0; 
.................... unsigned int16 BC_TEMP = 0; 
.................... float  temp = 0; 
.................... //int16 temp = 0; 
.................... float MAXTEMP = 0; 
.................... int16 BC_ATTEMPT_FLAG = 0; 
.................... int16 UNLEG2 = 0; 
....................  
....................  
.................... void BC_SETUP() 
.................... { 
....................    ANCON2= 0x01; // AN9 as analog, all other pins are digital 
....................    ADCON1L = 0x00; // SAMP bit = 0 ends sampling and starts converting 
....................    ADCHS0L = 0x09; // Connect AN9 as S/H+ input 
....................    // AN9 is the input 
....................    ADCON2H = 0x00; 
....................    ADRC = 1; 
....................    ADCSS0L = 0; 
....................    ADCON3L = 0x02; // Manual Sample, Tad = 3Tcy 
....................       //setup_adc(ADC_CLOCK_DIV_32); //VSS_VDD 
....................    ADCON2L = 0; 
....................    return; 
.................... } 
....................  
.................... void BC_READ_TO_PC() 
.................... { 
....................    ADON = 1; 
....................    SAMP = 1; 
....................    delay_ms(100); 
....................     
....................    SAMP = 0; // start converting 
....................    while (!DONE){}; 
....................    delay_ms(100); 
....................    //BC_temp_data[0] = ADCBUF0H;//read_adc(); 
....................    //BC_temp_data[1] = ADCBUF0L; 
....................     
....................    BC_temp_data_h = ADCBUF0H; 
....................    BC_temp_data_l = ADCBUF0L; 
....................    //temp = ((data_h << 8 ) | data_l); 
....................    fprintf(PC,"data_l:%x \r\n", BC_temp_data_l); 
....................    fprintf(PC,"data_h:%x \r\n", BC_temp_data_h); 
....................    BC_TEMP = BC_temp_data_h | BC_temp_data_l; 
....................    //fprintf(PC,"temp:%f\r\n",temp); 
....................    temp = BC_TEMP/1024*3.31*100-50;    //VDD: 3.31V(MEASURED) 
....................    //fprintf(PC,"%1.1f \r\n", temp); 
....................    return; 
.................... } 
....................  
.................... void CHECK_BC_TEMP() 
.................... { 
....................    BC_SETUP(); 
....................    ADON = 1; 
....................    SAMP = 1; 
....................    delay_ms(10); 
....................     
....................    SAMP = 0; // start converting 
....................    while (!DONE){}; 
....................    delay_ms(10); 
....................    BC_temp_data_h = ADCBUF0H;//read_adc(); 
....................    BC_temp_data_l = ADCBUF0L; 
....................    //fprintf(PC,"%x%x\r\n",ADCBUF0H,BC_temp_data_l); 
....................    BC_temp = BC_temp_data_h<<8 | BC_temp_data_l; 
....................    //fprintf(PC,"HEX : %x%x\r\n",BC_temp>>8,BC_temp); 
....................  
....................    temp = BC_temp;//float 
....................    temp = temp/1024*3.31*100-50; 
....................    fprintf(PC,"Current Temp: %1.1f\r\n",temp); 
....................     
....................    if(MAXTEMP < temp) 
....................    { 
....................       MAXTEMP = temp; 
....................    } 
.................... //!   fprintf(PC,"temp:%f\r\n",temp); 
.................... //!   temp = temp/1024*3.31*100-50;    //VDD: 5V 
.................... //!   fprintf(PC,"%1.1f \r\n", temp); 
....................    return; 
.................... } 
....................  
.................... void MEASURE_BC_TEMP() 
.................... { 
....................    BC_SETUP(); 
....................    ADON = 1; 
....................    SAMP = 1; 
....................    delay_ms(1); 
....................     
....................    SAMP = 0; // start converting 
....................    while (!DONE){}; 
....................    delay_ms(1); 
....................    BC_temp_data_h = ADCBUF0H;//read_adc(); 
....................    BC_temp_data_l = ADCBUF0L; 
....................  
....................    return; 
.................... } 
....................  
.................... void Turn_ON_BC() 
.................... { 
....................    output_high(PIN_D5); //switch signal on 
....................    return; 
.................... } 
....................  
.................... void Turn_OFF_BC() 
.................... { 
....................    output_low(PIN_D5); //switch signal off 
....................    return; 
.................... } 
....................  
.................... void CHECK_POWER() 
.................... { 
....................    return; 
.................... } 
....................  
.................... void BC_OPERATION() 
.................... { 
....................    CHECK_BC_TEMP(); 
....................    Turn_ON_BC(); 
....................    fprintf(PC,"Turned ON BC\r\n"); 
....................     
....................    for(int8 num = 0; num < 12; num++) 
....................    { 
....................       //Turn_OFF_BC(); 
....................       //delay_ms(10); 
....................       COLLECT_RESET_DATA(); 
....................       UNLEG2 = UNLEG2 + RESET_bffr[9]; //add the unleg2 current every second 
....................       //CHECK_BC_TEMP(); 
....................       //Turn_ON_BC(); 
....................       delay_ms(990); 
....................    } 
....................        
....................    Turn_OFF_BC(); 
....................    delay_ms(500); 
....................    CHECK_BC_TEMP(); 
....................    UNLEG2 = UNLEG2 / 12; //take average 
....................    fprintf(PC,"UNLEG2 CURRENT is %x\r\n",UNLEG2); 
....................    fprintf(PC,"MAXIMUM TEMPERATURE is %1.1f\r\n\r\n",MAXTEMP); 
....................    MAXTEMP = 0; 
....................    return; 
.................... } 
....................  
.................... void CLEAR_BC_FLAG() 
.................... { 
....................    BC_ATTEMPT_FLAG = 0; 
....................    fprintf(PC,"\r\nFlag delete done\r\n"); 
....................    return; 
.................... } 
....................  
.................... void MAKE_BC_FLAG_1() 
.................... { 
....................    BC_ATTEMPT_FLAG = 1; 
....................    fprintf(PC,"\r\nFlag:1\r\n"); 
....................    return; 
.................... } 
....................  
.................... void MAKE_BC_FLAG_2() 
.................... { 
....................    BC_ATTEMPT_FLAG = 2; 
....................    fprintf(PC,"\r\nFlag:2\r\n"); 
....................    return; 
.................... } 
....................  
.................... void MAKE_BC_FLAG_3() 
.................... { 
....................    BC_ATTEMPT_FLAG = 3; 
....................    fprintf(PC,"\r\nFlag:3\r\n"); 
....................    return; 
.................... } 
....................  
.................... void MAKE_BC_FLAG_4() 
.................... { 
....................    BC_ATTEMPT_FLAG = 4; 
....................    fprintf(PC,"\r\nFlag:4\r\n"); 
....................    return; 
.................... } 
....................  
.................... //--------ADCS MISSION--------------------------------------------------------- 
.................... ////////////////////////////////////////////////// 
.................... //ADCS MISSION ID: 0x45                         // 
.................... //ADCS MISSION DATA COLLECT: 55                 // 
.................... //ADCS SENSOR SAMPLING: 0x34                    //   
.................... //ADCS ACK: 0x55                                // 
.................... //ADCS Finish Storing: 0x67                     // 
.................... ////////////////////////////////////////////////// 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
.................... #define ADCS_SENSOR_SIZE 100 
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... int8 MEASURE_ADCS_FLAG = 0; 
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0; //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
.................... void Turn_On_ADCS() 
.................... { 
....................    output_high(PIN_D6); 
....................    return; 
.................... } 
....................  
.................... void Turn_Off_ADCS() 
.................... { 
....................    output_low(PIN_D6); 
....................    return; 
.................... } 
....................  
.................... void Send_Command_to_ADCS(int8 data) //testing for EM integration 
.................... { 
....................    fputc(data,ADCS); 
....................    return; 
.................... } 
....................  
.................... void DELETE_ADCS_SENSOR() 
.................... { 
....................    for(int a = 0; a < ADCS_SENSOR_SIZE; a++) 
....................    { 
....................       ADCS_SENSOR_DATA[a] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void ADCS_SETTINGS()//initiallize 
.................... { 
....................    //disable_interrupts(INT_rda);   // Main to PC 
....................    //disable_interrupts(INT_rda2);  // Main to COM PIC 
....................    //disable_interrupts(INT_rda3);  // Main to FAB PIC 
....................    //disable_interrupts(INT_rda4);  // Main to RESET PIC    
....................  
....................    output_low(PIN_C4); 
....................    sector_erase_SCF(ADCS_SENSOR_ADDRESS); 
....................    sector_erase_SMF(ADCS_SENSOR_ADDRESS); 
....................    //WRITE_DATA_NBYTE_SCF(0,399); 
....................    output_high(PIN_C4); 
....................  
....................    //Turn_On_ADCS(); 
....................    Delete_Buffer(); 
....................    return; 
.................... } 
....................  
.................... void DISPLAY_ADCS_SENSOR_TO_PC()//for testing 
.................... { 
....................    for(int b = 0; b < ADCS_SENSOR_SIZE; b++)//for checking 
....................    { 
....................       fputc(ADCS_SENSOR_DATA[b],PC); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Get_ADCS_Data() 
.................... { 
....................    Delete_ADCS_SENSOR(); //initialize 
....................    for(int32 num = 0; num < 1000000 ;num++) 
....................    { 
....................       if(kbhit(ADCS)) 
....................       { 
....................          //fprintf(PC,"command get\r\n"); 
....................          //delay_ms(10000); 
....................          ADCS_ACK = fgetc(ADCS); 
....................          if(ADCS_ACK == 0x67) 
....................          { 
....................             for(int num = 0; num < ADCS_SENSOR_SIZE; num++) 
....................             { 
....................                ADCS_SENSOR_DATA[num] = fgetc(ADCS); 
....................             } 
....................             //DISPLAY_ADCS_SENSOR_TO_PC(); 
....................             fprintf(PC,"HEADER=%x\r\n",ADCS_ACK); 
....................             //Delete_Buffer(); 
....................             //fputc(0x33,PC); 
....................          break; 
....................          } 
....................       } 
....................       //delay_us(1000); 
....................    } 
....................    if(num == 1000000) 
....................    { 
....................       fprintf(PC,"NO DATA\r\n"); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Get_ADCS_MISSION_Data() 
.................... { 
....................     
....................    Delete_ADCS_SENSOR(); //initialize 
....................    fputc(0x55,ADCS); 
....................    fputc(0x55,PC); 
....................    int i = 0; 
....................    for(int32 num = 0; num < 1000000 ;num++) 
....................    { 
....................       if(kbhit(ADCS) && fgetc(ADCS) == 0x67) 
....................       { 
....................          for(num = 0; num < 10000; num++) 
....................          { 
....................             if(Kbhit(ADCS)) 
....................             { 
....................                ADCS_SENSOR_DATA[i] = fgetc(ADCS); 
....................                i++; 
....................                if(i == 99) 
....................                { 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................          ADCS_ACK = 0x67; 
....................          break; 
....................          //fprintf(PC,"command get\r\n"); 
....................          //delay_ms(10000); 
....................          //ADCS_ACK = fgetc(ADCS); 
....................          //if(ADCS_ACK == 0x67) 
....................          //{ 
....................             //for(int num = 0; num < ADCS_SENSOR_SIZE; num++) 
....................             //{ 
....................                //ADCS_SENSOR_DATA[i] = fgetc(ADCS); 
....................                //i++; 
....................                //if(i == 99) 
....................                //{ 
....................                //   break; 
....................                //} 
....................             //} 
....................             //fprintf(PC,"HEADER=%x\r\n",ADCS_ACK); 
....................          //break; 
....................          //} 
....................       } 
....................    } 
....................    if(num == 1000000) 
....................    { 
....................       fprintf(PC,"NO DATA\r\n"); 
....................    } 
.................... //!      for(num = 0; num < 100; num++) 
.................... //!      { 
.................... //!         fputc(ADCS_SENSOR_DATA[num],PC); 
.................... //!      } 
....................    return; 
.................... } 
....................  
.................... void SAVE_SENSOR_TO_SMF() 
.................... { 
....................       output_low(PIN_A4); 
....................       //sector_erase_SMF(ADCS_SENSOR_ADDRESS); 
....................       int32 adrs = ADCS_SENSOR_ADDRESS; 
....................     
....................       for(int da = 0; da < ADCS_SENSOR_SIZE; da++ )//write sensor data to Shared Mission Flash 
....................       { 
....................          WRITE_DATA_BYTE_SMF(adrs,ADCS_SENSOR_DATA[da]); 
....................          adrs++; 
....................       } 
....................       fprintf(PC,"Write DATA to Mission Flash DONE\r\n"); 
....................       return; 
.................... } 
....................  
.................... void TRANSFER_SENSOR_FROM_SMF_TO_SCF() 
.................... { 
....................    output_low(PIN_C4);//get SCF access 
....................    output_low(PIN_A4); 
....................    //TRANSFER_DATA_NBYTE_TOPC_SMF(65536,32); 
....................    //delay_ms(10); 
....................    TRANSFER_DATA_NBYTE_SMFtoSCF(ADCS_SENSOR_ADDRESS,ADCS_SENSOR_ADDRESS,ADCS_SENSOR_SIZE); //From(SMF): sector0, To(SCF): sector1 
....................    TRANSFER_DATA_NBYTE_TOPC_SCF(ADCS_SENSOR_ADDRESS,ADCS_SENSOR_SIZE); 
....................    fprintf(PC,"Transfer DONE\r\n"); 
....................    //delay_ms(10); 
....................    output_high(PIN_C4);//give SCF access 
....................     
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + ADCS_SENSOR_SIZE; //for next storing address 
....................    DELETE_ADCS_SENSOR(); 
....................    //delay_ms(5000); 
....................    DISPLAY_ADCS_SENSOR_TO_PC();//for testing 
....................     
....................    output_high(PIN_C4); //give access to SCF 
....................     
....................    fprintf(PC,"DONE\r\n"); 
....................    return; 
.................... } 
....................  
.................... void CHECK_ADCS_WORKING()//this is for funcitonal testing 
.................... { 
....................    if(ADCS_SENSOR_DATA[99] == 0x57) 
....................    { 
....................       fprintf(PC,"\r\nMTQ WORKING\r\n"); 
....................    }else{ 
....................       fprintf(PC,"\r\nMTQ NOT WORKING\r\n"); 
....................    } 
....................    return; 
.................... } 
....................  
.................... //!void ADCS_TEST_OPERATION() //Integration Testing With ADCS 
.................... //!{ 
.................... //!    
.................... //!   ADCS_SETTINGS(); 
.................... //!    
.................... //!   fprintf(PC,"Turn On ADCS\r\n"); 
.................... //!   Turn_On_ADCS(); //Trun on ADCS 
.................... //!   delay_ms(1000); 
.................... //!    
.................... //!while(true){ 
.................... //! 
.................... //!   fprintf(PC,"Send Command to ADCS\r\n"); 
.................... //!   fputc(0x34,adcs); 
.................... //!   for(int32 num = 0; num < 1000000; num++) 
.................... //!   { 
.................... //!      if(kbhit(ADCS)) 
.................... //!      { 
.................... //!         ADCS_ACK = fgetc(ADCS); 
.................... //!         fprintf(PC,"GET ACK:%x\r\n",ADCS_ACK); 
.................... //!         //fprintf(PC,"COMMAND CAME\r\n"); 
.................... //!         break; 
.................... //!      } 
.................... //!      //delay_ms(1); 
.................... //!   } 
.................... //!    
.................... //!   if(ADCS_ACK == 0x55) 
.................... //!   { 
.................... //!      fprintf(PC,"ACK CAME\r\n"); 
.................... //!      //fputc(0x77,PC); 
.................... //!      fprintf(PC,"Start Getting Sensor\r\n"); 
.................... //!      Get_ADCS_Data(); 
.................... //!      CHECK_ADCS_WORKING(); 
.................... //!             
.................... //!      if(ADCS_ACK == 0x67) 
.................... //!      { 
.................... //!         ADCS_ACK = 0; 
.................... //!         //fprintf(PC,"\r\nCollecting Done\r\n\r\n"); 
.................... //!       
.................... //!         //fprintf(PC,"NEXT\r\n"); 
.................... //!       
.................... //!         SAVE_SENSOR_TO_SMF(); 
.................... //!         TRANSFER_SENSOR_FROM_SMF_TO_SCF(); 
.................... //!       
.................... //!      }else{ 
.................... //!         fprintf(PC,"ACK NOT COME\r\n"); 
.................... //!         ADCS_ACK_COMMING = 0; 
.................... //!         ADCS_ACK = 0; 
.................... //!      }    
.................... //!   }else{ 
.................... //!      fprintf(PC,"ACK NOT COME\r\n"); 
.................... //!      ADCS_ACK_COMMING = 0; 
.................... //!      ADCS_ACK = 0; 
.................... //!   }   
.................... //!    
.................... //!   if(MEASURE_ADCS_FLAG == ATTEMPT_TIME-1) //execute collecting 4 times 
.................... //!   { 
.................... //!      MEASURE_ADCS_FLAG = 0; 
.................... //!      break; 
.................... //!   }else{ 
.................... //!      MEASURE_ADCS_FLAG++; 
.................... //!   } 
.................... //!    
.................... //!   //fprintf(PC,"\r\nWaiting...\r\n\r\n"); 
.................... //!   //for(int32 ca = 0; ca < 100000; ca++){} 
.................... //!} 
.................... //!   Turn_OFF_ADCS();  //turn off the mux(give access to MAIN) 
.................... //!   printf(PC,"\r\n\r\nTrun_OFF_ADCS\r\n\r\n\r\n"); 
.................... //!    
.................... //!   output_low(PIN_C4); 
.................... //!   TRANSFER_DATA_NBYTE_TOPC_SCF(ADCS_SENSOR_ADDRESS-ATTEMPT_TIME*100, ATTEMPT_TIME*100); 
.................... //!   output_high(PIN_C4); 
.................... //!    
.................... //!   enable_interrupts(INT_rda);   // Main to PC 
.................... //!   enable_interrupts(INT_rda2);  // Main to COM  
.................... //!   enable_interrupts(INT_rda3);  // Main to FAB PIC 
.................... //!   enable_interrupts(INT_rda4);  // Main to RESET PIC    
.................... //!   //fputc(0x69,COM);  
.................... //!   return; 
.................... //!} 
....................  
.................... void ADCS_TEST_OPERATION() //Integration Testing With ADCS 
.................... { 
....................     
....................    ADCS_SETTINGS(); 
....................     
....................    fprintf(PC,"Turn On ADCS\r\n"); 
....................    Turn_On_ADCS(); //Trun on ADCS 
....................    delay_ms(1000); 
....................    fprintf(PC,"Send Command to ADCS\r\n"); 
....................    //fputc(0x45,adcs);//for execute stabilizse mission 
....................    fputc(0x34,adcs);//for get sensor data 
....................    for(int32 num = 0; num < 1000000; num++)//get ack from ADCS 
....................    { 
....................       if(kbhit(ADCS)) 
....................       { 
....................          ADCS_ACK = fgetc(ADCS); 
....................          fprintf(PC,"GET ACK:%x\r\n",ADCS_ACK); 
....................          //fprintf(PC,"COMMAND CAME\r\n"); 
....................          break; 
....................       } 
....................       //delay_ms(1); 
....................    } 
....................    if(ADCS_ACK == 0x55)//confirm ACK from ADCS is correct 
....................    {   
....................       //fprintf(PC,"ACK CAME\r\n"); 
....................       //fputc(0x77,PC); 
....................       //fprintf(PC,"Start Getting Mission Data\r\n"); 
....................       while(true){ 
....................        
....................          Get_ADCS_Data(); 
....................          //Get_ADCS_MISSION_Data(); 
....................          CHECK_ADCS_WORKING(); 
....................              
....................          if(ADCS_ACK == 0x67) 
....................          { 
....................             ADCS_ACK = 0; 
....................        
....................             SAVE_SENSOR_TO_SMF(); 
....................             TRANSFER_SENSOR_FROM_SMF_TO_SCF(); 
....................        
....................          }else{ 
....................             fprintf(PC,"ACK NOT COME\r\n"); 
....................             ADCS_ACK_COMMING = 0; 
....................             ADCS_ACK = 0; 
....................          }    
....................     
....................          if(MEASURE_ADCS_FLAG == ATTEMPT_TIME-1) //execute collecting 4 times 
....................          { 
....................             MEASURE_ADCS_FLAG = 0; 
....................             break; 
....................          }else{ 
....................          MEASURE_ADCS_FLAG++; 
....................          } 
....................  
....................       } 
....................    }else{ 
....................       fprintf(PC,"ACK NOT COME\r\n"); 
....................       ADCS_ACK_COMMING = 0; 
....................       ADCS_ACK = 0; 
....................    } 
....................    Turn_OFF_ADCS();  //turn off the mux(give access to MAIN) 
....................    printf(PC,"\r\n\r\nTrun_OFF_ADCS\r\n\r\n\r\n"); 
....................     
....................    output_low(PIN_C4); 
....................    TRANSFER_DATA_NBYTE_TOPC_SCF(ADCS_SENSOR_ADDRESS-ATTEMPT_TIME*100, ATTEMPT_TIME*100); 
....................    output_high(PIN_C4); 
....................     
.................... //!   enable_interrupts(INT_rda);   // Main to PC 
.................... //!   enable_interrupts(INT_rda2);  // Main to COM  
.................... //!   enable_interrupts(INT_rda3);  // Main to FAB PIC 
.................... //!   enable_interrupts(INT_rda4);  // Main to RESET PIC    
.................... //!   fputc(0x69,COM);  
....................    return; 
.................... } 
....................  
.................... void GET_ADCS_SENSOR_DATA()//after that, method will changed (ADCS make format and just send to MAIN PIC) 
.................... { 
....................    fputc(0x34,adcs);//send command (just collect sensor) 
....................    for(int32 num = 0; num < 1000000; num++) 
....................    { 
....................       if(kbhit(ADCS)) 
....................       { 
....................          ADCS_ACK = fgetc(ADCS); 
....................          break; 
....................       } 
....................    } 
....................     
....................    if(ADCS_ACK == 0x55) 
....................    { 
....................       Get_ADCS_Data(); 
....................       CHECK_ADCS_WORKING(); 
....................              
....................       if(ADCS_ACK == 0x67) 
....................       { 
....................          ADCS_ACK = 0;       
....................          //SAVE_SENSOR_TO_SMF(); 
....................          //TRANSFER_SENSOR_FROM_SMF_TO_SCF(); 
....................        
....................       }else{ 
....................          fprintf(PC,"ACK NOT COME from ADCS\r\n"); 
....................          ADCS_ACK_COMMING = 0; 
....................          ADCS_ACK = 0; 
....................       }    
....................    }else{ 
....................       fprintf(PC,"ACK NOT COME from ADCS\r\n"); 
....................       ADCS_ACK_COMMING = 0; 
....................       ADCS_ACK = 0; 
....................    } 
....................  
....................      //turn off the mux(give access to MAIN) 
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... //--------FAB HK collection---------------------------------------------------- 
.................... #define HK_size 119  //HK FORMAT ARRAY SIZE 
.................... #define CW_size 5  //CW FORMAT ARRAY SIZE 
.................... #define HIGH_SAMP_HK_size 96 //High Sampling HK FORMAT ARRAY SIZE 
.................... #define FAB_SENSOR_size 45 //HK FAB Part 
....................  
.................... unsigned int8 in_HK[FAB_SENSOR_size] = {}; 
.................... unsigned int8 CW_FORMAT[CW_size] = {}; 
.................... unsigned int8 HKDATA[HK_size] ={}; 
.................... //int8 in_High_HK[HIGH_SAMP_HK_size] = {}; 
.................... BYTE FAB_DATA = 0; 
.................... //int t; 
.................... static int8 FAB_MEASUERING_FLAG= 0; 
.................... static int8 HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
.................... int32 FAB_FLAG = 0; 
.................... int8 CHECK_FAB_RESPONSE = 0; 
....................  
.................... Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... #define buffer_from_FAB  (in_bffr_main[0]==0x33) 
....................  
....................  
....................  
.................... void Delete_in_HK() 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
....................    { 
....................       in_HK[num] = 0; 
....................    } 
....................    return; 
.................... } 
.................... ////////////////////////////////////// 
.................... void Delete_HKDATA() 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
....................    { 
....................       HKDATA[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Delete_CWFORMAT() 
.................... { 
....................    for(int num = 0; num < CW_size; num++) 
....................    { 
....................       CW_FORMAT[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... int8 CHECK_SUNSHINE(int16 voltage, int8 current) 
.................... { 
....................    if(voltage * current > EX_PANEL_THRESHHOLD) 
....................    { 
....................       return 1; 
....................    }else{ 
....................       return 0; 
....................    } 
.................... } 
....................  
.................... int8 CONVERT_16bit_GYRO_to_8bit(int8 HIGH_8bit, int8 LOW_8bit) 
.................... { 
....................    return make16(HIGH_8bit, LOW_8bit) * 0.00875;  
.................... } 
....................  
.................... void MAKE_CW1_FORMAT()//when you inprement, go to line 
.................... { 
....................    Delete_CWFORMAT(); 
....................    for(int8 num = 0; num < 3; num++) 
....................    { 
....................       CW_FORMAT[num] = HKDATA[num + 39]; 
....................    } 
....................     
.................... //   CW_FORMAT[3] = CW_FORMAT[3];//0:CW1 
....................    CW_FORMAT[3] = CW_FORMAT[3] + RESERVE_CHECK * 64; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + OPERATION_MODE; //48(=32+16):nomal, 32:low, 16:safe 
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_MAIN * 8; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_FAB * 4; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + ANT_DEP_STATUS * 2; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + CHECK_SUNSHINE(make16(HKDATA[23],HKDATA[24]),HKDATA[33]) * 1;//+X Panel 
....................     
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(make16(HKDATA[25],HKDATA[26]),HKDATA[34]) * 128;//-Y Panel 
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(make16(HKDATA[27],HKDATA[28]),HKDATA[35]) * 64;//-Z Panel 
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(make16(HKDATA[29],HKDATA[30]),HKDATA[36]) * 32;//+Y Panel 
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(make16(HKDATA[31],HKDATA[32]),HKDATA[37]) * 16;//+Z Panel 
....................    CW_FORMAT[4] = CW_FORMAT[4] + (HKDATA[2] & 0b00001111);//time data 
....................     
....................    CW_IDENTIFIER = 0; 
....................     
....................    return; 
.................... } 
.................... void MAKE_CW2_FORMAT()//when you inprement, go to line 
.................... { 
....................    Delete_CWFORMAT(); 
....................     
....................    CW_FORMAT[0] = CONVERT_16bit_GYRO_to_8bit(HKDATA[49], HKDATA[50]); //GYRO X axis 
....................    CW_FORMAT[1] = CONVERT_16bit_GYRO_to_8bit(HKDATA[51], HKDATA[52]); //GYRO Y axis 
....................    CW_FORMAT[2] = CONVERT_16bit_GYRO_to_8bit(HKDATA[53], HKDATA[54]); //GYRO Z axis 
....................     
....................    CW_FORMAT[3] = CW_FORMAT[3] + 128; //1:CW2 
....................    CW_FORMAT[3] = CW_FORMAT[3] + FIRST_HSSC_DONE * 64; //High Sampling Sensor Collection Flag 0:not done, 1:done 
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_CAM_DONE * 32; //AUTO CAM MISSION DONE 0:not done, 1:done 
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_LDM_DONE * 16; //AUTO LDM MISSION DONE 0:not done, 1:done 
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_ADCS_DONE * 8; //AUTO ADCS MISSION DONE 0:not done, 1:done 
....................    CW_FORMAT[3] = CW_FORMAT[3] + HKDATA[42] * 4; //Heater 0:OFF, 1:ON 
....................     
....................    CW_FORMAT[4] = (make16(HKDATA[16],HKDATA[17])) * 0.03;//CPLD_TEMP 
....................     
....................    CW_IDENTIFIER = 1; 
....................     
....................    return; 
.................... } 
....................  
.................... void MAKE_CW_FORMAT() 
.................... { 
....................    if(CW_IDENTIFIER) 
....................    { 
....................       MAKE_CW1_FORMAT(); 
....................    }else{ 
....................       MAKE_CW2_FORMAT(); 
....................    } 
.................... } 
....................  
.................... void SAVE_HKDATA_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress, HKDATA[num]); 
....................       Memory_Adress++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void SAVE_HKDATA_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
....................    for(int8 num = 0; num < HK_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress, HKDATA[num]); 
....................       Memory_Adress++; 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void SAVE_CWFORMAT_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    for(int8 num = 0; num < CW_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress, CW_FORMAT[num]); 
....................       Memory_Adress++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void SAVE_CWFORMAT_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
....................    for(int8 num = 0; num < CW_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress, CW_FORMAT[num]); 
....................       Memory_Adress++; 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void Send_COMMAND_TO_FAB(int8 cmd) 
.................... { 
....................    fputc(cmd,FAB); 
....................    return; 
.................... } 
....................  
.................... void COMMAND_TO_FAB(int32 delaytime) 
.................... { 
....................    FAB_DATA = 0; 
....................    enable_interrupts(INT_rda3);//FAB 
....................    Send_Command_to_FAB(0x61);  //send command to fab 
....................    fprintf(PC,"Sending Done\r\n"); 
....................    int32 a = 0; 
....................    while(FAB_DATA == 0){ 
....................       a++; 
....................       if(a > 50000) 
....................       { 
....................          break; 
....................       } 
....................    } 
....................    //FAB_DATA = 0; 
....................    waiting(delaytime); 
....................    disable_interrupts(INT_rda3); 
....................    return; 
.................... } 
....................  
.................... int8 ACK_FROM_FAB() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM); 
....................    return ack; 
.................... } 
....................  
.................... void Send_HKDATA_to_SCF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_SCF(adress);  //save HK to COM PIC 
....................    //fprintf(PC,"\r\nSending HK Done and Read from COMFLASH\r\n"); 
....................    //output_low(PIN_C4); 
....................    //TRANSFER_DATA_NBYTE_TOPC_SCF(adress,HK_size - 2); //for checking whether the data saved correctly 
....................    //output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void Send_HKDATA_to_OF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_OF(adress);  //save HK to COM PIC 
....................    //fprintf(PC,"\r\nSending HK Done and Read from MAINFLASH\r\n"); 
....................    //output_low(PIN_C4); 
....................    //TRANSFER_DATA_NBYTE_TOPC_OF(adress,HK_size - 2); //for checking whether the data saved correctly 
....................    //output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void SEND_CWFORMAT_TO_SCF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);  //save HK to COM PIC 
....................    fprintf(PC,"\r\nSAVE CW\r\n"); 
....................    output_low(PIN_C4); 
....................    TRANSFER_DATA_NBYTE_TOPC_SCF(adress,CW_size); //for checking whether the data saved correctly 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void SEND_CWFORMAT_TO_OF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);  //save HK to COM PIC 
....................    //fprintf(PC,"\r\nCW:\r\n"); 
....................    output_low(PIN_C4); 
....................    TRANSFER_DATA_NBYTE_TOPC_OF(adress,CW_size); //for checking whether the data saved correctly 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void CHECK_HKDATA(int8 in,int32 delaytime)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    fprintf(PC,"GET SENSOR DATA\r\n"); 
....................    Delete_HKDATA(); 
....................    waiting(delaytime); 
....................     
....................    for(int num = 0; num < 11 - in; num++) //Collect HK DATA 
....................    { 
....................       HKDATA[num + 5] = in_HK[num + 2 - in]; 
....................       fputc(HKDATA[num + 5],PC); 
....................    } 
....................     
....................    MEASURE_BC_TEMP(); 
....................    HKDATA[14] = BC_temp_data_h; 
....................    HKDATA[15] = BC_temp_data_l; 
....................     
....................    for(num = 9; num < FAB_SENSOR_size - 2; num++) //Collect HK DATA 
....................    { 
....................       HKDATA[num + 7] = in_HK[num + 2 - in]; 
....................       fputc(HKDATA[num + 7],PC); 
....................    } 
....................    FAB_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... void VERIFY_FABDATA(int32 delaytime1,int32 delaytime2) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
....................    { 
....................       COMMAND_TO_FAB(delaytime1); 
....................       //FAB_DATA = 0; 
....................       if(in_HK[0] == 0x33)//gather sensor data by interrupt 
....................       { 
....................          CHECK_HKDATA(2,delaytime2); 
....................          MAKE_CW_FORMAT(); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       }else if(in_HK[1] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HKDATA(1,delaytime2); 
....................          MAKE_CW_FORMAT(); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       }else if(in_HK[2] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HKDATA(0,delaytime2); 
....................          MAKE_CW_FORMAT(); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void GET_RESET_DATA() 
.................... { 
....................    COLLECT_RESET_DATA(); 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       fprintf(PC,"GET RESET\r\n"); 
....................       for(int num = 0; num < 5; num++)//timedata 
....................       { 
....................          HKDATA[num] = reset_bffr[num + 1]; 
....................          fputc(HKDATA[num],PC); 
....................       } 
....................     
....................       for(num = 0; num < 5; num++)//reset sensor data 
....................       { 
....................          HKDATA[num + 96] = reset_bffr[num + 6]; 
....................          fputc(HKDATA[num + 96],PC); 
....................       } 
....................    }else{ 
....................       fprintf(PC,"NO RESET\r\n"); 
....................    } 
....................  
....................    //Delete_Reset(); 
....................    return; 
.................... } 
....................  
.................... void MAKE_ADCS_HKDATA() 
.................... { 
....................    GET_ADCS_SENSOR_DATA(); 
....................    for(int num = 43; num < 55; num++) 
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 43]; 
....................    } 
....................    for(num = 55; num < 96; num++) 
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 34];//HKDATA[54] = ADCS_SENSOR_DATA[21] 
....................    } 
....................    return; 
.................... } 
....................  
.................... void DISPLAY_CW() 
.................... { 
....................    fprintf(PC,"\r\nCW:\r\n"); 
....................    for(int8 i = 0; i < 5; i++) 
....................    { 
....................       fprintf(PC,"%x",CW_FORMAT[i]); 
....................    } 
....................    fprintf(PC,"\r\n"); 
....................    return; 
.................... } 
....................  
.................... void FAB_TEST_OPERATION() 
.................... { 
....................     
....................    fprintf(PC,"FAB communication start\r\n"); 
....................    waiting(200000); 
....................    Turn_ON_ADCS(); 
....................    FAB_MEASUERING_FLAG++;//count until 7(it means 10 min) 
....................    FAB_DATA = 0;   //for initialize 
....................     
....................    fprintf(PC,"SENDING COMMAND TO FAB\r\n"); 
....................    VERIFY_FABDATA(300000,2000); 
....................  
....................    GET_RESET_DATA(); 
....................    MAKE_ADCS_HKDATA(); 
....................    Turn_OFF_ADCS(); 
....................    if(CHECK_FAB_RESPONSE) 
....................    { 
....................       fprintf(PC,"\r\nCollecting HK and Making CWFormat Done\r\n\r\n"); 
....................       fprintf(PC,"\r\n\r\nSensor:"); 
....................       for(int num = 0; num < HK_size; num++) 
....................       { 
....................          fprintf(PC,"%x",HKDATA[num]); 
....................       } 
....................       DISPLAY_CW(); 
....................       CHECK_FAB_RESPONSE = 0; 
....................       output_low(PIN_C4); 
....................       //sector_erase_SCF(65536*50); 
....................       //sector_erase_SCF(65536*51); 
....................       SEND_HKDATA_to_SCF(FAB_HK_ADDRESS); 
....................       SEND_HKDATA_to_OF(FAB_HK_ADDRESS); 
....................       SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS); 
....................       SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS); 
....................       FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;//prepare for next storing address 
....................       FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;//prepare for next storing address 
....................       fprintf(PC,"\r\nSENSOR SAVING DONE\r\n"); 
....................       output_high(PIN_C4); 
....................    }else{ 
....................       fprintf(PC,"NO RESPONSE FROM FAB\r\n\r\n");   
....................    } 
....................    Delete_in_HK(); 
....................    return; 
.................... } 
....................  
.................... //--------HIGH SAMPLING HK collection------------------------------------------ 
....................  
.................... void SAVE_HIGH_HKDATA_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
....................    for(int8 num = 0; num < HIGH_SAMP_HK_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress, HKDATA[num]); 
....................       Memory_Adress++; 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void Send_HIGH_HKDATA_to_SCF(int32 adress) 
.................... { 
....................    Save_HIGH_HKDATA_to_SCF(adress);  //save HK to COM PIC 
....................    //fprintf(PC,"Sending HK Done and Read from COMFLASH\r\n"); 
....................    output_low(PIN_C4); 
....................    //TRANSFER_DATA_NBYTE_TOPC_SCF(adress,HIGH_SAMP_HK_size); //for checking whether the data saved correctly 
....................    //fprintf(PC,"\r\n"); 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void SAVE_HIGH_HKDATA_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    int num; 
....................    for(num = 0; num < HIGH_SAMP_HK_size; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress, HKDATA[num]); 
....................       Memory_Adress++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Send_HIGH_HKDATA_to_OF(int32 adress) 
.................... { 
....................    Save_HIGH_HKDATA_to_OF(adress);  //save HK to COM PIC 
....................    //fprintf(PC,"Sending HK Done and Read from MAINFLASH\r\n"); 
....................     
....................    //TRANSFER_DATA_NBYTE_TOPC_OF(adress,HIGH_SAMP_HK_size); //for checking whether the data saved correctly 
....................    //fprintf(PC,"\r\n"); 
....................     
....................    return; 
.................... } 
....................  
.................... void CHECK_HIGH_SAMP_FABDATA(int8 in)//FAB sensor data collect 
.................... { 
....................    fprintf(PC,"GET SENSOR DATA\r\n"); 
....................    Delete_HKDATA(); 
....................    for(int num = 0; num < 9; num++) //Collect HK DATA 
....................    { 
....................       HKDATA[num + 5] = in_HK[num + 2 - in]; 
....................       //fputc(HKDATA[num],PC); 
....................    } 
....................    MEASURE_BC_TEMP(); 
....................    HKDATA[14] = BC_temp_data_h;//-X Panel Temp 
....................    HKDATA[15] = BC_temp_data_l;//-X Panel Temp 
....................    for(num = 16; num < 35; num++) //Collect HK DATA 
....................    { 
....................       HKDATA[num] = in_HK[num - 3 - in]; 
....................       //fputc(HKDATA[num],PC); 
....................    } 
....................    for(num = 35; num < 38; num++) //Collect HK DATA 
....................    { 
....................       HKDATA[num] = in_HK[num + 1 - in]; 
....................       //fputc(HKDATA[num],PC); 
....................    } 
....................    //FAB_DATA = 0; 
.................... } 
....................  
.................... void VERIFY_HIGH_SAMP_FABDATA(int32 delaytime) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
....................    { 
....................       COMMAND_TO_FAB(delaytime); 
....................       //FAB_DATA = 0; 
....................       //waiting(1000); 
....................       if(in_HK[0] == 0x33)//gather sensor data by interrupt 
....................       { 
....................          CHECK_HIGH_SAMP_FABDATA(2); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       }else if(in_HK[1] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(1); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       }else if(in_HK[2] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(0); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................          break; 
....................       } 
....................       FAB_DATA = 0; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... void GET_HIGH_SAMP_RESET_DATA() 
.................... { 
....................    COLLECT_RESET_DATA(); 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       fprintf(PC,"GET RESET\r\n"); 
....................       for(int num = 0; num < 5; num++)//timedata 
....................       { 
....................          HKDATA[num] = reset_bffr[num + 1]; 
....................          fputc(HKDATA[num],PC); 
....................       } 
....................     
....................       for(num = 0; num < 5; num++)//reset sensor data 
....................       { 
....................          HKDATA[num + 91] = reset_bffr[num + 6]; 
....................          //fputc(HKDATA[num + 85],PC); 
....................       } 
....................    }else{ 
....................       fprintf(PC,"NO RESET\r\n"); 
....................    } 
....................    //Delete_Reset(); 
.................... } 
....................  
.................... void MAKE_HIGH_SAMP_ADCS_FORMAT() 
.................... { 
....................    GET_ADCS_SENSOR_DATA(); 
....................    for(int num = 0; num < 12; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 38] = ADCS_SENSOR_DATA[num]; 
....................    } 
....................    for(num = 0; num < 41; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 50] = ADCS_SENSOR_DATA[num + 21]; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void MAKE_HIGH_SAMPLING_FORMAT() 
.................... { 
....................       if(in_HK[0] == 0x33)//gather sensor data by interrupt 
....................       { 
....................          CHECK_HIGH_SAMP_FABDATA(2); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................       }else if(in_HK[1] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(1); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................       }else if(in_HK[2] == 0x33){ 
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(0); 
....................          CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................       } 
....................  
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       for(int num = 0; num < 5; num++)//timedata 
....................       { 
....................          HKDATA[num] = reset_bffr[num + 1]; 
....................          //fputc(HKDATA[num],PC); 
....................       } 
....................     
....................       for(num = 0; num < 5; num++)//reset sensor data 
....................       { 
....................          HKDATA[num + 91] = reset_bffr[num + 6]; 
....................          //fputc(HKDATA[num + 91],PC); 
....................       } 
....................    } 
....................     
....................    for(int num = 0; num < 12; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 38] = ADCS_SENSOR_DATA[num]; 
....................    } 
....................    for(num = 0; num < 41; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 50] = ADCS_SENSOR_DATA[num + 21]; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY() 
.................... { 
....................    output_low(PIN_C4); 
....................    SEND_HIGH_HKDATA_to_SCF(HIGH_SAMP_HK_ADDRESS); 
....................    SEND_HIGH_HKDATA_to_OF(HIGH_SAMP_HK_ADDRESS); 
....................    HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS + HIGH_SAMP_HK_size - 2;//prepare for next storing address 
....................    output_high(PIN_C4);    
....................    return; 
.................... } 
....................  
.................... void HIGH_SAMP_FAB_OPERATION() 
.................... { 
....................    Turn_ON_ADCS(); 
....................    HIGH_SAMP_FAB_MEASUERING_FLAG++;//count until 90(it means 10 min) 
....................    //disable_interrupts(INT_rda2); 
....................    if(HIGH_SAMP_FAB_MEASUERING_FLAG == 3) 
....................       { 
....................          //FAB_MEASUERING_FLAG++; 
....................  
....................          fprintf(PC,"\r\n\90sec\r\n"); 
....................          VERIFY_FABDATA(10000,10); 
....................          GET_RESET_DATA(); 
....................          MAKE_ADCS_HKDATA(); 
....................          output_low(PIN_C4); 
....................          SEND_HKDATA_to_SCF(FAB_HK_ADDRESS); 
....................          SEND_HKDATA_to_OF(HIGH_SAMP_HK_ADDRESS); 
....................          SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS); 
....................          //fprintf(PC,"\r\nSAVING SENSOR DONE\r\n"); 
....................          FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;//prepare for next storing address 
....................          FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;//prepare for next storing address 
....................           
....................          MAKE_HIGH_SAMPLING_FORMAT(); 
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
....................          output_high(PIN_C4); 
....................          fprintf(PC,"\r\nSuccess%x\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
....................          HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
....................           
....................       }else{ 
....................     
....................          //fprintf(PC,"SEND COMMAND\r\n"); 
....................          VERIFY_HIGH_SAMP_FABDATA(10000);    
....................          GET_HIGH_SAMP_RESET_DATA(); 
....................          //enable_interrupts(INT_rda2); 
....................          MAKE_HIGH_SAMP_ADCS_FORMAT(); 
....................                
....................          fprintf(PC,"\r\n"); 
....................          for(int8 num = 0; num < HIGH_SAMP_HK_size; num++) 
....................          { 
....................             fputc(HKDATA[num],PC); 
....................          } 
....................          fprintf(PC,"\r\n");    
....................     
....................     
....................    //if(CHECK_FAB_RESPONSE) 
....................    //{ 
....................          fprintf(PC,"\r\nSuccess%x\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
....................          CHECK_FAB_RESPONSE = 0; 
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
....................       }    
....................    //}else{ 
....................       //fprintf(PC,"NO RESPONSE FROM FAB\r\n\r\n");   
....................       Delete_in_HK(); 
....................    //} 
....................     
....................     
....................    FAB_DATA = 0; 
....................    output_high(PIN_C4); 
....................    //disable_interrupts(INT_rda3); 
....................  
....................    return; 
.................... } 
....................  
....................  
.................... //--------Function for Testing------------------------------------------------- 
.................... //! 
.................... //!void Check_UART() 
.................... //!{ 
.................... //!      fputc(fgetc(PC),PC); 
.................... //!      return; 
.................... //!} 
.................... //! 
.................... //!void Turn_On_PWM(int a) 
.................... //!{ 
.................... //!   setup_timer_2(T2_DIV_BY_1, 150, 1); 
.................... //!   setup_ccp2(CCP_PWM);   // Configure CCP2 as a PWM 
.................... //!   set_pwm2_duty(a); 
.................... //!   return; 
.................... //!} 
.................... //! 
.................... //!void Turn_OFF_PWM() 
.................... //!{ 
.................... //!   setup_timer_2(T2_DIV_BY_1, 150, 1); 
.................... //!   setup_ccp2(CCP_PWM);   // Configure CCP2 as a PWM 
.................... //!   set_pwm2_duty(0); 
.................... //!   return; 
.................... //!} 
.................... //! 
....................  
....................  
.................... //--------CAM MISSION---------------------------------------------------------- 
.................... //#define STORE_TO_SING AA 
.................... ////////////////////////////////////////////////// 
.................... //CAM MISSION ID: 0x54                          // 
.................... //CAM ACK: 0x61                                 // 
.................... //CAM Finish Storing: 0x62                      // 
.................... ////////////////////////////////////////////////// 
.................... int32 CAM_ADDRESS = 65536; 
.................... int8 CAM_ACK = 0; 
....................  
....................  
.................... void Turn_On_CAM() 
.................... { 
....................    output_high(PIN_D7); 
....................    return; 
.................... } 
....................  
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low(PIN_D7); 
....................    return; 
.................... } 
....................  
.................... void Send_Command_to_CAM(int8 data) //testing for EM integration 
.................... { 
....................    fputc(data,CAM); 
....................    return; 
.................... } 
....................  
.................... void CAM_SETTINGS() 
.................... { 
....................    //disable_interrupts(INT_rda);   // Main to PC 
....................    fprintf(PC,"CAM Start\r\n"); 
....................    COM_ONEBYTE_COMMAND = 0; 
....................    //Delete_Buffer(); 
....................    fprintf(PC,"Delete Buffer\r\n"); 
....................  
....................    output_high(PIN_A5); //turn on MUX (give access to CAM) 
....................    delay_ms(100); 
....................    Turn_On_CAM(); //Trun on CAM 
....................    fprintf(PC,"Turned On MUX And CAM\r\n"); 
....................    delay_ms(10); 
....................    return; 
.................... } 
....................  
.................... void CHECK_ACK_FROM_CAM_10k() //check 10000 times (keep listening about 10 sec) 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
....................    { 
....................       if(kbhit(CAM)/*kbhit(PC)*/) 
....................       { 
....................          CAM_ACK = fgetc(CAM/*PC*/); 
....................          break; 
....................       } 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void CHECK_ACK_FROM_CAM_200k() //check 200000 times(keep listening about 200 sec) 
.................... { 
....................    for(int32 num = 0; num < 40000000; num++)  
....................    { 
....................       if(kbhit(CAM)/*kbhit(PC)*/) 
....................       { 
....................          CAM_ACK = fgetc(CAM/*PC*/); 
....................          break; 
....................       } 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... int8 ACK_from_CAM() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM | PC); 
....................    return ack; 
.................... } 
....................  
.................... void Transfer_Photo() //transfer photo from Shared Mission Flash to Shared COM Flash 
.................... { 
....................    output_low(RA5); 
....................    output_low(RC4); 
....................    TRANSFER_DATA_NBYTE_SMFtoSCF(0,CAM_ADDRESS,65536); //from: sector0, to: sector1, datasize: 64kbyte(this value is for testing) 
....................    CAM_ADDRESS = CAM_ADDRESS + 65536; 
....................    return; 
.................... } 
....................  
.................... void CAM_TEST_OPERATION() //Integration Testing With CAM 
.................... { 
....................    CAM_SETTINGS();  //initialize_CAM 
....................    delay_ms(5000); 
....................     
....................  
....................    fprintf(PC,"Send Command to CAM\r\n"); 
....................    delay_ms(10); 
....................    Send_Command_to_CAM(0x54); 
....................  
....................    fputc(0x54,PC); 
....................    CHECK_ACK_FROM_CAM_10k(); 
....................     
....................    if(CAM_ACK == 0x61) 
....................    { 
....................       CAM_ACK = 0; 
....................       fprintf(PC,"ACK Get\r\n\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(PC,"Wait Next Command...\r\n\r\n"); 
....................       CHECK_ACK_FROM_CAM_200k(); 
....................        
....................       if(CAM_ACK == 0x62) 
....................       { 
....................          CAM_ACK = 0; 
....................          fprintf(PC,"PHOTO SAVING DONE\r\n"); 
....................           
....................          output_low(PIN_A5);  //turn off the mux(give access to MAIN) 
....................          delay_ms(10); 
....................          //TRANSFER_DATA_NBYTE_TOPC_SMF(0x00000000,256);  //for checking 
....................          output_low(PIN_C4); 
....................          delay_ms(10); 
....................          fprintf(PC,"Copy and Read Start\r\n"); 
....................          delay_ms(1000); 
....................           
....................          sector_erase_SCF(CAM_ADDRESS); 
....................          TRANSFER_DATA_NBYTE_SMFtoSCF(0x00000000,CAM_ADDRESS,65536); //From(SMF): sector0, To(SCF): sector1 
....................          TRANSFER_DATA_NBYTE_TOPC_SCF(65536,65536); 
....................          CAM_ADDRESS = CAM_ADDRESS + 65536; 
....................          delay_ms(10); 
....................           
....................       }else{ 
....................          CAM_ACK = 0; 
....................          fprintf(PC,"SAVING FAILURED\r\n"); 
....................       }    
....................  
....................    }else{ 
....................       CAM_ACK = 0; 
....................       fprintf(PC,"ACK FAILURED\r\n"); 
....................    } 
....................     
....................     
....................     
....................  
....................     
.................... //***************************************************************************** 
.................... //!   int8 CAMSIZE[4] = {}; 
.................... //!   int32 CAM_ADD; 
.................... //!   while(true) 
.................... //!   { 
.................... //!      if(fgetc(CAM) == 0x23) 
.................... //!      { 
.................... //!         for(int a = 0; a < 4; a++) 
.................... //!         { 
.................... //!            CAMSIZE[a] = fgetc(CAM); 
.................... //!         } 
.................... //!      } 
.................... //!   } 
.................... //!   CAM_ADD = ((CAMSIZE[0]<<24 | CAMSIZE[1]<<16 | CAMSIZE[2]<<8 | CAMSIZE[3]) & 0xffffffff); 
.................... //!    
.................... //!   fprintf(PC,"data adress is %x\r\n", CAM_ADD);//for testing 
.................... //***************************************************************************** 
....................    
....................    Turn_Off_CAM(); 
....................    fprintf(PC,"Turned OFF CAM\r\n"); 
....................    output_high(PIN_C4); //Give Access to COM PIC 
....................    //fputc(0x69,COM);  
....................    //enable_interrupts(INT_rda);   // Main to PC 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... //--------Data Collection MISSION---------------------------------------------- 
.................... Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... int8 DC_ACK = 0; 
....................  
.................... void Turn_On_DC() 
.................... { 
....................    output_high(PIN_F5); 
....................    return; 
.................... } 
....................  
.................... void Turn_Off_DC() 
.................... { 
....................    output_low(PIN_F5); 
....................    return; 
.................... } 
....................  
.................... void CHECK_ACK_FROM_DC_10k() 
.................... { 
....................    for(int32 num = 0; num < 5000000 ;num++) 
....................    { 
....................       if(kbhit(DC)) 
....................       { 
....................          DC_ACK = fgetc(DC); 
....................          break; 
....................       } 
....................       //delay_ms(1); 
....................    }    
....................    return; 
.................... } 
....................  
.................... void DATACOLLECTION_TEST_OPERATION() 
.................... { 
....................    Turn_On_DC(); 
....................     
....................    fprintf(PC,"Trun ON DCM\r\n"); 
....................    //delay_ms(1000); 
....................       for(int32 num = 0; num < 10000 ;num++){} 
....................    //fputc(0x25,DC); 
....................    //while(true) 
....................    //{ 
....................       //fputc(0x69,DC); 
....................       //fputc(fgetc(DC),PC); 
....................    //} 
....................    //fprintf(PC,"SEND COMMAND AND WAIT FOR RESPONSE\r\n"); 
....................    CHECK_ACK_FROM_DC_10k(); 
....................    if(DC_ACK == 0x69) 
....................    { 
....................       fprintf(PC,"Get ACK From DC\r\n"); 
....................       DC_ACK = 0; 
....................       fprintf(PC,"WAITING NEXT RESPONSE\r\n"); 
....................       CHECK_ACK_FROM_DC_10k(); 
....................       if(DC_ACK == 0x25) 
....................       { 
....................          fprintf(PC,"DC WORKING\r\n"); 
....................          output_low(PIN_C4); 
....................          Write_DATA_BYTE_SCF(DC_STATUS_ADDRESS,0xBB); 
....................          Write_DATA_BYTE_SMF(DC_STATUS_ADDRESS,0xBB); 
....................          output_high(PIN_C4); 
....................          fprintf(PC,"COM FLASH ADDRESS:%x, Status:BB ",DC_STATUS_ADDRESS); 
....................          DC_STATUS_ADDRESS++; 
....................          DC_ACK = 0; 
....................       }else{ 
....................          DC_ACK = 0; 
....................          fprintf(PC,"FAILUED GETTING ACK From DC\r\n"); 
....................          output_low(PIN_C4); 
....................          Write_DATA_BYTE_SCF(DC_STATUS_ADDRESS,0xCC); 
....................          Write_DATA_BYTE_SMF(DC_STATUS_ADDRESS,0xCC); 
....................          output_high(PIN_C4); 
....................          fprintf(PC,"COM FLASH ADDRESS:%x, Status:CC ",DC_STATUS_ADDRESS); 
....................          DC_STATUS_ADDRESS++; 
....................          DC_ACK = 0; 
....................       } 
....................    }else{ 
....................       DC_ACK = 0; 
....................       fprintf(PC,"FAILUED GETTING ACK From DC\r\n"); 
....................    } 
....................     
....................    fprintf(PC,"Turn OFF...\r\n"); 
....................    Turn_Off_DC(); 
....................    output_high(PIN_C4); 
....................     
....................    return; 
.................... } 
....................  
.................... //-------Kill Switch----------------------------------------------------------- 
....................  
.................... void Count_Kill_Flag() 
.................... { 
....................    Kill_FLAG_MAIN++; 
....................    if(Kill_FLAG_MAIN > 5) 
....................    { 
....................       output_high(PIN_A4); //Kill Switch ON 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... //---------OTHER FUNCTUON------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 29 
.................... unsigned int sec_add_bfr[FLASH_ADD_SIZE] = {}; 
.................... #define FLAG_INFO_SIZE 13 
.................... int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... void CURRENT_FLAG_STATUS() 
.................... { 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"PASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    return; 
.................... } 
....................  
.................... void CURRENT_ADDRESS_OF_FLASH() 
.................... { 
....................    fprintf(PC,"\r\nFAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"DC ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"MAIN FLASH CW ADDERSS:%x%x%x%x\r\n",FAB_CW_ADDRESS_FOR_MF>>24,FAB_CW_ADDRESS_FOR_MF>>16,FAB_CW_ADDRESS_FOR_MF>>8,FAB_CW_ADDRESS_FOR_MF); 
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    //fprintf(PC,"Kill Flag:%d\r\n",Kill_Flag); 
....................    //delay_ms(5000); 
....................    return; 
.................... } 
....................  
.................... void WRITE_FLAG_to_EEPROM() 
.................... { 
....................    WRITE_PROGRAM_EEPROM(0xff000000, BC_ATTEMPT_FLAG); 
....................    return; 
.................... } 
.................... void READ_FLAG_from_EEPROM() 
.................... { 
....................    BC_ATTEMPT_FLAG = READ_PROGRAM_EEPROM(0xff000000); 
....................    fprintf(PC,"BC=%x",BC_ATTEMPT_FLAG); 
....................    return; 
.................... } 
....................  
.................... void STORE_FLAG_INFO() 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS; 
....................    flag_info_bffr[2] = RESERVE_CHECK; 
....................    flag_info_bffr[3] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[4] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[5] = MISSION_CONTENTS; 
....................    flag_info_bffr[6] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[7] = Kill_FLAG_FAB; 
....................    flag_info_bffr[8] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[9] = AUTO_CAM_DONE; 
....................    flag_info_bffr[10] = AUTO_LDM_DONE; 
....................    flag_info_bffr[11] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[12] = ANT_DEP_STATUS; 
....................     
....................    SUBSECTOR_4KB_ERASE_OF(65536*2); 
....................    SUBSECTOR_4KB_ERASE_SCF(65536*2); 
....................    //sector_erase_OF(0); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(num,flag_info_bffr[num]); 
....................    } 
....................     
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(num,flag_info_bffr[num]); 
....................    } 
....................    fprintf(PC,"Storeing FLAG INFO DONE\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... void STORE_ADRESS_DATA_TO_OF() 
.................... { 
....................    fprintf(PC,"Start Storeing\r\n"); 
....................     
....................    sec_add_bfr[0] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[1] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FAB_HK_ADDRESS; 
....................        
....................    sec_add_bfr[4] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[5] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[6] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[7] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[8] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[9] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[10] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[11] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[17] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[18] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[19] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS_FOR_MF >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS_FOR_MF >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS_FOR_MF >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS_FOR_MF; 
....................     
....................    sec_add_bfr[24] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[25] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[26] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[27] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[28] = BC_ATTEMPT_FLAG; 
....................    SUBSECTOR_4KB_ERASE_OF(0); 
....................    SUBSECTOR_4KB_ERASE_SCF(0); 
....................    //sector_erase_OF(0); 
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(num,sec_add_bfr[num]); 
....................    } 
....................     
....................    for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(num,sec_add_bfr[num]); 
....................    } 
....................    fprintf(PC,"Storeing ADD DONE\r\n"); 
....................    return; 
.................... } 
....................  
.................... void TAKE_FLAG_INFO_FROM_OF() 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(65536*2 + num); 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_OF() 
.................... { 
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(num); 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void MAKE_FLAG_INFO() 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = flag_info_bffr[1]; 
....................    RESERVE_CHECK       = flag_info_bffr[2]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[3]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[4]; 
....................    MISSION_CONTENTS    = flag_info_bffr[5]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[6]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[7]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[8]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[9]; 
....................    AUTO_LDM_DONE       = flag_info_bffr[10]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[11]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[12]; 
....................    return; 
.................... } 
....................  
.................... void MAKE_ADDRESS_DATA() 
.................... { 
....................  
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FAB_HK_ADDRESS = FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................     
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//FAB_CW_ADDRESS = FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS = CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//DC_STATUS_ADDRESS = DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS_FOR_MF = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_FOR_MF = FAB_CW_ADDRESS_FOR_MF_1 | FAB_CW_ADDRESS_FOR_MF_2 | FAB_CW_ADDRESS_FOR_MF_3 | FAB_CW_ADDRESS_FOR_MF_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    BC_ATTEMPT_FLAG = sec_add_bfr[28]; 
....................     
....................    return; 
.................... } 
....................  
.................... void CHECK_FLAG_INFO() 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF(); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff) 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................    fprintf(PC,"%d",checksum); 
....................     
....................    if(checksum != FLAG_INFO_SIZE)//if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO(); 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... void CHECK_ADDRESS_DATA() 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF(); 
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)//if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    fprintf(PC,"%d",checksum); 
....................     
....................    if(checksum != FLASH_ADD_SIZE)//if something stored 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]); 
....................       } 
....................       MAKE_ADDRESS_DATA(); 
....................    } 
....................    checksum = 0; 
....................     
.................... //!   if(READ_PROGRAM_EEPROM(0) != 0xff) 
.................... //!   { 
.................... //!      READ_FLAG_from_EEPROM(); 
.................... //!   } 
....................     
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"ERASE START\r\n"); 
....................    sector_erase_OF(0); 
....................    sector_erase_OF(FAB_CW_ADDRESS_FOR_MF); 
....................    for(int8 num = 0; num < 15; num++) 
....................    { 
....................       sector_erase_OF(65536*(1800 + num));//HIGH_SAMP_HK_ADDRESS 
....................       sector_erase_SCF(65536*(1800 + num));//HIGH_SAMP_HK_ADDRESS 
....................    } 
....................    for(num = 0; num < 3; num++) 
....................    { 
....................       sector_erase_OF(65536*(200 + num));//HK_ADDRESS 
....................       sector_erase_SCF(65536*(200 + num));//HK_ADDRESS 
....................       sector_erase_OF(65536*(50 + num));//CW_ADDRESS 
....................       sector_erase_SCF(65536*(50 + num));//CW_ADDRESS 
....................    } 
....................    sector_erase_SMF(FAB_HK_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(ADCS_SENSOR_ADDRESS); 
....................    for(num = 0; num < 20; num++) 
....................    { 
....................       sector_erase_SMF(65536 * (0 + num));//CAM_ADDRESS 
....................       sector_erase_SCF(65536 * (0 + num));//CAM_ADDRESS 
....................       //sector_erase_OF(65536*50 + num);//HK_ADDRESS 
....................       //sector_erase_SCF(65536*50 + num);//HK_ADDRESS 
....................    } 
....................    sector_erase_SMF(65536); 
....................    sector_erase_SMF(CAM_ADDRESS); 
....................    sector_erase_SMF(DC_STATUS_ADDRESS); 
....................    sector_erase_SCF(FAB_HK_ADDRESS); 
....................    sector_erase_SCF(65536*200); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(ADCS_SENSOR_ADDRESS); 
....................    sector_erase_SCF(CAM_ADDRESS); 
....................    sector_erase_SCF(DC_STATUS_ADDRESS); 
....................    fprintf(PC,"DONE"); 
....................    delay_ms(5000); 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... //-------Reset Function-------------------------------------------------------- 
....................  
....................  
.................... void RESET_SATELLITE()//send command to RESETPIC to reset satellite 
.................... { 
....................    fputc(0x93,RESET); 
....................    fprintf(PC,"SEND RESET COMMAND TO RESETPIC\r\n"); 
....................    return; 
.................... } 
....................  
....................  
.................... void HIGHSAMP_SENSOR_COLLECTION(int16 times) 
.................... { 
....................    for(int16 num = 0; num < times;) 
....................    { 
....................       if(FAB_FLAG > 4) 
....................       { 
....................          FAB_FLAG = 0; 
....................          HIGH_SAMP_FAB_OPERATION(); 
....................  
....................          num++; 
....................          if((num % 20) == 0)//once in the 20 times(every 100sec save the address to the flash) 
....................          { 
....................             STORE_ADRESS_DATA_TO_OF();//for store the flag 
....................          }  
....................       } 
....................    } 
.................... } 
....................  
.................... void AUTOMATICAL_MISSION_CHECK() 
.................... { 
....................    if(PASSED_DAYS == 0 && FIRST_HSSC_DONE == 0) 
....................    { 
....................       HIGHSAMP_SENSOR_COLLECTION(HIGH_SAMP_TIMES); 
....................       FIRST_HSSC_DONE = 1; 
....................    } 
....................    if(PASSED_DAYS < make16(RESET_bffr[4],RESET_bffr[5]))//if the date changed 
....................    { 
....................       PASSED_DAYS = make16(RESET_bffr[4],RESET_bffr[5]); 
....................       switch(PASSED_DAYS) 
....................       { 
....................          case 0: 
....................             break; 
....................          case 10: 
....................             if(AUTO_CAM_DONE == 0) 
....................             { 
....................                CAM_TEST_OPERATION(); 
....................                AUTO_CAM_DONE = 1; 
....................             } 
....................             break; 
....................          case 15: 
....................             if(AUTO_LDM_DONE == 0) 
....................             { 
....................                DATACOLLECTION_TEST_OPERATION(); 
....................                AUTO_LDM_DONE = 1; 
....................             } 
....................             break; 
....................          case 20: 
....................             if(AUTO_ADCS_DONE == 0) 
....................             { 
....................                ADCS_TEST_OPERATION(); 
....................                AUTO_ADCS_DONE = 1; 
....................             } 
....................             break;             
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... //----------Flash_memory_MT25QL01GBBB_OF.c------------------------------------- 
....................  
.................... void WRITE_ENABLE_OF(); 
.................... void WRITE_ENABLE_SCF(); 
.................... void WRITE_ENABLE_SMF(); 
....................  
.................... void sector_erase_OF(unsigned int32 sector_address); 
.................... void sector_erase_SCF(unsigned int32 sector_address); 
.................... void sector_erase_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data); 
....................  
.................... int8 READ_CHIP_ID_OF(); 
.................... int8 READ_CHIP_ID_SCF(); 
.................... int8 READ_CHIP_ID_SMF(); 
....................  
.................... int8 READ_STATUS_REGISTER_OF(); 
.................... int8 READ_STATUS_REGISTER_SCF(); 
.................... int8 READ_STATUS_REGISTER_SMF(); 
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS); 
....................  
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM); 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte); 
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
....................  
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to MISSION FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MISSION FLASH 
....................  
.................... void TRANSFER_DATA_NBYTE_OF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //for testing 
....................  
.................... //void sector_erase(unsigned int32 sector_address);  //this is for sector erase 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
.................... #include<reserve_function.c> 
.................... #define table_size 30 
.................... unsigned int8 reserve_table[table_size+1] = {}; 
.................... unsigned int8 table_num = 0; 
.................... int32 RSV_DATA_ADDRESS=0x00a00000; 
....................  
.................... void initialize_table() 
.................... { 
....................    for(int num = 0; num < table_size; num++) 
....................    { 
....................       reserve_table[num] = 0xff; 
....................    } 
....................    reserve_table[30] = 0; 
....................    return; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //                          ***Sort Function*** 
.................... //This is for sorting the saved reservation commands in ascending order. 
.................... // 
.................... //reserved_table[j-4] reserved_table[j-3] reserved_table[j-2] 
.................... //reserved_table[j-1]  reserved_table[j]  reserved_table[j+1] 
.................... // 
.................... //j-4 and j-1 data are the contents information(like mission) 
.................... //j-3 and j data are the time data(execute the command reserved_table[j] min later ) 
.................... //j-2 and j+1 data are the contents detail information 
.................... // 
.................... //by comapring j-3 and j data,if it is needed, swhich j-4 and j-1, j-3 and j, j-2 and j+1 
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void sort_table()//(command info, time info, mission mode)~10compare the time and sort 
.................... { 
....................    for(int i = 1; i < table_size - 2; i = i + 3){ 
....................  
....................       // compare from lower site 
....................       for(int j = table_size - 2; j > i; j = j - 3){ 
....................  
....................       // if upper value is larger, switch the values 
....................          if(reserve_table[j] < reserve_table[j-3]){//compare the time of [j]th and [j-3]th 
....................             int t1 = reserve_table[j+1]; 
....................             int t2 = reserve_table[j]; 
....................             int t3 = reserve_table[j-1]; 
....................              
....................             reserve_table[j+1] = reserve_table[j-2]; 
....................             reserve_table[j] = reserve_table[j-3]; 
....................             reserve_table[j-1] = reserve_table[j-4]; 
....................              
....................             reserve_table[j-2] = t1; 
....................             reserve_table[j-3] = t2; 
....................             reserve_table[j-4] = t3; 
....................          } 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Save_RSV() 
.................... { 
....................    SUBSECTOR_4KB_ERASE_OF(RSV_DATA_ADDRESS); 
....................    SUBSECTOR_4KB_ERASE_SCF(RSV_DATA_ADDRESS); 
....................    SUBSECTOR_4KB_ERASE_SMF(RSV_DATA_ADDRESS); 
....................    for(int num = 0; num < table_size + 1; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
....................       WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
....................       WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
....................    } 
....................     
....................    WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+31,RESERVE_MIN_FLAG); 
....................    WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+31,RESERVE_MIN_FLAG); 
....................    WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+31,RESERVE_MIN_FLAG); 
....................    for(num = 0; num < table_size + 1; num++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num)); 
....................    } 
....................    fprintf(PC,"\r\n"); 
....................    return; 
.................... } 
....................  
.................... void table_refresh()//everything is back to default  
.................... { 
....................    for(int i = 0; i < table_size; i++) 
....................    { 
....................       reserve_table[i] = 0xff; 
....................    } 
....................    reserve_table[30] = 0; 
....................    RESERVE_CHECK = 0; 
....................    MISSION_CONTENTS = 0;//closest mission command 
....................    RESERVE_TARGET_FLAG = 0;//closest time data 
....................    Save_RSV(); 
....................    return; 
.................... } 
....................  
.................... void Get_RSV() 
.................... { 
....................    //fprintf(PC,"%x"); 
....................    for(int num = 0; num < table_size+1; num++) 
....................    { 
....................       reserve_table[num]=READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num); 
....................    } 
.................... //   RESERVE_MIN_FLAG = READ_DATA_BYTE_OF(RSV_DATA_ADDRESS+31); 
....................    if(reserve_table[30] == 0xFF || reserve_table[30] == 0x00) 
....................    { 
....................       initialize_table(); 
....................    } 
....................    table_num = reserve_table[30]; 
....................    if(table_num != 0x00)//yes-->get reserved command and target time 
....................    { 
....................       RESERVE_CHECK = 1; 
....................       MISSION_CONTENTS = reserve_table[0];//closest mission command 
....................       RESERVE_TARGET_FLAG = reserve_table[1];//closest time data 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Disp_RSV()//show the reserve status (reserve command and reserve table) 
.................... { 
....................    Get_RSV();//get the info from the main flash 
....................    for(int num = 0; num < table_size+1; num++) 
....................    { 
....................       fprintf(PC,"%x",reserve_table[num]); 
....................    } 
....................    fprintf(PC,"\r\n"); 
....................    fprintf(PC,"RESERVE_CHECK = %x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"NEXT MISSION_CONTENTS = %x\r\n",MISSION_CONTENTS); 
....................    fprintf(PC,"RESERVE_TARGET_FLAG = %x\r\n",RESERVE_TARGET_FLAG); 
....................    fprintf(PC,"RESERVE_MIN_FLAG = %x\r\n",RESERVE_MIN_FLAG); 
....................    fprintf(PC,"table_num = %d\r\n",table_num); 
....................     
....................    return; 
.................... } 
....................  
.................... void input_reservation_COM()//put the command from COM into the table and sort 
.................... { 
.................... //!   reserve_table[table_num] = CMD_FROM_PC[0];//input the data about mission content 
.................... //!   reserve_table[table_num + 1] = CMD_FROM_PC[1];//input the data about time data 
.................... //!   reserve_table[table_num + 2] = CMD_FROM_PC[2];//input the data about mission detail mode 
....................    if(reserve_table[30] == 30) 
....................    { 
....................       fprintf(PC,"Reservation Full!\r\n\r\n"); 
....................    }else{ 
....................       if(in_bffr_main[5] <= RESERVE_TARGET_FLAG && RESERVE_CHECK != 0x00) 
....................       { 
....................          for(int num = 1; num < table_size - 2; num = num + 3) 
....................          { 
....................             if(reserve_table[num-1] != 0xff)//check whether command data is placed 
....................             { 
....................                reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;//update the time of all commands 
....................             } 
....................          } 
....................          reserve_table[table_num] = in_bffr_main[4];//input the data about mission content 
....................          reserve_table[table_num + 1] = in_bffr_main[5]; 
....................          RESERVE_MIN_FLAG = 0; 
....................       }else if(table_num != 0x00) 
....................       { 
....................          reserve_table[table_num + 1] = in_bffr_main[5] + RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG;//input the data about time data 
....................       }else{//if first reservation just resreve 
....................          reserve_table[table_num] = in_bffr_main[4];//input the data about mission content 
....................          reserve_table[table_num + 1] = in_bffr_main[5]; 
....................       } 
....................       reserve_table[table_num + 2] = in_bffr_main[6];//input the data about mission detail mode 
....................       table_num = table_num + 3;//update the table data 
....................       sort_table(); 
....................       for(int num = 0; num < table_size+1; num++) 
....................       { 
....................          fprintf(PC,"%x",reserve_table[num]);//show for the test 
....................       } 
....................       reserve_table[30] = table_num; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void input_reservation_PC()//put the command form PC into the table and sort 
.................... { 
.................... //!   reserve_table[table_num] = in_bffr_main[4]; 
.................... //!   reserve_table[table_num + 1] = in_bffr_main[5]; 
.................... //!   reserve_table[table_num + 2] = in_bffr_main[6]; 
....................    if(reserve_table[30] == 30) 
....................    { 
....................       fprintf(PC,"Reservation Full!\r\n\r\n"); 
....................    }else{ 
....................       if(CMD_FROM_PC[1] <= RESERVE_TARGET_FLAG && RESERVE_CHECK != 0x00) 
....................       { 
....................          for(int num = 1; num < table_size - 2; num = num + 3) 
....................          { 
....................             if(reserve_table[num-1] != 0xff)//check whether command data is placed 
....................             { 
....................                reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;//update the time of all commands 
....................             } 
....................          } 
....................          reserve_table[table_num] = CMD_FROM_PC[0];//input the data about mission content 
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1]; 
....................          RESERVE_MIN_FLAG = 0; 
....................       }else if(table_num != 0x00) 
....................       { 
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1] + RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG;//input the data about time data 
....................       }else{// 
....................          reserve_table[table_num] = CMD_FROM_PC[0];//input the data about mission content 
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1]; 
....................       } 
....................       reserve_table[table_num + 2] = CMD_FROM_PC[2];//input the data about mission detail mode 
....................       table_num = table_num + 3;//update the table data 
....................       sort_table(); 
....................       for(int num = 0; num < table_size+1; num++) 
....................       { 
....................          fprintf(PC,"%x",reserve_table[num]);//show for the test 
....................       } 
....................       reserve_table[30] = table_num; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void Remove_1_Reservation()//after executing the mission, it should be finished 
.................... { 
....................    for(int i = 1; i < table_size - 2; i = i + 3) 
....................    { 
....................       if(reserve_table[i-1] != 0xff)//check whether command data is placed 
....................       { 
....................          reserve_table[i] = reserve_table[i] - RESERVE_TARGET_FLAG;//update the time of all commands 
....................       } 
....................    } 
....................    reserve_table[0] = 0xff;//delete the finished mission data 
....................    reserve_table[1] = 0xff;//delete the finished mission data 
....................    reserve_table[2] = 0xff;//delete the finished mission data 
....................    reserve_table[30] = reserve_table[30] - 3;//update the table number data  
....................    sort_table(); 
....................    fprintf(PC,"remove finished command:"); 
....................    Save_RSV(); 
....................    fprintf(PC,"\r\n"); 
....................    return; 
.................... } 
....................  
.................... void Reserve_command_COM()//reservation from COM 
.................... { 
....................    fprintf(PC,"reserve\r\n"); 
....................    input_reservation_COM();//put reserve table buffer and sort 
....................    Save_RSV();//save reserve table to flash memory 
....................    RESERVE_CHECK = 1; 
....................    if(reserve_table[30] == 0x00) 
....................    { 
....................       RESERVE_MIN_FLAG = 0; //reset time flag 
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];//closest mission command 
....................    RESERVE_TARGET_FLAG = reserve_table[1];//closest time data 
.................... } 
....................  
.................... void Reserve_command_PC()//reservation from PC 
.................... { 
....................    fprintf(PC,"reserve\r\n"); 
....................    input_reservation_PC();//put reserve table buffer and sort 
....................    Save_RSV();//save reserve table to flash memory 
....................    if(reserve_table[30] == 0x00)//for only first reservation 
....................    { 
....................       RESERVE_CHECK = 1; 
....................       RESERVE_MIN_FLAG = 0; //reset time flag 
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];//closest mission command 
....................    RESERVE_TARGET_FLAG = reserve_table[1];//closest time data 
.................... } 
....................  
.................... void Reserve_next()//after finishing executing the reservation command, this function should be execute 
.................... { 
....................    fprintf(PC,"reserve next\r\n"); 
....................    //Save_RSV();//save reserve table to flash memory 
....................     
....................    //RESERVE_CHECK = 1; 
....................    RESERVE_MIN_FLAG = 0; //reset time flag 
....................    MISSION_CONTENTS = reserve_table[0];//update closest mission command 
....................    RESERVE_TARGET_FLAG = reserve_table[1];//update closest time data (it is the time after 1 mission) 
.................... } 
....................  
....................  
....................  
.................... #include<analyze_command.c> 
....................  
.................... void EXECUTE_MISSION_from_COM(int8 CMD) 
.................... { 
....................    switch(CMD) 
....................    { 
....................       case 0xC0: 
....................          CAM_TEST_OPERATION(); 
....................          if(AUTO_CAM_DONE == 0) 
....................          { 
....................             AUTO_CAM_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xA0: 
....................          ADCS_TEST_OPERATION(); 
....................          if(AUTO_ADCS_DONE == 0) 
....................          { 
....................             AUTO_ADCS_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xD0: 
....................          DATACOLLECTION_TEST_OPERATION(); 
....................          if(AUTO_LDM_DONE == 0) 
....................          { 
....................             AUTO_LDM_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          delay_ms(10); 
....................          break; 
....................       case 0x99: 
....................          CURRENT_ADDRESS_OF_FLASH(); 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xaa: 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //delay_ms(10); 
....................          break; 
....................       case 0x23: 
....................          //STORE_ADRESS_DATA_TO_OF(); 
....................          RESET_SATELLITE(); 
....................          break; 
....................       case 0xb0: 
....................          //CLEAR_BC_FLAG(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb1: 
....................          MAKE_BC_FLAG_1(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb2: 
....................          MAKE_BC_FLAG_2(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break;                
....................       case 0xb3: 
....................          MAKE_BC_FLAG_3(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb4: 
....................          MAKE_BC_FLAG_4(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0x4b: 
....................          Count_Kill_Flag(); 
....................          break; 
....................       case 0xfa: 
....................          //enable_interrupts(INT_rda3); 
....................          HIGHSAMP_SENSOR_COLLECTION(HIGH_SAMP_TIMES); 
....................          //disable_interrupts(INT_rda3); 
....................          break; 
....................       case 0x59: 
....................          GIVE_ACCESS_SCF_Nsec(5); 
....................          //Turn_OFF_ADCS(); 
....................          break; 
....................       case 0x9f: 
....................          Disp_RSV(); 
....................          break; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void EXECUTE_MISSION_from_PC(int8 CMD) 
.................... { 
....................    switch(CMD) 
....................    { 
....................       case 0xC0: 
....................          CAM_TEST_OPERATION(); 
....................          if(AUTO_CAM_DONE == 0) 
....................          { 
....................             AUTO_CAM_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xA0: 
....................          ADCS_TEST_OPERATION(); 
....................          if(AUTO_ADCS_DONE == 0) 
....................          { 
....................             AUTO_ADCS_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xD0: 
....................          DATACOLLECTION_TEST_OPERATION(); 
....................          if(AUTO_LDM_DONE == 0) 
....................          { 
....................             AUTO_LDM_DONE = 1; 
....................             STORE_FLAG_INFO(); 
....................          } 
....................          delay_ms(10); 
....................          break; 
....................       case 0x99: 
....................          CURRENT_ADDRESS_OF_FLASH(); 
....................          //delay_ms(10); 
....................          break; 
....................       case 0xaa: 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //delay_ms(10); 
....................          break; 
....................       case 0x23: 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          RESET_SATELLITE(); 
....................          break; 
....................       case 0xb0: 
....................          //CLEAR_BC_FLAG(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb1: 
....................          MAKE_BC_FLAG_1(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb2: 
....................          MAKE_BC_FLAG_2(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break;                
....................       case 0xb3: 
....................          MAKE_BC_FLAG_3(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          break; 
....................       case 0xb4: 
....................          MAKE_BC_FLAG_4(); 
....................          STORE_ADRESS_DATA_TO_OF(); 
....................          STORE_FLAG_INFO(); 
....................          //WRITE_FLAG_to_EEPROM(); 
....................          //READ_FLAG_from_EEPROM(); 
....................          break; 
....................       case 0x4b: 
....................          Count_Kill_Flag(); 
....................          break; 
....................       case 0xfa: 
....................          //enable_interrupts(INT_rda3); 
....................          HIGHSAMP_SENSOR_COLLECTION(HIGH_SAMP_TIMES); 
....................          Turn_OFF_ADCS(); 
....................          //disable_interrupts(INT_rda3); 
....................          break; 
....................       case 0x59: 
....................          GIVE_ACCESS_SCF_Nsec(5); 
....................          //Turn_OFF_ADCS(); 
....................          break; 
....................       case 0xee: 
....................          MEMORY_ERASE(); 
....................       break; 
....................       case 0x9f: 
....................          Disp_RSV(); 
....................          break; 
....................       case 0xcf: 
....................          table_refresh(); 
....................          break; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void Check_UART(); 
.................... void waiting(int32 counterval); 
.................... //void Turn_On_PWM(int a) 
.................... //void Turn_OFF_PWM() 
....................  
....................  
.................... /////////////MAIN PIC Buffer///////////// 
.................... void SerialDataReceive(); //get buffer data one by one 
.................... void Delete_Buffer(); //get buffer data one by one 
.................... void Transfer_Buffer(int PORT_NUM); //get buffer data one by one 
....................  
.................... SerialDataReceive(); 
.................... Transfer_Buffer(int PORT_NUM); //1:PC 2:COMPIC 3:RESETPIC 4:ADCS 5:S&F 6:CAM 
....................  
.................... /////////////RESET SENSOR collection///////////// 
....................  
.................... void DELETE_RESET(); 
.................... void COLLECT_RESET_DATA(); 
....................  
.................... /////////////FAB SENSOR collection///////////// 
.................... void Delete_in_HK(); 
.................... void Delete_HKDATA(); 
.................... void Delete_CWFORMAT(); 
.................... void MAKE_CW_FORMAT(); 
.................... void SAVE_HKDATA_TO_OF(unsigned int32 Memory_Adress); 
.................... void SAVE_HKDATA_TO_SCF(unsigned int32 Memory_Adress); 
.................... void SAVE_CWFORMAT_TO_OF(unsigned int32 Memory_Adress); 
.................... void SAVE_CWFORMAT_TO_SCF(unsigned int32 Memory_Adress); 
.................... void Send_COMMAND_TO_FAB(int8 cmd); 
.................... int8 ACK_FROM_FAB(); 
.................... void Send_HKDATA_to_SCF(int32 adress); 
.................... void Send_HKDATA_to_OF(int32 adress); 
.................... void SEND_CWFORMAT_TO_SCF(int32 adress); 
.................... void SEND_CWFORMAT_TO_OF(int32 adress); 
.................... void Send_HKDATA_to_PC(int32 adress); 
.................... void CHECK_HKDATA(int8 in); 
.................... void VERIFY_FABDATA(int32 delaytime1,int32 delaytime2); 
.................... void FAB_TEST_OPERATION(); 
.................... void GET_RESET_DATA(); 
....................  
.................... ///////////////HIGH SAMPLING HK collection////////////// 
.................... void SAVE_HIGH_HKDATA_TO_SCF(unsigned int32 Memory_Adress); 
.................... void Send_HIGH_HKDATA_to_SCF(int32 adress); 
.................... void SAVE_HIGH_HKDATA_TO_OF(unsigned int32 Memory_Adress); 
.................... void Send_HIGH_HKDATA_to_OF(int32 adress); 
.................... void CHECK_HIGH_SAMP_FABDATA(int8 in); 
.................... void VERIFY_HIGH_SAMP_FABDATA(int32 delaytime); 
.................... void GET_HIGH_SAMP_RESET_DATA(); 
.................... void HIGH_SAMP_FAB_OPERATION(); 
.................... void HIGHSAMP_SENSOR_COLLECTION(int16 second); 
....................  
.................... /////////////ANTENNA DEPLOYMENT///////////// 
.................... void BC_SETUP(); 
.................... void BC_READ_TO_PC(); 
.................... void CHECK_BC_TEMP(); 
.................... void Turn_ON_BC(); 
.................... void Turn_OFF_BC(); 
.................... void CHECK_POWER(); 
.................... void BC_OPERATION(); 
.................... void CLEAR_BC_FLAG(); 
.................... void MAKE_BC_FLAG_1(); 
.................... void MAKE_BC_FLAG_2(); 
.................... void MAKE_BC_FLAG_3(); 
.................... void MAKE_BC_FLAG_4(); 
....................  
....................  
.................... /////////////CAM MISSION///////////// 
.................... void Turn_On_CAM(); 
.................... void Turn_Off_CAM(); 
.................... void Send_Command_to_CAM(int8 data); 
.................... int8 ACK_from_CAM(); 
.................... void Transfer_Photo(); 
.................... void CAM_TEST_OPERATION(); 
....................  
....................  
.................... /////////////ADCS MISSION///////////// 
....................  
.................... void Turn_On_ADCS(); 
.................... void Turn_Off_ADCS(); 
.................... void Send_Command_to_ADCS(int8 data); 
.................... void DELETE_ADCS_SENSOR(); 
.................... void ADCS_SETTINGS();//initiallize 
.................... void DISPLAY_ADCS_SENSOR_TO_PC();//for testing 
.................... void Get_ADCS_Data(); 
.................... void SAVE_SENSOR_TO_SMF(); 
.................... void TRANSFER_SENSOR_FROM_SMF_TO_SCF(); 
.................... void ADCS_TEST_OPERATION(); 
....................  
....................  
.................... /////////////Data Collection MISSION///////////// 
.................... void Turn_On_DC(); 
.................... void Turn_Off_DC(); 
.................... void DATACOLLECTION_TEST_OPERATION(); 
....................  
.................... /////////////KILL FUNCTION/////////////////////// 
.................... void Count_Kill_Flag(); 
....................  
.................... /////////////OTHER FUNCTION////////////////////// 
.................... void CURRENT_ADDRESS_OF_COM_FLASH(); 
.................... void STORE_ADRESS_DATA_TO_OF(); 
.................... void TAKE_ADDRESS_DATA_FROM_OF(); 
.................... void MAKE_ADDRESS_DATA(); 
.................... void CHECK_ADDRESS_DATA(); 
.................... void MEMORY_ERASE(); 
....................  
....................  
.................... ////////////////////////////////RESERVATION FUNCTION (reserve_function.c)///////////////////////////////// 
.................... void initialize_table(); 
.................... void sort_table();//(command info, time info, mission mode)~10compare the time and sort 
.................... void Save_RSV(); 
.................... void table_refresh(); 
.................... void Get_RSV(); 
.................... void Disp_RSV();//show the reserve status (reserve command and reserve table) 
.................... void input_reservation_COM();//put the command into the table and sort 
.................... void input_reservation_PC();//put the command into the table and sort 
.................... void Remove_1_Reservation();//after executing the mission, it should be finished 
.................... void Reserve_command_COM();//reservation from COM 
.................... void Reserve_command_PC();//reservation from PC 
.................... void Reserve_next();//after finishing executing the reservation command, this function should be execute 
....................  
....................  
....................  
....................  
.................... int8 BUF_CMD_FROM_PC[4] = {}; 
.................... int8 ynflag1 = 0;//for checking address info 
.................... int8 ynflag2 = 0;//for checking data size info 
.................... int32 address = 0; 
.................... int32 data_size = 0; 
....................  
.................... void settings(); 
.................... void delete_pc_buffer(); 
.................... void certification1(); 
.................... void certification2(); 
.................... void put_address_number(); 
.................... void put_data_size(); 
....................  
....................  
.................... #INT_rda//PC Interrupt 
.................... void UART1_RXD(void) 
.................... { 
....................    BUF_CMD_FROM_PC[PC_DATA] = fgetc(PC); 
*
0082E:  CLRF   03
00830:  MOVF   36,W
00832:  ADDLW  E6
00834:  MOVWF  FE9
00836:  MOVLW  01
00838:  ADDWFC 03,W
0083A:  MOVWF  FEA
0083C:  BTFSS  F9E.5
0083E:  BRA    083C
00840:  MOVFF  FAE,FEF
....................    PC_DATA = ((PC_DATA + 1) % 4); 
00844:  MOVLW  01
00846:  ADDWF  36,W
00848:  ANDLW  03
0084A:  MOVWF  36
....................    //fputc(fgetc(PC),PC); 
0084C:  BCF    F9E.5
0084E:  GOTO   0078
.................... } 
....................  
....................  
.................... void main() 
*
00DDC:  CLRF   FF8
00DDE:  BCF    F9F.5
00DE0:  BSF    FD0.7
00DE2:  BSF    07.7
00DE4:  MOVLB  E
00DE6:  MOVLW  55
00DE8:  MOVWF  F7E
00DEA:  MOVLW  AA
00DEC:  MOVWF  F7E
00DEE:  BCF    F66.6
00DF0:  MOVLW  F4
00DF2:  MOVWF  x2A
00DF4:  MOVLW  F5
00DF6:  MOVWF  x2B
00DF8:  MOVLW  F8
00DFA:  MOVWF  x2C
00DFC:  MOVLW  F9
00DFE:  MOVWF  x2D
00E00:  MOVLW  01
00E02:  MOVWF  x1B
00E04:  MOVLW  20
00E06:  MOVWF  x1D
00E08:  MOVLW  30
00E0A:  MOVWF  x22
00E0C:  MOVLW  20
00E0E:  MOVWF  x24
00E10:  MOVLW  55
00E12:  MOVWF  F7E
00E14:  MOVLW  AA
00E16:  MOVWF  F7E
00E18:  BSF    F66.6
00E1A:  CLRF   F9B
00E1C:  CLRF   F64
00E1E:  CLRF   F65
00E20:  CLRF   F66
00E22:  MOVLW  02
00E24:  MOVWF  FD3
00E26:  BSF    F67.3
00E28:  MOVLW  22
00E2A:  MOVWF  FAF
00E2C:  MOVLW  00
00E2E:  MOVLB  F
00E30:  MOVWF  x30
00E32:  MOVLW  A6
00E34:  MOVWF  FAC
00E36:  MOVLW  90
00E38:  MOVWF  FAB
00E3A:  BSF    x31.3
00E3C:  MOVLW  A0
00E3E:  MOVWF  x1F
00E40:  MOVLW  01
00E42:  MOVWF  x20
00E44:  MOVLW  A6
00E46:  MOVWF  x32
00E48:  MOVLW  90
00E4A:  MOVWF  x33
00E4C:  BSF    x2D.3
00E4E:  MOVLW  A0
00E50:  MOVWF  x2B
00E52:  MOVLW  01
00E54:  MOVWF  x2C
00E56:  MOVLW  A6
00E58:  MOVWF  x2E
00E5A:  MOVLW  90
00E5C:  MOVWF  x2F
00E5E:  MOVLB  E
00E60:  BSF    xFD.3
00E62:  MOVLW  A0
00E64:  MOVWF  xFB
00E66:  MOVLW  01
00E68:  MOVWF  xFC
00E6A:  MOVLW  A6
00E6C:  MOVWF  xFE
00E6E:  MOVLW  90
00E70:  MOVWF  xFF
00E72:  BCF    F97.7
00E74:  BSF    F8E.7
00E76:  BCF    F98.2
00E78:  BSF    F8F.2
00E7A:  BCF    F98.0
00E7C:  BSF    F8F.0
00E7E:  BSF    F96.0
00E80:  BCF    F96.6
00E82:  BCF    F96.1
00E84:  BCF    F8D.1
00E86:  BSF    F93.5
00E88:  BCF    F93.4
00E8A:  BCF    F93.2
00E8C:  BCF    F8A.2
00E8E:  BSF    F92.0
00E90:  BCF    F92.1
00E92:  BCF    F92.3
00E94:  BCF    F89.3
00E96:  CLRF   1C
00E98:  CLRF   1B
00E9A:  CLRF   30
00E9C:  CLRF   31
00E9E:  CLRF   32
00EA0:  CLRF   33
00EA2:  CLRF   34
00EA4:  CLRF   35
00EA6:  CLRF   36
00EA8:  CLRF   37
00EAA:  CLRF   39
00EAC:  CLRF   38
00EAE:  CLRF   3A
00EB0:  CLRF   3B
00EB2:  CLRF   3C
00EB4:  CLRF   3D
00EB6:  CLRF   3E
00EB8:  CLRF   42
00EBA:  CLRF   41
00EBC:  CLRF   40
00EBE:  CLRF   3F
00EC0:  CLRF   43
00EC2:  CLRF   44
00EC4:  CLRF   45
00EC6:  CLRF   51
00EC8:  CLRF   50
00ECA:  CLRF   53
00ECC:  CLRF   52
00ECE:  CLRF   55
00ED0:  CLRF   54
00ED2:  CLRF   59
00ED4:  CLRF   58
00ED6:  CLRF   57
00ED8:  CLRF   56
00EDA:  CLRF   5D
00EDC:  CLRF   5C
00EDE:  CLRF   5B
00EE0:  CLRF   5A
00EE2:  CLRF   5F
00EE4:  CLRF   5E
00EE6:  MOVLB  0
00EE8:  CLRF   x61
00EEA:  CLRF   x60
00EEC:  MOVLW  01
00EEE:  MOVWF  xC9
00EF0:  MOVLW  F4
00EF2:  MOVWF  xC8
00EF4:  CLRF   xC7
00EF6:  CLRF   xC6
00EF8:  CLRF   xCA
00EFA:  CLRF   xCB
00EFC:  CLRF   xCC
00EFE:  MOVLB  1
00F00:  CLRF   x76
00F02:  CLRF   x77
00F04:  CLRF   x78
00F06:  CLRF   x7C
00F08:  CLRF   x7B
00F0A:  CLRF   x7A
00F0C:  CLRF   x79
00F0E:  CLRF   x7D
00F10:  CLRF   x81
00F12:  MOVLW  C8
00F14:  MOVWF  x80
00F16:  CLRF   x7F
00F18:  CLRF   x7E
00F1A:  CLRF   x85
00F1C:  MOVLW  32
00F1E:  MOVWF  x84
00F20:  CLRF   x83
00F22:  CLRF   x82
00F24:  CLRF   x89
00F26:  MOVLW  01
00F28:  MOVWF  x88
00F2A:  CLRF   x87
00F2C:  CLRF   x86
00F2E:  MOVLW  07
00F30:  MOVWF  x8D
00F32:  MOVLW  08
00F34:  MOVWF  x8C
00F36:  CLRF   x8B
00F38:  CLRF   x8A
00F3A:  CLRF   x91
00F3C:  MOVLW  01
00F3E:  MOVWF  x90
00F40:  CLRF   x8F
00F42:  CLRF   x8E
00F44:  CLRF   x92
00F46:  MOVWF  x96
00F48:  MOVLW  2C
00F4A:  MOVWF  x95
00F4C:  CLRF   x94
00F4E:  CLRF   x93
00F50:  CLRF   x97
00F52:  CLRF   xE1
00F54:  CLRF   xE5
00F56:  MOVLW  A0
00F58:  MOVWF  xE4
00F5A:  CLRF   xE3
00F5C:  CLRF   xE2
00F5E:  CLRF   xEA
00F60:  CLRF   xEB
00F62:  CLRF   xEF
00F64:  CLRF   xEE
00F66:  CLRF   xED
00F68:  CLRF   xEC
00F6A:  CLRF   xF3
00F6C:  CLRF   xF2
00F6E:  CLRF   xF1
00F70:  CLRF   xF0
00F72:  MOVLB  E
00F74:  CLRF   xD9
00F76:  CLRF   xDA
00F78:  CLRF   x45
00F7A:  CLRF   x46
00F7C:  CLRF   x47
00F7E:  BCF    x8D.7
00F80:  BCF    x8D.6
00F82:  BCF    x8D.5
00F84:  MOVLB  1
00F86:  CLRF   x88
00F88:  MOVLB  F
00F8A:  CLRF   x53
00F8C:  CLRF   x38
00F8E:  CLRF   x37
00F90:  BRA    0FAE
00F92:  DATA 13,40
00F94:  DATA 1D,00
00F96:  DATA 0A,40
00F98:  DATA 46,00
00F9A:  DATA 64,40
00F9C:  DATA 62,00
00F9E:  DATA A9,40
00FA0:  DATA CD,00
00FA2:  DATA 49,41
00FA4:  DATA 98,00
00FA6:  DATA 04,01
00FA8:  DATA E6,00
00FAA:  DATA 00,00
00FAC:  DATA 00,00
00FAE:  MOVLW  00
00FB0:  MOVWF  FF8
00FB2:  MOVLW  0F
00FB4:  MOVWF  FF7
00FB6:  MOVLW  92
00FB8:  MOVWF  FF6
00FBA:  TBLRD*+
00FBC:  MOVF   FF5,W
00FBE:  MOVWF  00
00FC0:  XORLW  00
00FC2:  BZ    0FEA
00FC4:  TBLRD*+
00FC6:  MOVF   FF5,W
00FC8:  MOVWF  01
00FCA:  BTFSC  FE8.7
00FCC:  BRA    0FD8
00FCE:  ANDLW  0F
00FD0:  MOVWF  FEA
00FD2:  TBLRD*+
00FD4:  MOVFF  FF5,FE9
00FD8:  BTFSC  01.6
00FDA:  TBLRD*+
00FDC:  BTFSS  01.6
00FDE:  TBLRD*+
00FE0:  MOVFF  FF5,FEE
00FE4:  DCFSNZ 00,F
00FE6:  BRA    0FBA
00FE8:  BRA    0FDC
00FEA:  CLRF   FF8
.................... { 
....................    settings(); 
00FEC:  MOVLB  0
00FEE:  BRA    0910
....................    float num = 0x3b28e384; 
....................    int32 con = 0; 
00FF0:  MOVLW  8E
00FF2:  MOVLB  1
00FF4:  MOVWF  xF7
00FF6:  MOVLW  A3
00FF8:  MOVWF  xF6
00FFA:  MOVLW  6C
00FFC:  MOVWF  xF5
00FFE:  MOVLW  9C
01000:  MOVWF  xF4
01002:  CLRF   xFB
01004:  CLRF   xFA
01006:  CLRF   xF9
01008:  CLRF   xF8
....................    while(true) 
....................    { 
....................       fprintf(PC,"%.6f\r\n",num); 
0100A:  MOVLW  89
0100C:  MOVWF  FE9
0100E:  MOVFF  1F7,1FF
01012:  MOVFF  1F6,1FE
01016:  MOVFF  1F5,1FD
0101A:  MOVFF  1F4,1FC
0101E:  MOVLW  06
01020:  MOVLB  2
01022:  MOVWF  x00
01024:  MOVLB  0
01026:  BRA    0AF2
01028:  MOVLW  0D
0102A:  BTFSS  F9E.4
0102C:  BRA    102A
0102E:  MOVWF  FAD
01030:  MOVLW  0A
01032:  BTFSS  F9E.4
01034:  BRA    1032
01036:  MOVWF  FAD
....................       delay_ms(3000); 
01038:  MOVLW  0C
0103A:  MOVLB  1
0103C:  MOVWF  xFC
0103E:  MOVLW  FA
01040:  MOVWF  xFD
01042:  MOVLB  0
01044:  BRA    0C98
01046:  MOVLB  1
01048:  DECFSZ xFC,F
0104A:  BRA    103E
....................       con = num && 0xffffffff; 
0104C:  MOVF   xF4,F
0104E:  BNZ   1060
01050:  MOVF   xF5,F
01052:  BNZ   1060
01054:  MOVF   xF6,F
01056:  BNZ   1060
01058:  MOVF   xF7,F
0105A:  BNZ   1060
0105C:  MOVLW  00
0105E:  BRA    1062
01060:  MOVLW  01
01062:  CLRF   xFB
01064:  CLRF   xFA
01066:  CLRF   xF9
01068:  MOVWF  xF8
....................       fprintf(PC,"%ld\r\n",con); 
0106A:  MOVLW  41
0106C:  MOVWF  FE9
0106E:  MOVFF  1FB,1FF
01072:  MOVFF  1FA,1FE
01076:  MOVFF  1F9,1FD
0107A:  MOVFF  1F8,1FC
0107E:  MOVLB  0
01080:  BRA    0CC4
01082:  MOVLW  0D
01084:  BTFSS  F9E.4
01086:  BRA    1084
01088:  MOVWF  FAD
0108A:  MOVLW  0A
0108C:  BTFSS  F9E.4
0108E:  BRA    108C
01090:  MOVWF  FAD
01092:  MOVLB  1
01094:  BRA    100A
....................    } 
.................... } 
....................  
01096:  SLEEP 
....................  
.................... //!void main() 
.................... //!{ 
.................... //!   settings(); 
.................... //!   while(true) 
.................... //!   { 
.................... //!      if(BUF_CMD_FROM_PC[0]==0x25) 
.................... //!      { 
.................... //!         delete_pc_buffer(); 
.................... //!         put_address_number(); 
.................... //!          
.................... //!         if(ynflag1 == 0) 
.................... //!         { 
.................... //!            delete_pc_buffer(); 
.................... //!            put_data_size(); 
.................... //!            if(ynflag2 == 0) 
.................... //!            { 
.................... //!               TRANSFER_DATA_NBYTE_TOPC_SCF(address, data_size); //for testing 
.................... //!            }else{ 
.................... //!               fprintf(PC,"error1\r\n"); 
.................... //!               delay_ms(1000); 
.................... //!               delete_pc_buffer(); 
.................... //!               BUF_CMD_FROM_PC[0] = 0x25; 
.................... //!            } 
.................... //!         delete_pc_buffer(); 
.................... //!         }else{ 
.................... //!            fprintf(PC,"error2\r\n"); 
.................... //!            delay_ms(1000); 
.................... //!            delete_pc_buffer(); 
.................... //!            BUF_CMD_FROM_PC[0] = 0x25; 
.................... //!         } 
.................... //! 
.................... //!      } 
.................... //!   } 
.................... //!    
.................... //!} 
.................... //! 
.................... //! 
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void settings() 
.................... { 
....................    enable_interrupts(global); 
*
00910:  MOVLW  C0
00912:  IORWF  FF2,F
....................    enable_interrupts(INT_rda);   // Main to PC 
00914:  BSF    F9D.5
.................... //   enable_interrupts(INT_rda2);  // Main to COM PIC 
....................    //enable_interrupts(INT_rda3);  // Main to FAB PIC 
....................    //enable_interrupts(INT_rda4);  // Main to RESET PIC 
....................    //enable_interrupts(INT_TIMER0); 
....................     
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_BIT); 
00916:  MOVLW  D7
00918:  MOVWF  FD5
....................    set_timer0(0); 
0091A:  CLRF   FD7
0091C:  CLRF   FD6
....................    return; 
0091E:  GOTO   0FF0 (RETURN)
.................... } 
....................  
.................... void delete_pc_buffer()//delete everything 
.................... { 
....................    ynflag1 = 0; 
....................    ynflag2 = 0; 
....................    PC_DATA = 0; 
....................    for(int i = 0; i < 3; i++) 
....................    { 
....................       BUF_CMD_FROM_PC[i] = 0; 
....................    } 
.................... return; 
.................... } 
....................  
.................... void certification1() 
.................... { 
....................    while(true){ 
....................       if(BUF_CMD_FROM_PC[0] == 0x02) 
....................       { 
....................          ynflag1 = 1; 
....................          break; 
....................       }else if(BUF_CMD_FROM_PC[0] == 0x01){ 
....................          ynflag1 = 0; 
....................          break; 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void certification2() 
.................... { 
....................    while(true){ 
....................       if(BUF_CMD_FROM_PC[0] == 0x02) 
....................       { 
....................          ynflag2 = 1; 
....................          break; 
....................       }else if(BUF_CMD_FROM_PC[0] == 0x01){ 
....................          ynflag2 = 0; 
....................          break; 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void put_address_number() 
.................... { 
....................    fprintf(PC,"Download satellite data manually.\r\n"); 
....................    fprintf(PC,"Please input address number\r\n"); 
....................    while(true) 
....................    { 
....................       if(PC_data == 3) 
....................       { 
....................          delay_ms(100); 
....................          break; 
....................       } 
....................    } 
....................    address = make32(BUF_CMD_FROM_PC[0],BUF_CMD_FROM_PC[1],BUF_CMD_FROM_PC[2],BUF_CMD_FROM_PC[3]); 
....................    fprintf(PC,"%lx\r\n",address); 
....................    fprintf(PC,"Is the address correct?(yes:01, no:02)\r\n"); 
....................    delete_pc_buffer(); 
....................    certification1(); 
....................    return; 
.................... } 
....................  
.................... void put_data_size() 
.................... { 
....................    fprintf(PC,"Please input data size information \r\n"); 
....................    while(true) 
....................    { 
....................       if(PC_data == 3) 
....................       { 
....................          delay_ms(100); 
....................          break; 
....................       } 
....................    } 
....................    data_size = make32(BUF_CMD_FROM_PC[0],BUF_CMD_FROM_PC[1],BUF_CMD_FROM_PC[2],BUF_CMD_FROM_PC[3]); 
....................    fprintf(PC,"%ld\r\n",data_size); 
....................    fprintf(PC,"Is the data size correct?(yes:01, no:02)\r\n"); 
....................    delete_pc_buffer(); 
....................    certification2(); 
....................    return; 
.................... } 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
