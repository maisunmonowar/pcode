CCS PCH C Compiler, Version 5.056, 29513               04-Jun-20 17:21

               Filename:   C:\Users\maisun\Documents\PhD\offline\code\ccs\bootlo\main.lst

               ROM used:   1602 bytes (1%)
                           Largest free fragment is 65520
               RAM used:   73 (2%) at main() level
                           132 (4%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   05C8
.................... #include "main.h" 
.................... //#DEVICE ADC=16 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
*
0001E:  DATA 0D,0A
00020:  DATA 42,6F
00022:  DATA 6F,74
00024:  DATA 6C,6F
00026:  DATA 61,64
00028:  DATA 65,72
0002A:  DATA 20,56
0002C:  DATA 20,31
0002E:  DATA 0D,0A
00030:  DATA 00,00
00032:  DATA 0D,0A
00034:  DATA 64,6F
00036:  DATA 77,6E
00038:  DATA 6C,6F
0003A:  DATA 61,64
0003C:  DATA 69,6E
0003E:  DATA 67,00
*
00082:  TBLRD*+
00084:  MOVF   FF5,F
00086:  BZ    00A8
00088:  MOVFF  FF6,49
0008C:  MOVFF  FF7,4A
00090:  MOVFF  FF8,4B
00094:  MOVFF  FF5,7B
00098:  RCALL  0040
0009A:  MOVFF  49,FF6
0009E:  MOVFF  4A,FF7
000A2:  MOVFF  4B,FF8
000A6:  BRA    0082
000A8:  RETURN 0
*
00158:  MOVFF  7C,01
0015C:  MOVFF  7B,00
00160:  TSTFSZ x7B
00162:  INCF   01,F
00164:  TBLRD*+
00166:  MOVFF  FF5,FEE
0016A:  DECFSZ 00,F
0016C:  BRA    0164
0016E:  DECFSZ 01,F
00170:  BRA    0164
00172:  CLRF   FF8
00174:  RETURN 0
00176:  MOVF   FF2,W
00178:  MOVWF  03
0017A:  BCF    FF2.7
0017C:  BSF    F7F.2
0017E:  MOVLB  F
00180:  MOVLW  55
00182:  MOVWF  F7E
00184:  MOVLW  AA
00186:  MOVWF  F7E
00188:  BSF    F7F.1
0018A:  NOP   
0018C:  MOVF   03,W
0018E:  IORWF  FF2,F
00190:  MOVLB  0
00192:  RETURN 0
00194:  BSF    FD0.6
00196:  MOVF   FF6,W
00198:  ANDLW  3F
0019A:  MOVWF  00
0019C:  MOVLW  C0
0019E:  ANDWF  FF6,F
001A0:  TBLRD*-
001A2:  MOVFF  7C,02
001A6:  MOVFF  7B,01
001AA:  TSTFSZ 00
001AC:  BRA    01C4
001AE:  MOVF   FF6,W
001B0:  ADDLW  01
001B2:  BNZ   01C4
001B4:  MOVLW  00
001B6:  ADDWFC FF7,W
001B8:  ANDLW  01
001BA:  BNZ   01C4
001BC:  BSF    F7F.4
001BE:  TBLRD*+
001C0:  RCALL  0176
001C2:  TBLRD*-
001C4:  TSTFSZ 00
001C6:  BRA    01DE
001C8:  MOVFF  FEE,FF5
001CC:  TSTFSZ 01
001CE:  BRA    01D4
001D0:  MOVF   02,F
001D2:  BZ    01E0
001D4:  TBLWT+*
001D6:  DECF   01,F
001D8:  BTFSS  FD8.0
001DA:  DECF   02,F
001DC:  BRA    01E4
001DE:  DECF   00,F
001E0:  TBLRD+*
001E2:  TBLWT*
001E4:  MOVLW  3F
001E6:  ANDWF  FF6,W
001E8:  XORLW  3F
001EA:  BNZ   01AA
001EC:  RCALL  0176
001EE:  TSTFSZ 02
001F0:  BRA    01AA
001F2:  TSTFSZ 01
001F4:  BRA    01AA
001F6:  CLRF   FF8
001F8:  RETURN 0
001FA:  BSF    FD0.6
001FC:  MOVF   FF6,W
001FE:  ANDLW  3F
00200:  MOVWF  00
00202:  MOVLW  C0
00204:  ANDWF  FF6,F
00206:  TBLRD*-
00208:  MOVFF  7B,01
0020C:  TSTFSZ 00
0020E:  BRA    0226
00210:  MOVF   FF6,W
00212:  ADDLW  01
00214:  BNZ   0226
00216:  MOVLW  00
00218:  ADDWFC FF7,W
0021A:  ANDLW  01
0021C:  BNZ   0226
0021E:  BSF    F7F.4
00220:  TBLRD*+
00222:  RCALL  0176
00224:  TBLRD*-
00226:  TSTFSZ 00
00228:  BRA    0238
0022A:  MOVFF  FEE,FF5
0022E:  MOVF   01,F
00230:  BZ    023A
00232:  TBLWT+*
00234:  DECF   01,F
00236:  BRA    023E
00238:  DECF   00,F
0023A:  TBLRD+*
0023C:  TBLWT*
0023E:  MOVLW  3F
00240:  ANDWF  FF6,W
00242:  XORLW  3F
00244:  BNZ   020C
00246:  RCALL  0176
00248:  TSTFSZ 01
0024A:  BRA    020C
0024C:  CLRF   FF8
0024E:  RETURN 0
....................  
.................... #list 
....................  
.................... #FUSES NOWDT NOBROWNOUT 
.................... #use delay(clock=16000000, crystal=16000000) 
.................... //#DEVICE ADC=16 
....................  
.................... #use rs232(baud=9600, xmit=PIN_E5, rcv=PIN_E4)//#use rs232(baud=9600, xmit=PIN_E5, rcv=PIN_E4) 
*
00040:  BCF    F96.5
00042:  BCF    F8D.5
00044:  MOVLW  08
00046:  MOVWF  01
00048:  BRA    004A
0004A:  NOP   
0004C:  BSF    01.7
0004E:  BRA    006C
00050:  BCF    01.7
00052:  RRCF   x7B,F
00054:  BTFSC  FD8.0
00056:  BSF    F8D.5
00058:  BTFSS  FD8.0
0005A:  BCF    F8D.5
0005C:  BSF    01.6
0005E:  BRA    006C
00060:  BCF    01.6
00062:  DECFSZ 01,F
00064:  BRA    0052
00066:  BRA    0068
00068:  NOP   
0006A:  BSF    F8D.5
0006C:  MOVLW  84
0006E:  MOVWF  FE9
00070:  DECFSZ FE9,F
00072:  BRA    0070
00074:  BRA    0076
00076:  NOP   
00078:  BTFSC  01.7
0007A:  BRA    0050
0007C:  BTFSC  01.6
0007E:  BRA    0060
00080:  RETURN 0
*
000AA:  BSF    F96.4
000AC:  BTFSC  F84.4
000AE:  BRA    00AC
000B0:  MOVLW  08
000B2:  MOVWF  00
000B4:  CLRF   x7F
000B6:  BSF    00.7
000B8:  BRA    00D6
000BA:  BCF    00.7
000BC:  BRA    00D6
000BE:  BCF    FD8.0
000C0:  BTFSC  F84.4
000C2:  BSF    FD8.0
000C4:  RRCF   x7F,F
000C6:  BSF    00.6
000C8:  BRA    00D6
000CA:  BCF    00.6
000CC:  DECFSZ 00,F
000CE:  BRA    00BE
000D0:  MOVFF  7F,01
000D4:  BRA    00EE
000D6:  MOVLW  84
000D8:  BTFSC  00.7
000DA:  MOVLW  24
000DC:  MOVWF  01
000DE:  DECFSZ 01,F
000E0:  BRA    00DE
000E2:  BRA    00E4
000E4:  BTFSC  00.7
000E6:  BRA    00BA
000E8:  BTFSC  00.6
000EA:  BRA    00CA
000EC:  BRA    00BE
000EE:  GOTO   0274 (RETURN)
....................  
.................... #define PUSH_BUTTON PIN_B7 
....................  
....................   
.................... #define _bootloader 
....................  
.................... // NOTE - User must include bootloader.h in application program 
.................... #include "bootloader.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END may need to be adjusted for a specific chip and       //// 
.................... ////  bootloader.  LOADER_END must be 1 minus a multiple of            //// 
.................... ////  FLASH_ERASE_SIZE.                                                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2014 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __BOOTLOADER_H__ 
.................... #define __BOOTLOADER_H__ 
....................  
.................... #ifndef LOADER_END 
....................  #if defined(__PCM__) 
....................   #ifdef BOOTLOADER_MODE2X 
....................    #define LOADER_END 0x4BF 
....................   #else 
....................    #define LOADER_END 0x33F 
....................   #endif 
....................  #elif defined(__PCH__) 
....................   #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................   #if ((0x700 % FLASH_SIZE) == 0)         //IF 0x500 is even flash boundary 
....................    #define LOADER_END   0x6FF 
....................   #else                                  //ELSE, goto next even boundary 
....................    #define LOADER_END   ((0x700+FLASH_SIZE-(0x700 % FLASH_SIZE))-1) 
....................   #endif 
....................  #else 
....................   #error Bootloader only works with PCM or PCH compiler 
....................  #endif 
.................... #endif 
....................  
.................... #define LOADER_SIZE   LOADER_END 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #define BOOTLOADER_AT_START 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  #if defined(__PCM__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+5) 
....................  #elif defined(__PCH__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  #endif 
....................  
....................  #org 0, LOADER_END {} 
.................... #else 
....................  #ifdef __PCM__ 
....................   #if getenv("PROGRAM_MEMORY") <= 0x800 
....................    #org LOADER_END+3, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+3, 0x7FF {} 
....................    #if getenv("PROGRAM_MEMORY") <= 0x1000 
....................     #org 0x800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................    #else 
....................     #org 0x800, 0xFFF{} 
....................     #if getenv("PROGRAM_MEMORY") <= 0x1800 
....................      #org 0x1000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................     #else 
....................      #org 0x1000, 0x17FF {} 
....................      #if getenv("PROGRAM_MEMORY") <= 0x2000 
....................       #org 0x1800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................      #else 
....................       #org 0x1800, 0x1FFF {} 
....................       #if getenv("PROGRAM_MEMORY") <= 0x2800 
....................        #org 0x2000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................       #else 
....................        #org 0x2000, 0x27FF {} 
....................        #if getenv("PROGRAM_MEMORY") <= 0x3000 
....................         #org 0x2800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................        #else 
....................         #org 0x2800, 0x2FFF {} 
....................         #if getenv("PROGRAM_MEMORY") <= 0x3800 
....................          #org 0x3000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................         #else 
....................          #org 0x3000, 0x37FF {} 
....................          #org 0x3800, 0x3FFF {} 
....................         #endif 
....................        #endif 
....................       #endif 
....................      #endif 
....................     #endif 
....................    #endif 
....................   #endif 
....................  #else 
....................   #if getenv("PROGRAM_MEMORY") <= 0x10000 
....................    #org LOADER_END+5, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+5, 0xFFFE {} 
....................    #org 0x10000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "loader.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         loader.c                                  //// 
.................... ////                                                                   //// 
.................... //// This driver will take an Intel 8-bit Hex file over RS232 channels //// 
.................... //// and modify the flash program memory with the new code.  A proxy   //// 
.................... //// function is required to sit between the real loading function     //// 
.................... //// and the main code because the #org preprocessor command could     //// 
.................... //// possibly change the order of functions within a defined block.    //// 
.................... ////                                                                   //// 
.................... //// After each good line, the loader sends an ACKLOD character.  The  //// 
.................... //// driver uses XON/XOFF flow control.  Also, any buffer on the PC    //// 
.................... //// UART must be turned off, or to its lowest setting, otherwise it   //// 
.................... //// will miss data.                                                   //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2014 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef LOADER_END 
....................  #define LOADER_END      getenv("PROGRAM_MEMORY")-1 
....................  
....................  #if defined(__PCM__) 
....................   #define LOADER_SIZE   0x27F 
....................  #elif defined(__PCH__) 
....................   #if (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE")) == 0 
....................    #define LOADER_SIZE   0x3FF 
....................   #else 
....................    #define LOADER_SIZE   (getenv("PROGRAM_MEMORY") % (getenv("FLASH_ERASE_SIZE")) - 1) 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... #define LOADER_ADDR LOADER_END-LOADER_SIZE 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #ORG LOADER_ADDR+4, LOADER_END auto=0 default 
.................... #endif 
....................  
.................... #ifndef BUFFER_LEN_LOD 
....................  #define BUFFER_LEN_LOD    64 
.................... #endif 
....................  
.................... #ifdef BOOTLOADER_MODE2X 
....................  #define BUFFER_COUNT   2 
.................... #else 
....................  #define BUFFER_COUNT   1 
.................... #endif 
....................  
.................... #if defined(__PCM__) && !getenv("ENH16") && (BUFFER_COUNT == 2) 
....................  struct 
....................  { 
....................    int8 idx; 
....................    char *buffer; 
....................  } rBuffer[BUFFER_COUNT]; 
....................  
....................  char Buffer1[BUFFER_LEN_LOD]; 
....................  char Buffer2[BUFFER_LEN_LOD]; 
.................... #else 
....................  struct 
....................  { 
....................    int8 idx; 
....................    char buffer[BUFFER_LEN_LOD]; 
....................  } rBuffer[BUFFER_COUNT]; 
.................... #endif 
....................  
.................... #define ACKLOD 0x06 
.................... #define XON    0x11 
.................... #define XOFF   0x13 
....................  
.................... unsigned int atoi_b16(char *s); 
....................  
.................... #ifdef BOOTLOADER_STREAM 
....................  #define BootLoaderGetc()     fgetc(BOOTLOADER_STREAM) 
....................  #define BootLoaderPutc(c)    fputc(c, BOOTLOADER_STREAM) 
.................... #else 
....................  #define BootLoaderGetc()     getc() 
....................  #define BootLoaderPutc(c)    putc(c) 
.................... #endif 
....................  
.................... void real_load_program (void) 
*
00250:  BCF    49.1
00252:  CLRF   4F
00254:  CLRF   4E
.................... { 
....................    int1  do_ACKLOD, done=FALSE; 
....................    int8  checksum, line_type; 
....................    int16 l_addr,h_addr=0; 
....................    int32 addr; 
....................   #if getenv("FLASH_ERASE_SIZE") != getenv("FLASH_WRITE_SIZE") 
....................    int32 next_addr; 
....................   #endif 
....................    int8  dataidx, i, count; 
....................    int8  data[BUFFER_LEN_LOD / 2]; 
....................   #ifdef BOOTLOADER_MODE2X 
....................    int8  buffidx; 
....................   #endif 
....................     
....................   #if defined(__PCM__) && !getenv("ENH16") && (BUFFER_COUNT == 2) 
....................    rBuffer[0].buffer = &Buffer1[0]; 
....................    rBuffer[1].buffer = &Buffer2[0]; 
....................   #endif 
....................     
....................   #ifdef BOOTLOADER_MODE2X 
....................    buffidx = 0; 
....................  
....................    while (!done)  // Loop until the entire program is downloaded 
....................    { 
....................       rBuffer[buffidx].idx = 0;     // Read into the buffer until 0x0D ('\r') is received or the buffer is full 
....................        
....................       do { 
....................          rBuffer[buffidx].buffer[rBuffer[buffidx].idx] = BootLoaderGetc(); 
....................           
....................       } while ((rBuffer[buffidx].buffer[rBuffer[buffidx].idx++] != 0x0D) && (rBuffer[buffidx].idx <= BUFFER_LEN_LOD)); 
....................        
....................       if(++buffidx >= BUFFER_COUNT) 
....................       { 
....................   #else 
....................    while (!done)  // Loop until the entire program is downloaded 
00256:  BTFSC  49.1
00258:  BRA    05B0
....................    { 
....................       rBuffer[0].idx = 0; 
0025A:  CLRF   06
....................        
....................       do { 
....................          rBuffer[0].buffer[rBuffer[0].idx] = BootLoaderGetc(); 
0025C:  CLRF   03
0025E:  MOVF   06,W
00260:  ADDLW  07
00262:  MOVWF  FE9
00264:  MOVLW  00
00266:  ADDWFC 03,W
00268:  MOVWF  FEA
0026A:  MOVFF  FEA,7E
0026E:  MOVFF  FE9,7D
00272:  BRA    00AA
00274:  MOVFF  7E,FEA
00278:  MOVFF  7D,FE9
0027C:  MOVFF  01,FEF
....................           
....................       } while ((rBuffer[0].buffer[rBuffer[0].idx++] != 0x0D) && (rBuffer[0].idx <= BUFFER_LEN_LOD)); 
00280:  MOVF   06,W
00282:  INCF   06,F
00284:  CLRF   03
00286:  ADDLW  07
00288:  MOVWF  FE9
0028A:  MOVLW  00
0028C:  ADDWFC 03,W
0028E:  MOVWF  FEA
00290:  MOVF   FEF,W
00292:  SUBLW  0D
00294:  BZ    029C
00296:  MOVF   06,W
00298:  SUBLW  40
0029A:  BC    025C
....................   #endif 
....................    
....................          BootLoaderPutc(XOFF);  // Suspend sender 
0029C:  MOVLW  13
0029E:  MOVWF  x7B
002A0:  RCALL  0040
....................     
....................          do_ACKLOD = TRUE; 
002A2:  BSF    49.0
....................           
....................         #ifdef BOOTLOADER_MODE2X 
....................          if(rBuffer[0].idx != rBuffer[1].idx) 
....................             do_ACKLOD = FALSE; 
....................          else 
....................          { 
....................             for(i=0;i<(rBuffer[0].idx-1);i++) 
....................             { 
....................                if(rBuffer[0].buffer[i] != rBuffer[1].buffer[i]) 
....................                { 
....................                   do_ACKLOD = FALSE; 
....................                   break; 
....................                } 
....................             } 
....................              
....................             if(do_ACKLOD) 
....................             { 
....................         #endif    
....................                // Only process data blocks that start with ':' 
....................                if (rBuffer[0].buffer[0] == ':') 
002A4:  MOVF   07,W
002A6:  SUBLW  3A
002A8:  BTFSS  FD8.2
002AA:  BRA    059E
....................                { 
....................                   count = atoi_b16 (&rBuffer[0].buffer[1]);  // Get the number of bytes from the buffer 
002AC:  CLRF   x80
002AE:  MOVLW  08
002B0:  MOVWF  x7F
002B2:  RCALL  00F2
002B4:  MOVFF  01,5A
....................           
....................                   // Get the lower 16 bits of address 
....................                   l_addr = make16(atoi_b16(&rBuffer[0].buffer[3]),atoi_b16(&rBuffer[0].buffer[5])); 
002B8:  CLRF   x80
002BA:  MOVLW  0A
002BC:  MOVWF  x7F
002BE:  RCALL  00F2
002C0:  MOVFF  01,7B
002C4:  CLRF   x80
002C6:  MOVLW  0C
002C8:  MOVWF  x7F
002CA:  RCALL  00F2
002CC:  MOVFF  7B,4D
002D0:  MOVFF  01,4C
....................           
....................                   line_type = atoi_b16 (&rBuffer[0].buffer[7]); 
002D4:  CLRF   x80
002D6:  MOVLW  0E
002D8:  MOVWF  x7F
002DA:  RCALL  00F2
002DC:  MOVFF  01,4B
....................           
....................                   addr = make32(h_addr,l_addr); 
002E0:  MOVFF  4E,52
002E4:  MOVFF  4F,53
002E8:  MOVFF  4C,50
002EC:  MOVFF  4D,51
....................           
....................                  #if defined(__PCM__)  // PIC16 uses word addresses 
....................                   addr /= 2; 
....................                  #endif 
....................                    
....................                   checksum = 0;  // Sum the bytes to find the check sum value 
002F0:  CLRF   4A
....................                   for (i=1; i<(rBuffer[0].idx-3); i+=2) 
002F2:  MOVLW  01
002F4:  MOVWF  59
002F6:  MOVLW  03
002F8:  SUBWF  06,W
002FA:  SUBWF  59,W
002FC:  BC    0326
....................                      checksum += atoi_b16 (&rBuffer[0].buffer[i]); 
002FE:  CLRF   03
00300:  MOVF   59,W
00302:  ADDLW  07
00304:  MOVWF  01
00306:  MOVLW  00
00308:  ADDWFC 03,F
0030A:  MOVFF  01,7B
0030E:  MOVFF  03,7C
00312:  MOVFF  03,80
00316:  MOVFF  01,7F
0031A:  RCALL  00F2
0031C:  MOVF   01,W
0031E:  ADDWF  4A,F
00320:  MOVLW  02
00322:  ADDWF  59,F
00324:  BRA    02F6
....................                   checksum = 0xFF - checksum + 1; 
00326:  MOVLW  FF
00328:  BSF    FD8.0
0032A:  SUBFWB 4A,W
0032C:  ADDLW  01
0032E:  MOVWF  4A
....................           
....................                   if (checksum != atoi_b16 (&rBuffer[0].buffer[rBuffer[0].idx-3])) 
00330:  MOVLW  03
00332:  SUBWF  06,W
00334:  CLRF   03
00336:  ADDLW  07
00338:  MOVWF  01
0033A:  MOVLW  00
0033C:  ADDWFC 03,F
0033E:  MOVFF  01,7B
00342:  MOVFF  03,7C
00346:  MOVFF  03,80
0034A:  MOVFF  01,7F
0034E:  RCALL  00F2
00350:  MOVF   01,W
00352:  SUBWF  4A,W
00354:  BZ    035A
....................                      do_ACKLOD = FALSE; 
00356:  BCF    49.0
00358:  BRA    059E
....................                   else 
....................                   { 
....................                      // If the line type is 1, then data is done being sent 
....................                      if (line_type == 1) 
0035A:  DECFSZ 4B,W
0035C:  BRA    0362
....................                         done = TRUE; 
0035E:  BSF    49.1
00360:  BRA    059E
....................                      else if (line_type == 4) 
00362:  MOVF   4B,W
00364:  SUBLW  04
00366:  BNZ   038A
....................                         h_addr = make16(atoi_b16(&rBuffer[0].buffer[9]), atoi_b16(&rBuffer[0].buffer[11])); 
00368:  CLRF   x80
0036A:  MOVLW  10
0036C:  MOVWF  x7F
0036E:  RCALL  00F2
00370:  MOVFF  01,7B
00374:  CLRF   x80
00376:  MOVLW  12
00378:  MOVWF  x7F
0037A:  RCALL  00F2
0037C:  MOVFF  01,7C
00380:  MOVFF  7B,4F
00384:  MOVFF  01,4E
00388:  BRA    059E
....................                      else if (line_type == 0) 
0038A:  MOVF   4B,F
0038C:  BTFSS  FD8.2
0038E:  BRA    059E
....................                      { 
....................                         if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < getenv("PROGRAM_MEMORY")) 
00390:  MOVF   53,F
00392:  BNZ   03A0
00394:  MOVF   52,F
00396:  BNZ   03A0
00398:  MOVF   51,W
0039A:  SUBLW  07
0039C:  BTFSC  FD8.0
0039E:  BRA    059E
003A0:  MOVF   53,F
003A2:  BTFSS  FD8.2
003A4:  BRA    059E
003A6:  MOVF   52,W
003A8:  SUBLW  01
003AA:  BTFSS  FD8.0
003AC:  BRA    059E
003AE:  BNZ   03C2
003B0:  MOVF   51,W
003B2:  SUBLW  FF
003B4:  BTFSS  FD8.0
003B6:  BRA    059E
003B8:  BNZ   03C2
003BA:  MOVF   50,W
003BC:  SUBLW  EF
003BE:  BTFSS  FD8.0
003C0:  BRA    059E
....................                         { 
....................                            // Loops through all of the data and stores it in data 
....................                            // The last 2 bytes are the check sum, hence buffidx-3 
....................                            for (i = 9,dataidx=0; i < rBuffer[0].idx-3; i += 2) 
003C2:  MOVLW  09
003C4:  MOVWF  59
003C6:  CLRF   58
003C8:  MOVLW  03
003CA:  SUBWF  06,W
003CC:  SUBWF  59,W
003CE:  BC    0416
....................                               data[dataidx++]=atoi_b16(&rBuffer[0].buffer[i]); 
003D0:  MOVF   58,W
003D2:  INCF   58,F
003D4:  CLRF   03
003D6:  ADDLW  5B
003D8:  MOVWF  01
003DA:  MOVLW  00
003DC:  ADDWFC 03,F
003DE:  MOVFF  01,7B
003E2:  MOVFF  03,7C
003E6:  CLRF   03
003E8:  MOVF   59,W
003EA:  ADDLW  07
003EC:  MOVWF  01
003EE:  MOVLW  00
003F0:  ADDWFC 03,F
003F2:  MOVFF  01,7D
003F6:  MOVFF  03,7E
003FA:  MOVFF  03,80
003FE:  MOVFF  01,7F
00402:  RCALL  00F2
00404:  MOVFF  7C,FEA
00408:  MOVFF  7B,FE9
0040C:  MOVFF  01,FEF
....................           
....................                            #if getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE") 
00410:  MOVLW  02
00412:  ADDWF  59,F
00414:  BRA    03C8
....................                               if ((addr!=next_addr) && (addr > (next_addr + (getenv("FLASH_ERASE_SIZE") - (next_addr % getenv("FLASH_ERASE_SIZE"))))) && ((addr & (getenv("FLASH_ERASE_SIZE")-1)) != 0)) 
00416:  MOVF   54,W
00418:  SUBWF  50,W
0041A:  BNZ   0430
0041C:  MOVF   55,W
0041E:  SUBWF  51,W
00420:  BNZ   0430
00422:  MOVF   56,W
00424:  SUBWF  52,W
00426:  BNZ   0430
00428:  MOVF   57,W
0042A:  SUBWF  53,W
0042C:  BTFSC  FD8.2
0042E:  BRA    0512
00430:  MOVFF  54,00
00434:  MOVF   55,W
00436:  ANDLW  01
00438:  MOVWF  01
0043A:  CLRF   02
0043C:  CLRF   03
0043E:  MOVLW  00
00440:  BSF    FD8.0
00442:  SUBFWB 00,F
00444:  MOVLW  02
00446:  SUBFWB 01,F
00448:  MOVLW  00
0044A:  SUBFWB 02,F
0044C:  SUBFWB 03,F
0044E:  MOVF   54,W
00450:  ADDWF  00,F
00452:  MOVF   55,W
00454:  ADDWFC 01,F
00456:  MOVF   56,W
00458:  ADDWFC 02,F
0045A:  MOVF   57,W
0045C:  ADDWFC 03,F
0045E:  MOVF   03,W
00460:  SUBWF  53,W
00462:  BNC   0512
00464:  BNZ   047C
00466:  MOVF   02,W
00468:  SUBWF  52,W
0046A:  BNC   0512
0046C:  BNZ   047C
0046E:  MOVF   01,W
00470:  SUBWF  51,W
00472:  BNC   0512
00474:  BNZ   047C
00476:  MOVF   50,W
00478:  SUBWF  00,W
0047A:  BC    0512
0047C:  MOVFF  50,7B
00480:  MOVF   51,W
00482:  ANDLW  01
00484:  MOVWF  x7C
00486:  CLRF   x7D
00488:  CLRF   x7E
0048A:  MOVF   x7B,F
0048C:  BNZ   049A
0048E:  MOVF   x7C,F
00490:  BNZ   049A
00492:  MOVF   x7D,F
00494:  BNZ   049A
00496:  MOVF   x7E,F
00498:  BZ    0512
....................                               { 
....................                                  #if defined(__PCH__) && defined(BOOTLOADER_AT_START) 
....................                                     #if ((getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE")) != 0) 
....................                                        if (addr > (getenv("PROGRAM_MEMORY") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE")))) 
0049A:  MOVF   53,F
0049C:  BNZ   04B8
0049E:  MOVF   52,W
004A0:  SUBLW  00
004A2:  BC    04FE
004A4:  XORLW  FF
004A6:  BNZ   04B8
004A8:  MOVF   51,W
004AA:  SUBLW  FD
004AC:  BC    04FE
004AE:  XORLW  FF
004B0:  BNZ   04B8
004B2:  MOVF   50,W
004B4:  SUBLW  00
004B6:  BC    04FE
....................                                        { 
....................                                           read_program_memory(getenv("PROGRAM_MEMORY"), rBuffer[0].buffer, getenv("FLASH_ERASE_SIZE") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE"))); 
004B8:  MOVLW  01
004BA:  MOVWF  FF8
004BC:  SETF   FF7
004BE:  MOVLW  F0
004C0:  MOVWF  FF6
004C2:  CLRF   FEA
004C4:  MOVLW  07
004C6:  MOVWF  FE9
004C8:  CLRF   x7C
004CA:  MOVLW  10
004CC:  MOVWF  x7B
004CE:  RCALL  0158
....................                                           erase_program_eeprom(addr); 
004D0:  BSF    FD0.6
004D2:  MOVFF  52,FF8
004D6:  MOVFF  51,FF7
004DA:  MOVFF  50,FF6
004DE:  BSF    F7F.4
004E0:  RCALL  0176
004E2:  CLRF   FF8
....................                                           write_program_memory(getenv("PROGRAM_MEMORY"), rBuffer[0].buffer, getenv("FLASH_ERASE_SIZE") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE"))); 
004E4:  MOVLW  01
004E6:  MOVWF  FF8
004E8:  SETF   FF7
004EA:  MOVLW  F0
004EC:  MOVWF  FF6
004EE:  CLRF   FEA
004F0:  MOVLW  07
004F2:  MOVWF  FE9
004F4:  CLRF   x7C
004F6:  MOVLW  10
004F8:  MOVWF  x7B
004FA:  RCALL  0194
....................                                        } 
004FC:  BRA    0512
....................                                        else 
....................                                     #endif 
....................                                  #endif 
....................                                           erase_program_eeprom(addr); 
004FE:  BSF    FD0.6
00500:  MOVFF  52,FF8
00504:  MOVFF  51,FF7
00508:  MOVFF  50,FF6
0050C:  BSF    F7F.4
0050E:  RCALL  0176
00510:  CLRF   FF8
....................                               } 
....................                               #if defined(__PCM__) 
....................                                  next_addr = addr + count/2; 
....................                               #else 
....................                                  next_addr = addr + count; 
00512:  MOVF   5A,W
00514:  ADDWF  50,W
00516:  MOVWF  54
00518:  MOVLW  00
0051A:  ADDWFC 51,W
0051C:  MOVWF  55
0051E:  MOVLW  00
00520:  ADDWFC 52,W
00522:  MOVWF  56
00524:  MOVLW  00
00526:  ADDWFC 53,W
00528:  MOVWF  57
....................                               #endif 
....................                            #endif 
....................                             
....................                            #if defined(__PCH__) && defined(BOOTLOADER_AT_START) 
....................                               #if ((getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE")) != 0) 
....................                                  if (addr == (getenv("PROGRAM_MEMORY") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE")))) 
0052A:  MOVF   50,F
0052C:  BNZ   0586
0052E:  MOVF   51,W
00530:  SUBLW  FE
00532:  BNZ   0586
00534:  DECFSZ 52,W
00536:  BRA    0586
00538:  MOVF   53,F
0053A:  BNZ   0586
....................                                  { 
....................                                     read_program_memory(getenv("PROGRAM_MEMORY"), rBuffer[0].buffer, getenv("FLASH_ERASE_SIZE") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE"))); 
0053C:  MOVLW  01
0053E:  MOVWF  FF8
00540:  SETF   FF7
00542:  MOVLW  F0
00544:  MOVWF  FF6
00546:  CLRF   FEA
00548:  MOVLW  07
0054A:  MOVWF  FE9
0054C:  CLRF   x7C
0054E:  MOVLW  10
00550:  MOVWF  x7B
00552:  RCALL  0158
....................                                     write_program_memory(addr, data, count); 
00554:  MOVFF  52,FF8
00558:  MOVFF  51,FF7
0055C:  MOVFF  50,FF6
00560:  CLRF   FEA
00562:  MOVLW  5B
00564:  MOVWF  FE9
00566:  MOVFF  5A,7B
0056A:  RCALL  01FA
....................                                     write_program_memory(getenv("PROGRAM_MEMORY"), rBuffer[0].buffer, getenv("FLASH_ERASE_SIZE") - (getenv("PROGRAM_MEMORY") % getenv("FLASH_ERASE_SIZE"))); 
0056C:  MOVLW  01
0056E:  MOVWF  FF8
00570:  SETF   FF7
00572:  MOVLW  F0
00574:  MOVWF  FF6
00576:  CLRF   FEA
00578:  MOVLW  07
0057A:  MOVWF  FE9
0057C:  CLRF   x7C
0057E:  MOVLW  10
00580:  MOVWF  x7B
00582:  RCALL  0194
....................                                  } 
00584:  BRA    059E
....................                                  else 
....................                               #endif 
....................                            #endif 
....................                                     write_program_memory(addr, data, count); 
00586:  MOVFF  52,FF8
0058A:  MOVFF  51,FF7
0058E:  MOVFF  50,FF6
00592:  CLRF   FEA
00594:  MOVLW  5B
00596:  MOVWF  FE9
00598:  MOVFF  5A,7B
0059C:  RCALL  01FA
....................                         } 
....................                      } 
....................                   } 
....................                } 
....................         #ifdef BOOTLOADER_MODE2X 
....................             } 
....................          } 
....................           
....................          buffidx = 0; 
....................         #endif 
....................  
....................          if (do_ACKLOD) 
0059E:  BTFSS  49.0
005A0:  BRA    05A8
....................             BootLoaderPutc(ACKLOD); 
005A2:  MOVLW  06
005A4:  MOVWF  x7B
005A6:  RCALL  0040
....................           
....................          BootLoaderPutc(XON); 
005A8:  MOVLW  11
005AA:  MOVWF  x7B
005AC:  RCALL  0040
....................           
....................      #ifdef BOOTLOADER_MODE2X 
005AE:  BRA    0256
....................       }  
....................      #endif 
....................    } 
....................  
....................    BootLoaderPutc(ACKLOD); 
005B0:  MOVLW  06
005B2:  MOVWF  x7B
005B4:  RCALL  0040
....................    BootLoaderPutc(XON); 
005B6:  MOVLW  11
005B8:  MOVWF  x7B
005BA:  RCALL  0040
....................  
....................    reset_cpu(); 
005BC:  RESET
005BE:  GOTO   05C4 (RETURN)
.................... } 
....................  
.................... unsigned int atoi_b16(char *s) {  // Convert two hex characters to a int8 
*
000F2:  CLRF   x81
....................    unsigned int result = 0; 
....................    int i; 
....................  
....................    for (i=0; i<2; i++,s++)  { 
000F4:  CLRF   x82
000F6:  MOVF   x82,W
000F8:  SUBLW  01
000FA:  BNC   0152
....................       if (*s >= 'A') 
000FC:  MOVFF  80,03
00100:  MOVFF  7F,FE9
00104:  MOVFF  80,FEA
00108:  MOVF   FEF,W
0010A:  SUBLW  40
0010C:  BC    012E
....................          result = 16*result + (*s) - 'A' + 10; 
0010E:  MOVF   x81,W
00110:  MULLW  10
00112:  MOVFF  FF3,83
00116:  MOVFF  80,03
0011A:  MOVFF  7F,FE9
0011E:  MOVFF  80,FEA
00122:  MOVF   FEF,W
00124:  ADDWF  x83,W
00126:  ADDLW  BF
00128:  ADDLW  0A
0012A:  MOVWF  x81
0012C:  BRA    0146
....................       else 
....................          result = 16*result + (*s) - '0'; 
0012E:  MOVF   x81,W
00130:  MULLW  10
00132:  MOVFF  FF3,83
00136:  MOVFF  7F,FE9
0013A:  MOVFF  80,FEA
0013E:  MOVF   FEF,W
00140:  ADDWF  x83,W
00142:  ADDLW  D0
00144:  MOVWF  x81
00146:  MOVF   x82,W
00148:  INCF   x82,F
0014A:  INCF   x7F,F
0014C:  BTFSC  FD8.2
0014E:  INCF   x80,F
00150:  BRA    00F6
....................    } 
....................  
....................    return(result); 
00152:  MOVFF  81,01
00156:  RETURN 0
.................... } 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #ORG default 
....................  #ORG LOADER_ADDR, LOADER_ADDR+3 
.................... #endif 
.................... void load_program(void) 
.................... { 
....................    real_load_program(); 
*
005C2:  BRA    0250
005C4:  GOTO   0638 (RETURN)
.................... } 
....................  
....................  
.................... #INT_GLOBAL 
.................... void isr(void){ 
....................    jump_to_isr(LOADER_END+5*(getenv("BITS_PER_INSTRUCTION")/8)); 
*
00008:  GOTO   0808
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  GOTO   0818
.................... } 
....................  
0001C:  RETFIE 0
.................... #org LOADER_END+2, LOADER_END+4 
.................... void application(void)  
.................... {     
....................   while(TRUE); 
*
00800:  BRA    0800
00802:  RETURN 0
.................... } 
....................  
.................... void main() 
*
005C8:  CLRF   FF8
005CA:  BCF    FD0.7
005CC:  MOVLB  E
005CE:  MOVLW  55
005D0:  MOVWF  F7E
005D2:  MOVLW  AA
005D4:  MOVWF  F7E
005D6:  BCF    F66.6
005D8:  MOVLW  55
005DA:  MOVWF  F7E
005DC:  MOVLW  AA
005DE:  MOVWF  F7E
005E0:  BSF    F66.6
005E2:  CLRF   F9B
005E4:  CLRF   F64
005E6:  CLRF   F65
005E8:  CLRF   F66
005EA:  MOVLW  02
005EC:  MOVWF  FD3
005EE:  BCF    F96.5
005F0:  BSF    F8D.5
005F2:  CLRF   48
005F4:  CLRF   47
005F6:  CLRF   xD9
005F8:  CLRF   xDA
005FA:  CLRF   x45
005FC:  CLRF   x46
005FE:  CLRF   x47
00600:  BCF    x8D.7
00602:  BCF    x8D.6
00604:  BCF    x8D.5
00606:  MOVLB  1
00608:  CLRF   x88
0060A:  MOVLB  F
0060C:  CLRF   x53
0060E:  CLRF   x38
00610:  CLRF   x37
.................... { 
....................     // Enter Bootloader if Pin D0 is low after a RESET 
....................    if(!input(PUSH_BUTTON)) 
00612:  BSF    F93.7
00614:  BTFSC  F81.7
00616:  BRA    063A
....................    { 
....................       printf("\r\nBootloader V 1\r\n"); 
00618:  MOVLW  1E
0061A:  MOVWF  FF6
0061C:  MOVLW  00
0061E:  MOVWF  FF7
00620:  MOVLW  00
00622:  MOVWF  FF8
00624:  MOVLB  0
00626:  RCALL  0082
....................     
....................       // Let the user know it is ready to accept a download 
....................       printf("\r\ndownloading"); 
00628:  MOVLW  32
0062A:  MOVWF  FF6
0062C:  MOVLW  00
0062E:  MOVWF  FF7
00630:  MOVLW  00
00632:  MOVWF  FF8
00634:  RCALL  0082
....................       load_program(); 
00636:  BRA    05C2
00638:  MOVLB  F
....................    } 
....................     
....................    application(); 
0063A:  MOVLB  0
0063C:  RCALL  0800
.................... } 
....................  
0063E:  SLEEP 
....................  

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
