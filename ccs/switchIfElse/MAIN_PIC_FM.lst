CCS PCH C Compiler, Version 5.056, 29513               28-Feb-20 18:33

               Filename:   C:\Users\maisun\Documents\PhD\offline\code\ccs\switchIfElse\MAIN_PIC_FM.lst

               ROM used:   60576 bytes (46%)
                           Largest free fragment is 35284
               RAM used:   813 (23%) at main() level
                           950 (27%) worst case
               Stack used: 22 locations (13 in main + 9 for interrupts)
               Stack size: 31

*
00002:  NOP   
00004:  GOTO   3838
*
0000A:  GOTO   00F4
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  NOP   
0001A:  MOVWF  04
0001C:  MOVFF  FD8,05
00020:  MOVFF  FE0,06
00024:  MOVLB  0
00026:  MOVFF  FE9,0C
0002A:  MOVFF  FEA,07
0002E:  MOVFF  FE1,08
00032:  MOVFF  FE2,09
00036:  MOVFF  FD9,0A
0003A:  MOVFF  FDA,0B
0003E:  MOVFF  FF3,12
00042:  MOVFF  FF4,13
00046:  MOVFF  FFA,14
0004A:  MOVFF  FF5,15
0004E:  MOVFF  FF6,16
00052:  MOVFF  FF7,17
00056:  MOVFF  FF8,18
0005A:  MOVFF  FFB,19
0005E:  MOVFF  00,0E
00062:  MOVFF  01,0F
00066:  MOVFF  02,10
0006A:  MOVFF  03,11
0006E:  BTFSS  FF2.5
00070:  GOTO   007A
00074:  BTFSC  FF2.2
00076:  GOTO   1610
0007A:  BTFSS  F9D.5
0007C:  GOTO   0086
00080:  BTFSC  F9E.5
00082:  GOTO   1670
00086:  BTFSS  F61.5
00088:  GOTO   0092
0008C:  BTFSC  FA6.5
0008E:  GOTO   16E8
00092:  BTFSS  F61.7
00094:  GOTO   009E
00098:  BTFSC  FA6.7
0009A:  GOTO   1720
0009E:  MOVFF  0E,00
000A2:  MOVFF  0F,01
000A6:  MOVFF  10,02
000AA:  MOVFF  11,03
000AE:  MOVFF  0C,FE9
000B2:  MOVFF  07,FEA
000B6:  BSF    07.7
000B8:  MOVFF  08,FE1
000BC:  MOVFF  09,FE2
000C0:  MOVFF  0A,FD9
000C4:  MOVFF  0B,FDA
000C8:  MOVFF  12,FF3
000CC:  MOVFF  13,FF4
000D0:  MOVFF  14,FFA
000D4:  MOVFF  15,FF5
000D8:  MOVFF  16,FF6
000DC:  MOVFF  17,FF7
000E0:  MOVFF  18,FF8
000E4:  MOVFF  19,FFB
000E8:  MOVF   04,W
000EA:  MOVFF  06,FE0
000EE:  MOVFF  05,FD8
000F2:  RETFIE 0
000F4:  MOVLB  0
000F6:  MOVFF  FE9,21
000FA:  MOVFF  FEA,1C
000FE:  MOVFF  FE1,1D
00102:  MOVFF  FE2,1E
00106:  MOVFF  FD9,1F
0010A:  MOVFF  FDA,20
0010E:  MOVFF  FF3,27
00112:  MOVFF  FF4,28
00116:  MOVFF  FFA,29
0011A:  MOVFF  FF5,2A
0011E:  MOVFF  FF6,2B
00122:  MOVFF  FF7,2C
00126:  MOVFF  FF8,2D
0012A:  MOVFF  FFB,2E
0012E:  MOVFF  00,23
00132:  MOVFF  01,24
00136:  MOVFF  02,25
0013A:  MOVFF  03,26
0013E:  BTFSS  FA3.5
00140:  GOTO   014A
00144:  BTFSC  FA4.5
00146:  GOTO   1694
0014A:  MOVFF  23,00
0014E:  MOVFF  24,01
00152:  MOVFF  25,02
00156:  MOVFF  26,03
0015A:  MOVFF  21,FE9
0015E:  MOVFF  1C,FEA
00162:  BSF    1C.7
00164:  MOVFF  1D,FE1
00168:  MOVFF  1E,FE2
0016C:  MOVFF  1F,FD9
00170:  MOVFF  20,FDA
00174:  MOVFF  27,FF3
00178:  MOVFF  28,FF4
0017C:  MOVFF  29,FFA
00180:  MOVFF  2A,FF5
00184:  MOVFF  2B,FF6
00188:  MOVFF  2C,FF7
0018C:  MOVFF  2D,FF8
00190:  MOVFF  2E,FFB
00194:  RETFIE 1
.................... //*PURPOSE This program is to test in-orbit update feasibility 
.................... //*AUTHOR Maisun Ibn Monowar 
.................... /**:CHANGES 
....................             Rewrote command analyzer 
....................             Allocated memory segement to each segment. 
.................... */ 
.................... #include <MAIN_PIC_FM.h> 
.................... #ifndef MAIN_PIC_FM_H 
.................... #define MAIN_PIC_FM_H 
....................  
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
*
001DA:  DATA 0D,0A
001DC:  DATA 50,41
001DE:  DATA 53,53
001E0:  DATA 45,44
001E2:  DATA 20,44
001E4:  DATA 41,59
001E6:  DATA 53,3A
001E8:  DATA 25,78
001EA:  DATA 0D,0A
001EC:  DATA 00,00
001EE:  DATA 52,45
001F0:  DATA 53,45
001F2:  DATA 52,56
001F4:  DATA 45,20
001F6:  DATA 43,48
001F8:  DATA 45,43
001FA:  DATA 4B,3A
001FC:  DATA 25,78
001FE:  DATA 0D,0A
00200:  DATA 00,00
00202:  DATA 4B,69
00204:  DATA 6C,6C
00206:  DATA 20,46
00208:  DATA 4C,41
0020A:  DATA 47,20
0020C:  DATA 4D,41
0020E:  DATA 49,4E
00210:  DATA 3A,25
00212:  DATA 78,0D
00214:  DATA 0A,00
00216:  DATA 4B,69
00218:  DATA 6C,6C
0021A:  DATA 20,46
0021C:  DATA 4C,41
0021E:  DATA 47,20
00220:  DATA 46,41
00222:  DATA 42,3A
00224:  DATA 25,78
00226:  DATA 0D,0A
00228:  DATA 00,00
0022A:  DATA 41,55
0022C:  DATA 54,4F
0022E:  DATA 20,48
00230:  DATA 49,47
00232:  DATA 48,20
00234:  DATA 53,41
00236:  DATA 4D,50
00238:  DATA 4C,49
0023A:  DATA 4E,47
0023C:  DATA 3A,25
0023E:  DATA 78,0D
00240:  DATA 0A,00
00242:  DATA 41,55
00244:  DATA 54,4F
00246:  DATA 20,43
00248:  DATA 41,4D
0024A:  DATA 3A,25
0024C:  DATA 78,0D
0024E:  DATA 0A,00
00250:  DATA 41,55
00252:  DATA 54,4F
00254:  DATA 20,4D
00256:  DATA 42,50
00258:  DATA 3A,25
0025A:  DATA 78,0D
0025C:  DATA 0A,00
0025E:  DATA 41,55
00260:  DATA 54,4F
00262:  DATA 20,41
00264:  DATA 44,43
00266:  DATA 53,3A
00268:  DATA 25,78
0026A:  DATA 0D,0A
0026C:  DATA 00,00
0026E:  DATA 41,4E
00270:  DATA 54,45
00272:  DATA 4E,4E
00274:  DATA 41,20
00276:  DATA 44,45
00278:  DATA 50,4C
0027A:  DATA 4F,59
0027C:  DATA 3A,25
0027E:  DATA 78,0D
00280:  DATA 0A,00
00282:  DATA 41,4E
00284:  DATA 54,45
00286:  DATA 4E,4E
00288:  DATA 41,20
0028A:  DATA 44,45
0028C:  DATA 50,4C
0028E:  DATA 4F,59
00290:  DATA 20,41
00292:  DATA 54,54
00294:  DATA 45,4D
00296:  DATA 50,54
00298:  DATA 3A,25
0029A:  DATA 78,0D
0029C:  DATA 0A,00
0029E:  DATA 55,50
002A0:  DATA 4C,49
002A2:  DATA 4E,4B
002A4:  DATA 20,53
002A6:  DATA 55,43
002A8:  DATA 43,45
002AA:  DATA 53,53
002AC:  DATA 3A,25
002AE:  DATA 78,0D
002B0:  DATA 0A,0D
002B2:  DATA 0A,00
002B4:  DATA 0D,0A
002B6:  DATA 41,44
002B8:  DATA 44,20
002BA:  DATA 49,4E
002BC:  DATA 46,4F
002BE:  DATA 20,41
002C0:  DATA 44,44
002C2:  DATA 52,45
002C4:  DATA 53,53
002C6:  DATA 3A,25
002C8:  DATA 6C,78
002CA:  DATA 0D,0A
002CC:  DATA 0D,0A
002CE:  DATA 00,00
002D0:  DATA 46,4C
002D2:  DATA 41,47
002D4:  DATA 20,44
002D6:  DATA 41,54
002D8:  DATA 41,20
002DA:  DATA 41,44
002DC:  DATA 44,52
002DE:  DATA 45,53
002E0:  DATA 53,3A
002E2:  DATA 25,78
002E4:  DATA 25,78
002E6:  DATA 25,78
002E8:  DATA 25,78
002EA:  DATA 0D,0A
002EC:  DATA 00,00
002EE:  DATA 52,45
002F0:  DATA 53,45
002F2:  DATA 52,56
002F4:  DATA 41,54
002F6:  DATA 49,4F
002F8:  DATA 4E,20
002FA:  DATA 54,41
002FC:  DATA 42,4C
002FE:  DATA 45,20
00300:  DATA 41,44
00302:  DATA 44,52
00304:  DATA 45,53
00306:  DATA 53,3A
00308:  DATA 25,78
0030A:  DATA 25,78
0030C:  DATA 25,78
0030E:  DATA 25,78
00310:  DATA 0D,0A
00312:  DATA 00,00
00314:  DATA 53,41
00316:  DATA 54,45
00318:  DATA 4C,4C
0031A:  DATA 49,54
0031C:  DATA 45,20
0031E:  DATA 4C,4F
00320:  DATA 47,20
00322:  DATA 41,44
00324:  DATA 44,52
00326:  DATA 45,53
00328:  DATA 53,3A
0032A:  DATA 25,78
0032C:  DATA 25,78
0032E:  DATA 25,78
00330:  DATA 25,78
00332:  DATA 0D,0A
00334:  DATA 00,00
00336:  DATA 43,41
00338:  DATA 4D,20
0033A:  DATA 41,44
0033C:  DATA 44,52
0033E:  DATA 45,53
00340:  DATA 53,3A
00342:  DATA 25,78
00344:  DATA 25,78
00346:  DATA 25,78
00348:  DATA 25,78
0034A:  DATA 0D,0A
0034C:  DATA 00,00
0034E:  DATA 46,41
00350:  DATA 42,20
00352:  DATA 48,4B
00354:  DATA 20,41
00356:  DATA 44,44
00358:  DATA 52,45
0035A:  DATA 53,53
0035C:  DATA 3A,25
0035E:  DATA 78,25
00360:  DATA 78,25
00362:  DATA 78,25
00364:  DATA 78,0D
00366:  DATA 0A,00
00368:  DATA 46,41
0036A:  DATA 42,20
0036C:  DATA 43,57
0036E:  DATA 20,41
00370:  DATA 44,44
00372:  DATA 52,45
00374:  DATA 53,53
00376:  DATA 3A,25
00378:  DATA 78,25
0037A:  DATA 78,25
0037C:  DATA 78,25
0037E:  DATA 78,0D
00380:  DATA 0A,00
00382:  DATA 41,44
00384:  DATA 43,53
00386:  DATA 20,53
00388:  DATA 45,4E
0038A:  DATA 53,4F
0038C:  DATA 52,20
0038E:  DATA 41,44
00390:  DATA 44,52
00392:  DATA 45,53
00394:  DATA 53,3A
00396:  DATA 25,78
00398:  DATA 25,78
0039A:  DATA 25,78
0039C:  DATA 25,78
0039E:  DATA 0D,0A
003A0:  DATA 00,00
003A2:  DATA 41,44
003A4:  DATA 43,53
003A6:  DATA 20,54
003A8:  DATA 4C,45
003AA:  DATA 20,41
003AC:  DATA 44,44
003AE:  DATA 52,45
003B0:  DATA 53,53
003B2:  DATA 3A,25
003B4:  DATA 78,25
003B6:  DATA 78,25
003B8:  DATA 78,25
003BA:  DATA 78,0D
003BC:  DATA 0A,00
003BE:  DATA 4D,49
003C0:  DATA 53,53
003C2:  DATA 49,4F
003C4:  DATA 4E,20
003C6:  DATA 42,4F
003C8:  DATA 53,53
003CA:  DATA 20,41
003CC:  DATA 44,44
003CE:  DATA 52,45
003D0:  DATA 53,53
003D2:  DATA 3A,25
003D4:  DATA 78,25
003D6:  DATA 78,25
003D8:  DATA 78,25
003DA:  DATA 78,0D
003DC:  DATA 0A,00
003DE:  DATA 48,49
003E0:  DATA 47,48
003E2:  DATA 20,53
003E4:  DATA 41,4D
003E6:  DATA 50,20
003E8:  DATA 48,4B
003EA:  DATA 20,41
003EC:  DATA 44,44
003EE:  DATA 45,52
003F0:  DATA 53,53
003F2:  DATA 3A,25
003F4:  DATA 78,25
003F6:  DATA 78,25
003F8:  DATA 78,25
003FA:  DATA 78,0D
003FC:  DATA 0A,00
003FE:  DATA 57,52
00400:  DATA 49,54
00402:  DATA 45,20
00404:  DATA 25,6C
00406:  DATA 78,20
00408:  DATA 54,49
0040A:  DATA 4D,45
0040C:  DATA 53,0D
0040E:  DATA 0A,00
00410:  DATA 0D,0A
00412:  DATA 50,41
00414:  DATA 53,53
00416:  DATA 45,44
00418:  DATA 20,44
0041A:  DATA 41,59
0041C:  DATA 53,3A
0041E:  DATA 25,6C
00420:  DATA 78,0D
00422:  DATA 0A,00
00424:  DATA 52,45
00426:  DATA 53,45
00428:  DATA 52,56
0042A:  DATA 45,20
0042C:  DATA 43,48
0042E:  DATA 45,43
00430:  DATA 4B,3A
00432:  DATA 25,78
00434:  DATA 0D,0A
00436:  DATA 00,00
00438:  DATA 4B,69
0043A:  DATA 6C,6C
0043C:  DATA 20,46
0043E:  DATA 4C,41
00440:  DATA 47,20
00442:  DATA 4D,41
00444:  DATA 49,4E
00446:  DATA 3A,25
00448:  DATA 78,0D
0044A:  DATA 0A,00
0044C:  DATA 4B,69
0044E:  DATA 6C,6C
00450:  DATA 20,46
00452:  DATA 4C,41
00454:  DATA 47,20
00456:  DATA 46,41
00458:  DATA 42,3A
0045A:  DATA 25,78
0045C:  DATA 0D,0A
0045E:  DATA 00,00
00460:  DATA 41,55
00462:  DATA 54,4F
00464:  DATA 20,48
00466:  DATA 49,47
00468:  DATA 48,20
0046A:  DATA 53,41
0046C:  DATA 4D,50
0046E:  DATA 4C,49
00470:  DATA 4E,47
00472:  DATA 3A,25
00474:  DATA 78,0D
00476:  DATA 0A,00
00478:  DATA 41,55
0047A:  DATA 54,4F
0047C:  DATA 20,43
0047E:  DATA 41,4D
00480:  DATA 3A,25
00482:  DATA 78,0D
00484:  DATA 0A,00
00486:  DATA 41,55
00488:  DATA 54,4F
0048A:  DATA 20,4D
0048C:  DATA 42,50
0048E:  DATA 3A,25
00490:  DATA 78,0D
00492:  DATA 0A,00
00494:  DATA 41,55
00496:  DATA 54,4F
00498:  DATA 20,41
0049A:  DATA 44,43
0049C:  DATA 53,3A
0049E:  DATA 25,78
004A0:  DATA 0D,0A
004A2:  DATA 00,00
004A4:  DATA 41,4E
004A6:  DATA 54,45
004A8:  DATA 4E,4E
004AA:  DATA 41,20
004AC:  DATA 44,45
004AE:  DATA 50,4C
004B0:  DATA 4F,59
004B2:  DATA 3A,25
004B4:  DATA 78,0D
004B6:  DATA 0A,00
004B8:  DATA 55,50
004BA:  DATA 4C,49
004BC:  DATA 4E,4B
004BE:  DATA 20,53
004C0:  DATA 55,43
004C2:  DATA 43,45
004C4:  DATA 53,53
004C6:  DATA 3A,25
004C8:  DATA 78,0D
004CA:  DATA 0A,0D
004CC:  DATA 0A,00
004CE:  DATA 46,4C
004D0:  DATA 41,47
004D2:  DATA 20,49
004D4:  DATA 4E,46
004D6:  DATA 4F,20
004D8:  DATA 53,54
004DA:  DATA 4F,52
004DC:  DATA 45,44
004DE:  DATA 20,49
004E0:  DATA 4E,20
004E2:  DATA 46,4C
004E4:  DATA 41,53
004E6:  DATA 48,0D
004E8:  DATA 0A,00
004EA:  DATA 0D,0A
004EC:  DATA 61,64
004EE:  DATA 64,72
004F0:  DATA 65,73
004F2:  DATA 73,20
004F4:  DATA 69,6E
004F6:  DATA 66,6F
004F8:  DATA 20,6C
004FA:  DATA 6F,63
004FC:  DATA 61,74
004FE:  DATA 69,6F
00500:  DATA 6E,3A
00502:  DATA 25,6C
00504:  DATA 78,0D
00506:  DATA 0A,00
00508:  DATA 41,44
0050A:  DATA 20,43
0050C:  DATA 4F,55
0050E:  DATA 4E,54
00510:  DATA 45,52
00512:  DATA 3A,25
00514:  DATA 6C,78
00516:  DATA 0D,0A
00518:  DATA 00,00
0051A:  DATA 43,48
0051C:  DATA 41,4E
0051E:  DATA 47,45
00520:  DATA 44,20
00522:  DATA 4D,45
00524:  DATA 4D,4F
00526:  DATA 52,59
00528:  DATA 20,41
0052A:  DATA 44,44
0052C:  DATA 52,45
0052E:  DATA 53,53
00530:  DATA 3A,00
00532:  DATA 0D,0A
00534:  DATA 53,74
00536:  DATA 6F,72
00538:  DATA 65,69
0053A:  DATA 6E,67
0053C:  DATA 20,41
0053E:  DATA 64,64
00540:  DATA 72,65
00542:  DATA 73,73
00544:  DATA 20,44
00546:  DATA 61,74
00548:  DATA 61,20
0054A:  DATA 69,6E
0054C:  DATA 20,46
0054E:  DATA 6C,61
00550:  DATA 73,68
00552:  DATA 0D,0A
00554:  DATA 00,00
00556:  DATA 41,44
00558:  DATA 44,52
0055A:  DATA 45,53
0055C:  DATA 53,20
0055E:  DATA 44,41
00560:  DATA 54,41
00562:  DATA 20,53
00564:  DATA 54,4F
00566:  DATA 52,45
00568:  DATA 20,44
0056A:  DATA 4F,4E
0056C:  DATA 45,3A
0056E:  DATA 25,6C
00570:  DATA 78,0D
00572:  DATA 0A,00
00574:  DATA 46,4C
00576:  DATA 41,53
00578:  DATA 48,20
0057A:  DATA 4D,45
0057C:  DATA 4D,4F
0057E:  DATA 52,59
00580:  DATA 20,45
00582:  DATA 52,41
00584:  DATA 53,45
00586:  DATA 20,53
00588:  DATA 54,41
0058A:  DATA 52,54
0058C:  DATA 0D,0A
0058E:  DATA 00,00
00590:  DATA 46,4C
00592:  DATA 41,53
00594:  DATA 48,20
00596:  DATA 4D,45
00598:  DATA 4D,4F
0059A:  DATA 52,59
0059C:  DATA 20,45
0059E:  DATA 52,41
005A0:  DATA 53,45
005A2:  DATA 20,44
005A4:  DATA 4F,4E
005A6:  DATA 45,0D
005A8:  DATA 0A,00
005AA:  DATA 52,65
005AC:  DATA 6D,61
005AE:  DATA 69,6E
005B0:  DATA 69,6E
005B2:  DATA 67,20
005B4:  DATA 74,69
005B6:  DATA 6D,65
005B8:  DATA 3A,20
005BA:  DATA 25,64
005BC:  DATA 20,20
005BE:  DATA 0D,00
005C0:  DATA 65,72
005C2:  DATA 61,73
005C4:  DATA 69,6E
005C6:  DATA 67,20
005C8:  DATA 6E,65
005CA:  DATA 78,74
005CC:  DATA 20,73
005CE:  DATA 65,63
005D0:  DATA 74,6F
005D2:  DATA 72,0D
005D4:  DATA 0A,00
005D6:  DATA 65,72
005D8:  DATA 61,73
005DA:  DATA 69,6E
005DC:  DATA 67,20
005DE:  DATA 6E,65
005E0:  DATA 78,74
005E2:  DATA 20,73
005E4:  DATA 65,63
005E6:  DATA 74,6F
005E8:  DATA 72,0D
005EA:  DATA 0A,00
005EC:  DATA 65,72
005EE:  DATA 61,73
005F0:  DATA 69,6E
005F2:  DATA 67,20
005F4:  DATA 6E,65
005F6:  DATA 78,74
005F8:  DATA 20,73
005FA:  DATA 65,63
005FC:  DATA 74,6F
005FE:  DATA 72,0D
00600:  DATA 0A,00
*
006A4:  TBLRD*+
006A6:  MOVF   FF5,F
006A8:  BZ    06CC
006AA:  MOVFF  FF6,38F
006AE:  MOVFF  FF7,390
006B2:  MOVFF  FF8,391
006B6:  MOVF   FF5,W
006B8:  BTFSS  F9E.4
006BA:  BRA    06B8
006BC:  MOVWF  FAD
006BE:  MOVFF  38F,FF6
006C2:  MOVFF  390,FF7
006C6:  MOVFF  391,FF8
006CA:  BRA    06A4
006CC:  RETURN 0
006CE:  TBLRD*+
006D0:  MOVFF  FF6,3A3
006D4:  MOVFF  FF7,3A4
006D8:  MOVFF  FF8,3A5
006DC:  MOVF   FF5,W
006DE:  BTFSS  F9E.4
006E0:  BRA    06DE
006E2:  MOVWF  FAD
006E4:  MOVFF  3A3,FF6
006E8:  MOVFF  3A4,FF7
006EC:  MOVFF  3A5,FF8
006F0:  MOVLB  3
006F2:  DECFSZ xA2,F
006F4:  BRA    06F8
006F6:  BRA    06FC
006F8:  MOVLB  0
006FA:  BRA    06CE
006FC:  MOVLB  0
006FE:  RETURN 0
00700:  MOVLB  3
00702:  BTFSC  xA3.7
00704:  BRA    0726
00706:  MOVLW  0F
00708:  MOVWF  00
0070A:  SWAPF  xA2,W
0070C:  ANDWF  00,F
0070E:  MOVLW  0A
00710:  SUBWF  00,W
00712:  BC    071A
00714:  MOVLW  30
00716:  ADDWF  00,F
00718:  BRA    071E
0071A:  MOVF   xA3,W
0071C:  ADDWF  00,F
0071E:  MOVF   00,W
00720:  BTFSS  F9E.4
00722:  BRA    0720
00724:  MOVWF  FAD
00726:  MOVLW  0F
00728:  ANDWF  xA2,F
0072A:  MOVLW  0A
0072C:  SUBWF  xA2,W
0072E:  BC    0734
00730:  MOVLW  30
00732:  BRA    0738
00734:  BCF    xA3.7
00736:  MOVF   xA3,W
00738:  ADDWF  xA2,F
0073A:  MOVF   xA2,W
0073C:  BTFSS  F9E.4
0073E:  BRA    073C
00740:  MOVWF  FAD
00742:  MOVLB  0
00744:  RETURN 0
00746:  DATA 65,72
00748:  DATA 61,73
0074A:  DATA 69,6E
0074C:  DATA 67,20
0074E:  DATA 6E,65
00750:  DATA 78,74
00752:  DATA 20,73
00754:  DATA 65,63
00756:  DATA 74,6F
00758:  DATA 72,0D
0075A:  DATA 0A,00
0075C:  DATA 65,72
0075E:  DATA 61,73
00760:  DATA 69,6E
00762:  DATA 67,20
00764:  DATA 6E,65
00766:  DATA 78,74
00768:  DATA 20,73
0076A:  DATA 65,63
0076C:  DATA 74,6F
0076E:  DATA 72,0D
00770:  DATA 0A,00
00772:  DATA 52,45
00774:  DATA 53,45
00776:  DATA 52,56
00778:  DATA 45,5F
0077A:  DATA 43,48
0077C:  DATA 45,43
0077E:  DATA 4B,20
00780:  DATA 3D,20
00782:  DATA 25,78
00784:  DATA 0D,0A
00786:  DATA 00,00
00788:  DATA 4E,45
0078A:  DATA 58,54
0078C:  DATA 20,46
0078E:  DATA 55,4E
00790:  DATA 43,54
00792:  DATA 49,4F
00794:  DATA 4E,5F
00796:  DATA 43,4F
00798:  DATA 4E,54
0079A:  DATA 45,4E
0079C:  DATA 54,53
0079E:  DATA 20,3D
007A0:  DATA 20,25
007A2:  DATA 78,0D
007A4:  DATA 0A,00
007A6:  DATA 52,45
007A8:  DATA 53,45
007AA:  DATA 52,56
007AC:  DATA 45,5F
007AE:  DATA 54,41
007B0:  DATA 52,47
007B2:  DATA 45,54
007B4:  DATA 5F,46
007B6:  DATA 4C,41
007B8:  DATA 47,20
007BA:  DATA 3D,20
007BC:  DATA 25,78
007BE:  DATA 0D,0A
007C0:  DATA 00,00
007C2:  DATA 4E,45
007C4:  DATA 58,54
007C6:  DATA 20,46
007C8:  DATA 55,4E
007CA:  DATA 43,54
007CC:  DATA 49,4F
007CE:  DATA 4E,20
007D0:  DATA 44,45
007D2:  DATA 54,41
007D4:  DATA 49,4C
007D6:  DATA 20,3D
007D8:  DATA 20,25
007DA:  DATA 78,0D
007DC:  DATA 0A,00
007DE:  DATA 4E,45
007E0:  DATA 58,54
007E2:  DATA 20,46
007E4:  DATA 55,4E
007E6:  DATA 43,54
007E8:  DATA 49,4F
007EA:  DATA 4E,20
007EC:  DATA 41,44
007EE:  DATA 44,52
007F0:  DATA 45,53
007F2:  DATA 53,20
007F4:  DATA 3D,20
007F6:  DATA 25,78
007F8:  DATA 25,78
007FA:  DATA 25,78
007FC:  DATA 25,78
007FE:  DATA 0D,0A
00800:  DATA 00,00
00802:  DATA 4E,45
00804:  DATA 58,54
00806:  DATA 20,46
00808:  DATA 55,4E
0080A:  DATA 43,54
0080C:  DATA 49,4F
0080E:  DATA 4E,20
00810:  DATA 50,43
00812:  DATA 4B,54
00814:  DATA 20,4E
00816:  DATA 55,4D
00818:  DATA 42,45
0081A:  DATA 52,20
0081C:  DATA 3D,20
0081E:  DATA 25,78
00820:  DATA 0D,0A
00822:  DATA 00,00
00824:  DATA 52,45
00826:  DATA 53,45
00828:  DATA 52,56
0082A:  DATA 45,5F
0082C:  DATA 4D,49
0082E:  DATA 4E,5F
00830:  DATA 46,4C
00832:  DATA 41,47
00834:  DATA 20,3D
00836:  DATA 20,25
00838:  DATA 78,0D
0083A:  DATA 0A,00
0083C:  DATA 54,41
0083E:  DATA 42,4C
00840:  DATA 45,20
00842:  DATA 4E,55
00844:  DATA 4D,20
00846:  DATA 3D,20
00848:  DATA 25,78
0084A:  DATA 0D,0A
0084C:  DATA 00,00
0084E:  DATA 52,65
00850:  DATA 73,65
00852:  DATA 72,76
00854:  DATA 61,74
00856:  DATA 69,6F
00858:  DATA 6E,20
0085A:  DATA 74,61
0085C:  DATA 62,6C
0085E:  DATA 65,20
00860:  DATA 69,73
00862:  DATA 20,46
00864:  DATA 75,6C
00866:  DATA 6C,21
00868:  DATA 0D,0A
0086A:  DATA 0D,0A
0086C:  DATA 00,00
0086E:  DATA 54,61
00870:  DATA 62,6C
00872:  DATA 65,20
00874:  DATA 6E,75
00876:  DATA 6D,3A
00878:  DATA 20,25
0087A:  DATA 78,0D
0087C:  DATA 0A,00
0087E:  DATA 52,65
00880:  DATA 73,65
00882:  DATA 72,76
00884:  DATA 61,74
00886:  DATA 69,6F
00888:  DATA 6E,20
0088A:  DATA 74,61
0088C:  DATA 62,6C
0088E:  DATA 65,20
00890:  DATA 69,73
00892:  DATA 20,46
00894:  DATA 75,6C
00896:  DATA 6C,21
00898:  DATA 0D,0A
0089A:  DATA 0D,0A
0089C:  DATA 00,00
0089E:  DATA 52,65
008A0:  DATA 6D,6F
008A2:  DATA 76,65
008A4:  DATA 64,20
008A6:  DATA 66,69
008A8:  DATA 6E,69
008AA:  DATA 73,68
008AC:  DATA 65,64
008AE:  DATA 20,6D
008B0:  DATA 69,73
008B2:  DATA 73,69
008B4:  DATA 6F,6E
008B6:  DATA 20,63
008B8:  DATA 6F,6D
008BA:  DATA 6D,61
008BC:  DATA 6E,64
008BE:  DATA 3A,00
008C0:  DATA 52,65
008C2:  DATA 73,65
008C4:  DATA 72,76
008C6:  DATA 65,20
008C8:  DATA 43,4D
008CA:  DATA 44,20
008CC:  DATA 66,72
008CE:  DATA 6F,6D
008D0:  DATA 20,43
008D2:  DATA 4F,4D
008D4:  DATA 0D,0A
008D6:  DATA 00,00
008D8:  DATA 52,65
008DA:  DATA 73,65
008DC:  DATA 72,76
008DE:  DATA 65,20
008E0:  DATA 43,4D
008E2:  DATA 44,20
008E4:  DATA 66,72
008E6:  DATA 6F,6D
008E8:  DATA 20,50
008EA:  DATA 43,0D
008EC:  DATA 0A,00
008EE:  DATA 52,65
008F0:  DATA 73,65
008F2:  DATA 72,76
008F4:  DATA 65,20
008F6:  DATA 6E,65
008F8:  DATA 78,74
008FA:  DATA 0D,0A
008FC:  DATA 00,00
008FE:  DATA 52,65
00900:  DATA 61,64
00902:  DATA 79,20
00904:  DATA 66,6F
00906:  DATA 72,20
00908:  DATA 72,65
0090A:  DATA 73,65
0090C:  DATA 74,00
0090E:  DATA 4C,4F
00910:  DATA 47,20
00912:  DATA 73,61
00914:  DATA 76,69
00916:  DATA 6E,67
00918:  DATA 20,64
0091A:  DATA 6F,6E
0091C:  DATA 65,0D
0091E:  DATA 0A,00
00920:  DATA 45,52
00922:  DATA 41,53
00924:  DATA 45,20
00926:  DATA 4F,46
00928:  DATA 3A,25
0092A:  DATA 78,25
0092C:  DATA 78,25
0092E:  DATA 78,25
00930:  DATA 78,0D
00932:  DATA 0A,00
00934:  DATA 45,52
00936:  DATA 41,53
00938:  DATA 45,20
0093A:  DATA 53,43
0093C:  DATA 46,3A
0093E:  DATA 25,78
00940:  DATA 25,78
00942:  DATA 25,78
00944:  DATA 25,78
00946:  DATA 0D,0A
00948:  DATA 00,00
0094A:  DATA 45,52
0094C:  DATA 41,53
0094E:  DATA 45,20
00950:  DATA 53,4D
00952:  DATA 46,3A
00954:  DATA 25,78
00956:  DATA 25,78
00958:  DATA 25,78
0095A:  DATA 25,78
0095C:  DATA 0D,0A
0095E:  DATA 00,00
00960:  DATA 74,72
00962:  DATA 61,6E
00964:  DATA 73,66
00966:  DATA 65,72
00968:  DATA 20,4F
0096A:  DATA 46,32
0096C:  DATA 53,43
0096E:  DATA 46,3A
00970:  DATA 25,78
00972:  DATA 25,78
00974:  DATA 25,78
00976:  DATA 25,78
00978:  DATA 0D,0A
0097A:  DATA 00,00
0097C:  DATA 74,72
0097E:  DATA 61,6E
00980:  DATA 73,66
00982:  DATA 65,72
00984:  DATA 20,4F
00986:  DATA 46,32
00988:  DATA 53,4D
0098A:  DATA 46,3A
0098C:  DATA 25,78
0098E:  DATA 25,78
00990:  DATA 25,78
00992:  DATA 25,78
00994:  DATA 0D,0A
00996:  DATA 00,00
00998:  DATA 74,72
0099A:  DATA 61,6E
0099C:  DATA 73,66
0099E:  DATA 65,72
009A0:  DATA 20,53
009A2:  DATA 43,46
009A4:  DATA 32,4F
009A6:  DATA 46,3A
009A8:  DATA 25,78
009AA:  DATA 25,78
009AC:  DATA 25,78
009AE:  DATA 25,78
009B0:  DATA 0D,0A
009B2:  DATA 00,00
009B4:  DATA 74,72
009B6:  DATA 61,6E
009B8:  DATA 73,66
009BA:  DATA 65,72
009BC:  DATA 20,53
009BE:  DATA 43,46
009C0:  DATA 32,53
009C2:  DATA 4D,46
009C4:  DATA 3A,25
009C6:  DATA 78,25
009C8:  DATA 78,25
009CA:  DATA 78,25
009CC:  DATA 78,0D
009CE:  DATA 0A,00
009D0:  DATA 74,72
009D2:  DATA 61,6E
009D4:  DATA 73,66
009D6:  DATA 65,72
009D8:  DATA 20,53
009DA:  DATA 4D,46
009DC:  DATA 32,4F
009DE:  DATA 46,3A
009E0:  DATA 25,78
009E2:  DATA 25,78
009E4:  DATA 25,78
009E6:  DATA 25,78
009E8:  DATA 0D,0A
009EA:  DATA 00,00
009EC:  DATA 74,72
009EE:  DATA 61,6E
009F0:  DATA 73,66
009F2:  DATA 65,72
009F4:  DATA 20,53
009F6:  DATA 4D,46
009F8:  DATA 32,53
009FA:  DATA 43,46
009FC:  DATA 3A,25
009FE:  DATA 78,25
00A00:  DATA 78,25
00A02:  DATA 78,25
00A04:  DATA 78,0D
00A06:  DATA 0A,00
00A08:  DATA 54,72
00A0A:  DATA 61,6E
00A0C:  DATA 73,66
00A0E:  DATA 65,72
00A10:  DATA 72,65
00A12:  DATA 64,20
00A14:  DATA 25,6C
00A16:  DATA 64,20
00A18:  DATA 42,79
00A1A:  DATA 74,65
00A1C:  DATA 73,00
00A1E:  DATA 73,65
00A20:  DATA 6E,64
00A22:  DATA 69,6E
00A24:  DATA 67,20
00A26:  DATA 63,6F
00A28:  DATA 6D,6D
00A2A:  DATA 61,6E
00A2C:  DATA 64,73
00A2E:  DATA 20,74
00A30:  DATA 6F,20
00A32:  DATA 4D,42
00A34:  DATA 50,0D
00A36:  DATA 0A,00
00A38:  DATA 52,65
00A3A:  DATA 63,65
00A3C:  DATA 69,76
00A3E:  DATA 65,64
00A40:  DATA 20,41
00A42:  DATA 43,4B
00A44:  DATA 20,46
00A46:  DATA 72,6F
00A48:  DATA 6D,20
00A4A:  DATA 4D,42
00A4C:  DATA 50,0D
00A4E:  DATA 0A,00
00A50:  DATA 54,52
00A52:  DATA 41,4E
00A54:  DATA 53,46
00A56:  DATA 45,52
00A58:  DATA 52,49
00A5A:  DATA 4E,47
00A5C:  DATA 20,25
00A5E:  DATA 6C,78
00A60:  DATA 20,50
00A62:  DATA 41,43
00A64:  DATA 4B,45
00A66:  DATA 54,53
00A68:  DATA 0D,0A
00A6A:  DATA 00,00
00A6C:  DATA 46,41
00A6E:  DATA 49,4C
00A70:  DATA 55,52
00A72:  DATA 45,44
00A74:  DATA 20,47
00A76:  DATA 45,54
00A78:  DATA 54,49
00A7A:  DATA 4E,47
00A7C:  DATA 20,41
00A7E:  DATA 43,4B
00A80:  DATA 20,46
00A82:  DATA 72,6F
00A84:  DATA 6D,20
00A86:  DATA 4D,42
00A88:  DATA 50,0D
00A8A:  DATA 0A,00
00A8C:  DATA 73,65
00A8E:  DATA 6E,64
00A90:  DATA 69,6E
00A92:  DATA 67,20
00A94:  DATA 63,6F
00A96:  DATA 6D,6D
00A98:  DATA 61,6E
00A9A:  DATA 64,73
00A9C:  DATA 20,74
00A9E:  DATA 6F,20
00AA0:  DATA 4D,42
00AA2:  DATA 50,0D
00AA4:  DATA 0A,00
00AA6:  DATA 52,65
00AA8:  DATA 63,65
00AAA:  DATA 69,76
00AAC:  DATA 65,64
00AAE:  DATA 20,41
00AB0:  DATA 43,4B
00AB2:  DATA 20,46
00AB4:  DATA 72,6F
00AB6:  DATA 6D,20
00AB8:  DATA 4D,42
00ABA:  DATA 50,0D
00ABC:  DATA 0A,00
00ABE:  DATA 46,41
00AC0:  DATA 49,4C
00AC2:  DATA 55,52
00AC4:  DATA 45,44
00AC6:  DATA 20,47
00AC8:  DATA 45,54
00ACA:  DATA 54,49
00ACC:  DATA 4E,47
00ACE:  DATA 20,41
00AD0:  DATA 43,4B
00AD2:  DATA 20,46
00AD4:  DATA 72,6F
00AD6:  DATA 6D,20
00AD8:  DATA 4D,42
00ADA:  DATA 50,0D
00ADC:  DATA 0A,00
00ADE:  DATA 50,57
00AE0:  DATA 52,20
00AE2:  DATA 63,79
00AE4:  DATA 63,6C
00AE6:  DATA 65,20
00AE8:  DATA 61,6E
00AEA:  DATA 64,20
00AEC:  DATA 73,65
00AEE:  DATA 6E,64
00AF0:  DATA 69,6E
00AF2:  DATA 67,20
00AF4:  DATA 63,6F
00AF6:  DATA 6D,6D
00AF8:  DATA 61,6E
00AFA:  DATA 64,73
00AFC:  DATA 20,61
00AFE:  DATA 67,61
00B00:  DATA 69,6E
00B02:  DATA 0D,0A
00B04:  DATA 00,00
00B06:  DATA 0D,0A
00B08:  DATA 73,65
00B0A:  DATA 6E,64
00B0C:  DATA 69,6E
00B0E:  DATA 67,20
00B10:  DATA 53,59
00B12:  DATA 4E,43
00B14:  DATA 20,74
00B16:  DATA 69,6D
00B18:  DATA 65,20
00B1A:  DATA 74,6F
00B1C:  DATA 20,4D
00B1E:  DATA 42,50
00B20:  DATA 0D,0A
00B22:  DATA 00,00
00B24:  DATA 54,69
00B26:  DATA 6D,65
00B28:  DATA 20,72
00B2A:  DATA 65,63
00B2C:  DATA 65,69
00B2E:  DATA 76,65
00B30:  DATA 64,20
00B32:  DATA 66,72
00B34:  DATA 6F,6D
00B36:  DATA 20,52
00B38:  DATA 45,53
00B3A:  DATA 45,54
00B3C:  DATA 0D,0A
00B3E:  DATA 00,00
00B40:  DATA 4E,4F
00B42:  DATA 20,52
00B44:  DATA 45,53
00B46:  DATA 45,54
00B48:  DATA 20,74
00B4A:  DATA 69,6D
00B4C:  DATA 65,0D
00B4E:  DATA 0A,00
00B50:  DATA 54,69
00B52:  DATA 6D,65
00B54:  DATA 20,52
00B56:  DATA 65,63
00B58:  DATA 65,69
00B5A:  DATA 76,65
00B5C:  DATA 64,20
00B5E:  DATA 66,6F
00B60:  DATA 72,20
00B62:  DATA 4D,42
00B64:  DATA 50,0D
00B66:  DATA 0A,00
00B68:  DATA 46,41
00B6A:  DATA 49,4C
00B6C:  DATA 55,52
00B6E:  DATA 45,44
00B70:  DATA 20,47
00B72:  DATA 45,54
00B74:  DATA 54,49
00B76:  DATA 4E,47
00B78:  DATA 20,41
00B7A:  DATA 43,4B
00B7C:  DATA 20,46
00B7E:  DATA 72,6F
00B80:  DATA 6D,20
00B82:  DATA 4D,42
00B84:  DATA 50,0D
00B86:  DATA 0A,00
00B88:  DATA 0D,0A
00B8A:  DATA 43,57
00B8C:  DATA 20,41
00B8E:  DATA 4E,53
00B90:  DATA 3A,00
00B92:  DATA 54,75
00B94:  DATA 72,6E
00B96:  DATA 20,4F
00B98:  DATA 6E,20
00B9A:  DATA 41,44
00B9C:  DATA 43,53
00B9E:  DATA 20,0D
00BA0:  DATA 0A,00
00BA2:  DATA 52,65
00BA4:  DATA 63,65
00BA6:  DATA 69,76
00BA8:  DATA 65,64
00BAA:  DATA 20,41
00BAC:  DATA 43,4B
00BAE:  DATA 20,46
00BB0:  DATA 72,6F
00BB2:  DATA 6D,20
00BB4:  DATA 41,44
00BB6:  DATA 43,53
00BB8:  DATA 0D,0A
00BBA:  DATA 00,00
00BBC:  DATA 53,65
00BBE:  DATA 6E,74
00BC0:  DATA 20,54
00BC2:  DATA 4C,45
00BC4:  DATA 20,64
00BC6:  DATA 61,74
00BC8:  DATA 61,20
00BCA:  DATA 74,6F
00BCC:  DATA 20,41
00BCE:  DATA 44,43
00BD0:  DATA 53,0D
00BD2:  DATA 0A,00
00BD4:  DATA 46,41
00BD6:  DATA 49,4C
00BD8:  DATA 55,52
00BDA:  DATA 45,44
00BDC:  DATA 20,47
00BDE:  DATA 45,54
00BE0:  DATA 54,49
00BE2:  DATA 4E,47
00BE4:  DATA 20,41
00BE6:  DATA 43,4B
00BE8:  DATA 20,46
00BEA:  DATA 72,6F
00BEC:  DATA 6D,20
00BEE:  DATA 41,44
00BF0:  DATA 43,53
00BF2:  DATA 0D,0A
00BF4:  DATA 00,00
00BF6:  DATA 54,75
00BF8:  DATA 72,6E
00BFA:  DATA 20,4F
00BFC:  DATA 6E,20
00BFE:  DATA 41,44
00C00:  DATA 43,53
00C02:  DATA 20,0D
00C04:  DATA 0A,00
00C06:  DATA 52,65
00C08:  DATA 63,65
00C0A:  DATA 69,76
00C0C:  DATA 65,64
00C0E:  DATA 20,41
00C10:  DATA 43,4B
00C12:  DATA 20,46
00C14:  DATA 72,6F
00C16:  DATA 6D,20
00C18:  DATA 41,44
00C1A:  DATA 43,53
00C1C:  DATA 0D,0A
00C1E:  DATA 00,00
00C20:  DATA 53,65
00C22:  DATA 6E,74
00C24:  DATA 20,4F
00C26:  DATA 50,45
00C28:  DATA 52,41
00C2A:  DATA 54,49
00C2C:  DATA 4F,4E
00C2E:  DATA 20,4D
00C30:  DATA 4F,44
00C32:  DATA 45,20
00C34:  DATA 74,6F
00C36:  DATA 20,41
00C38:  DATA 44,43
00C3A:  DATA 53,0D
00C3C:  DATA 0A,00
00C3E:  DATA 46,41
00C40:  DATA 49,4C
00C42:  DATA 55,52
00C44:  DATA 45,44
00C46:  DATA 20,47
00C48:  DATA 45,54
00C4A:  DATA 54,49
00C4C:  DATA 4E,47
00C4E:  DATA 20,41
00C50:  DATA 43,4B
00C52:  DATA 20,46
00C54:  DATA 72,6F
00C56:  DATA 6D,20
00C58:  DATA 41,44
00C5A:  DATA 43,53
00C5C:  DATA 0D,0A
00C5E:  DATA 00,00
00C60:  DATA 64,6F
00C62:  DATA 6E,65
00C64:  DATA 0D,0A
00C66:  DATA 00,00
00C68:  DATA 53,74
00C6A:  DATA 6F,70
00C6C:  DATA 20,41
00C6E:  DATA 44,43
00C70:  DATA 53,20
00C72:  DATA 4D,69
00C74:  DATA 73,73
00C76:  DATA 69,6F
00C78:  DATA 6E,0D
00C7A:  DATA 0A,00
00C7C:  DATA 0D,0A
00C7E:  DATA 0D,0A
00C80:  DATA 54,75
00C82:  DATA 72,6E
00C84:  DATA 65,64
00C86:  DATA 5F,4F
00C88:  DATA 46,46
00C8A:  DATA 5F,41
00C8C:  DATA 44,43
00C8E:  DATA 53,0D
00C90:  DATA 0A,0D
00C92:  DATA 0A,0D
00C94:  DATA 0A,00
00C96:  DATA 0D,0A
00C98:  DATA 0D,0A
00C9A:  DATA 54,75
00C9C:  DATA 72,6E
00C9E:  DATA 65,64
00CA0:  DATA 5F,4F
00CA2:  DATA 4E,5F
00CA4:  DATA 41,44
00CA6:  DATA 43,53
00CA8:  DATA 0D,0A
00CAA:  DATA 0D,0A
00CAC:  DATA 0D,0A
00CAE:  DATA 00,00
00CB0:  DATA 4E,4F
00CB2:  DATA 20,44
00CB4:  DATA 41,54
00CB6:  DATA 41,0D
00CB8:  DATA 0A,00
00CBA:  MOVFF  FEA,3AA
00CBE:  MOVFF  FE9,3A9
00CC2:  MOVLB  3
00CC4:  SWAPF  xA3,W
00CC6:  IORLW  F0
00CC8:  MOVWF  xA5
00CCA:  ADDWF  xA5,F
00CCC:  ADDLW  E2
00CCE:  MOVWF  xA6
00CD0:  ADDLW  32
00CD2:  MOVWF  xA8
00CD4:  MOVF   xA3,W
00CD6:  ANDLW  0F
00CD8:  ADDWF  xA6,F
00CDA:  ADDWF  xA6,F
00CDC:  ADDWF  xA8,F
00CDE:  ADDLW  E9
00CE0:  MOVWF  xA7
00CE2:  ADDWF  xA7,F
00CE4:  ADDWF  xA7,F
00CE6:  SWAPF  xA2,W
00CE8:  ANDLW  0F
00CEA:  ADDWF  xA7,F
00CEC:  ADDWF  xA8,F
00CEE:  RLCF   xA7,F
00CF0:  RLCF   xA8,F
00CF2:  COMF   xA8,F
00CF4:  RLCF   xA8,F
00CF6:  MOVF   xA2,W
00CF8:  ANDLW  0F
00CFA:  ADDWF  xA8,F
00CFC:  RLCF   xA5,F
00CFE:  MOVLW  07
00D00:  MOVWF  xA4
00D02:  MOVLW  0A
00D04:  DECF   xA7,F
00D06:  ADDWF  xA8,F
00D08:  BNC   0D04
00D0A:  DECF   xA6,F
00D0C:  ADDWF  xA7,F
00D0E:  BNC   0D0A
00D10:  DECF   xA5,F
00D12:  ADDWF  xA6,F
00D14:  BNC   0D10
00D16:  DECF   xA4,F
00D18:  ADDWF  xA5,F
00D1A:  BNC   0D16
00D1C:  MOVLW  03
00D1E:  MOVWF  FEA
00D20:  MOVLW  A4
00D22:  MOVWF  FE9
00D24:  MOVLW  07
00D26:  ANDWF  xA9,W
00D28:  BCF    xA9.6
00D2A:  ADDWF  FE9,F
00D2C:  MOVLW  00
00D2E:  ADDWFC FEA,F
00D30:  MOVF   FE9,W
00D32:  SUBLW  A8
00D34:  BNZ   0D3E
00D36:  MOVF   FEA,W
00D38:  SUBLW  03
00D3A:  BNZ   0D3E
00D3C:  BSF    xA9.6
00D3E:  MOVF   FEF,W
00D40:  MOVWF  00
00D42:  BNZ   0D54
00D44:  BTFSC  xA9.6
00D46:  BRA    0D54
00D48:  BTFSC  xA9.4
00D4A:  BRA    0D64
00D4C:  BTFSC  xA9.3
00D4E:  BRA    0D54
00D50:  MOVLW  20
00D52:  BRA    0D5A
00D54:  BSF    xA9.3
00D56:  BCF    xA9.4
00D58:  MOVLW  30
00D5A:  ADDWF  00,F
00D5C:  MOVF   00,W
00D5E:  BTFSS  F9E.4
00D60:  BRA    0D5E
00D62:  MOVWF  FAD
00D64:  MOVF   FEE,W
00D66:  BTFSS  xA9.6
00D68:  BRA    0D30
00D6A:  MOVLB  0
00D6C:  RETURN 0
00D6E:  DATA 25,6C
00D70:  DATA 75,64
00D72:  DATA 2C,25
00D74:  DATA 6C,75
00D76:  DATA 64,0D
00D78:  DATA 0A,00
00D7A:  DATA 67,69
00D7C:  DATA 76,69
00D7E:  DATA 6E,67
00D80:  DATA 20,61
00D82:  DATA 63,63
00D84:  DATA 65,73
00D86:  DATA 73,20
00D88:  DATA 74,6F
00D8A:  DATA 20,43
00D8C:  DATA 4F,4D
00D8E:  DATA 20,66
00D90:  DATA 6F,72
00D92:  DATA 20,25
00D94:  DATA 64,20
00D96:  DATA 6D,69
00D98:  DATA 6E,0D
00D9A:  DATA 0A,00
00D9C:  DATA 0D,0A
00D9E:  DATA 42,61
00DA0:  DATA 63,6B
00DA2:  DATA 20,74
00DA4:  DATA 6F,20
00DA6:  DATA 4E,6F
00DA8:  DATA 6D,61
00DAA:  DATA 6C,20
00DAC:  DATA 4F,70
00DAE:  DATA 65,72
00DB0:  DATA 61,74
00DB2:  DATA 69,6F
00DB4:  DATA 6E,0D
00DB6:  DATA 0A,00
00DB8:  DATA 43,75
00DBA:  DATA 72,72
00DBC:  DATA 65,6E
00DBE:  DATA 74,20
00DC0:  DATA 54,65
00DC2:  DATA 6D,70
00DC4:  DATA 3A,20
00DC6:  DATA 25,31
00DC8:  DATA 2E,31
00DCA:  DATA 66,0D
00DCC:  DATA 0A,00
00DCE:  DATA 54,75
00DD0:  DATA 72,6E
00DD2:  DATA 65,64
00DD4:  DATA 20,4F
00DD6:  DATA 4E,20
00DD8:  DATA 42,43
00DDA:  DATA 0D,0A
00DDC:  DATA 00,00
00DDE:  DATA 54,75
00DE0:  DATA 72,6E
00DE2:  DATA 65,64
00DE4:  DATA 20,4F
00DE6:  DATA 46,46
00DE8:  DATA 20,42
00DEA:  DATA 43,0D
00DEC:  DATA 0A,00
00DEE:  DATA 4D,41
00DF0:  DATA 58,49
00DF2:  DATA 4D,55
00DF4:  DATA 4D,20
00DF6:  DATA 54,45
00DF8:  DATA 4D,50
00DFA:  DATA 45,52
00DFC:  DATA 41,54
00DFE:  DATA 55,52
00E00:  DATA 45,20
00E02:  DATA 69,73
00E04:  DATA 20,25
00E06:  DATA 31,2E
00E08:  DATA 31,66
00E0A:  DATA 0D,0A
00E0C:  DATA 0D,0A
00E0E:  DATA 00,00
00E10:  DATA 0D,0A
00E12:  DATA 42,43
00E14:  DATA 20,41
00E16:  DATA 74,74
00E18:  DATA 65,6D
00E1A:  DATA 70,74
00E1C:  DATA 20,46
00E1E:  DATA 6C,61
00E20:  DATA 67,20
00E22:  DATA 63,6C
00E24:  DATA 65,61
00E26:  DATA 72,20
00E28:  DATA 64,6F
00E2A:  DATA 6E,65
00E2C:  DATA 0D,0A
00E2E:  DATA 00,00
00E30:  DATA 0D,0A
00E32:  DATA 42,43
00E34:  DATA 20,41
00E36:  DATA 74,74
00E38:  DATA 65,6D
00E3A:  DATA 70,74
00E3C:  DATA 20,46
00E3E:  DATA 6C,61
00E40:  DATA 67,3A
00E42:  DATA 31,0D
00E44:  DATA 0A,00
00E46:  DATA 0D,0A
00E48:  DATA 42,43
00E4A:  DATA 20,41
00E4C:  DATA 74,74
00E4E:  DATA 65,6D
00E50:  DATA 70,74
00E52:  DATA 20,46
00E54:  DATA 6C,61
00E56:  DATA 67,3A
00E58:  DATA 32,0D
00E5A:  DATA 0A,00
00E5C:  DATA 0D,0A
00E5E:  DATA 42,43
00E60:  DATA 20,41
00E62:  DATA 74,74
00E64:  DATA 65,6D
00E66:  DATA 70,74
00E68:  DATA 20,46
00E6A:  DATA 6C,61
00E6C:  DATA 67,3A
00E6E:  DATA 33,0D
00E70:  DATA 0A,00
00E72:  DATA 0D,0A
00E74:  DATA 42,43
00E76:  DATA 20,41
00E78:  DATA 74,74
00E7A:  DATA 65,6D
00E7C:  DATA 70,74
00E7E:  DATA 20,46
00E80:  DATA 6C,61
00E82:  DATA 67,3A
00E84:  DATA 34,0D
00E86:  DATA 0A,00
00E88:  DATA 41,6E
00E8A:  DATA 74,20
00E8C:  DATA 44,65
00E8E:  DATA 70,20
00E90:  DATA 41,74
00E92:  DATA 74,65
00E94:  DATA 6D,70
00E96:  DATA 74,20
00E98:  DATA 4E,6F
00E9A:  DATA 3A,20
00E9C:  DATA 25,78
00E9E:  DATA 0D,0A
00EA0:  DATA 00,00
00EA2:  DATA 42,43
00EA4:  DATA 20,63
00EA6:  DATA 6F,6D
00EA8:  DATA 6D,61
00EAA:  DATA 6E,64
00EAC:  DATA 20,73
00EAE:  DATA 65,6E
00EB0:  DATA 74,20
00EB2:  DATA 74,6F
00EB4:  DATA 20,52
00EB6:  DATA 45,53
00EB8:  DATA 45,54
00EBA:  DATA 20,50
00EBC:  DATA 49,43
00EBE:  DATA 0D,0A
00EC0:  DATA 00,00
00EC2:  DATA 0D,0A
00EC4:  DATA 41,44
00EC6:  DATA 43,53
00EC8:  DATA 20,44
00ECA:  DATA 41,54
00ECC:  DATA 41,20
00ECE:  DATA 72,65
00ED0:  DATA 63,65
00ED2:  DATA 69,76
00ED4:  DATA 65,64
00ED6:  DATA 0D,0A
00ED8:  DATA 00,00
00EDA:  DATA 0D,0A
00EDC:  DATA 41,44
00EDE:  DATA 43,53
00EE0:  DATA 20,44
00EE2:  DATA 41,54
00EE4:  DATA 41,20
00EE6:  DATA 6E,6F
00EE8:  DATA 74,20
00EEA:  DATA 72,65
00EEC:  DATA 63,65
00EEE:  DATA 69,76
00EF0:  DATA 65,64
00EF2:  DATA 0D,0A
00EF4:  DATA 00,00
00EF6:  DATA 0D,0A
00EF8:  DATA 54,4C
00EFA:  DATA 45,3A
00EFC:  DATA 0D,0A
00EFE:  DATA 00,00
00F00:  DATA 0D,0A
00F02:  DATA 43,57
00F04:  DATA 20,53
00F06:  DATA 41,56
00F08:  DATA 45,44
00F0A:  DATA 0D,0A
00F0C:  DATA 00,00
00F0E:  DATA 47,45
00F10:  DATA 54,20
00F12:  DATA 53,45
00F14:  DATA 4E,53
00F16:  DATA 4F,52
00F18:  DATA 20,44
00F1A:  DATA 41,54
00F1C:  DATA 41,0D
00F1E:  DATA 0A,00
00F20:  DATA 0D,0A
00F22:  DATA 52,45
00F24:  DATA 53,45
00F26:  DATA 54,20
00F28:  DATA 44,41
00F2A:  DATA 54,41
00F2C:  DATA 20,4F
00F2E:  DATA 42,54
00F30:  DATA 41,49
00F32:  DATA 4E,45
00F34:  DATA 44,0D
00F36:  DATA 0A,00
00F38:  DATA 0D,0A
00F3A:  DATA 52,45
00F3C:  DATA 53,45
00F3E:  DATA 54,20
00F40:  DATA 44,41
00F42:  DATA 54,41
00F44:  DATA 20,4E
00F46:  DATA 4F,20
00F48:  DATA 4F,42
00F4A:  DATA 54,41
00F4C:  DATA 49,4E
00F4E:  DATA 45,44
00F50:  DATA 0D,0A
00F52:  DATA 00,00
00F54:  DATA 0D,0A
00F56:  DATA 43,57
00F58:  DATA 3A,0D
00F5A:  DATA 0A,00
00F5C:  DATA 0D,0A
00F5E:  DATA 43,6F
00F60:  DATA 6C,6C
00F62:  DATA 65,63
00F64:  DATA 74,69
00F66:  DATA 6E,67
00F68:  DATA 20,48
00F6A:  DATA 4B,20
00F6C:  DATA 61,6E
00F6E:  DATA 64,20
00F70:  DATA 4D,61
00F72:  DATA 6B,69
00F74:  DATA 6E,67
00F76:  DATA 20,43
00F78:  DATA 57,46
00F7A:  DATA 6F,72
00F7C:  DATA 6D,61
00F7E:  DATA 74,20
00F80:  DATA 44,6F
00F82:  DATA 6E,65
00F84:  DATA 0D,0A
00F86:  DATA 00,00
00F88:  DATA 0D,0A
00F8A:  DATA 48,4B
00F8C:  DATA 20,64
00F8E:  DATA 61,74
00F90:  DATA 61,3A
00F92:  DATA 0D,0A
00F94:  DATA 00,00
00F96:  DATA 0D,0A
00F98:  DATA 53,45
00F9A:  DATA 4E,53
00F9C:  DATA 4F,52
00F9E:  DATA 53,20
00FA0:  DATA 44,41
00FA2:  DATA 54,41
00FA4:  DATA 20,53
00FA6:  DATA 41,56
00FA8:  DATA 45,44
00FAA:  DATA 20,4F
00FAC:  DATA 4E,20
00FAE:  DATA 46,4C
00FB0:  DATA 41,53
00FB2:  DATA 48,0D
00FB4:  DATA 0A,00
00FB6:  DATA 4E,4F
00FB8:  DATA 20,52
00FBA:  DATA 45,53
00FBC:  DATA 50,4F
00FBE:  DATA 4E,53
00FC0:  DATA 45,20
00FC2:  DATA 46,52
00FC4:  DATA 4F,4D
00FC6:  DATA 20,46
00FC8:  DATA 41,42
00FCA:  DATA 0D,0A
00FCC:  DATA 0D,0A
00FCE:  DATA 00,00
00FD0:  DATA 0D,0A
00FD2:  DATA 46,41
00FD4:  DATA 42,20
00FD6:  DATA 44,41
00FD8:  DATA 54,41
00FDA:  DATA 20,4F
00FDC:  DATA 42,54
00FDE:  DATA 41,49
00FE0:  DATA 4E,45
00FE2:  DATA 44,0D
00FE4:  DATA 0A,00
00FE6:  DATA 47,45
00FE8:  DATA 54,20
00FEA:  DATA 52,45
00FEC:  DATA 53,45
00FEE:  DATA 54,0D
00FF0:  DATA 0A,00
00FF2:  DATA 4E,4F
00FF4:  DATA 20,52
00FF6:  DATA 45,53
00FF8:  DATA 45,54
00FFA:  DATA 0D,0A
00FFC:  DATA 00,00
00FFE:  DATA 0D,0A
01000:  DATA 39,30
01002:  DATA 73,65
01004:  DATA 63,0D
01006:  DATA 0A,00
01008:  DATA 0D,0A
0100A:  DATA 43,4F
0100C:  DATA 55,4E
0100E:  DATA 54,3A
01010:  DATA 25,64
01012:  DATA 0D,0A
01014:  DATA 00,00
01016:  DATA 0D,0A
01018:  DATA 43,4F
0101A:  DATA 55,4E
0101C:  DATA 54,3A
0101E:  DATA 25,64
01020:  DATA 0D,0A
01022:  DATA 00,00
01024:  DATA 43,6F
01026:  DATA 6D,6D
01028:  DATA 61,6E
0102A:  DATA 64,3A
0102C:  DATA 25,78
0102E:  DATA 0D,0A
01030:  DATA 00,00
01032:  DATA 43,41
01034:  DATA 4D,20
01036:  DATA 53,74
01038:  DATA 61,72
0103A:  DATA 74,20
0103C:  DATA 6F,70
0103E:  DATA 65,72
01040:  DATA 61,74
01042:  DATA 69,6F
01044:  DATA 6E,0D
01046:  DATA 0A,00
01048:  DATA 44,65
0104A:  DATA 6C,65
0104C:  DATA 74,69
0104E:  DATA 6E,67
01050:  DATA 20,31
01052:  DATA 20,73
01054:  DATA 65,63
01056:  DATA 74,6F
01058:  DATA 72,20
0105A:  DATA 53,4D
0105C:  DATA 46,20
0105E:  DATA 41,64
01060:  DATA 64,72
01062:  DATA 65,73
01064:  DATA 73,20
01066:  DATA 30,30
01068:  DATA 30,38
0106A:  DATA 30,30
0106C:  DATA 30,30
0106E:  DATA 0D,0A
01070:  DATA 00,00
01072:  DATA 54,75
01074:  DATA 72,6E
01076:  DATA 65,64
01078:  DATA 20,4F
0107A:  DATA 6E,20
0107C:  DATA 43,41
0107E:  DATA 4D,20
01080:  DATA 61,6E
01082:  DATA 64,20
01084:  DATA 4D,55
01086:  DATA 58,20
01088:  DATA 43,41
0108A:  DATA 4D,20
0108C:  DATA 73,69
0108E:  DATA 64,65
01090:  DATA 0D,0A
01092:  DATA 00,00
*
010DE:  DATA 53,65
010E0:  DATA 6E,64
010E2:  DATA 69,6E
010E4:  DATA 67,20
010E6:  DATA 68,61
010E8:  DATA 6E,64
010EA:  DATA 20,73
010EC:  DATA 68,61
010EE:  DATA 6B,65
010F0:  DATA 20,43
010F2:  DATA 6F,6D
010F4:  DATA 6D,61
010F6:  DATA 6E,64
010F8:  DATA 20,74
010FA:  DATA 6F,20
010FC:  DATA 43,41
010FE:  DATA 4D,0D
01100:  DATA 0A,00
01102:  DATA 41,43
01104:  DATA 4B,20
01106:  DATA 72,65
01108:  DATA 63,65
0110A:  DATA 69,76
0110C:  DATA 65,64
0110E:  DATA 20,66
01110:  DATA 72,6F
01112:  DATA 6D,20
01114:  DATA 43,41
01116:  DATA 4D,0D
01118:  DATA 0A,0D
0111A:  DATA 0A,00
0111C:  DATA 53,65
0111E:  DATA 6E,64
01120:  DATA 69,6E
01122:  DATA 67,20
01124:  DATA 43,41
01126:  DATA 4D,20
01128:  DATA 4D,4F
0112A:  DATA 44,45
0112C:  DATA 20,64
0112E:  DATA 61,74
01130:  DATA 61,0D
01132:  DATA 0A,00
01134:  DATA 43,61
01136:  DATA 70,74
01138:  DATA 75,72
0113A:  DATA 69,6E
0113C:  DATA 67,20
0113E:  DATA 61,6E
01140:  DATA 64,20
01142:  DATA 73,61
01144:  DATA 76,69
01146:  DATA 6E,67
01148:  DATA 20,69
0114A:  DATA 6E,20
0114C:  DATA 53,46
0114E:  DATA 4D,2E
01150:  DATA 2E,2E
01152:  DATA 0D,0A
01154:  DATA 0D,0A
01156:  DATA 00,00
01158:  DATA 50,48
0115A:  DATA 4F,54
0115C:  DATA 4F,20
0115E:  DATA 53,41
01160:  DATA 56,49
01162:  DATA 4E,47
01164:  DATA 20,44
01166:  DATA 4F,4E
01168:  DATA 45,0D
0116A:  DATA 0A,00
0116C:  DATA 52,65
0116E:  DATA 61,64
01170:  DATA 20,61
01172:  DATA 6E,64
01174:  DATA 20,54
01176:  DATA 72,61
01178:  DATA 6E,73
0117A:  DATA 66,65
0117C:  DATA 72,20
0117E:  DATA 64,61
01180:  DATA 74,61
01182:  DATA 20,66
01184:  DATA 72,6F
01186:  DATA 6D,20
01188:  DATA 53,4D
0118A:  DATA 46,20
0118C:  DATA 54,4F
0118E:  DATA 20,53
01190:  DATA 43,46
01192:  DATA 20,61
01194:  DATA 6E,64
01196:  DATA 20,4F
01198:  DATA 46,20
0119A:  DATA 53,74
0119C:  DATA 61,72
0119E:  DATA 74,0D
011A0:  DATA 0A,00
011A2:  DATA 43,41
011A4:  DATA 4D,20
011A6:  DATA 44,41
011A8:  DATA 54,41
011AA:  DATA 20,53
011AC:  DATA 41,56
011AE:  DATA 49,4E
011B0:  DATA 47,20
011B2:  DATA 46,41
011B4:  DATA 49,4C
011B6:  DATA 55,52
011B8:  DATA 45,44
011BA:  DATA 0D,0A
011BC:  DATA 00,00
011BE:  DATA 43,41
011C0:  DATA 4D,20
011C2:  DATA 41,43
011C4:  DATA 4B,20
011C6:  DATA 46,41
011C8:  DATA 49,4C
011CA:  DATA 55,52
011CC:  DATA 45,44
011CE:  DATA 0D,0A
011D0:  DATA 00,00
011D2:  DATA 54,75
011D4:  DATA 72,6E
011D6:  DATA 65,64
011D8:  DATA 20,4F
011DA:  DATA 46,46
011DC:  DATA 20,43
011DE:  DATA 41,4D
011E0:  DATA 0D,0A
011E2:  DATA 00,00
011E4:  DATA 53,65
011E6:  DATA 6E,64
011E8:  DATA 69,6E
011EA:  DATA 67,20
011EC:  DATA 68,61
011EE:  DATA 6E,64
011F0:  DATA 20,73
011F2:  DATA 68,61
011F4:  DATA 6B,65
011F6:  DATA 20,43
011F8:  DATA 6F,6D
011FA:  DATA 6D,61
011FC:  DATA 6E,64
011FE:  DATA 20,74
01200:  DATA 6F,20
01202:  DATA 43,41
01204:  DATA 4D,0D
01206:  DATA 0A,00
01208:  DATA 41,43
0120A:  DATA 4B,20
0120C:  DATA 72,65
0120E:  DATA 63,65
01210:  DATA 69,76
01212:  DATA 65,64
01214:  DATA 20,66
01216:  DATA 72,6F
01218:  DATA 6D,20
0121A:  DATA 43,41
0121C:  DATA 4D,0D
0121E:  DATA 0A,0D
01220:  DATA 0A,00
01222:  DATA 53,65
01224:  DATA 6E,64
01226:  DATA 69,6E
01228:  DATA 67,20
0122A:  DATA 43,41
0122C:  DATA 4D,20
0122E:  DATA 4D,4F
01230:  DATA 44,45
01232:  DATA 20,64
01234:  DATA 61,74
01236:  DATA 61,0D
01238:  DATA 0A,00
0123A:  DATA 43,61
0123C:  DATA 70,74
0123E:  DATA 75,72
01240:  DATA 69,6E
01242:  DATA 67,20
01244:  DATA 61,6E
01246:  DATA 64,20
01248:  DATA 73,61
0124A:  DATA 76,69
0124C:  DATA 6E,67
0124E:  DATA 20,69
01250:  DATA 6E,20
01252:  DATA 53,46
01254:  DATA 4D,2E
01256:  DATA 2E,2E
01258:  DATA 0D,0A
0125A:  DATA 0D,0A
0125C:  DATA 00,00
0125E:  DATA 50,48
01260:  DATA 4F,54
01262:  DATA 4F,20
01264:  DATA 25,64
01266:  DATA 20,53
01268:  DATA 41,56
0126A:  DATA 49,4E
0126C:  DATA 47,20
0126E:  DATA 44,4F
01270:  DATA 4E,45
01272:  DATA 0D,0A
01274:  DATA 00,00
01276:  DATA 43,41
01278:  DATA 4D,20
0127A:  DATA 44,41
0127C:  DATA 54,41
0127E:  DATA 20,53
01280:  DATA 41,56
01282:  DATA 49,4E
01284:  DATA 47,20
01286:  DATA 46,41
01288:  DATA 49,4C
0128A:  DATA 55,52
0128C:  DATA 45,44
0128E:  DATA 0D,0A
01290:  DATA 00,00
01292:  DATA 43,41
01294:  DATA 4D,20
01296:  DATA 41,43
01298:  DATA 4B,20
0129A:  DATA 46,41
0129C:  DATA 49,4C
0129E:  DATA 55,52
012A0:  DATA 45,44
012A2:  DATA 0D,0A
012A4:  DATA 00,00
012A6:  DATA 54,75
012A8:  DATA 72,6E
012AA:  DATA 65,64
012AC:  DATA 20,4F
012AE:  DATA 46,46
012B0:  DATA 20,43
012B2:  DATA 41,4D
012B4:  DATA 0D,0A
012B6:  DATA 00,00
012B8:  DATA 4B,69
012BA:  DATA 6C,6C
012BC:  DATA 20,63
012BE:  DATA 6F,75
012C0:  DATA 6E,74
012C2:  DATA 65,72
012C4:  DATA 3A,20
012C6:  DATA 25,78
012C8:  DATA 0D,0A
012CA:  DATA 00,00
012CC:  DATA 4B,69
012CE:  DATA 6C,6C
012D0:  DATA 20,63
012D2:  DATA 6F,75
012D4:  DATA 6E,74
012D6:  DATA 65,72
012D8:  DATA 3A,20
012DA:  DATA 25,78
012DC:  DATA 0D,0A
012DE:  DATA 00,00
012E0:  DATA 73,65
012E2:  DATA 6E,64
012E4:  DATA 69,6E
012E6:  DATA 67,20
012E8:  DATA 42,43
012EA:  DATA 20,63
012EC:  DATA 6F,6D
012EE:  DATA 6D,61
012F0:  DATA 6E,64
012F2:  DATA 20,74
012F4:  DATA 6F,20
012F6:  DATA 52,45
012F8:  DATA 53,45
012FA:  DATA 54,20
012FC:  DATA 50,49
012FE:  DATA 43,0D
01300:  DATA 0A,00
01302:  DATA 48,53
01304:  DATA 53,43
01306:  DATA 20,44
01308:  DATA 4F,4E
0130A:  DATA 45,0D
0130C:  DATA 0A,00
0130E:  DATA 2C,41
01310:  DATA 55,54
01312:  DATA 4F,0D
01314:  DATA 0A,00
01316:  DATA 2C,4E
01318:  DATA 4F,52
0131A:  DATA 4D,41
0131C:  DATA 4C,0D
0131E:  DATA 0A,00
*
01536:  CLRF   01
01538:  CLRF   02
0153A:  CLRF   00
0153C:  CLRF   03
0153E:  MOVLB  3
01540:  MOVF   x87,W
01542:  BNZ   1548
01544:  MOVF   x86,W
01546:  BZ    1578
01548:  MOVLW  10
0154A:  MOVWF  x88
0154C:  BCF    FD8.0
0154E:  RLCF   x84,F
01550:  RLCF   x85,F
01552:  RLCF   00,F
01554:  RLCF   03,F
01556:  MOVF   x87,W
01558:  SUBWF  03,W
0155A:  BNZ   1560
0155C:  MOVF   x86,W
0155E:  SUBWF  00,W
01560:  BNC   1570
01562:  MOVF   x86,W
01564:  SUBWF  00,F
01566:  BTFSS  FD8.0
01568:  DECF   03,F
0156A:  MOVF   x87,W
0156C:  SUBWF  03,F
0156E:  BSF    FD8.0
01570:  RLCF   01,F
01572:  RLCF   02,F
01574:  DECFSZ x88,F
01576:  BRA    154C
01578:  MOVLB  0
0157A:  RETURN 0
*
01588:  DATA 53,65
0158A:  DATA 6E,74
0158C:  DATA 20,43
0158E:  DATA 4D,44
01590:  DATA 20,48
01592:  DATA 65,61
01594:  DATA 74,65
01596:  DATA 72,20
01598:  DATA 4F,4E
0159A:  DATA 0D,0A
0159C:  DATA 00,00
0159E:  DATA 53,65
015A0:  DATA 6E,74
015A2:  DATA 20,43
015A4:  DATA 4D,44
015A6:  DATA 20,48
015A8:  DATA 65,61
015AA:  DATA 74,65
015AC:  DATA 72,20
015AE:  DATA 4F,46
015B0:  DATA 46,0D
015B2:  DATA 0A,00
015B4:  DATA 53,65
015B6:  DATA 6E,74
015B8:  DATA 20,43
015BA:  DATA 4D,44
015BC:  DATA 20,48
015BE:  DATA 65,61
015C0:  DATA 74,65
015C2:  DATA 72,20
015C4:  DATA 41,55
015C6:  DATA 54,4F
015C8:  DATA 0D,0A
015CA:  DATA 00,00
015CC:  DATA 53,65
015CE:  DATA 6E,74
015D0:  DATA 20,43
015D2:  DATA 4D,44
015D4:  DATA 20,48
015D6:  DATA 65,61
015D8:  DATA 74,65
015DA:  DATA 72,20
015DC:  DATA 4F,4E
015DE:  DATA 0D,0A
015E0:  DATA 00,00
015E2:  DATA 53,65
015E4:  DATA 6E,74
015E6:  DATA 20,43
015E8:  DATA 4D,44
015EA:  DATA 20,48
015EC:  DATA 65,61
015EE:  DATA 74,65
015F0:  DATA 72,20
015F2:  DATA 4F,46
015F4:  DATA 46,0D
015F6:  DATA 0A,00
015F8:  DATA 53,65
015FA:  DATA 6E,74
015FC:  DATA 20,43
015FE:  DATA 4D,44
01600:  DATA 20,48
01602:  DATA 65,61
01604:  DATA 74,65
01606:  DATA 72,20
01608:  DATA 41,55
0160A:  DATA 54,4F
0160C:  DATA 0D,0A
0160E:  DATA 00,00
*
016BC:  MOVLB  3
016BE:  MOVF   x79,W
016C0:  CLRF   01
016C2:  SUBWF  x78,W
016C4:  BC    16CC
016C6:  MOVFF  378,00
016CA:  BRA    16E4
016CC:  CLRF   00
016CE:  MOVLW  08
016D0:  MOVWF  x7A
016D2:  RLCF   x78,F
016D4:  RLCF   00,F
016D6:  MOVF   x79,W
016D8:  SUBWF  00,W
016DA:  BTFSC  FD8.0
016DC:  MOVWF  00
016DE:  RLCF   01,F
016E0:  DECFSZ x7A,F
016E2:  BRA    16D2
016E4:  MOVLB  0
016E6:  RETURN 0
*
01762:  DATA 53,74
01764:  DATA 61,72
01766:  DATA 74,20
01768:  DATA 4F,70
0176A:  DATA 65,72
0176C:  DATA 61,74
0176E:  DATA 69,6E
01770:  DATA 67,0D
01772:  DATA 0A,00
01774:  DATA 0D,0A
01776:  DATA 43,57
01778:  DATA 3A,00
0177A:  DATA 0D,0A
0177C:  DATA 2A,2A
0177E:  DATA 2A,39
01780:  DATA 30,73
01782:  DATA 65,63
01784:  DATA 20,70
01786:  DATA 61,73
01788:  DATA 73,65
0178A:  DATA 64,2A
0178C:  DATA 2A,2A
0178E:  DATA 0D,0A
01790:  DATA 00,00
01792:  DATA 43,57
01794:  DATA 3A,00
01796:  DATA 45,78
01798:  DATA 65,63
0179A:  DATA 75,74
0179C:  DATA 65,20
0179E:  DATA 72,65
017A0:  DATA 73,65
017A2:  DATA 72,76
017A4:  DATA 65,64
017A6:  DATA 20,63
017A8:  DATA 6F,6D
017AA:  DATA 6D,61
017AC:  DATA 6E,64
017AE:  DATA 0D,0A
017B0:  DATA 00,00
017B2:  DATA 43,4F
017B4:  DATA 4D,20
017B6:  DATA 43,4F
017B8:  DATA 4D,4D
017BA:  DATA 41,4E
017BC:  DATA 44,3A
017BE:  DATA 0D,0A
017C0:  DATA 00,00
017C2:  DATA 43,4F
017C4:  DATA 4D,4D
017C6:  DATA 41,4E
017C8:  DATA 44,20
017CA:  DATA 52,45
017CC:  DATA 43,45
017CE:  DATA 49,56
017D0:  DATA 45,44
017D2:  DATA 20,46
017D4:  DATA 52,4F
017D6:  DATA 4D,20
017D8:  DATA 50,43
017DA:  DATA 3A,20
017DC:  DATA 00,00
*
01B08:  MOVLW  8E
01B0A:  MOVWF  00
01B0C:  MOVFF  347,01
01B10:  MOVFF  346,02
01B14:  CLRF   03
01B16:  BTFSS  01.7
01B18:  BRA    1B24
01B1A:  COMF   01,F
01B1C:  COMF   02,F
01B1E:  INCF   02,F
01B20:  BNZ   1B24
01B22:  INCF   01,F
01B24:  MOVF   01,F
01B26:  BNZ   1B3A
01B28:  MOVFF  02,01
01B2C:  CLRF   02
01B2E:  MOVLW  08
01B30:  SUBWF  00,F
01B32:  MOVF   01,F
01B34:  BNZ   1B3A
01B36:  CLRF   00
01B38:  BRA    1B56
01B3A:  BCF    FD8.0
01B3C:  BTFSC  01.7
01B3E:  BRA    1B48
01B40:  RLCF   02,F
01B42:  RLCF   01,F
01B44:  DECF   00,F
01B46:  BRA    1B3A
01B48:  MOVLB  3
01B4A:  BTFSS  x47.7
01B4C:  BRA    1B52
01B4E:  MOVLB  0
01B50:  BRA    1B56
01B52:  BCF    01.7
01B54:  MOVLB  0
01B56:  RETURN 0
01B58:  MOVLB  3
01B5A:  MOVF   x4E,W
01B5C:  BTFSC  FD8.2
01B5E:  BRA    1C42
01B60:  MOVWF  00
01B62:  MOVF   x52,W
01B64:  BTFSC  FD8.2
01B66:  BRA    1C42
01B68:  ADDWF  00,F
01B6A:  BNC   1B74
01B6C:  MOVLW  81
01B6E:  ADDWF  00,F
01B70:  BC    1C42
01B72:  BRA    1B7C
01B74:  MOVLW  7F
01B76:  SUBWF  00,F
01B78:  BNC   1C42
01B7A:  BZ    1C42
01B7C:  MOVFF  34F,356
01B80:  MOVF   x53,W
01B82:  XORWF  x56,F
01B84:  BSF    x4F.7
01B86:  BSF    x53.7
01B88:  MOVF   x51,W
01B8A:  MULWF  x55
01B8C:  MOVFF  FF4,358
01B90:  MOVF   x50,W
01B92:  MULWF  x54
01B94:  MOVFF  FF4,03
01B98:  MOVFF  FF3,357
01B9C:  MULWF  x55
01B9E:  MOVF   FF3,W
01BA0:  ADDWF  x58,F
01BA2:  MOVF   FF4,W
01BA4:  ADDWFC x57,F
01BA6:  MOVLW  00
01BA8:  ADDWFC 03,F
01BAA:  MOVF   x51,W
01BAC:  MULWF  x54
01BAE:  MOVF   FF3,W
01BB0:  ADDWF  x58,F
01BB2:  MOVF   FF4,W
01BB4:  ADDWFC x57,F
01BB6:  MOVLW  00
01BB8:  CLRF   02
01BBA:  ADDWFC 03,F
01BBC:  ADDWFC 02,F
01BBE:  MOVF   x4F,W
01BC0:  MULWF  x55
01BC2:  MOVF   FF3,W
01BC4:  ADDWF  x57,F
01BC6:  MOVF   FF4,W
01BC8:  ADDWFC 03,F
01BCA:  MOVLW  00
01BCC:  ADDWFC 02,F
01BCE:  MOVF   x4F,W
01BD0:  MULWF  x54
01BD2:  MOVF   FF3,W
01BD4:  ADDWF  03,F
01BD6:  MOVF   FF4,W
01BD8:  ADDWFC 02,F
01BDA:  MOVLW  00
01BDC:  CLRF   01
01BDE:  ADDWFC 01,F
01BE0:  MOVF   x51,W
01BE2:  MULWF  x53
01BE4:  MOVF   FF3,W
01BE6:  ADDWF  x57,F
01BE8:  MOVF   FF4,W
01BEA:  ADDWFC 03,F
01BEC:  MOVLW  00
01BEE:  ADDWFC 02,F
01BF0:  ADDWFC 01,F
01BF2:  MOVF   x50,W
01BF4:  MULWF  x53
01BF6:  MOVF   FF3,W
01BF8:  ADDWF  03,F
01BFA:  MOVF   FF4,W
01BFC:  ADDWFC 02,F
01BFE:  MOVLW  00
01C00:  ADDWFC 01,F
01C02:  MOVF   x4F,W
01C04:  MULWF  x53
01C06:  MOVF   FF3,W
01C08:  ADDWF  02,F
01C0A:  MOVF   FF4,W
01C0C:  ADDWFC 01,F
01C0E:  INCF   00,F
01C10:  BTFSC  01.7
01C12:  BRA    1C1E
01C14:  RLCF   x57,F
01C16:  RLCF   03,F
01C18:  RLCF   02,F
01C1A:  RLCF   01,F
01C1C:  DECF   00,F
01C1E:  MOVLW  00
01C20:  BTFSS  x57.7
01C22:  BRA    1C38
01C24:  INCF   03,F
01C26:  ADDWFC 02,F
01C28:  ADDWFC 01,F
01C2A:  MOVF   01,W
01C2C:  BNZ   1C38
01C2E:  MOVF   02,W
01C30:  BNZ   1C38
01C32:  MOVF   03,W
01C34:  BNZ   1C38
01C36:  INCF   00,F
01C38:  BTFSC  x56.7
01C3A:  BSF    01.7
01C3C:  BTFSS  x56.7
01C3E:  BCF    01.7
01C40:  BRA    1C4A
01C42:  CLRF   00
01C44:  CLRF   01
01C46:  CLRF   02
01C48:  CLRF   03
01C4A:  MOVLB  0
01C4C:  RETURN 0
01C4E:  MOVLW  80
01C50:  BTFSS  FD8.1
01C52:  BRA    1C58
01C54:  MOVLB  3
01C56:  XORWF  x4F,F
01C58:  MOVLB  3
01C5A:  CLRF   x54
01C5C:  CLRF   x55
01C5E:  MOVFF  34B,353
01C62:  MOVF   x4F,W
01C64:  XORWF  x53,F
01C66:  MOVF   x4A,W
01C68:  BTFSC  FD8.2
01C6A:  BRA    1E2A
01C6C:  MOVWF  x52
01C6E:  MOVWF  00
01C70:  MOVF   x4E,W
01C72:  BTFSC  FD8.2
01C74:  BRA    1E3C
01C76:  SUBWF  x52,F
01C78:  BTFSC  FD8.2
01C7A:  BRA    1D82
01C7C:  BNC   1CFA
01C7E:  MOVFF  34F,358
01C82:  BSF    x58.7
01C84:  MOVFF  350,357
01C88:  MOVFF  351,356
01C8C:  CLRF   x55
01C8E:  BCF    FD8.0
01C90:  RRCF   x58,F
01C92:  RRCF   x57,F
01C94:  RRCF   x56,F
01C96:  RRCF   x55,F
01C98:  DECFSZ x52,F
01C9A:  BRA    1C8C
01C9C:  BTFSS  x53.7
01C9E:  BRA    1CA6
01CA0:  BSF    x54.0
01CA2:  BRA    1E64
01CA4:  BCF    x54.0
01CA6:  BCF    x52.0
01CA8:  BSF    x54.4
01CAA:  MOVLW  03
01CAC:  MOVWF  FEA
01CAE:  MOVLW  4D
01CB0:  MOVWF  FE9
01CB2:  BRA    1E8A
01CB4:  BCF    x54.4
01CB6:  BTFSC  x53.7
01CB8:  BRA    1CCE
01CBA:  BTFSS  x52.0
01CBC:  BRA    1CE4
01CBE:  RRCF   x58,F
01CC0:  RRCF   x57,F
01CC2:  RRCF   x56,F
01CC4:  RRCF   x55,F
01CC6:  INCF   00,F
01CC8:  BTFSC  FD8.2
01CCA:  BRA    1E5A
01CCC:  BRA    1CE4
01CCE:  BTFSC  x58.7
01CD0:  BRA    1CEA
01CD2:  BCF    FD8.0
01CD4:  RLCF   x55,F
01CD6:  RLCF   x56,F
01CD8:  RLCF   x57,F
01CDA:  RLCF   x58,F
01CDC:  DECF   00,F
01CDE:  BTFSC  FD8.2
01CE0:  BRA    1E5A
01CE2:  BRA    1CCE
01CE4:  BSF    x54.6
01CE6:  BRA    1DC2
01CE8:  BCF    x54.6
01CEA:  MOVFF  34B,353
01CEE:  BTFSS  x4B.7
01CF0:  BRA    1CF6
01CF2:  BSF    x58.7
01CF4:  BRA    1E4C
01CF6:  BCF    x58.7
01CF8:  BRA    1E4C
01CFA:  MOVFF  34E,352
01CFE:  MOVFF  34E,00
01D02:  MOVF   x4A,W
01D04:  SUBWF  x52,F
01D06:  MOVFF  34B,358
01D0A:  BSF    x58.7
01D0C:  MOVFF  34C,357
01D10:  MOVFF  34D,356
01D14:  CLRF   x55
01D16:  BCF    FD8.0
01D18:  RRCF   x58,F
01D1A:  RRCF   x57,F
01D1C:  RRCF   x56,F
01D1E:  RRCF   x55,F
01D20:  DECFSZ x52,F
01D22:  BRA    1D14
01D24:  BTFSS  x53.7
01D26:  BRA    1D2E
01D28:  BSF    x54.1
01D2A:  BRA    1E64
01D2C:  BCF    x54.1
01D2E:  BCF    x52.0
01D30:  BSF    x54.5
01D32:  MOVLW  03
01D34:  MOVWF  FEA
01D36:  MOVLW  51
01D38:  MOVWF  FE9
01D3A:  BRA    1E8A
01D3C:  BCF    x54.5
01D3E:  BTFSC  x53.7
01D40:  BRA    1D56
01D42:  BTFSS  x52.0
01D44:  BRA    1D6C
01D46:  RRCF   x58,F
01D48:  RRCF   x57,F
01D4A:  RRCF   x56,F
01D4C:  RRCF   x55,F
01D4E:  INCF   00,F
01D50:  BTFSC  FD8.2
01D52:  BRA    1E5A
01D54:  BRA    1D6C
01D56:  BTFSC  x58.7
01D58:  BRA    1D72
01D5A:  BCF    FD8.0
01D5C:  RLCF   x55,F
01D5E:  RLCF   x56,F
01D60:  RLCF   x57,F
01D62:  RLCF   x58,F
01D64:  DECF   00,F
01D66:  BTFSC  FD8.2
01D68:  BRA    1E5A
01D6A:  BRA    1D56
01D6C:  BSF    x54.7
01D6E:  BRA    1DC2
01D70:  BCF    x54.7
01D72:  MOVFF  34F,353
01D76:  BTFSS  x4F.7
01D78:  BRA    1D7E
01D7A:  BSF    x58.7
01D7C:  BRA    1E4C
01D7E:  BCF    x58.7
01D80:  BRA    1E4C
01D82:  MOVFF  34F,358
01D86:  BSF    x58.7
01D88:  MOVFF  350,357
01D8C:  MOVFF  351,356
01D90:  BTFSS  x53.7
01D92:  BRA    1D9C
01D94:  BCF    x58.7
01D96:  BSF    x54.2
01D98:  BRA    1E64
01D9A:  BCF    x54.2
01D9C:  CLRF   x55
01D9E:  BCF    x52.0
01DA0:  MOVLW  03
01DA2:  MOVWF  FEA
01DA4:  MOVLW  4D
01DA6:  MOVWF  FE9
01DA8:  BRA    1E8A
01DAA:  BTFSC  x53.7
01DAC:  BRA    1DE6
01DAE:  MOVFF  34B,353
01DB2:  BTFSS  x52.0
01DB4:  BRA    1DC2
01DB6:  RRCF   x58,F
01DB8:  RRCF   x57,F
01DBA:  RRCF   x56,F
01DBC:  RRCF   x55,F
01DBE:  INCF   00,F
01DC0:  BZ    1E5A
01DC2:  BTFSS  x55.7
01DC4:  BRA    1DDC
01DC6:  INCF   x56,F
01DC8:  BNZ   1DDC
01DCA:  INCF   x57,F
01DCC:  BNZ   1DDC
01DCE:  INCF   x58,F
01DD0:  BNZ   1DDC
01DD2:  RRCF   x58,F
01DD4:  RRCF   x57,F
01DD6:  RRCF   x56,F
01DD8:  INCF   00,F
01DDA:  BZ    1E5A
01DDC:  BTFSC  x54.6
01DDE:  BRA    1CE8
01DE0:  BTFSC  x54.7
01DE2:  BRA    1D70
01DE4:  BRA    1E1E
01DE6:  MOVLW  80
01DE8:  XORWF  x58,F
01DEA:  BTFSS  x58.7
01DEC:  BRA    1DF6
01DEE:  BRA    1E64
01DF0:  MOVFF  34F,353
01DF4:  BRA    1E0A
01DF6:  MOVFF  34B,353
01DFA:  MOVF   x58,F
01DFC:  BNZ   1E0A
01DFE:  MOVF   x57,F
01E00:  BNZ   1E0A
01E02:  MOVF   x56,F
01E04:  BNZ   1E0A
01E06:  CLRF   00
01E08:  BRA    1E4C
01E0A:  BTFSC  x58.7
01E0C:  BRA    1E1E
01E0E:  BCF    FD8.0
01E10:  RLCF   x55,F
01E12:  RLCF   x56,F
01E14:  RLCF   x57,F
01E16:  RLCF   x58,F
01E18:  DECFSZ 00,F
01E1A:  BRA    1E0A
01E1C:  BRA    1E5A
01E1E:  BTFSS  x53.7
01E20:  BRA    1E26
01E22:  BSF    x58.7
01E24:  BRA    1E4C
01E26:  BCF    x58.7
01E28:  BRA    1E4C
01E2A:  MOVFF  34E,00
01E2E:  MOVFF  34F,358
01E32:  MOVFF  350,357
01E36:  MOVFF  351,356
01E3A:  BRA    1E4C
01E3C:  MOVFF  34A,00
01E40:  MOVFF  34B,358
01E44:  MOVFF  34C,357
01E48:  MOVFF  34D,356
01E4C:  MOVFF  358,01
01E50:  MOVFF  357,02
01E54:  MOVFF  356,03
01E58:  BRA    1EC2
01E5A:  CLRF   00
01E5C:  CLRF   01
01E5E:  CLRF   02
01E60:  CLRF   03
01E62:  BRA    1EC2
01E64:  CLRF   x55
01E66:  COMF   x56,F
01E68:  COMF   x57,F
01E6A:  COMF   x58,F
01E6C:  COMF   x55,F
01E6E:  INCF   x55,F
01E70:  BNZ   1E7C
01E72:  INCF   x56,F
01E74:  BNZ   1E7C
01E76:  INCF   x57,F
01E78:  BNZ   1E7C
01E7A:  INCF   x58,F
01E7C:  BTFSC  x54.0
01E7E:  BRA    1CA4
01E80:  BTFSC  x54.1
01E82:  BRA    1D2C
01E84:  BTFSC  x54.2
01E86:  BRA    1D9A
01E88:  BRA    1DF0
01E8A:  MOVF   FEF,W
01E8C:  ADDWF  x56,F
01E8E:  BNC   1E9A
01E90:  INCF   x57,F
01E92:  BNZ   1E9A
01E94:  INCF   x58,F
01E96:  BTFSC  FD8.2
01E98:  BSF    x52.0
01E9A:  MOVF   FED,F
01E9C:  MOVF   FEF,W
01E9E:  ADDWF  x57,F
01EA0:  BNC   1EA8
01EA2:  INCF   x58,F
01EA4:  BTFSC  FD8.2
01EA6:  BSF    x52.0
01EA8:  MOVF   FED,F
01EAA:  MOVF   FEF,W
01EAC:  BTFSC  FEF.7
01EAE:  BRA    1EB2
01EB0:  XORLW  80
01EB2:  ADDWF  x58,F
01EB4:  BTFSC  FD8.0
01EB6:  BSF    x52.0
01EB8:  BTFSC  x54.4
01EBA:  BRA    1CB4
01EBC:  BTFSC  x54.5
01EBE:  BRA    1D3C
01EC0:  BRA    1DAA
01EC2:  MOVLB  0
01EC4:  RETURN 0
01EC6:  MOVLW  8E
01EC8:  MOVWF  00
01ECA:  MOVLB  3
01ECC:  MOVF   x46,W
01ECE:  SUBWF  00,F
01ED0:  MOVFF  347,02
01ED4:  MOVFF  348,01
01ED8:  BSF    02.7
01EDA:  MOVF   00,F
01EDC:  BZ    1EF0
01EDE:  BCF    FD8.0
01EE0:  MOVF   02,F
01EE2:  BNZ   1EE8
01EE4:  MOVF   01,F
01EE6:  BZ    1EF0
01EE8:  RRCF   02,F
01EEA:  RRCF   01,F
01EEC:  DECFSZ 00,F
01EEE:  BRA    1EDE
01EF0:  BTFSS  x47.7
01EF2:  BRA    1EFE
01EF4:  COMF   01,F
01EF6:  COMF   02,F
01EF8:  INCF   01,F
01EFA:  BTFSC  FD8.2
01EFC:  INCF   02,F
01EFE:  MOVLB  0
01F00:  RETURN 0
01F02:  MOVLW  C0
01F04:  ANDWF  FF6,F
01F06:  MOVLW  3F
01F08:  MOVWF  00
01F0A:  TBLRD*
01F0C:  TBLWT*+
01F0E:  DECFSZ 00,F
01F10:  BRA    1F0A
01F12:  TBLRD*
01F14:  TBLWT*
01F16:  RETURN 0
01F18:  MOVF   FF2,W
01F1A:  MOVWF  03
01F1C:  BCF    FF2.7
01F1E:  BSF    F7F.2
01F20:  MOVLB  F
01F22:  MOVLW  55
01F24:  MOVWF  F7E
01F26:  MOVLW  AA
01F28:  MOVWF  F7E
01F2A:  BSF    F7F.1
01F2C:  NOP   
01F2E:  MOVF   03,W
01F30:  IORWF  FF2,F
01F32:  MOVLB  0
01F34:  RETURN 0
01F36:  MOVLW  8E
01F38:  MOVWF  00
01F3A:  MOVFF  342,01
01F3E:  MOVFF  341,02
01F42:  CLRF   03
01F44:  MOVF   01,F
01F46:  BNZ   1F5A
01F48:  MOVFF  02,01
01F4C:  CLRF   02
01F4E:  MOVLW  08
01F50:  SUBWF  00,F
01F52:  MOVF   01,F
01F54:  BNZ   1F5A
01F56:  CLRF   00
01F58:  BRA    1F6A
01F5A:  BCF    FD8.0
01F5C:  BTFSC  01.7
01F5E:  BRA    1F68
01F60:  RLCF   02,F
01F62:  RLCF   01,F
01F64:  DECF   00,F
01F66:  BRA    1F5A
01F68:  BCF    01.7
01F6A:  GOTO   1A012 (RETURN)
01F6E:  MOVLB  3
01F70:  MOVF   x45,W
01F72:  BTFSC  FD8.2
01F74:  BRA    20C0
01F76:  MOVWF  x51
01F78:  MOVF   x49,W
01F7A:  BTFSC  FD8.2
01F7C:  BRA    20C0
01F7E:  SUBWF  x51,F
01F80:  BNC   1F8C
01F82:  MOVLW  7F
01F84:  ADDWF  x51,F
01F86:  BTFSC  FD8.0
01F88:  BRA    20C0
01F8A:  BRA    1F98
01F8C:  MOVLW  81
01F8E:  SUBWF  x51,F
01F90:  BTFSS  FD8.0
01F92:  BRA    20C0
01F94:  BTFSC  FD8.2
01F96:  BRA    20C0
01F98:  MOVFF  351,00
01F9C:  CLRF   01
01F9E:  CLRF   02
01FA0:  CLRF   03
01FA2:  CLRF   x50
01FA4:  MOVFF  346,34F
01FA8:  BSF    x4F.7
01FAA:  MOVFF  347,34E
01FAE:  MOVFF  348,34D
01FB2:  MOVLW  19
01FB4:  MOVWF  x51
01FB6:  MOVF   x4C,W
01FB8:  SUBWF  x4D,F
01FBA:  BC    1FD6
01FBC:  MOVLW  01
01FBE:  SUBWF  x4E,F
01FC0:  BC    1FD6
01FC2:  SUBWF  x4F,F
01FC4:  BC    1FD6
01FC6:  SUBWF  x50,F
01FC8:  BC    1FD6
01FCA:  INCF   x50,F
01FCC:  INCF   x4F,F
01FCE:  INCF   x4E,F
01FD0:  MOVF   x4C,W
01FD2:  ADDWF  x4D,F
01FD4:  BRA    2026
01FD6:  MOVF   x4B,W
01FD8:  SUBWF  x4E,F
01FDA:  BC    2000
01FDC:  MOVLW  01
01FDE:  SUBWF  x4F,F
01FE0:  BC    2000
01FE2:  SUBWF  x50,F
01FE4:  BC    2000
01FE6:  INCF   x50,F
01FE8:  INCF   x4F,F
01FEA:  MOVF   x4B,W
01FEC:  ADDWF  x4E,F
01FEE:  MOVF   x4C,W
01FF0:  ADDWF  x4D,F
01FF2:  BNC   2026
01FF4:  INCF   x4E,F
01FF6:  BNZ   2026
01FF8:  INCF   x4F,F
01FFA:  BNZ   2026
01FFC:  INCF   x50,F
01FFE:  BRA    2026
02000:  MOVF   x4A,W
02002:  IORLW  80
02004:  SUBWF  x4F,F
02006:  BC    2024
02008:  MOVLW  01
0200A:  SUBWF  x50,F
0200C:  BC    2024
0200E:  INCF   x50,F
02010:  MOVF   x4A,W
02012:  IORLW  80
02014:  ADDWF  x4F,F
02016:  MOVF   x4B,W
02018:  ADDWF  x4E,F
0201A:  BNC   1FEE
0201C:  INCF   x4F,F
0201E:  BNZ   1FEE
02020:  INCF   x50,F
02022:  BRA    1FEE
02024:  BSF    03.0
02026:  DECFSZ x51,F
02028:  BRA    202C
0202A:  BRA    2042
0202C:  BCF    FD8.0
0202E:  RLCF   x4D,F
02030:  RLCF   x4E,F
02032:  RLCF   x4F,F
02034:  RLCF   x50,F
02036:  BCF    FD8.0
02038:  RLCF   03,F
0203A:  RLCF   02,F
0203C:  RLCF   01,F
0203E:  RLCF   x52,F
02040:  BRA    1FB6
02042:  BTFSS  x52.0
02044:  BRA    2052
02046:  BCF    FD8.0
02048:  RRCF   01,F
0204A:  RRCF   02,F
0204C:  RRCF   03,F
0204E:  RRCF   x52,F
02050:  BRA    2056
02052:  DECF   00,F
02054:  BZ    20C0
02056:  BTFSC  x52.7
02058:  BRA    2096
0205A:  BCF    FD8.0
0205C:  RLCF   x4D,F
0205E:  RLCF   x4E,F
02060:  RLCF   x4F,F
02062:  RLCF   x50,F
02064:  MOVF   x4C,W
02066:  SUBWF  x4D,F
02068:  BC    2078
0206A:  MOVLW  01
0206C:  SUBWF  x4E,F
0206E:  BC    2078
02070:  SUBWF  x4F,F
02072:  BC    2078
02074:  SUBWF  x50,F
02076:  BNC   20AC
02078:  MOVF   x4B,W
0207A:  SUBWF  x4E,F
0207C:  BC    2088
0207E:  MOVLW  01
02080:  SUBWF  x4F,F
02082:  BC    2088
02084:  SUBWF  x50,F
02086:  BNC   20AC
02088:  MOVF   x4A,W
0208A:  IORLW  80
0208C:  SUBWF  x4F,F
0208E:  BC    2096
02090:  MOVLW  01
02092:  SUBWF  x50,F
02094:  BNC   20AC
02096:  INCF   03,F
02098:  BNZ   20AC
0209A:  INCF   02,F
0209C:  BNZ   20AC
0209E:  INCF   01,F
020A0:  BNZ   20AC
020A2:  INCF   00,F
020A4:  BZ    20C0
020A6:  RRCF   01,F
020A8:  RRCF   02,F
020AA:  RRCF   03,F
020AC:  MOVFF  346,351
020B0:  MOVF   x4A,W
020B2:  XORWF  x51,F
020B4:  BTFSS  x51.7
020B6:  BRA    20BC
020B8:  BSF    01.7
020BA:  BRA    20C8
020BC:  BCF    01.7
020BE:  BRA    20C8
020C0:  CLRF   00
020C2:  CLRF   01
020C4:  CLRF   02
020C6:  CLRF   03
020C8:  MOVLB  0
020CA:  GOTO   1A07E (RETURN)
020CE:  MOVLB  3
020D0:  MOVF   x4E,W
020D2:  SUBLW  B6
020D4:  MOVWF  x4E
020D6:  CLRF   03
020D8:  MOVFF  34F,352
020DC:  BSF    x4F.7
020DE:  BCF    FD8.0
020E0:  RRCF   x4F,F
020E2:  RRCF   x50,F
020E4:  RRCF   x51,F
020E6:  RRCF   03,F
020E8:  RRCF   02,F
020EA:  RRCF   01,F
020EC:  RRCF   00,F
020EE:  DECFSZ x4E,F
020F0:  BRA    20DE
020F2:  BTFSS  x52.7
020F4:  BRA    210C
020F6:  COMF   00,F
020F8:  COMF   01,F
020FA:  COMF   02,F
020FC:  COMF   03,F
020FE:  INCF   00,F
02100:  BTFSC  FD8.2
02102:  INCF   01,F
02104:  BTFSC  FD8.2
02106:  INCF   02,F
02108:  BTFSC  FD8.2
0210A:  INCF   03,F
0210C:  MOVLB  0
0210E:  GOTO   21FC (RETURN)
02112:  BTFSC  FD8.1
02114:  BRA    211E
02116:  MOVLW  03
02118:  MOVWF  FEA
0211A:  MOVLW  56
0211C:  MOVWF  FE9
0211E:  CLRF   00
02120:  CLRF   01
02122:  CLRF   02
02124:  CLRF   03
02126:  MOVLB  3
02128:  CLRF   x56
0212A:  CLRF   x57
0212C:  CLRF   x58
0212E:  CLRF   x59
02130:  MOVF   x55,W
02132:  IORWF  x54,W
02134:  IORWF  x53,W
02136:  IORWF  x52,W
02138:  BZ    2192
0213A:  MOVLW  20
0213C:  MOVWF  x5A
0213E:  BCF    FD8.0
02140:  RLCF   x4E,F
02142:  RLCF   x4F,F
02144:  RLCF   x50,F
02146:  RLCF   x51,F
02148:  RLCF   x56,F
0214A:  RLCF   x57,F
0214C:  RLCF   x58,F
0214E:  RLCF   x59,F
02150:  MOVF   x55,W
02152:  SUBWF  x59,W
02154:  BNZ   2166
02156:  MOVF   x54,W
02158:  SUBWF  x58,W
0215A:  BNZ   2166
0215C:  MOVF   x53,W
0215E:  SUBWF  x57,W
02160:  BNZ   2166
02162:  MOVF   x52,W
02164:  SUBWF  x56,W
02166:  BNC   2186
02168:  MOVF   x52,W
0216A:  SUBWF  x56,F
0216C:  MOVF   x53,W
0216E:  BTFSS  FD8.0
02170:  INCFSZ x53,W
02172:  SUBWF  x57,F
02174:  MOVF   x54,W
02176:  BTFSS  FD8.0
02178:  INCFSZ x54,W
0217A:  SUBWF  x58,F
0217C:  MOVF   x55,W
0217E:  BTFSS  FD8.0
02180:  INCFSZ x55,W
02182:  SUBWF  x59,F
02184:  BSF    FD8.0
02186:  RLCF   00,F
02188:  RLCF   01,F
0218A:  RLCF   02,F
0218C:  RLCF   03,F
0218E:  DECFSZ x5A,F
02190:  BRA    213E
02192:  MOVFF  356,FEF
02196:  MOVFF  357,FEC
0219A:  MOVFF  358,FEC
0219E:  MOVFF  359,FEC
021A2:  MOVLB  0
021A4:  RETURN 0
021A6:  MOVF   FE9,W
021A8:  MOVLB  3
021AA:  MOVWF  x46
021AC:  MOVF   x45,W
021AE:  MOVWF  x48
021B0:  BZ    21E8
021B2:  MOVFF  344,351
021B6:  MOVFF  343,350
021BA:  MOVFF  342,34F
021BE:  MOVFF  341,34E
021C2:  CLRF   x55
021C4:  CLRF   x54
021C6:  MOVLW  20
021C8:  MOVWF  x53
021CA:  MOVLW  82
021CC:  MOVWF  x52
021CE:  MOVLB  0
021D0:  RCALL  1B58
021D2:  MOVFF  03,344
021D6:  MOVFF  02,343
021DA:  MOVFF  01,342
021DE:  MOVFF  00,341
021E2:  MOVLB  3
021E4:  DECFSZ x48,F
021E6:  BRA    21B2
021E8:  MOVFF  344,351
021EC:  MOVFF  343,350
021F0:  MOVFF  342,34F
021F4:  MOVFF  341,34E
021F8:  MOVLB  0
021FA:  BRA    20CE
021FC:  MOVFF  03,344
02200:  MOVFF  02,343
02204:  MOVFF  01,342
02208:  MOVFF  00,341
0220C:  MOVLB  3
0220E:  BTFSS  x44.7
02210:  BRA    222C
02212:  DECF   x46,F
02214:  BSF    x46.5
02216:  COMF   x41,F
02218:  COMF   x42,F
0221A:  COMF   x43,F
0221C:  COMF   x44,F
0221E:  INCF   x41,F
02220:  BTFSC  FD8.2
02222:  INCF   x42,F
02224:  BTFSC  FD8.2
02226:  INCF   x43,F
02228:  BTFSC  FD8.2
0222A:  INCF   x44,F
0222C:  MOVLW  3B
0222E:  MOVWF  x4D
02230:  MOVLW  9A
02232:  MOVWF  x4C
02234:  MOVLW  CA
02236:  MOVWF  x4B
02238:  CLRF   x4A
0223A:  MOVLW  0A
0223C:  MOVWF  x48
0223E:  MOVF   x45,W
02240:  BTFSC  FD8.2
02242:  INCF   x46,F
02244:  BSF    FD8.1
02246:  MOVLW  03
02248:  MOVWF  FEA
0224A:  MOVLW  41
0224C:  MOVWF  FE9
0224E:  MOVFF  344,351
02252:  MOVFF  343,350
02256:  MOVFF  342,34F
0225A:  MOVFF  341,34E
0225E:  MOVFF  34D,355
02262:  MOVFF  34C,354
02266:  MOVFF  34B,353
0226A:  MOVFF  34A,352
0226E:  MOVLB  0
02270:  RCALL  2112
02272:  MOVF   01,W
02274:  MOVF   00,F
02276:  BNZ   229E
02278:  MOVLB  3
0227A:  INCF   x45,W
0227C:  SUBWF  x48,W
0227E:  BTFSS  FD8.2
02280:  BRA    2286
02282:  MOVLB  0
02284:  BRA    229E
02286:  MOVF   x46,W
02288:  BZ    22A4
0228A:  ANDLW  0F
0228C:  SUBWF  x48,W
0228E:  BZ    2292
02290:  BC    230A
02292:  BTFSC  x46.7
02294:  BRA    230A
02296:  BTFSC  x46.6
02298:  BRA    22A4
0229A:  MOVLW  20
0229C:  BRA    2300
0229E:  MOVLW  20
022A0:  MOVLB  3
022A2:  ANDWF  x46,F
022A4:  BTFSS  x46.5
022A6:  BRA    22C2
022A8:  BCF    x46.5
022AA:  MOVF   x45,W
022AC:  BTFSS  FD8.2
022AE:  DECF   x46,F
022B0:  MOVF   00,W
022B2:  MOVWF  x46
022B4:  MOVLW  2D
022B6:  BTFSS  F9E.4
022B8:  BRA    22B6
022BA:  MOVWF  FAD
022BC:  MOVF   x46,W
022BE:  MOVWF  00
022C0:  CLRF   x46
022C2:  MOVF   x45,W
022C4:  SUBWF  x48,W
022C6:  BNZ   22DE
022C8:  MOVF   00,W
022CA:  MOVWF  x46
022CC:  MOVLW  2E
022CE:  BTFSS  F9E.4
022D0:  BRA    22CE
022D2:  MOVWF  FAD
022D4:  MOVF   x46,W
022D6:  MOVWF  00
022D8:  MOVLW  20
022DA:  ANDWF  x46,F
022DC:  MOVLW  00
022DE:  MOVLW  30
022E0:  BTFSS  x46.5
022E2:  BRA    2300
022E4:  BCF    x46.5
022E6:  MOVF   x45,W
022E8:  BTFSS  FD8.2
022EA:  DECF   x46,F
022EC:  MOVF   00,W
022EE:  MOVWF  x46
022F0:  MOVLW  2D
022F2:  BTFSS  F9E.4
022F4:  BRA    22F2
022F6:  MOVWF  FAD
022F8:  MOVF   x46,W
022FA:  MOVWF  00
022FC:  CLRF   x46
022FE:  MOVLW  30
02300:  ADDWF  00,F
02302:  MOVF   00,W
02304:  BTFSS  F9E.4
02306:  BRA    2304
02308:  MOVWF  FAD
0230A:  BCF    FD8.1
0230C:  MOVFF  34D,351
02310:  MOVFF  34C,350
02314:  MOVFF  34B,34F
02318:  MOVFF  34A,34E
0231C:  CLRF   x55
0231E:  CLRF   x54
02320:  CLRF   x53
02322:  MOVLW  0A
02324:  MOVWF  x52
02326:  MOVLB  0
02328:  RCALL  2112
0232A:  MOVFF  03,34D
0232E:  MOVFF  02,34C
02332:  MOVFF  01,34B
02336:  MOVFF  00,34A
0233A:  MOVLB  3
0233C:  DECFSZ x48,F
0233E:  BRA    2244
02340:  MOVLB  0
02342:  RETURN 0
02344:  MOVFF  346,34D
02348:  MOVLB  3
0234A:  MOVF   x4A,W
0234C:  XORWF  x4D,F
0234E:  BTFSS  x4D.7
02350:  BRA    235C
02352:  BCF    FD8.2
02354:  BCF    FD8.0
02356:  BTFSC  x46.7
02358:  BSF    FD8.0
0235A:  BRA    23BA
0235C:  MOVFF  346,34D
02360:  MOVFF  349,34E
02364:  MOVF   x45,W
02366:  SUBWF  x4E,F
02368:  BZ    2376
0236A:  BTFSS  x4D.7
0236C:  BRA    23BA
0236E:  MOVF   FD8,W
02370:  XORLW  01
02372:  MOVWF  FD8
02374:  BRA    23BA
02376:  MOVFF  34A,34E
0237A:  MOVF   x46,W
0237C:  SUBWF  x4E,F
0237E:  BZ    238C
02380:  BTFSS  x4D.7
02382:  BRA    23BA
02384:  MOVF   FD8,W
02386:  XORLW  01
02388:  MOVWF  FD8
0238A:  BRA    23BA
0238C:  MOVFF  34B,34E
02390:  MOVF   x47,W
02392:  SUBWF  x4E,F
02394:  BZ    23A2
02396:  BTFSS  x4D.7
02398:  BRA    23BA
0239A:  MOVF   FD8,W
0239C:  XORLW  01
0239E:  MOVWF  FD8
023A0:  BRA    23BA
023A2:  MOVFF  34C,34E
023A6:  MOVF   x48,W
023A8:  SUBWF  x4E,F
023AA:  BZ    23B8
023AC:  BTFSS  x4D.7
023AE:  BRA    23BA
023B0:  MOVF   FD8,W
023B2:  XORLW  01
023B4:  MOVWF  FD8
023B6:  BRA    23BA
023B8:  BCF    FD8.0
023BA:  MOVLB  0
023BC:  RETURN 0
*
02404:  MOVLW  20
02406:  MOVLB  3
02408:  BTFSS  x3F.4
0240A:  MOVLW  30
0240C:  MOVWF  x40
0240E:  MOVFF  33E,00
02412:  BTFSS  x3E.7
02414:  BRA    2426
02416:  COMF   00,F
02418:  INCF   00,F
0241A:  MOVFF  00,33E
0241E:  MOVLW  2D
02420:  MOVWF  x40
02422:  BSF    x3F.7
02424:  BSF    x3F.0
02426:  MOVF   01,W
02428:  CLRF   1B
0242A:  BTFSC  FF2.7
0242C:  BSF    1B.7
0242E:  BCF    FF2.7
02430:  MOVFF  33E,378
02434:  MOVLW  64
02436:  MOVWF  x79
02438:  MOVLB  0
0243A:  CALL   16BC
0243E:  BTFSC  1B.7
02440:  BSF    FF2.7
02442:  MOVFF  00,33E
02446:  MOVLW  30
02448:  ADDWF  01,W
0244A:  MOVLB  3
0244C:  MOVWF  x41
0244E:  CLRF   1B
02450:  BTFSC  FF2.7
02452:  BSF    1B.7
02454:  BCF    FF2.7
02456:  MOVFF  33E,378
0245A:  MOVLW  0A
0245C:  MOVWF  x79
0245E:  MOVLB  0
02460:  CALL   16BC
02464:  BTFSC  1B.7
02466:  BSF    FF2.7
02468:  MOVLW  30
0246A:  ADDWF  00,W
0246C:  MOVLB  3
0246E:  MOVWF  x43
02470:  MOVLW  30
02472:  ADDWF  01,W
02474:  MOVWF  x42
02476:  MOVFF  340,00
0247A:  MOVLW  30
0247C:  SUBWF  x41,W
0247E:  BZ    2488
02480:  BSF    x3F.1
02482:  BTFSC  x3F.7
02484:  BSF    x3F.2
02486:  BRA    24AC
02488:  MOVFF  340,341
0248C:  MOVLW  20
0248E:  MOVWF  x40
02490:  MOVLW  30
02492:  SUBWF  x42,W
02494:  BZ    249E
02496:  BSF    x3F.0
02498:  BTFSC  x3F.7
0249A:  BSF    x3F.1
0249C:  BRA    24AC
0249E:  BTFSS  FD8.2
024A0:  BSF    x3F.0
024A2:  BNZ   24AC
024A4:  MOVFF  341,342
024A8:  MOVLW  20
024AA:  MOVWF  x41
024AC:  BTFSC  x3F.2
024AE:  BRA    24BA
024B0:  BTFSC  x3F.1
024B2:  BRA    24C2
024B4:  BTFSC  x3F.0
024B6:  BRA    24CA
024B8:  BRA    24D2
024BA:  MOVF   x40,W
024BC:  BTFSS  F9E.4
024BE:  BRA    24BC
024C0:  MOVWF  FAD
024C2:  MOVF   x41,W
024C4:  BTFSS  F9E.4
024C6:  BRA    24C4
024C8:  MOVWF  FAD
024CA:  MOVF   x42,W
024CC:  BTFSS  F9E.4
024CE:  BRA    24CC
024D0:  MOVWF  FAD
024D2:  MOVF   x43,W
024D4:  BTFSS  F9E.4
024D6:  BRA    24D4
024D8:  MOVWF  FAD
024DA:  MOVLB  0
024DC:  RETURN 0
024DE:  MOVLB  3
024E0:  CLRF   x3C
024E2:  CLRF   x3D
024E4:  MOVLW  01
024E6:  MOVWF  x3E
024E8:  CLRF   FDA
024EA:  CLRF   FD9
024EC:  MOVLW  03
024EE:  MOVWF  x41
024F0:  MOVLW  34
024F2:  MOVWF  x40
024F4:  MOVLW  03
024F6:  MOVWF  FEA
024F8:  MOVLW  38
024FA:  MOVWF  FE9
024FC:  MOVFF  341,FE2
02500:  MOVFF  340,FE1
02504:  MOVFF  33E,33F
02508:  BCF    FD8.0
0250A:  MOVF   FE5,W
0250C:  MULWF  FEE
0250E:  MOVF   FF3,W
02510:  ADDWFC x3C,F
02512:  MOVF   FF4,W
02514:  ADDWFC x3D,F
02516:  DECFSZ x3F,F
02518:  BRA    2508
0251A:  MOVFF  33C,FDE
0251E:  MOVFF  33D,33C
02522:  CLRF   x3D
02524:  BTFSC  FD8.0
02526:  INCF   x3D,F
02528:  INCF   x40,F
0252A:  BTFSC  FD8.2
0252C:  INCF   x41,F
0252E:  INCF   x3E,F
02530:  MOVF   x3E,W
02532:  SUBLW  05
02534:  BNZ   24F4
02536:  MOVLB  0
02538:  RETURN 0
0253A:  MOVLB  3
0253C:  MOVF   x42,W
0253E:  MULWF  x44
02540:  MOVFF  FF3,01
02544:  MOVFF  FF4,00
02548:  MULWF  x45
0254A:  MOVF   FF3,W
0254C:  ADDWF  00,F
0254E:  MOVF   x43,W
02550:  MULWF  x44
02552:  MOVF   FF3,W
02554:  ADDWFC 00,W
02556:  MOVWF  02
02558:  MOVLB  0
0255A:  RETURN 0
*
02582:  ADDWF  FE8,W
02584:  CLRF   FF7
02586:  RLCF   FF7,F
02588:  ADDLW  A3
0258A:  MOVWF  FF6
0258C:  MOVLW  25
0258E:  ADDWFC FF7,F
02590:  MOVLW  00
02592:  MOVWF  FF8
02594:  MOVWF  FFB
02596:  TBLRD*-
02598:  MOVF   FF5,W
0259A:  MOVWF  FFA
0259C:  TBLRD*
0259E:  MOVF   FF5,W
025A0:  MOVWF  FF9
025A2:  DATA F0,B0
025A4:  DATA F8,B0
025A6:  DATA 00,B1
025A8:  DATA 08,B1
025AA:  DATA 10,B1
025AC:  DATA 18,B1
025AE:  DATA 20,B1
025B0:  DATA 28,B1
025B2:  DATA 30,B1
025B4:  DATA 38,B1
025B6:  DATA 40,B1
025B8:  DATA 48,B1
025BA:  DATA 50,B1
025BC:  DATA 58,B1
025BE:  DATA 60,B1
025C0:  MOVFF  FEA,353
025C4:  MOVFF  FE9,352
025C8:  MOVLB  3
025CA:  BTFSS  x4C.7
025CC:  BRA    25DE
025CE:  BSF    x52.7
025D0:  BTFSS  x52.4
025D2:  INCF   x52,F
025D4:  COMF   x4B,F
025D6:  COMF   x4C,F
025D8:  INCF   x4B,F
025DA:  BTFSC  FD8.2
025DC:  INCF   x4C,F
025DE:  SWAPF  x4C,W
025E0:  IORLW  F0
025E2:  MOVWF  x4E
025E4:  ADDWF  x4E,F
025E6:  ADDLW  E2
025E8:  MOVWF  x4F
025EA:  ADDLW  32
025EC:  MOVWF  x51
025EE:  MOVF   x4C,W
025F0:  ANDLW  0F
025F2:  ADDWF  x4F,F
025F4:  ADDWF  x4F,F
025F6:  ADDWF  x51,F
025F8:  ADDLW  E9
025FA:  MOVWF  x50
025FC:  ADDWF  x50,F
025FE:  ADDWF  x50,F
02600:  SWAPF  x4B,W
02602:  ANDLW  0F
02604:  ADDWF  x50,F
02606:  ADDWF  x51,F
02608:  RLCF   x50,F
0260A:  RLCF   x51,F
0260C:  COMF   x51,F
0260E:  RLCF   x51,F
02610:  MOVF   x4B,W
02612:  ANDLW  0F
02614:  ADDWF  x51,F
02616:  RLCF   x4E,F
02618:  MOVLW  07
0261A:  MOVWF  x4D
0261C:  MOVLW  0A
0261E:  DECF   x50,F
02620:  ADDWF  x51,F
02622:  BNC   261E
02624:  DECF   x4F,F
02626:  ADDWF  x50,F
02628:  BNC   2624
0262A:  DECF   x4E,F
0262C:  ADDWF  x4F,F
0262E:  BNC   262A
02630:  DECF   x4D,F
02632:  ADDWF  x4E,F
02634:  BNC   2630
02636:  MOVLW  03
02638:  MOVWF  FEA
0263A:  MOVLW  4D
0263C:  MOVWF  FE9
0263E:  MOVLW  07
02640:  ANDWF  x52,W
02642:  BCF    x52.6
02644:  MOVF   FED,F
02646:  ANDWF  x52,W
02648:  BNZ   2658
0264A:  BTFSC  x52.4
0264C:  MOVF   FEE,F
0264E:  BTFSC  x52.4
02650:  BRA    2658
02652:  MOVLW  20
02654:  MOVWF  00
02656:  BRA    269A
02658:  ADDWF  FE9,F
0265A:  MOVLW  00
0265C:  ADDWFC FEA,F
0265E:  MOVF   FE9,W
02660:  SUBLW  51
02662:  BNZ   266C
02664:  MOVF   FEA,W
02666:  SUBLW  03
02668:  BNZ   266C
0266A:  BSF    x52.6
0266C:  MOVF   FEF,W
0266E:  MOVWF  00
02670:  BNZ   2682
02672:  BTFSC  x52.6
02674:  BRA    2682
02676:  BTFSC  x52.4
02678:  BRA    26A2
0267A:  BTFSC  x52.3
0267C:  BRA    2682
0267E:  MOVLW  20
02680:  BRA    2698
02682:  BTFSS  x52.7
02684:  BRA    2692
02686:  MOVLW  2D
02688:  MOVWF  00
0268A:  MOVF   FED,W
0268C:  BCF    x52.6
0268E:  BCF    x52.7
02690:  BRA    269A
02692:  BSF    x52.3
02694:  BCF    x52.4
02696:  MOVLW  30
02698:  ADDWF  00,F
0269A:  MOVF   00,W
0269C:  BTFSS  F9E.4
0269E:  BRA    269C
026A0:  MOVWF  FAD
026A2:  MOVF   FEE,W
026A4:  BTFSS  x52.6
026A6:  BRA    265E
026A8:  MOVLB  0
026AA:  GOTO   138B4 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
.................... #FUSES NOWDT, NOBROWNOUT, NOPROTECT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
0063E:  MOVLW  03
00640:  MOVWF  FEA
00642:  MOVLW  98
00644:  MOVWF  FE9
00646:  MOVF   FEF,W
00648:  BZ    0666
0064A:  MOVLW  05
0064C:  MOVWF  01
0064E:  CLRF   00
00650:  DECFSZ 00,F
00652:  BRA    0650
00654:  DECFSZ 01,F
00656:  BRA    064E
00658:  MOVLW  2E
0065A:  MOVWF  00
0065C:  DECFSZ 00,F
0065E:  BRA    065C
00660:  BRA    0662
00662:  DECFSZ FEF,F
00664:  BRA    064A
00666:  RETURN 0
.................... #build(reset=0x2:0x9, interrupt=0xa:0xa+9) 
....................  
.................... //#include<HAMING_CORRECT.h> 
....................      
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------- 
....................  
.................... #pin_select TX1=PIN_C6                                                           //TX PIN EXT +/- 6v 
.................... #pin_select RX1=PIN_C7                                                           //RX PIN EXT +/- 6V 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc)                          // MAIN to Ext +/- 6v 
*
001D2:  BTFSS  F9E.4
001D4:  BRA    01D2
001D6:  MOVWF  FAD
001D8:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_B6,rcv=PIN_B7,bits=8,stream=pc)           //UART MAIN to ICSP, PGC and PGD pins 
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com)                           //UART Main to COM PIC 
*
019D6:  BTFSS  FA4.4
019D8:  BRA    19D6
019DA:  MOVLB  F
019DC:  MOVWF  x1D
019DE:  MOVLB  0
019E0:  RETURN 0
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab)                           //UART MAIN to FAB PIC 
*
01A84:  BTFSS  FA6.4
01A86:  BRA    1A84
01A88:  MOVLB  F
01A8A:  MOVWF  x29
01A8C:  MOVLB  0
01A8E:  RETURN 0
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset)                         //UART MAIN to RESET PIC 
*
0157C:  BTFSS  FA6.6
0157E:  BRA    157C
01580:  MOVLB  E
01582:  MOVWF  xF9
01584:  MOVLB  0
01586:  RETURN 0
....................  
.................... #use rs232(baud=9600,parity=N,xmit=pin_F7,rcv=pin_F6,bits=8,stream=ADCS)         //UART MAIN to ADCS 
*
014A6:  BCF    F97.7
014A8:  BCF    F8E.7
014AA:  MOVLW  08
014AC:  MOVWF  01
014AE:  BRA    14B0
014B0:  NOP   
014B2:  BSF    01.7
014B4:  BRA    14D6
014B6:  BCF    01.7
014B8:  MOVLB  3
014BA:  RRCF   x84,F
014BC:  MOVLB  0
014BE:  BTFSC  FD8.0
014C0:  BSF    F8E.7
014C2:  BTFSS  FD8.0
014C4:  BCF    F8E.7
014C6:  BSF    01.6
014C8:  BRA    14D6
014CA:  BCF    01.6
014CC:  DECFSZ 01,F
014CE:  BRA    14B8
014D0:  BRA    14D2
014D2:  NOP   
014D4:  BSF    F8E.7
014D6:  MOVLW  84
014D8:  MOVWF  FE9
014DA:  DECFSZ FE9,F
014DC:  BRA    14DA
014DE:  BRA    14E0
014E0:  NOP   
014E2:  BTFSC  01.7
014E4:  BRA    14B6
014E6:  BTFSC  01.6
014E8:  BRA    14CA
014EA:  RETURN 0
014EC:  BSF    F97.6
014EE:  BTFSC  F85.6
014F0:  BRA    14EE
014F2:  MOVLW  08
014F4:  MOVWF  00
014F6:  MOVLB  3
014F8:  CLRF   x88
014FA:  BSF    00.7
014FC:  BRA    151A
014FE:  BCF    00.7
01500:  BRA    151A
01502:  BCF    FD8.0
01504:  BTFSC  F85.6
01506:  BSF    FD8.0
01508:  RRCF   x88,F
0150A:  BSF    00.6
0150C:  BRA    151A
0150E:  BCF    00.6
01510:  DECFSZ 00,F
01512:  BRA    1502
01514:  MOVFF  388,01
01518:  BRA    1532
0151A:  MOVLW  84
0151C:  BTFSC  00.7
0151E:  MOVLW  24
01520:  MOVWF  01
01522:  DECFSZ 01,F
01524:  BRA    1522
01526:  BRA    1528
01528:  BTFSC  00.7
0152A:  BRA    14FE
0152C:  BTFSC  00.6
0152E:  BRA    150E
01530:  BRA    1502
01532:  MOVLB  0
01534:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=CAM)          //UART MAIN to CAM 
*
01094:  BSF    F98.3
01096:  BTFSC  F86.3
01098:  BRA    1096
0109A:  MOVLW  08
0109C:  MOVWF  00
0109E:  MOVLB  3
010A0:  CLRF   x81
010A2:  BSF    00.7
010A4:  BRA    10C2
010A6:  BCF    00.7
010A8:  BRA    10C2
010AA:  BCF    FD8.0
010AC:  BTFSC  F86.3
010AE:  BSF    FD8.0
010B0:  RRCF   x81,F
010B2:  BSF    00.6
010B4:  BRA    10C2
010B6:  BCF    00.6
010B8:  DECFSZ 00,F
010BA:  BRA    10AA
010BC:  MOVFF  381,01
010C0:  BRA    10DA
010C2:  MOVLW  84
010C4:  BTFSC  00.7
010C6:  MOVLW  24
010C8:  MOVWF  01
010CA:  DECFSZ 01,F
010CC:  BRA    10CA
010CE:  BRA    10D0
010D0:  BTFSC  00.7
010D2:  BRA    10A6
010D4:  BTFSC  00.6
010D6:  BRA    10B6
010D8:  BRA    10AA
010DA:  MOVLB  0
010DC:  RETURN 0
*
023BE:  BCF    F98.2
023C0:  BCF    F8F.2
023C2:  MOVLW  08
023C4:  MOVWF  01
023C6:  BRA    23C8
023C8:  NOP   
023CA:  BSF    01.7
023CC:  BRA    23EE
023CE:  BCF    01.7
023D0:  MOVLB  3
023D2:  RRCF   x39,F
023D4:  MOVLB  0
023D6:  BTFSC  FD8.0
023D8:  BSF    F8F.2
023DA:  BTFSS  FD8.0
023DC:  BCF    F8F.2
023DE:  BSF    01.6
023E0:  BRA    23EE
023E2:  BCF    01.6
023E4:  DECFSZ 01,F
023E6:  BRA    23D0
023E8:  BRA    23EA
023EA:  NOP   
023EC:  BSF    F8F.2
023EE:  MOVLW  84
023F0:  MOVWF  FE9
023F2:  DECFSZ FE9,F
023F4:  BRA    23F2
023F6:  BRA    23F8
023F8:  NOP   
023FA:  BTFSC  01.7
023FC:  BRA    23CE
023FE:  BTFSC  01.6
02400:  BRA    23E2
02402:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC)          //UART MAIN to MB DCM 
*
019E2:  BCF    F98.0
019E4:  BCF    F8F.0
019E6:  MOVLW  08
019E8:  MOVWF  01
019EA:  BRA    19EC
019EC:  NOP   
019EE:  BSF    01.7
019F0:  BRA    1A12
019F2:  BCF    01.7
019F4:  MOVLB  3
019F6:  RRCF   x4F,F
019F8:  MOVLB  0
019FA:  BTFSC  FD8.0
019FC:  BSF    F8F.0
019FE:  BTFSS  FD8.0
01A00:  BCF    F8F.0
01A02:  BSF    01.6
01A04:  BRA    1A12
01A06:  BCF    01.6
01A08:  DECFSZ 01,F
01A0A:  BRA    19F4
01A0C:  BRA    1A0E
01A0E:  NOP   
01A10:  BSF    F8F.0
01A12:  MOVLW  84
01A14:  MOVWF  FE9
01A16:  DECFSZ FE9,F
01A18:  BRA    1A16
01A1A:  BRA    1A1C
01A1C:  NOP   
01A1E:  BTFSC  01.7
01A20:  BRA    19F2
01A22:  BTFSC  01.6
01A24:  BRA    1A06
01A26:  RETURN 0
01A28:  BSF    F98.1
01A2A:  BTFSC  F86.1
01A2C:  BRA    1A2A
01A2E:  MOVLW  08
01A30:  MOVWF  00
01A32:  MOVLB  3
01A34:  CLRF   x53
01A36:  BSF    00.7
01A38:  BRA    1A56
01A3A:  BCF    00.7
01A3C:  BRA    1A56
01A3E:  BCF    FD8.0
01A40:  BTFSC  F86.1
01A42:  BSF    FD8.0
01A44:  RRCF   x53,F
01A46:  BSF    00.6
01A48:  BRA    1A56
01A4A:  BCF    00.6
01A4C:  DECFSZ 00,F
01A4E:  BRA    1A3E
01A50:  MOVFF  353,01
01A54:  BRA    1A6E
01A56:  MOVLW  84
01A58:  BTFSC  00.7
01A5A:  MOVLW  24
01A5C:  MOVWF  01
01A5E:  DECFSZ 01,F
01A60:  BRA    1A5E
01A62:  BRA    1A64
01A64:  BTFSC  00.7
01A66:  BRA    1A3A
01A68:  BTFSC  00.6
01A6A:  BRA    1A4A
01A6C:  BRA    1A3E
01A6E:  MOVLB  0
01A70:  RETURN 0
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0)        //MAIN flash memory port 
*
00602:  MOVLB  3
00604:  MOVF   xB2,W
00606:  SUBLW  08
00608:  BZ    0612
0060A:  MOVWF  xB3
0060C:  RLCF   xB1,F
0060E:  DECFSZ xB3,F
00610:  BRA    060C
00612:  BSF    F96.0
00614:  BCF    F96.6
00616:  BCF    F96.1
00618:  BCF    F8D.1
0061A:  MOVFF  3B2,3B3
0061E:  BTFSS  xB1.7
00620:  BCF    F8D.6
00622:  BTFSC  xB1.7
00624:  BSF    F8D.6
00626:  RLCF   xB1,F
00628:  BSF    F8D.1
0062A:  RLCF   01,F
0062C:  BTFSS  F84.0
0062E:  BCF    01.0
00630:  BTFSC  F84.0
00632:  BSF    01.0
00634:  BCF    F8D.1
00636:  DECFSZ xB3,F
00638:  BRA    061E
0063A:  MOVLB  0
0063C:  RETURN 0
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0)         //COM flash memory port 
*
00668:  MOVLB  3
0066A:  MOVF   x9A,W
0066C:  SUBLW  08
0066E:  BZ    0678
00670:  MOVWF  x9B
00672:  RLCF   x99,F
00674:  DECFSZ x9B,F
00676:  BRA    0672
00678:  BSF    F93.5
0067A:  BCF    F93.4
0067C:  BCF    F93.2
0067E:  BCF    F8A.2
00680:  MOVFF  39A,39B
00684:  BTFSS  x99.7
00686:  BCF    F8A.4
00688:  BTFSC  x99.7
0068A:  BSF    F8A.4
0068C:  RLCF   x99,F
0068E:  BSF    F8A.2
00690:  RLCF   01,F
00692:  BTFSS  F81.5
00694:  BCF    01.0
00696:  BTFSC  F81.5
00698:  BSF    01.0
0069A:  BCF    F8A.2
0069C:  DECFSZ x9B,F
0069E:  BRA    0684
006A0:  MOVLB  0
006A2:  RETURN 0
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0)     //MISSION flash memory port 
*
00196:  MOVLB  3
00198:  MOVF   x9A,W
0019A:  SUBLW  08
0019C:  BZ    01A6
0019E:  MOVWF  x9B
001A0:  RLCF   x99,F
001A2:  DECFSZ x9B,F
001A4:  BRA    01A0
001A6:  BSF    F92.0
001A8:  BCF    F92.1
001AA:  BCF    F92.3
001AC:  BCF    F89.3
001AE:  MOVFF  39A,39B
001B2:  BTFSS  x99.7
001B4:  BCF    F89.1
001B6:  BTFSC  x99.7
001B8:  BSF    F89.1
001BA:  RLCF   x99,F
001BC:  BSF    F89.3
001BE:  RLCF   01,F
001C0:  BTFSS  F80.0
001C2:  BCF    01.0
001C4:  BTFSC  F80.0
001C6:  BSF    01.0
001C8:  BCF    F89.3
001CA:  DECFSZ x9B,F
001CC:  BRA    01B2
001CE:  MOVLB  0
001D0:  RETURN 0
....................  
.................... #ORG 0x0000C800, 0x0000EFFF {} 
.................... #ORG 0x0000F000, 0x000117FF {} 
.................... #ORG 0x00011800, 0x00013FFF {} 
.................... #ORG 0x00014000, 0x000167FF {} 
.................... #ORG 0x00016800, 0x00018FFF {} 
.................... #ORG 0x00019000, 0x0001B7FF {} 
.................... #ORG 0x0001B800, 0x0001DFFF {} 
.................... #ORG 0x0001E000, 0x0001FFEF {} 
.................... #endif 
....................  
.................... #include<mainpic_function.h> 
.................... #ifndef MAINPIC_FUNCTION_H 
.................... #define MAINPIC_FUNCTION_H 
....................  
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c>                                       //all flash memory 
.................... #ifndef FLASH_MEMORY_MT25QL01GBBB_OF_C 
.................... #define FLASH_MEMORY_MT25QL01GBBB_OF_C 
....................  
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
.................... #define DIE_ERASE            0xC4 
....................  
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_OF() 
.................... { 
....................    output_low(CS_PIN); 
*
118FA:  BCF    F96.2
118FC:  BCF    F8D.2
....................  
....................    spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
118FE:  MOVLW  06
11900:  MOVLB  3
11902:  MOVWF  xB1
11904:  MOVLW  08
11906:  MOVWF  xB2
11908:  MOVLB  0
1190A:  CALL   0602
....................  
....................    output_high(CS_PIN); 
1190E:  BCF    F96.2
11910:  BSF    F8D.2
....................    return; 
11912:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_SCF() 
.................... { 
....................    output_low(CS_PIN_2); 
*
119A4:  BCF    F93.3
119A6:  BCF    F8A.3
....................  
....................    ///////////////////////////////////////////////////////////// 
....................    //delay_ms(2); 
....................    spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
119A8:  MOVLW  06
119AA:  MOVLB  3
119AC:  MOVWF  x99
119AE:  MOVLW  08
119B0:  MOVWF  x9A
119B2:  MOVLB  0
119B4:  CALL   0668
....................    ///////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_2);   
119B8:  BCF    F93.3
119BA:  BSF    F8A.3
....................    return; 
119BC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_SMF() 
.................... { 
....................    output_low(CS_PIN_3); 
*
11A4E:  BCF    F92.2
11A50:  BCF    F89.2
....................  
....................    ///////////////////////////////////////////////////////////// 
....................    //delay_ms(2); 
....................    spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
11A52:  MOVLW  06
11A54:  MOVLB  3
11A56:  MOVWF  x99
11A58:  MOVLW  08
11A5A:  MOVWF  x9A
11A5C:  MOVLB  0
11A5E:  CALL   0196
....................    ///////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_3); 
11A62:  BCF    F92.2
11A64:  BSF    F89.2
....................    return; 
11A66:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_OF(unsigned int32 sector_address)                              //borra un sector de la flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
12014:  MOVLB  3
12016:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
1201A:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
1201E:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
12022:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_OF(); 
12026:  MOVLB  0
12028:  RCALL  118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
1202A:  BCF    F96.2
1202C:  BCF    F8D.2
....................    delay_us(2); 
1202E:  MOVLW  02
12030:  MOVWF  00
12032:  DECFSZ 00,F
12034:  BRA    12032
12036:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR);                                               //SECTOR ERASE COMAND   (0xDC) 
12038:  MOVLW  DC
1203A:  MOVLB  3
1203C:  MOVWF  xB1
1203E:  MOVLW  08
12040:  MOVWF  xB2
12042:  MOVLB  0
12044:  CALL   0602
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
12048:  MOVFF  38D,3B1
1204C:  MOVLW  08
1204E:  MOVLB  3
12050:  MOVWF  xB2
12052:  MOVLB  0
12054:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[1]);     
12058:  MOVFF  38E,3B1
1205C:  MOVLW  08
1205E:  MOVLB  3
12060:  MOVWF  xB2
12062:  MOVLB  0
12064:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[2]);     
12068:  MOVFF  38F,3B1
1206C:  MOVLW  08
1206E:  MOVLB  3
12070:  MOVWF  xB2
12072:  MOVLB  0
12074:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[3]); 
12078:  MOVFF  390,3B1
1207C:  MOVLW  08
1207E:  MOVLB  3
12080:  MOVWF  xB2
12082:  MOVLB  0
12084:  CALL   0602
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
12088:  MOVLW  02
1208A:  MOVWF  00
1208C:  DECFSZ 00,F
1208E:  BRA    1208C
12090:  NOP   
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
12092:  BCF    F96.2
12094:  BSF    F8D.2
....................    //delay_ms(1000); 
....................    delay_ms(750); 
12096:  MOVLW  03
12098:  MOVLB  3
1209A:  MOVWF  x91
1209C:  MOVLW  FA
1209E:  MOVWF  x98
120A0:  MOVLB  0
120A2:  CALL   063E
120A6:  MOVLB  3
120A8:  DECFSZ x91,F
120AA:  BRA    1209C
....................     
....................    return; 
120AC:  MOVLB  0
120AE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
120B0:  MOVLB  3
120B2:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
120B6:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
120BA:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
120BE:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
120C2:  MOVLB  0
120C4:  RCALL  119A4
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
120C6:  BCF    F93.3
120C8:  BCF    F8A.3
....................    delay_us(2); 
120CA:  MOVLW  02
120CC:  MOVWF  00
120CE:  DECFSZ 00,F
120D0:  BRA    120CE
120D2:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
120D4:  MOVLW  DC
120D6:  MOVLB  3
120D8:  MOVWF  x99
120DA:  MOVLW  08
120DC:  MOVWF  x9A
120DE:  MOVLB  0
120E0:  CALL   0668
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
120E4:  MOVFF  38D,399
120E8:  MOVLW  08
120EA:  MOVLB  3
120EC:  MOVWF  x9A
120EE:  MOVLB  0
120F0:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[1]);     
120F4:  MOVFF  38E,399
120F8:  MOVLW  08
120FA:  MOVLB  3
120FC:  MOVWF  x9A
120FE:  MOVLB  0
12100:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[2]);     
12104:  MOVFF  38F,399
12108:  MOVLW  08
1210A:  MOVLB  3
1210C:  MOVWF  x9A
1210E:  MOVLB  0
12110:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[3]); 
12114:  MOVFF  390,399
12118:  MOVLW  08
1211A:  MOVLB  3
1211C:  MOVWF  x9A
1211E:  MOVLB  0
12120:  CALL   0668
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
12124:  MOVLW  02
12126:  MOVWF  00
12128:  DECFSZ 00,F
1212A:  BRA    12128
1212C:  NOP   
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
1212E:  BCF    F93.3
12130:  BSF    F8A.3
....................    //delay_ms(1000); 
....................    delay_ms(750); 
12132:  MOVLW  03
12134:  MOVLB  3
12136:  MOVWF  x91
12138:  MOVLW  FA
1213A:  MOVWF  x98
1213C:  MOVLB  0
1213E:  CALL   063E
12142:  MOVLB  3
12144:  DECFSZ x91,F
12146:  BRA    12138
....................     
....................    return; 
12148:  MOVLB  0
1214A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
1214C:  MOVLB  3
1214E:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
12152:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
12156:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
1215A:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
1215E:  MOVLB  0
12160:  RCALL  11A4E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
12162:  BCF    F92.2
12164:  BCF    F89.2
....................    delay_us(2); 
12166:  MOVLW  02
12168:  MOVWF  00
1216A:  DECFSZ 00,F
1216C:  BRA    1216A
1216E:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
12170:  MOVLW  DC
12172:  MOVLB  3
12174:  MOVWF  x99
12176:  MOVLW  08
12178:  MOVWF  x9A
1217A:  MOVLB  0
1217C:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
12180:  MOVFF  38D,399
12184:  MOVLW  08
12186:  MOVLB  3
12188:  MOVWF  x9A
1218A:  MOVLB  0
1218C:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
12190:  MOVFF  38E,399
12194:  MOVLW  08
12196:  MOVLB  3
12198:  MOVWF  x9A
1219A:  MOVLB  0
1219C:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
121A0:  MOVFF  38F,399
121A4:  MOVLW  08
121A6:  MOVLB  3
121A8:  MOVWF  x9A
121AA:  MOVLB  0
121AC:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
121B0:  MOVFF  390,399
121B4:  MOVLW  08
121B6:  MOVLB  3
121B8:  MOVWF  x9A
121BA:  MOVLB  0
121BC:  CALL   0196
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
121C0:  MOVLW  02
121C2:  MOVWF  00
121C4:  DECFSZ 00,F
121C6:  BRA    121C4
121C8:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
121CA:  BCF    F92.2
121CC:  BSF    F89.2
....................    //delay_ms(1000);   
....................    delay_ms(750); 
121CE:  MOVLW  03
121D0:  MOVLB  3
121D2:  MOVWF  x91
121D4:  MOVLW  FA
121D6:  MOVWF  x98
121D8:  MOVLB  0
121DA:  CALL   063E
121DE:  MOVLB  3
121E0:  DECFSZ x91,F
121E2:  BRA    121D4
....................    return; 
121E4:  MOVLB  0
121E6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address)                       //Funcion que borra un sector de 4KB de la Main Flash 
.................... {                                                                                //Recibe la direccion del sector que se quiere borrar 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
11914:  MOVLB  3
11916:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
1191A:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
1191E:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
11922:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_OF();                                                            //Funcion que habilita escritura en Own Flash 
11926:  MOVLB  0
11928:  RCALL  118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
1192A:  BCF    F96.2
1192C:  BCF    F8D.2
....................    delay_us(2); 
1192E:  MOVLW  02
11930:  MOVWF  00
11932:  DECFSZ 00,F
11934:  BRA    11932
11936:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR);                                        //SECTOR ERASE COMAND   (0xDC) 
11938:  MOVLW  21
1193A:  MOVLB  3
1193C:  MOVWF  xB1
1193E:  MOVLW  08
11940:  MOVWF  xB2
11942:  MOVLB  0
11944:  CALL   0602
....................     
....................    spi_xfer(SPIPORT,adsress[0]);                                                 //Se le pasa la direccion del sector a borrar 
11948:  MOVFF  393,3B1
1194C:  MOVLW  08
1194E:  MOVLB  3
11950:  MOVWF  xB2
11952:  MOVLB  0
11954:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[1]);     
11958:  MOVFF  394,3B1
1195C:  MOVLW  08
1195E:  MOVLB  3
11960:  MOVWF  xB2
11962:  MOVLB  0
11964:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[2]);     
11968:  MOVFF  395,3B1
1196C:  MOVLW  08
1196E:  MOVLB  3
11970:  MOVWF  xB2
11972:  MOVLB  0
11974:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[3]); 
11978:  MOVFF  396,3B1
1197C:  MOVLW  08
1197E:  MOVLB  3
11980:  MOVWF  xB2
11982:  MOVLB  0
11984:  CALL   0602
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11988:  MOVLW  02
1198A:  MOVWF  00
1198C:  DECFSZ 00,F
1198E:  BRA    1198C
11990:  NOP   
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
11992:  BCF    F96.2
11994:  BSF    F8D.2
....................    delay_ms(100);   
11996:  MOVLW  64
11998:  MOVLB  3
1199A:  MOVWF  x98
1199C:  MOVLB  0
1199E:  CALL   063E
....................     
....................    return; 
119A2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
119BE:  MOVLB  3
119C0:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
119C4:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
119C8:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
119CC:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_SCF();                                                           //Funcion que habilita escritura en COM Flash 
119D0:  MOVLB  0
119D2:  RCALL  119A4
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
119D4:  BCF    F93.3
119D6:  BCF    F8A.3
....................    delay_us(2); 
119D8:  MOVLW  02
119DA:  MOVWF  00
119DC:  DECFSZ 00,F
119DE:  BRA    119DC
119E0:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
119E2:  MOVLW  21
119E4:  MOVLB  3
119E6:  MOVWF  x99
119E8:  MOVLW  08
119EA:  MOVWF  x9A
119EC:  MOVLB  0
119EE:  CALL   0668
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
119F2:  MOVFF  393,399
119F6:  MOVLW  08
119F8:  MOVLB  3
119FA:  MOVWF  x9A
119FC:  MOVLB  0
119FE:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[1]);     
11A02:  MOVFF  394,399
11A06:  MOVLW  08
11A08:  MOVLB  3
11A0A:  MOVWF  x9A
11A0C:  MOVLB  0
11A0E:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[2]);     
11A12:  MOVFF  395,399
11A16:  MOVLW  08
11A18:  MOVLB  3
11A1A:  MOVWF  x9A
11A1C:  MOVLB  0
11A1E:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[3]); 
11A22:  MOVFF  396,399
11A26:  MOVLW  08
11A28:  MOVLB  3
11A2A:  MOVWF  x9A
11A2C:  MOVLB  0
11A2E:  CALL   0668
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11A32:  MOVLW  02
11A34:  MOVWF  00
11A36:  DECFSZ 00,F
11A38:  BRA    11A36
11A3A:  NOP   
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
11A3C:  BCF    F93.3
11A3E:  BSF    F8A.3
....................    delay_ms(10);   
11A40:  MOVLW  0A
11A42:  MOVLB  3
11A44:  MOVWF  x98
11A46:  MOVLB  0
11A48:  CALL   063E
....................     
....................    return; 
11A4C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
11A68:  MOVLB  3
11A6A:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
11A6E:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
11A72:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
11A76:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_SMF();                                                           //Funcion que habilita escritura en Mission Flash 
11A7A:  MOVLB  0
11A7C:  RCALL  11A4E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
11A7E:  BCF    F92.2
11A80:  BCF    F89.2
....................    delay_us(2); 
11A82:  MOVLW  02
11A84:  MOVWF  00
11A86:  DECFSZ 00,F
11A88:  BRA    11A86
11A8A:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
11A8C:  MOVLW  21
11A8E:  MOVLB  3
11A90:  MOVWF  x99
11A92:  MOVLW  08
11A94:  MOVWF  x9A
11A96:  MOVLB  0
11A98:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
11A9C:  MOVFF  393,399
11AA0:  MOVLW  08
11AA2:  MOVLB  3
11AA4:  MOVWF  x9A
11AA6:  MOVLB  0
11AA8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
11AAC:  MOVFF  394,399
11AB0:  MOVLW  08
11AB2:  MOVLB  3
11AB4:  MOVWF  x9A
11AB6:  MOVLB  0
11AB8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
11ABC:  MOVFF  395,399
11AC0:  MOVLW  08
11AC2:  MOVLB  3
11AC4:  MOVWF  x9A
11AC6:  MOVLB  0
11AC8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11ACC:  MOVFF  396,399
11AD0:  MOVLW  08
11AD2:  MOVLB  3
11AD4:  MOVWF  x9A
11AD6:  MOVLB  0
11AD8:  CALL   0196
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11ADC:  MOVLW  02
11ADE:  MOVWF  00
11AE0:  DECFSZ 00,F
11AE2:  BRA    11AE0
11AE4:  NOP   
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
11AE6:  BCF    F92.2
11AE8:  BSF    F89.2
....................    delay_ms(1000);   
11AEA:  MOVLW  04
11AEC:  MOVLB  3
11AEE:  MOVWF  x97
11AF0:  MOVLW  FA
11AF2:  MOVWF  x98
11AF4:  MOVLB  0
11AF6:  CALL   063E
11AFA:  MOVLB  3
11AFC:  DECFSZ x97,F
11AFE:  BRA    11AF0
....................     
....................    return; 
11B00:  MOVLB  0
11B02:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data)                  //Funcion que escribe un Byte en la Main Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
11B8C:  MOVLB  3
11B8E:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
11B92:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
11B96:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
11B9A:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_OF(); 
11B9E:  MOVLB  0
11BA0:  RCALL  118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
11BA2:  BCF    F96.2
11BA4:  BCF    F8D.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE);                                                 //PAGE WRITE COMAND  (0x12) 
11BA6:  MOVLW  12
11BA8:  MOVLB  3
11BAA:  MOVWF  xB1
11BAC:  MOVLW  08
11BAE:  MOVWF  xB2
11BB0:  MOVLB  0
11BB2:  CALL   0602
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
11BB6:  MOVFF  395,3B1
11BBA:  MOVLW  08
11BBC:  MOVLB  3
11BBE:  MOVWF  xB2
11BC0:  MOVLB  0
11BC2:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[1]);     
11BC6:  MOVFF  396,3B1
11BCA:  MOVLW  08
11BCC:  MOVLB  3
11BCE:  MOVWF  xB2
11BD0:  MOVLB  0
11BD2:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[2]);     
11BD6:  MOVFF  397,3B1
11BDA:  MOVLW  08
11BDC:  MOVLB  3
11BDE:  MOVWF  xB2
11BE0:  MOVLB  0
11BE2:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[3]); 
11BE6:  MOVFF  398,3B1
11BEA:  MOVLW  08
11BEC:  MOVLB  3
11BEE:  MOVWF  xB2
11BF0:  MOVLB  0
11BF2:  CALL   0602
....................     
....................    spi_xfer(SPIPORT,data);  
11BF6:  MOVFF  394,3B1
11BFA:  MOVLW  08
11BFC:  MOVLB  3
11BFE:  MOVWF  xB2
11C00:  MOVLB  0
11C02:  CALL   0602
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
11C06:  BCF    F96.2
11C08:  BSF    F8D.2
....................  
....................    //delay_us(5);   
....................     
....................    return; 
11C0A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
11C0C:  MOVLB  3
11C0E:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
11C12:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
11C16:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
11C1A:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_SCF(); 
11C1E:  MOVLB  0
11C20:  RCALL  119A4
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
11C22:  BCF    F93.3
11C24:  BCF    F8A.3
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
11C26:  MOVLW  12
11C28:  MOVLB  3
11C2A:  MOVWF  x99
11C2C:  MOVLW  08
11C2E:  MOVWF  x9A
11C30:  MOVLB  0
11C32:  CALL   0668
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
11C36:  MOVFF  395,399
11C3A:  MOVLW  08
11C3C:  MOVLB  3
11C3E:  MOVWF  x9A
11C40:  MOVLB  0
11C42:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[1]);     
11C46:  MOVFF  396,399
11C4A:  MOVLW  08
11C4C:  MOVLB  3
11C4E:  MOVWF  x9A
11C50:  MOVLB  0
11C52:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[2]);     
11C56:  MOVFF  397,399
11C5A:  MOVLW  08
11C5C:  MOVLB  3
11C5E:  MOVWF  x9A
11C60:  MOVLB  0
11C62:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[3]); 
11C66:  MOVFF  398,399
11C6A:  MOVLW  08
11C6C:  MOVLB  3
11C6E:  MOVWF  x9A
11C70:  MOVLB  0
11C72:  CALL   0668
....................     
....................    spi_xfer(SPIPORT_2,data);  
11C76:  MOVFF  394,399
11C7A:  MOVLW  08
11C7C:  MOVLB  3
11C7E:  MOVWF  x9A
11C80:  MOVLB  0
11C82:  CALL   0668
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
11C86:  BCF    F93.3
11C88:  BSF    F8A.3
....................  
....................    //delay_us(5);   
....................     
....................    return; 
11C8A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
11C8C:  MOVLB  3
11C8E:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
11C92:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
11C96:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
11C9A:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_SMF(); 
11C9E:  MOVLB  0
11CA0:  RCALL  11A4E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
11CA2:  BCF    F92.2
11CA4:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
11CA6:  MOVLW  12
11CA8:  MOVLB  3
11CAA:  MOVWF  x99
11CAC:  MOVLW  08
11CAE:  MOVWF  x9A
11CB0:  MOVLB  0
11CB2:  CALL   0196
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
11CB6:  MOVFF  395,399
11CBA:  MOVLW  08
11CBC:  MOVLB  3
11CBE:  MOVWF  x9A
11CC0:  MOVLB  0
11CC2:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
11CC6:  MOVFF  396,399
11CCA:  MOVLW  08
11CCC:  MOVLB  3
11CCE:  MOVWF  x9A
11CD0:  MOVLB  0
11CD2:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
11CD6:  MOVFF  397,399
11CDA:  MOVLW  08
11CDC:  MOVLB  3
11CDE:  MOVWF  x9A
11CE0:  MOVLB  0
11CE2:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11CE6:  MOVFF  398,399
11CEA:  MOVLW  08
11CEC:  MOVLB  3
11CEE:  MOVWF  x9A
11CF0:  MOVLB  0
11CF2:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,data);  
11CF6:  MOVFF  394,399
11CFA:  MOVLW  08
11CFC:  MOVLB  3
11CFE:  MOVWF  x9A
11D00:  MOVLB  0
11D02:  CALL   0196
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
11D06:  BCF    F92.2
11D08:  BSF    F89.2
....................  
....................    //delay_us(10);   
....................     
....................    return; 
11D0A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
11B04:  MOVLB  3
11B06:  MOVFF  3AB,3AC
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
11B0A:  MOVFF  3AA,3AD
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
11B0E:  MOVFF  3A9,3AE
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
11B12:  MOVFF  3A8,3AF
....................  
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
11B16:  BCF    F96.2
11B18:  BCF    F8D.2
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
11B1A:  MOVLW  13
11B1C:  MOVWF  xB1
11B1E:  MOVLW  08
11B20:  MOVWF  xB2
11B22:  MOVLB  0
11B24:  CALL   0602
....................  
....................    spi_xfer(SPIPORT,adsress[0]); 
11B28:  MOVFF  3AC,3B1
11B2C:  MOVLW  08
11B2E:  MOVLB  3
11B30:  MOVWF  xB2
11B32:  MOVLB  0
11B34:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[1]); 
11B38:  MOVFF  3AD,3B1
11B3C:  MOVLW  08
11B3E:  MOVLB  3
11B40:  MOVWF  xB2
11B42:  MOVLB  0
11B44:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[2]); 
11B48:  MOVFF  3AE,3B1
11B4C:  MOVLW  08
11B4E:  MOVLB  3
11B50:  MOVWF  xB2
11B52:  MOVLB  0
11B54:  CALL   0602
....................    spi_xfer(SPIPORT,adsress[3]); 
11B58:  MOVFF  3AF,3B1
11B5C:  MOVLW  08
11B5E:  MOVLB  3
11B60:  MOVWF  xB2
11B62:  MOVLB  0
11B64:  CALL   0602
....................    data = spi_xfer(SPIPORT); 
11B68:  MOVLW  01
11B6A:  MOVLB  3
11B6C:  MOVWF  xB1
11B6E:  MOVLW  08
11B70:  MOVWF  xB2
11B72:  MOVLB  0
11B74:  CALL   0602
11B78:  MOVF   01,W
11B7A:  MOVFF  01,3B0
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
11B7E:  BCF    F96.2
11B80:  BSF    F8D.2
....................    return data; 
11B82:  MOVLB  3
11B84:  MOVFF  3B0,01
11B88:  MOVLB  0
11B8A:  RETURN 0
....................  
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
12442:  MOVLB  3
12444:  MOVFF  352,353
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
12448:  MOVFF  351,354
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
1244C:  MOVFF  350,355
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
12450:  MOVFF  34F,356
....................  
....................    output_low(CS_PIN_2);                                                           //lower the CS PIN 
12454:  BCF    F93.3
12456:  BCF    F8A.3
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT_2,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
12458:  MOVLW  13
1245A:  MOVWF  x99
1245C:  MOVLW  08
1245E:  MOVWF  x9A
12460:  MOVLB  0
12462:  CALL   0668
....................  
....................    spi_xfer(SPIPORT_2,adsress[0]); 
12466:  MOVFF  353,399
1246A:  MOVLW  08
1246C:  MOVLB  3
1246E:  MOVWF  x9A
12470:  MOVLB  0
12472:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[1]); 
12476:  MOVFF  354,399
1247A:  MOVLW  08
1247C:  MOVLB  3
1247E:  MOVWF  x9A
12480:  MOVLB  0
12482:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[2]); 
12486:  MOVFF  355,399
1248A:  MOVLW  08
1248C:  MOVLB  3
1248E:  MOVWF  x9A
12490:  MOVLB  0
12492:  CALL   0668
....................    spi_xfer(SPIPORT_2,adsress[3]); 
12496:  MOVFF  356,399
1249A:  MOVLW  08
1249C:  MOVLB  3
1249E:  MOVWF  x9A
124A0:  MOVLB  0
124A2:  CALL   0668
....................    data = spi_xfer(SPIPORT_2); 
124A6:  MOVLW  02
124A8:  MOVLB  3
124AA:  MOVWF  x99
124AC:  MOVLW  08
124AE:  MOVWF  x9A
124B0:  MOVLB  0
124B2:  CALL   0668
124B6:  MOVF   01,W
124B8:  MOVFF  01,357
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_2);                                                          //take CS PIN higher back 
124BC:  BCF    F93.3
124BE:  BSF    F8A.3
....................    return data; 
124C0:  MOVLB  3
124C2:  MOVFF  357,01
124C6:  MOVLB  0
124C8:  RETURN 0
....................   
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
11800:  MOVLB  3
11802:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
11806:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
1180A:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
1180E:  MOVFF  389,390
....................     
....................    output_low(CS_PIN_3);                                                           //lower the CS PIN 
11812:  BCF    F92.2
11814:  BCF    F89.2
....................   
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT_3,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
11816:  MOVLW  13
11818:  MOVWF  x99
1181A:  MOVLW  08
1181C:  MOVWF  x9A
1181E:  MOVLB  0
11820:  CALL   0196
....................  
....................    spi_xfer(SPIPORT_3,adsress[0]); 
11824:  MOVFF  38D,399
11828:  MOVLW  08
1182A:  MOVLB  3
1182C:  MOVWF  x9A
1182E:  MOVLB  0
11830:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]); 
11834:  MOVFF  38E,399
11838:  MOVLW  08
1183A:  MOVLB  3
1183C:  MOVWF  x9A
1183E:  MOVLB  0
11840:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]); 
11844:  MOVFF  38F,399
11848:  MOVLW  08
1184A:  MOVLB  3
1184C:  MOVWF  x9A
1184E:  MOVLB  0
11850:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11854:  MOVFF  390,399
11858:  MOVLW  08
1185A:  MOVLB  3
1185C:  MOVWF  x9A
1185E:  MOVLB  0
11860:  CALL   0196
....................    data = spi_xfer(SPIPORT_3); 
11864:  MOVLW  03
11866:  MOVLB  3
11868:  MOVWF  x99
1186A:  MOVLW  08
1186C:  MOVWF  x9A
1186E:  MOVLB  0
11870:  CALL   0196
11874:  MOVF   01,W
11876:  MOVFF  01,391
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_3);                                                          //take CS PIN higher back 
1187A:  BCF    F92.2
1187C:  BSF    F89.2
....................    return data; 
1187E:  MOVLB  3
11880:  MOVFF  391,01
11884:  MOVLB  0
11886:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte)          //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
12F70:  MOVLB  3
12F72:  CLRF   x4D
12F74:  CLRF   x4C
12F76:  CLRF   x4B
12F78:  CLRF   x4A
12F7A:  MOVF   x4D,W
12F7C:  SUBWF  x49,W
12F7E:  BNC   12FE0
12F80:  BNZ   12F98
12F82:  MOVF   x4C,W
12F84:  SUBWF  x48,W
12F86:  BNC   12FE0
12F88:  BNZ   12F98
12F8A:  MOVF   x4B,W
12F8C:  SUBWF  x47,W
12F8E:  BNC   12FE0
12F90:  BNZ   12F98
12F92:  MOVF   x46,W
12F94:  SUBWF  x4A,W
12F96:  BC    12FE0
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
12F98:  MOVFF  345,3AB
12F9C:  MOVFF  344,3AA
12FA0:  MOVFF  343,3A9
12FA4:  MOVFF  342,3A8
12FA8:  MOVLB  0
12FAA:  CALL   11B04
12FAE:  MOVFF  01,34E
12FB2:  MOVLB  3
12FB4:  MOVF   x4E,W
12FB6:  MOVLB  0
12FB8:  CALL   01D2
....................       ADRESS++; 
12FBC:  MOVLW  01
12FBE:  MOVLB  3
12FC0:  ADDWF  x42,F
12FC2:  BTFSC  FD8.0
12FC4:  INCF   x43,F
12FC6:  BTFSC  FD8.2
12FC8:  INCF   x44,F
12FCA:  BTFSC  FD8.2
12FCC:  INCF   x45,F
12FCE:  MOVLW  01
12FD0:  ADDWF  x4A,F
12FD2:  BTFSC  FD8.0
12FD4:  INCF   x4B,F
12FD6:  BTFSC  FD8.2
12FD8:  INCF   x4C,F
12FDA:  BTFSC  FD8.2
12FDC:  INCF   x4D,F
12FDE:  BRA    12F7A
....................    } 
....................    return; 
12FE0:  MOVLB  0
12FE2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
13644:  MOVLB  3
13646:  CLRF   x43
13648:  CLRF   x42
1364A:  CLRF   x41
1364C:  CLRF   x40
1364E:  MOVF   x43,W
13650:  SUBWF  x3F,W
13652:  BNC   136BA
13654:  BNZ   1366C
13656:  MOVF   x42,W
13658:  SUBWF  x3E,W
1365A:  BNC   136BA
1365C:  BNZ   1366C
1365E:  MOVF   x41,W
13660:  SUBWF  x3D,W
13662:  BNC   136BA
13664:  BNZ   1366C
13666:  MOVF   x3C,W
13668:  SUBWF  x40,W
1366A:  BC    136BA
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(ADRESS)); 
1366C:  MOVFF  33B,352
13670:  MOVFF  33A,351
13674:  MOVFF  339,350
13678:  MOVFF  338,34F
1367C:  MOVLB  0
1367E:  CALL   12442
13682:  MOVFF  01,344
13686:  MOVFF  01,3A2
1368A:  MOVLW  57
1368C:  MOVLB  3
1368E:  MOVWF  xA3
13690:  MOVLB  0
13692:  CALL   0700
....................       ADRESS++; 
13696:  MOVLW  01
13698:  MOVLB  3
1369A:  ADDWF  x38,F
1369C:  BTFSC  FD8.0
1369E:  INCF   x39,F
136A0:  BTFSC  FD8.2
136A2:  INCF   x3A,F
136A4:  BTFSC  FD8.2
136A6:  INCF   x3B,F
136A8:  MOVLW  01
136AA:  ADDWF  x40,F
136AC:  BTFSC  FD8.0
136AE:  INCF   x41,F
136B0:  BTFSC  FD8.2
136B2:  INCF   x42,F
136B4:  BTFSC  FD8.2
136B6:  INCF   x43,F
136B8:  BRA    1364E
....................    } 
....................    return; 
136BA:  MOVLB  0
136BC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
11888:  MOVLB  3
1188A:  CLRF   x88
1188C:  CLRF   x87
1188E:  CLRF   x86
11890:  CLRF   x85
11892:  MOVF   x88,W
11894:  SUBWF  x84,W
11896:  BNC   118F6
11898:  BNZ   118B0
1189A:  MOVF   x87,W
1189C:  SUBWF  x83,W
1189E:  BNC   118F6
118A0:  BNZ   118B0
118A2:  MOVF   x86,W
118A4:  SUBWF  x82,W
118A6:  BNC   118F6
118A8:  BNZ   118B0
118AA:  MOVF   x81,W
118AC:  SUBWF  x85,W
118AE:  BC    118F6
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
118B0:  MOVFF  380,38C
118B4:  MOVFF  37F,38B
118B8:  MOVFF  37E,38A
118BC:  MOVFF  37D,389
118C0:  MOVLB  0
118C2:  RCALL  11800
118C4:  MOVFF  01,389
118C8:  MOVLB  3
118CA:  MOVF   x89,W
118CC:  MOVLB  0
118CE:  CALL   01D2
....................       ADRESS++; 
118D2:  MOVLW  01
118D4:  MOVLB  3
118D6:  ADDWF  x7D,F
118D8:  BTFSC  FD8.0
118DA:  INCF   x7E,F
118DC:  BTFSC  FD8.2
118DE:  INCF   x7F,F
118E0:  BTFSC  FD8.2
118E2:  INCF   x80,F
118E4:  MOVLW  01
118E6:  ADDWF  x85,F
118E8:  BTFSC  FD8.0
118EA:  INCF   x86,F
118EC:  BTFSC  FD8.2
118EE:  INCF   x87,F
118F0:  BTFSC  FD8.2
118F2:  INCF   x88,F
118F4:  BRA    11892
....................    } 
....................    return; 
118F6:  MOVLB  0
118F8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
135B2:  MOVLB  3
135B4:  CLRF   x47
135B6:  CLRF   x46
135B8:  CLRF   x45
135BA:  CLRF   x44
135BC:  MOVF   x47,W
135BE:  SUBWF  x43,W
135C0:  BNC   13640
135C2:  BNZ   135DA
135C4:  MOVF   x46,W
135C6:  SUBWF  x42,W
135C8:  BNC   13640
135CA:  BNZ   135DA
135CC:  MOVF   x45,W
135CE:  SUBWF  x41,W
135D0:  BNC   13640
135D2:  BNZ   135DA
135D4:  MOVF   x40,W
135D6:  SUBWF  x44,W
135D8:  BC    13640
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
135DA:  MOVFF  33B,38C
135DE:  MOVFF  33A,38B
135E2:  MOVFF  339,38A
135E6:  MOVFF  338,389
135EA:  MOVLB  0
135EC:  CALL   11800
135F0:  MOVFF  01,348
135F4:  MOVFF  33F,393
135F8:  MOVFF  33E,392
135FC:  MOVFF  33D,391
13600:  MOVFF  33C,390
13604:  MOVFF  01,394
13608:  CALL   11B8C
....................       FROM_ADRESS++; 
1360C:  MOVLW  01
1360E:  MOVLB  3
13610:  ADDWF  x38,F
13612:  BTFSC  FD8.0
13614:  INCF   x39,F
13616:  BTFSC  FD8.2
13618:  INCF   x3A,F
1361A:  BTFSC  FD8.2
1361C:  INCF   x3B,F
....................       TO_ADRESS++; 
1361E:  MOVLW  01
13620:  ADDWF  x3C,F
13622:  BTFSC  FD8.0
13624:  INCF   x3D,F
13626:  BTFSC  FD8.2
13628:  INCF   x3E,F
1362A:  BTFSC  FD8.2
1362C:  INCF   x3F,F
1362E:  MOVLW  01
13630:  ADDWF  x44,F
13632:  BTFSC  FD8.0
13634:  INCF   x45,F
13636:  BTFSC  FD8.2
13638:  INCF   x46,F
1363A:  BTFSC  FD8.2
1363C:  INCF   x47,F
1363E:  BRA    135BC
....................    } 
....................    return; 
13640:  MOVLB  0
13642:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
13520:  MOVLB  3
13522:  CLRF   x47
13524:  CLRF   x46
13526:  CLRF   x45
13528:  CLRF   x44
1352A:  MOVF   x47,W
1352C:  SUBWF  x43,W
1352E:  BNC   135AE
13530:  BNZ   13548
13532:  MOVF   x46,W
13534:  SUBWF  x42,W
13536:  BNC   135AE
13538:  BNZ   13548
1353A:  MOVF   x45,W
1353C:  SUBWF  x41,W
1353E:  BNC   135AE
13540:  BNZ   13548
13542:  MOVF   x40,W
13544:  SUBWF  x44,W
13546:  BC    135AE
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
13548:  MOVFF  33B,38C
1354C:  MOVFF  33A,38B
13550:  MOVFF  339,38A
13554:  MOVFF  338,389
13558:  MOVLB  0
1355A:  CALL   11800
1355E:  MOVFF  01,348
13562:  MOVFF  33F,393
13566:  MOVFF  33E,392
1356A:  MOVFF  33D,391
1356E:  MOVFF  33C,390
13572:  MOVFF  01,394
13576:  CALL   11C0C
....................       FROM_ADRESS++; 
1357A:  MOVLW  01
1357C:  MOVLB  3
1357E:  ADDWF  x38,F
13580:  BTFSC  FD8.0
13582:  INCF   x39,F
13584:  BTFSC  FD8.2
13586:  INCF   x3A,F
13588:  BTFSC  FD8.2
1358A:  INCF   x3B,F
....................       TO_ADRESS++; 
1358C:  MOVLW  01
1358E:  ADDWF  x3C,F
13590:  BTFSC  FD8.0
13592:  INCF   x3D,F
13594:  BTFSC  FD8.2
13596:  INCF   x3E,F
13598:  BTFSC  FD8.2
1359A:  INCF   x3F,F
1359C:  MOVLW  01
1359E:  ADDWF  x44,F
135A0:  BTFSC  FD8.0
135A2:  INCF   x45,F
135A4:  BTFSC  FD8.2
135A6:  INCF   x46,F
135A8:  BTFSC  FD8.2
135AA:  INCF   x47,F
135AC:  BRA    1352A
....................    } 
....................    return; 
135AE:  MOVLB  0
135B0:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<MEMORY_OPERATION.c> 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
*
124D0:  MOVLW  DA
124D2:  MOVWF  FF6
124D4:  MOVLW  01
124D6:  MOVWF  FF7
124D8:  MOVLW  00
124DA:  MOVWF  FF8
124DC:  MOVLW  0E
124DE:  MOVLB  3
124E0:  MOVWF  xA2
124E2:  MOVLB  0
124E4:  CALL   06CE
124E8:  MOVFF  69,3A2
124EC:  MOVLW  57
124EE:  MOVLB  3
124F0:  MOVWF  xA3
124F2:  MOVLB  0
124F4:  CALL   0700
124F8:  MOVLW  0D
124FA:  BTFSS  F9E.4
124FC:  BRA    124FA
124FE:  MOVWF  FAD
12500:  MOVLW  0A
12502:  BTFSS  F9E.4
12504:  BRA    12502
12506:  MOVWF  FAD
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
12508:  MOVLW  EE
1250A:  MOVWF  FF6
1250C:  MOVLW  01
1250E:  MOVWF  FF7
12510:  MOVLW  00
12512:  MOVWF  FF8
12514:  MOVLW  0E
12516:  MOVLB  3
12518:  MOVWF  xA2
1251A:  MOVLB  0
1251C:  CALL   06CE
12520:  MOVFF  6B,3A2
12524:  MOVLW  57
12526:  MOVLB  3
12528:  MOVWF  xA3
1252A:  MOVLB  0
1252C:  CALL   0700
12530:  MOVLW  0D
12532:  BTFSS  F9E.4
12534:  BRA    12532
12536:  MOVWF  FAD
12538:  MOVLW  0A
1253A:  BTFSS  F9E.4
1253C:  BRA    1253A
1253E:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
12540:  MOVLW  02
12542:  MOVWF  FF6
12544:  MOVLW  02
12546:  MOVWF  FF7
12548:  MOVLW  00
1254A:  MOVWF  FF8
1254C:  MOVLW  0F
1254E:  MOVLB  3
12550:  MOVWF  xA2
12552:  MOVLB  0
12554:  CALL   06CE
12558:  MOVFF  75,3A2
1255C:  MOVLW  57
1255E:  MOVLB  3
12560:  MOVWF  xA3
12562:  MOVLB  0
12564:  CALL   0700
12568:  MOVLW  0D
1256A:  BTFSS  F9E.4
1256C:  BRA    1256A
1256E:  MOVWF  FAD
12570:  MOVLW  0A
12572:  BTFSS  F9E.4
12574:  BRA    12572
12576:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
12578:  MOVLW  16
1257A:  MOVWF  FF6
1257C:  MOVLW  02
1257E:  MOVWF  FF7
12580:  MOVLW  00
12582:  MOVWF  FF8
12584:  MOVLW  0E
12586:  MOVLB  3
12588:  MOVWF  xA2
1258A:  MOVLB  0
1258C:  CALL   06CE
12590:  MOVFF  76,3A2
12594:  MOVLW  57
12596:  MOVLB  3
12598:  MOVWF  xA3
1259A:  MOVLB  0
1259C:  CALL   0700
125A0:  MOVLW  0D
125A2:  BTFSS  F9E.4
125A4:  BRA    125A2
125A6:  MOVWF  FAD
125A8:  MOVLW  0A
125AA:  BTFSS  F9E.4
125AC:  BRA    125AA
125AE:  MOVWF  FAD
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
125B0:  MOVLW  2A
125B2:  MOVWF  FF6
125B4:  MOVLW  02
125B6:  MOVWF  FF7
125B8:  MOVLW  00
125BA:  MOVWF  FF8
125BC:  MOVLW  13
125BE:  MOVLB  3
125C0:  MOVWF  xA2
125C2:  MOVLB  0
125C4:  CALL   06CE
125C8:  MOVFF  77,3A2
125CC:  MOVLW  57
125CE:  MOVLB  3
125D0:  MOVWF  xA3
125D2:  MOVLB  0
125D4:  CALL   0700
125D8:  MOVLW  0D
125DA:  BTFSS  F9E.4
125DC:  BRA    125DA
125DE:  MOVWF  FAD
125E0:  MOVLW  0A
125E2:  BTFSS  F9E.4
125E4:  BRA    125E2
125E6:  MOVWF  FAD
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
125E8:  MOVLW  42
125EA:  MOVWF  FF6
125EC:  MOVLW  02
125EE:  MOVWF  FF7
125F0:  MOVLW  00
125F2:  MOVWF  FF8
125F4:  MOVLW  09
125F6:  MOVLB  3
125F8:  MOVWF  xA2
125FA:  MOVLB  0
125FC:  CALL   06CE
12600:  MOVFF  78,3A2
12604:  MOVLW  57
12606:  MOVLB  3
12608:  MOVWF  xA3
1260A:  MOVLB  0
1260C:  CALL   0700
12610:  MOVLW  0D
12612:  BTFSS  F9E.4
12614:  BRA    12612
12616:  MOVWF  FAD
12618:  MOVLW  0A
1261A:  BTFSS  F9E.4
1261C:  BRA    1261A
1261E:  MOVWF  FAD
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
12620:  MOVLW  50
12622:  MOVWF  FF6
12624:  MOVLW  02
12626:  MOVWF  FF7
12628:  MOVLW  00
1262A:  MOVWF  FF8
1262C:  MOVLW  09
1262E:  MOVLB  3
12630:  MOVWF  xA2
12632:  MOVLB  0
12634:  CALL   06CE
12638:  MOVFF  79,3A2
1263C:  MOVLW  57
1263E:  MOVLB  3
12640:  MOVWF  xA3
12642:  MOVLB  0
12644:  CALL   0700
12648:  MOVLW  0D
1264A:  BTFSS  F9E.4
1264C:  BRA    1264A
1264E:  MOVWF  FAD
12650:  MOVLW  0A
12652:  BTFSS  F9E.4
12654:  BRA    12652
12656:  MOVWF  FAD
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
12658:  MOVLW  5E
1265A:  MOVWF  FF6
1265C:  MOVLW  02
1265E:  MOVWF  FF7
12660:  MOVLW  00
12662:  MOVWF  FF8
12664:  MOVLW  0A
12666:  MOVLB  3
12668:  MOVWF  xA2
1266A:  MOVLB  0
1266C:  CALL   06CE
12670:  MOVFF  7A,3A2
12674:  MOVLW  57
12676:  MOVLB  3
12678:  MOVWF  xA3
1267A:  MOVLB  0
1267C:  CALL   0700
12680:  MOVLW  0D
12682:  BTFSS  F9E.4
12684:  BRA    12682
12686:  MOVWF  FAD
12688:  MOVLW  0A
1268A:  BTFSS  F9E.4
1268C:  BRA    1268A
1268E:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
12690:  MOVLW  6E
12692:  MOVWF  FF6
12694:  MOVLW  02
12696:  MOVWF  FF7
12698:  MOVLW  00
1269A:  MOVWF  FF8
1269C:  MOVLW  0F
1269E:  MOVLB  3
126A0:  MOVWF  xA2
126A2:  MOVLB  0
126A4:  CALL   06CE
126A8:  MOVFF  7B,3A2
126AC:  MOVLW  57
126AE:  MOVLB  3
126B0:  MOVWF  xA3
126B2:  MOVLB  0
126B4:  CALL   0700
126B8:  MOVLW  0D
126BA:  BTFSS  F9E.4
126BC:  BRA    126BA
126BE:  MOVWF  FAD
126C0:  MOVLW  0A
126C2:  BTFSS  F9E.4
126C4:  BRA    126C2
126C6:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
126C8:  MOVLW  82
126CA:  MOVWF  FF6
126CC:  MOVLW  02
126CE:  MOVWF  FF7
126D0:  MOVLW  00
126D2:  MOVWF  FF8
126D4:  MOVLW  17
126D6:  MOVLB  3
126D8:  MOVWF  xA2
126DA:  MOVLB  0
126DC:  CALL   06CE
126E0:  MOVFF  68,3A2
126E4:  MOVLW  57
126E6:  MOVLB  3
126E8:  MOVWF  xA3
126EA:  MOVLB  0
126EC:  CALL   0700
126F0:  MOVLW  0D
126F2:  BTFSS  F9E.4
126F4:  BRA    126F2
126F6:  MOVWF  FAD
126F8:  MOVLW  0A
126FA:  BTFSS  F9E.4
126FC:  BRA    126FA
126FE:  MOVWF  FAD
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
12700:  MOVLW  9E
12702:  MOVWF  FF6
12704:  MOVLW  02
12706:  MOVWF  FF7
12708:  MOVLW  00
1270A:  MOVWF  FF8
1270C:  MOVLW  0F
1270E:  MOVLB  3
12710:  MOVWF  xA2
12712:  MOVLB  0
12714:  CALL   06CE
12718:  MOVFF  7C,3A2
1271C:  MOVLW  57
1271E:  MOVLB  3
12720:  MOVWF  xA3
12722:  MOVLB  0
12724:  CALL   0700
12728:  MOVLW  AF
1272A:  MOVWF  FF6
1272C:  MOVLW  02
1272E:  MOVWF  FF7
12730:  MOVLW  00
12732:  MOVWF  FF8
12734:  MOVLW  04
12736:  MOVLB  3
12738:  MOVWF  xA2
1273A:  MOVLB  0
1273C:  CALL   06CE
....................    return; 
12740:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
12742:  MOVLW  B4
12744:  MOVWF  FF6
12746:  MOVLW  02
12748:  MOVWF  FF7
1274A:  MOVLW  00
1274C:  MOVWF  FF8
1274E:  MOVLW  13
12750:  MOVLB  3
12752:  MOVWF  xA2
12754:  MOVLB  0
12756:  CALL   06CE
1275A:  MOVFF  33,3A2
1275E:  MOVLW  57
12760:  MOVLB  3
12762:  MOVWF  xA3
12764:  MOVLB  0
12766:  CALL   0700
1276A:  MOVFF  32,3A2
1276E:  MOVLW  57
12770:  MOVLB  3
12772:  MOVWF  xA3
12774:  MOVLB  0
12776:  CALL   0700
1277A:  MOVFF  31,3A2
1277E:  MOVLW  57
12780:  MOVLB  3
12782:  MOVWF  xA3
12784:  MOVLB  0
12786:  CALL   0700
1278A:  MOVFF  30,3A2
1278E:  MOVLW  57
12790:  MOVLB  3
12792:  MOVWF  xA3
12794:  MOVLB  0
12796:  CALL   0700
1279A:  MOVLW  CA
1279C:  MOVWF  FF6
1279E:  MOVLW  02
127A0:  MOVWF  FF7
127A2:  MOVLW  00
127A4:  MOVWF  FF8
127A6:  MOVLW  04
127A8:  MOVLB  3
127AA:  MOVWF  xA2
127AC:  MOVLB  0
127AE:  CALL   06CE
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
127B2:  MOVFF  3B,338
127B6:  MOVLB  3
127B8:  CLRF   x39
127BA:  CLRF   x3A
127BC:  CLRF   x3B
127BE:  MOVFF  3A,33D
127C2:  MOVFF  3B,33E
127C6:  CLRF   x3F
127C8:  CLRF   x40
127CA:  MOVFF  39,342
127CE:  MOVFF  3A,343
127D2:  MOVFF  3B,344
127D6:  CLRF   x45
127D8:  MOVLW  D0
127DA:  MOVWF  FF6
127DC:  MOVLW  02
127DE:  MOVWF  FF7
127E0:  MOVLW  00
127E2:  MOVWF  FF8
127E4:  MOVLW  12
127E6:  MOVWF  xA2
127E8:  MOVLB  0
127EA:  CALL   06CE
127EE:  MOVFF  338,3A2
127F2:  MOVLW  57
127F4:  MOVLB  3
127F6:  MOVWF  xA3
127F8:  MOVLB  0
127FA:  CALL   0700
127FE:  MOVFF  33D,3A2
12802:  MOVLW  57
12804:  MOVLB  3
12806:  MOVWF  xA3
12808:  MOVLB  0
1280A:  CALL   0700
1280E:  MOVFF  342,3A2
12812:  MOVLW  57
12814:  MOVLB  3
12816:  MOVWF  xA3
12818:  MOVLB  0
1281A:  CALL   0700
1281E:  MOVFF  38,3A2
12822:  MOVLW  57
12824:  MOVLB  3
12826:  MOVWF  xA3
12828:  MOVLB  0
1282A:  CALL   0700
1282E:  MOVLW  0D
12830:  BTFSS  F9E.4
12832:  BRA    12830
12834:  MOVWF  FAD
12836:  MOVLW  0A
12838:  BTFSS  F9E.4
1283A:  BRA    12838
1283C:  MOVWF  FAD
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
1283E:  MOVFF  3F,338
12842:  MOVLB  3
12844:  CLRF   x39
12846:  CLRF   x3A
12848:  CLRF   x3B
1284A:  MOVFF  3E,33D
1284E:  MOVFF  3F,33E
12852:  CLRF   x3F
12854:  CLRF   x40
12856:  MOVFF  3D,342
1285A:  MOVFF  3E,343
1285E:  MOVFF  3F,344
12862:  CLRF   x45
12864:  MOVLW  EE
12866:  MOVWF  FF6
12868:  MOVLW  02
1286A:  MOVWF  FF7
1286C:  MOVLW  00
1286E:  MOVWF  FF8
12870:  MOVLW  1A
12872:  MOVWF  xA2
12874:  MOVLB  0
12876:  CALL   06CE
1287A:  MOVFF  338,3A2
1287E:  MOVLW  57
12880:  MOVLB  3
12882:  MOVWF  xA3
12884:  MOVLB  0
12886:  CALL   0700
1288A:  MOVFF  33D,3A2
1288E:  MOVLW  57
12890:  MOVLB  3
12892:  MOVWF  xA3
12894:  MOVLB  0
12896:  CALL   0700
1289A:  MOVFF  342,3A2
1289E:  MOVLW  57
128A0:  MOVLB  3
128A2:  MOVWF  xA3
128A4:  MOVLB  0
128A6:  CALL   0700
128AA:  MOVFF  3C,3A2
128AE:  MOVLW  57
128B0:  MOVLB  3
128B2:  MOVWF  xA3
128B4:  MOVLB  0
128B6:  CALL   0700
128BA:  MOVLW  0D
128BC:  BTFSS  F9E.4
128BE:  BRA    128BC
128C0:  MOVWF  FAD
128C2:  MOVLW  0A
128C4:  BTFSS  F9E.4
128C6:  BRA    128C4
128C8:  MOVWF  FAD
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
128CA:  MOVFF  43,338
128CE:  MOVLB  3
128D0:  CLRF   x39
128D2:  CLRF   x3A
128D4:  CLRF   x3B
128D6:  MOVFF  42,33D
128DA:  MOVFF  43,33E
128DE:  CLRF   x3F
128E0:  CLRF   x40
128E2:  MOVFF  41,342
128E6:  MOVFF  42,343
128EA:  MOVFF  43,344
128EE:  CLRF   x45
128F0:  MOVLW  14
128F2:  MOVWF  FF6
128F4:  MOVLW  03
128F6:  MOVWF  FF7
128F8:  MOVLW  00
128FA:  MOVWF  FF8
128FC:  MOVLW  16
128FE:  MOVWF  xA2
12900:  MOVLB  0
12902:  CALL   06CE
12906:  MOVFF  338,3A2
1290A:  MOVLW  57
1290C:  MOVLB  3
1290E:  MOVWF  xA3
12910:  MOVLB  0
12912:  CALL   0700
12916:  MOVFF  33D,3A2
1291A:  MOVLW  57
1291C:  MOVLB  3
1291E:  MOVWF  xA3
12920:  MOVLB  0
12922:  CALL   0700
12926:  MOVFF  342,3A2
1292A:  MOVLW  57
1292C:  MOVLB  3
1292E:  MOVWF  xA3
12930:  MOVLB  0
12932:  CALL   0700
12936:  MOVFF  40,3A2
1293A:  MOVLW  57
1293C:  MOVLB  3
1293E:  MOVWF  xA3
12940:  MOVLB  0
12942:  CALL   0700
12946:  MOVLW  0D
12948:  BTFSS  F9E.4
1294A:  BRA    12948
1294C:  MOVWF  FAD
1294E:  MOVLW  0A
12950:  BTFSS  F9E.4
12952:  BRA    12950
12954:  MOVWF  FAD
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
12956:  MOVFF  47,338
1295A:  MOVLB  3
1295C:  CLRF   x39
1295E:  CLRF   x3A
12960:  CLRF   x3B
12962:  MOVFF  46,33D
12966:  MOVFF  47,33E
1296A:  CLRF   x3F
1296C:  CLRF   x40
1296E:  MOVFF  45,342
12972:  MOVFF  46,343
12976:  MOVFF  47,344
1297A:  CLRF   x45
1297C:  MOVLW  36
1297E:  MOVWF  FF6
12980:  MOVLW  03
12982:  MOVWF  FF7
12984:  MOVLW  00
12986:  MOVWF  FF8
12988:  MOVLW  0C
1298A:  MOVWF  xA2
1298C:  MOVLB  0
1298E:  CALL   06CE
12992:  MOVFF  338,3A2
12996:  MOVLW  57
12998:  MOVLB  3
1299A:  MOVWF  xA3
1299C:  MOVLB  0
1299E:  CALL   0700
129A2:  MOVFF  33D,3A2
129A6:  MOVLW  57
129A8:  MOVLB  3
129AA:  MOVWF  xA3
129AC:  MOVLB  0
129AE:  CALL   0700
129B2:  MOVFF  342,3A2
129B6:  MOVLW  57
129B8:  MOVLB  3
129BA:  MOVWF  xA3
129BC:  MOVLB  0
129BE:  CALL   0700
129C2:  MOVFF  44,3A2
129C6:  MOVLW  57
129C8:  MOVLB  3
129CA:  MOVWF  xA3
129CC:  MOVLB  0
129CE:  CALL   0700
129D2:  MOVLW  0D
129D4:  BTFSS  F9E.4
129D6:  BRA    129D4
129D8:  MOVWF  FAD
129DA:  MOVLW  0A
129DC:  BTFSS  F9E.4
129DE:  BRA    129DC
129E0:  MOVWF  FAD
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
129E2:  MOVFF  4B,338
129E6:  MOVLB  3
129E8:  CLRF   x39
129EA:  CLRF   x3A
129EC:  CLRF   x3B
129EE:  MOVFF  4A,33D
129F2:  MOVFF  4B,33E
129F6:  CLRF   x3F
129F8:  CLRF   x40
129FA:  MOVFF  49,342
129FE:  MOVFF  4A,343
12A02:  MOVFF  4B,344
12A06:  CLRF   x45
12A08:  MOVLW  4E
12A0A:  MOVWF  FF6
12A0C:  MOVLW  03
12A0E:  MOVWF  FF7
12A10:  MOVLW  00
12A12:  MOVWF  FF8
12A14:  MOVLW  0F
12A16:  MOVWF  xA2
12A18:  MOVLB  0
12A1A:  CALL   06CE
12A1E:  MOVFF  338,3A2
12A22:  MOVLW  57
12A24:  MOVLB  3
12A26:  MOVWF  xA3
12A28:  MOVLB  0
12A2A:  CALL   0700
12A2E:  MOVFF  33D,3A2
12A32:  MOVLW  57
12A34:  MOVLB  3
12A36:  MOVWF  xA3
12A38:  MOVLB  0
12A3A:  CALL   0700
12A3E:  MOVFF  342,3A2
12A42:  MOVLW  57
12A44:  MOVLB  3
12A46:  MOVWF  xA3
12A48:  MOVLB  0
12A4A:  CALL   0700
12A4E:  MOVFF  48,3A2
12A52:  MOVLW  57
12A54:  MOVLB  3
12A56:  MOVWF  xA3
12A58:  MOVLB  0
12A5A:  CALL   0700
12A5E:  MOVLW  0D
12A60:  BTFSS  F9E.4
12A62:  BRA    12A60
12A64:  MOVWF  FAD
12A66:  MOVLW  0A
12A68:  BTFSS  F9E.4
12A6A:  BRA    12A68
12A6C:  MOVWF  FAD
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
12A6E:  MOVFF  4F,338
12A72:  MOVLB  3
12A74:  CLRF   x39
12A76:  CLRF   x3A
12A78:  CLRF   x3B
12A7A:  MOVFF  4E,33D
12A7E:  MOVFF  4F,33E
12A82:  CLRF   x3F
12A84:  CLRF   x40
12A86:  MOVFF  4D,342
12A8A:  MOVFF  4E,343
12A8E:  MOVFF  4F,344
12A92:  CLRF   x45
12A94:  MOVLW  68
12A96:  MOVWF  FF6
12A98:  MOVLW  03
12A9A:  MOVWF  FF7
12A9C:  MOVLW  00
12A9E:  MOVWF  FF8
12AA0:  MOVLW  0F
12AA2:  MOVWF  xA2
12AA4:  MOVLB  0
12AA6:  CALL   06CE
12AAA:  MOVFF  338,3A2
12AAE:  MOVLW  57
12AB0:  MOVLB  3
12AB2:  MOVWF  xA3
12AB4:  MOVLB  0
12AB6:  CALL   0700
12ABA:  MOVFF  33D,3A2
12ABE:  MOVLW  57
12AC0:  MOVLB  3
12AC2:  MOVWF  xA3
12AC4:  MOVLB  0
12AC6:  CALL   0700
12ACA:  MOVFF  342,3A2
12ACE:  MOVLW  57
12AD0:  MOVLB  3
12AD2:  MOVWF  xA3
12AD4:  MOVLB  0
12AD6:  CALL   0700
12ADA:  MOVFF  4C,3A2
12ADE:  MOVLW  57
12AE0:  MOVLB  3
12AE2:  MOVWF  xA3
12AE4:  MOVLB  0
12AE6:  CALL   0700
12AEA:  MOVLW  0D
12AEC:  BTFSS  F9E.4
12AEE:  BRA    12AEC
12AF0:  MOVWF  FAD
12AF2:  MOVLW  0A
12AF4:  BTFSS  F9E.4
12AF6:  BRA    12AF4
12AF8:  MOVWF  FAD
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
12AFA:  MOVFF  53,338
12AFE:  MOVLB  3
12B00:  CLRF   x39
12B02:  CLRF   x3A
12B04:  CLRF   x3B
12B06:  MOVFF  52,33D
12B0A:  MOVFF  53,33E
12B0E:  CLRF   x3F
12B10:  CLRF   x40
12B12:  MOVFF  51,342
12B16:  MOVFF  52,343
12B1A:  MOVFF  53,344
12B1E:  CLRF   x45
12B20:  MOVLW  82
12B22:  MOVWF  FF6
12B24:  MOVLW  03
12B26:  MOVWF  FF7
12B28:  MOVLW  00
12B2A:  MOVWF  FF8
12B2C:  MOVLW  14
12B2E:  MOVWF  xA2
12B30:  MOVLB  0
12B32:  CALL   06CE
12B36:  MOVFF  338,3A2
12B3A:  MOVLW  57
12B3C:  MOVLB  3
12B3E:  MOVWF  xA3
12B40:  MOVLB  0
12B42:  CALL   0700
12B46:  MOVFF  33D,3A2
12B4A:  MOVLW  57
12B4C:  MOVLB  3
12B4E:  MOVWF  xA3
12B50:  MOVLB  0
12B52:  CALL   0700
12B56:  MOVFF  342,3A2
12B5A:  MOVLW  57
12B5C:  MOVLB  3
12B5E:  MOVWF  xA3
12B60:  MOVLB  0
12B62:  CALL   0700
12B66:  MOVFF  50,3A2
12B6A:  MOVLW  57
12B6C:  MOVLB  3
12B6E:  MOVWF  xA3
12B70:  MOVLB  0
12B72:  CALL   0700
12B76:  MOVLW  0D
12B78:  BTFSS  F9E.4
12B7A:  BRA    12B78
12B7C:  MOVWF  FAD
12B7E:  MOVLW  0A
12B80:  BTFSS  F9E.4
12B82:  BRA    12B80
12B84:  MOVWF  FAD
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
12B86:  MOVFF  57,338
12B8A:  MOVLB  3
12B8C:  CLRF   x39
12B8E:  CLRF   x3A
12B90:  CLRF   x3B
12B92:  MOVFF  56,33D
12B96:  MOVFF  57,33E
12B9A:  CLRF   x3F
12B9C:  CLRF   x40
12B9E:  MOVFF  55,342
12BA2:  MOVFF  56,343
12BA6:  MOVFF  57,344
12BAA:  CLRF   x45
12BAC:  MOVLW  A2
12BAE:  MOVWF  FF6
12BB0:  MOVLW  03
12BB2:  MOVWF  FF7
12BB4:  MOVLW  00
12BB6:  MOVWF  FF8
12BB8:  MOVLW  11
12BBA:  MOVWF  xA2
12BBC:  MOVLB  0
12BBE:  CALL   06CE
12BC2:  MOVFF  338,3A2
12BC6:  MOVLW  57
12BC8:  MOVLB  3
12BCA:  MOVWF  xA3
12BCC:  MOVLB  0
12BCE:  CALL   0700
12BD2:  MOVFF  33D,3A2
12BD6:  MOVLW  57
12BD8:  MOVLB  3
12BDA:  MOVWF  xA3
12BDC:  MOVLB  0
12BDE:  CALL   0700
12BE2:  MOVFF  342,3A2
12BE6:  MOVLW  57
12BE8:  MOVLB  3
12BEA:  MOVWF  xA3
12BEC:  MOVLB  0
12BEE:  CALL   0700
12BF2:  MOVFF  54,3A2
12BF6:  MOVLW  57
12BF8:  MOVLB  3
12BFA:  MOVWF  xA3
12BFC:  MOVLB  0
12BFE:  CALL   0700
12C02:  MOVLW  0D
12C04:  BTFSS  F9E.4
12C06:  BRA    12C04
12C08:  MOVWF  FAD
12C0A:  MOVLW  0A
12C0C:  BTFSS  F9E.4
12C0E:  BRA    12C0C
12C10:  MOVWF  FAD
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
12C12:  MOVFF  5B,338
12C16:  MOVLB  3
12C18:  CLRF   x39
12C1A:  CLRF   x3A
12C1C:  CLRF   x3B
12C1E:  MOVFF  5A,33D
12C22:  MOVFF  5B,33E
12C26:  CLRF   x3F
12C28:  CLRF   x40
12C2A:  MOVFF  59,342
12C2E:  MOVFF  5A,343
12C32:  MOVFF  5B,344
12C36:  CLRF   x45
12C38:  MOVLW  BE
12C3A:  MOVWF  FF6
12C3C:  MOVLW  03
12C3E:  MOVWF  FF7
12C40:  MOVLW  00
12C42:  MOVWF  FF8
12C44:  MOVLW  15
12C46:  MOVWF  xA2
12C48:  MOVLB  0
12C4A:  CALL   06CE
12C4E:  MOVFF  338,3A2
12C52:  MOVLW  57
12C54:  MOVLB  3
12C56:  MOVWF  xA3
12C58:  MOVLB  0
12C5A:  CALL   0700
12C5E:  MOVFF  33D,3A2
12C62:  MOVLW  57
12C64:  MOVLB  3
12C66:  MOVWF  xA3
12C68:  MOVLB  0
12C6A:  CALL   0700
12C6E:  MOVFF  342,3A2
12C72:  MOVLW  57
12C74:  MOVLB  3
12C76:  MOVWF  xA3
12C78:  MOVLB  0
12C7A:  CALL   0700
12C7E:  MOVFF  58,3A2
12C82:  MOVLW  57
12C84:  MOVLB  3
12C86:  MOVWF  xA3
12C88:  MOVLB  0
12C8A:  CALL   0700
12C8E:  MOVLW  0D
12C90:  BTFSS  F9E.4
12C92:  BRA    12C90
12C94:  MOVWF  FAD
12C96:  MOVLW  0A
12C98:  BTFSS  F9E.4
12C9A:  BRA    12C98
12C9C:  MOVWF  FAD
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
12C9E:  MOVFF  5F,338
12CA2:  MOVLB  3
12CA4:  CLRF   x39
12CA6:  CLRF   x3A
12CA8:  CLRF   x3B
12CAA:  MOVFF  5E,33D
12CAE:  MOVFF  5F,33E
12CB2:  CLRF   x3F
12CB4:  CLRF   x40
12CB6:  MOVFF  5D,342
12CBA:  MOVFF  5E,343
12CBE:  MOVFF  5F,344
12CC2:  CLRF   x45
12CC4:  MOVLW  DE
12CC6:  MOVWF  FF6
12CC8:  MOVLW  03
12CCA:  MOVWF  FF7
12CCC:  MOVLW  00
12CCE:  MOVWF  FF8
12CD0:  MOVLW  15
12CD2:  MOVWF  xA2
12CD4:  MOVLB  0
12CD6:  CALL   06CE
12CDA:  MOVFF  338,3A2
12CDE:  MOVLW  57
12CE0:  MOVLB  3
12CE2:  MOVWF  xA3
12CE4:  MOVLB  0
12CE6:  CALL   0700
12CEA:  MOVFF  33D,3A2
12CEE:  MOVLW  57
12CF0:  MOVLB  3
12CF2:  MOVWF  xA3
12CF4:  MOVLB  0
12CF6:  CALL   0700
12CFA:  MOVFF  342,3A2
12CFE:  MOVLW  57
12D00:  MOVLB  3
12D02:  MOVWF  xA3
12D04:  MOVLB  0
12D06:  CALL   0700
12D0A:  MOVFF  5C,3A2
12D0E:  MOVLW  57
12D10:  MOVLB  3
12D12:  MOVWF  xA3
12D14:  MOVLB  0
12D16:  CALL   0700
12D1A:  MOVLW  0D
12D1C:  BTFSS  F9E.4
12D1E:  BRA    12D1C
12D20:  MOVWF  FAD
12D22:  MOVLW  0A
12D24:  BTFSS  F9E.4
12D26:  BRA    12D24
12D28:  MOVWF  FAD
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
12D2A:  MOVLW  FE
12D2C:  MOVWF  FF6
12D2E:  MOVLW  03
12D30:  MOVWF  FF7
12D32:  MOVLW  00
12D34:  MOVWF  FF8
12D36:  MOVLW  06
12D38:  MOVLB  3
12D3A:  MOVWF  xA2
12D3C:  MOVLB  0
12D3E:  CALL   06CE
12D42:  MOVFF  37,3A2
12D46:  MOVLW  57
12D48:  MOVLB  3
12D4A:  MOVWF  xA3
12D4C:  MOVLB  0
12D4E:  CALL   0700
12D52:  MOVFF  36,3A2
12D56:  MOVLW  57
12D58:  MOVLB  3
12D5A:  MOVWF  xA3
12D5C:  MOVLB  0
12D5E:  CALL   0700
12D62:  MOVFF  35,3A2
12D66:  MOVLW  57
12D68:  MOVLB  3
12D6A:  MOVWF  xA3
12D6C:  MOVLB  0
12D6E:  CALL   0700
12D72:  MOVFF  34,3A2
12D76:  MOVLW  57
12D78:  MOVLB  3
12D7A:  MOVWF  xA3
12D7C:  MOVLB  0
12D7E:  CALL   0700
12D82:  MOVLW  07
12D84:  MOVWF  FF6
12D86:  MOVLW  04
12D88:  MOVWF  FF7
12D8A:  MOVLW  00
12D8C:  MOVWF  FF8
12D8E:  MOVLW  08
12D90:  MOVLB  3
12D92:  MOVWF  xA2
12D94:  MOVLB  0
12D96:  CALL   06CE
....................    return; 
12D9A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
*
13C2A:  BSF    FD0.6
13C2C:  MOVFF  62,FF8
13C30:  MOVFF  61,FF7
13C34:  MOVFF  60,FF6
13C38:  BSF    F7F.4
13C3A:  CALL   1F18
13C3E:  CLRF   FF8
....................    return; 
13C40:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
*
12FE4:  MOVLB  3
12FE6:  CLRF   x40
12FE8:  MOVFF  68,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
12FEC:  BSF    FD0.6
12FEE:  MOVFF  62,FF8
12FF2:  MOVFF  61,FF7
12FF6:  MOVFF  60,FF6
12FFA:  MOVLB  0
12FFC:  CALL   1F02
13000:  MOVFF  60,FF6
13004:  MOVFF  33F,FF5
13008:  TBLWT*+
1300A:  MOVFF  340,FF5
1300E:  TBLWT*
13010:  CALL   1F18
13014:  CLRF   FF8
13016:  CLRF   FF8
....................    DATA = (int16)PASSED_DAYS; 
13018:  MOVFF  6A,340
1301C:  MOVFF  69,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
13020:  MOVLW  02
13022:  ADDWF  x60,W
13024:  MOVLB  3
13026:  MOVWF  x41
13028:  MOVLW  00
1302A:  MOVLB  0
1302C:  ADDWFC x61,W
1302E:  MOVLB  3
13030:  MOVWF  x42
13032:  MOVLW  00
13034:  MOVLB  0
13036:  ADDWFC x62,W
13038:  MOVLB  3
1303A:  MOVWF  x43
1303C:  MOVLW  00
1303E:  MOVLB  0
13040:  ADDWFC x63,W
13042:  MOVLB  3
13044:  MOVWF  x44
13046:  BSF    FD0.6
13048:  MOVFF  343,FF8
1304C:  MOVFF  342,FF7
13050:  MOVFF  341,FF6
13054:  MOVLB  0
13056:  CALL   1F02
1305A:  MOVFF  341,FF6
1305E:  MOVFF  33F,FF5
13062:  TBLWT*+
13064:  MOVFF  340,FF5
13068:  TBLWT*
1306A:  CALL   1F18
1306E:  CLRF   FF8
13070:  CLRF   FF8
....................    DATA = (int16)RESERVE_CHECK; 
13072:  MOVLB  3
13074:  CLRF   x40
13076:  MOVFF  6B,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
1307A:  MOVLW  04
1307C:  MOVLB  0
1307E:  ADDWF  x60,W
13080:  MOVLB  3
13082:  MOVWF  x41
13084:  MOVLW  00
13086:  MOVLB  0
13088:  ADDWFC x61,W
1308A:  MOVLB  3
1308C:  MOVWF  x42
1308E:  MOVLW  00
13090:  MOVLB  0
13092:  ADDWFC x62,W
13094:  MOVLB  3
13096:  MOVWF  x43
13098:  MOVLW  00
1309A:  MOVLB  0
1309C:  ADDWFC x63,W
1309E:  MOVLB  3
130A0:  MOVWF  x44
130A2:  BSF    FD0.6
130A4:  MOVFF  343,FF8
130A8:  MOVFF  342,FF7
130AC:  MOVFF  341,FF6
130B0:  MOVLB  0
130B2:  CALL   1F02
130B6:  MOVFF  341,FF6
130BA:  MOVFF  33F,FF5
130BE:  TBLWT*+
130C0:  MOVFF  340,FF5
130C4:  TBLWT*
130C6:  CALL   1F18
130CA:  CLRF   FF8
130CC:  CLRF   FF8
....................    DATA = (int16)RESERVE_MIN_FLAG; 
130CE:  MOVLB  3
130D0:  CLRF   x40
130D2:  MOVFF  6C,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
130D6:  MOVLW  06
130D8:  MOVLB  0
130DA:  ADDWF  x60,W
130DC:  MOVLB  3
130DE:  MOVWF  x41
130E0:  MOVLW  00
130E2:  MOVLB  0
130E4:  ADDWFC x61,W
130E6:  MOVLB  3
130E8:  MOVWF  x42
130EA:  MOVLW  00
130EC:  MOVLB  0
130EE:  ADDWFC x62,W
130F0:  MOVLB  3
130F2:  MOVWF  x43
130F4:  MOVLW  00
130F6:  MOVLB  0
130F8:  ADDWFC x63,W
130FA:  MOVLB  3
130FC:  MOVWF  x44
130FE:  BSF    FD0.6
13100:  MOVFF  343,FF8
13104:  MOVFF  342,FF7
13108:  MOVFF  341,FF6
1310C:  MOVLB  0
1310E:  CALL   1F02
13112:  MOVFF  341,FF6
13116:  MOVFF  33F,FF5
1311A:  TBLWT*+
1311C:  MOVFF  340,FF5
13120:  TBLWT*
13122:  CALL   1F18
13126:  CLRF   FF8
13128:  CLRF   FF8
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
1312A:  MOVLB  3
1312C:  CLRF   x40
1312E:  MOVFF  6D,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
13132:  MOVLW  08
13134:  MOVLB  0
13136:  ADDWF  x60,W
13138:  MOVLB  3
1313A:  MOVWF  x41
1313C:  MOVLW  00
1313E:  MOVLB  0
13140:  ADDWFC x61,W
13142:  MOVLB  3
13144:  MOVWF  x42
13146:  MOVLW  00
13148:  MOVLB  0
1314A:  ADDWFC x62,W
1314C:  MOVLB  3
1314E:  MOVWF  x43
13150:  MOVLW  00
13152:  MOVLB  0
13154:  ADDWFC x63,W
13156:  MOVLB  3
13158:  MOVWF  x44
1315A:  BSF    FD0.6
1315C:  MOVFF  343,FF8
13160:  MOVFF  342,FF7
13164:  MOVFF  341,FF6
13168:  MOVLB  0
1316A:  CALL   1F02
1316E:  MOVFF  341,FF6
13172:  MOVFF  33F,FF5
13176:  TBLWT*+
13178:  MOVFF  340,FF5
1317C:  TBLWT*
1317E:  CALL   1F18
13182:  CLRF   FF8
13184:  CLRF   FF8
....................    DATA = (int16)MISSION_CONTENTS; 
13186:  MOVLB  3
13188:  CLRF   x40
1318A:  MOVFF  6E,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
1318E:  MOVLW  0A
13190:  MOVLB  0
13192:  ADDWF  x60,W
13194:  MOVLB  3
13196:  MOVWF  x41
13198:  MOVLW  00
1319A:  MOVLB  0
1319C:  ADDWFC x61,W
1319E:  MOVLB  3
131A0:  MOVWF  x42
131A2:  MOVLW  00
131A4:  MOVLB  0
131A6:  ADDWFC x62,W
131A8:  MOVLB  3
131AA:  MOVWF  x43
131AC:  MOVLW  00
131AE:  MOVLB  0
131B0:  ADDWFC x63,W
131B2:  MOVLB  3
131B4:  MOVWF  x44
131B6:  BSF    FD0.6
131B8:  MOVFF  343,FF8
131BC:  MOVFF  342,FF7
131C0:  MOVFF  341,FF6
131C4:  MOVLB  0
131C6:  CALL   1F02
131CA:  MOVFF  341,FF6
131CE:  MOVFF  33F,FF5
131D2:  TBLWT*+
131D4:  MOVFF  340,FF5
131D8:  TBLWT*
131DA:  CALL   1F18
131DE:  CLRF   FF8
131E0:  CLRF   FF8
....................    DATA = (int16)MISSION_DETAIL; 
131E2:  MOVLB  3
131E4:  CLRF   x40
131E6:  MOVFF  6F,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
131EA:  MOVLW  0C
131EC:  MOVLB  0
131EE:  ADDWF  x60,W
131F0:  MOVLB  3
131F2:  MOVWF  x41
131F4:  MOVLW  00
131F6:  MOVLB  0
131F8:  ADDWFC x61,W
131FA:  MOVLB  3
131FC:  MOVWF  x42
131FE:  MOVLW  00
13200:  MOVLB  0
13202:  ADDWFC x62,W
13204:  MOVLB  3
13206:  MOVWF  x43
13208:  MOVLW  00
1320A:  MOVLB  0
1320C:  ADDWFC x63,W
1320E:  MOVLB  3
13210:  MOVWF  x44
13212:  BSF    FD0.6
13214:  MOVFF  343,FF8
13218:  MOVFF  342,FF7
1321C:  MOVFF  341,FF6
13220:  MOVLB  0
13222:  CALL   1F02
13226:  MOVFF  341,FF6
1322A:  MOVFF  33F,FF5
1322E:  TBLWT*+
13230:  MOVFF  340,FF5
13234:  TBLWT*
13236:  CALL   1F18
1323A:  CLRF   FF8
1323C:  CLRF   FF8
....................    DATA = (int16)Kill_FLAG_MAIN; 
1323E:  MOVLB  3
13240:  CLRF   x40
13242:  MOVFF  75,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
13246:  MOVLW  0E
13248:  MOVLB  0
1324A:  ADDWF  x60,W
1324C:  MOVLB  3
1324E:  MOVWF  x41
13250:  MOVLW  00
13252:  MOVLB  0
13254:  ADDWFC x61,W
13256:  MOVLB  3
13258:  MOVWF  x42
1325A:  MOVLW  00
1325C:  MOVLB  0
1325E:  ADDWFC x62,W
13260:  MOVLB  3
13262:  MOVWF  x43
13264:  MOVLW  00
13266:  MOVLB  0
13268:  ADDWFC x63,W
1326A:  MOVLB  3
1326C:  MOVWF  x44
1326E:  BSF    FD0.6
13270:  MOVFF  343,FF8
13274:  MOVFF  342,FF7
13278:  MOVFF  341,FF6
1327C:  MOVLB  0
1327E:  CALL   1F02
13282:  MOVFF  341,FF6
13286:  MOVFF  33F,FF5
1328A:  TBLWT*+
1328C:  MOVFF  340,FF5
13290:  TBLWT*
13292:  CALL   1F18
13296:  CLRF   FF8
13298:  CLRF   FF8
....................    DATA = (int16)Kill_FLAG_FAB; 
1329A:  MOVLB  3
1329C:  CLRF   x40
1329E:  MOVFF  76,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
132A2:  MOVLW  10
132A4:  MOVLB  0
132A6:  ADDWF  x60,W
132A8:  MOVLB  3
132AA:  MOVWF  x41
132AC:  MOVLW  00
132AE:  MOVLB  0
132B0:  ADDWFC x61,W
132B2:  MOVLB  3
132B4:  MOVWF  x42
132B6:  MOVLW  00
132B8:  MOVLB  0
132BA:  ADDWFC x62,W
132BC:  MOVLB  3
132BE:  MOVWF  x43
132C0:  MOVLW  00
132C2:  MOVLB  0
132C4:  ADDWFC x63,W
132C6:  MOVLB  3
132C8:  MOVWF  x44
132CA:  BSF    FD0.6
132CC:  MOVFF  343,FF8
132D0:  MOVFF  342,FF7
132D4:  MOVFF  341,FF6
132D8:  MOVLB  0
132DA:  CALL   1F02
132DE:  MOVFF  341,FF6
132E2:  MOVFF  33F,FF5
132E6:  TBLWT*+
132E8:  MOVFF  340,FF5
132EC:  TBLWT*
132EE:  CALL   1F18
132F2:  CLRF   FF8
132F4:  CLRF   FF8
....................    DATA = (int16)FIRST_HSSC_DONE; 
132F6:  MOVLB  3
132F8:  CLRF   x40
132FA:  MOVFF  77,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
132FE:  MOVLW  12
13300:  MOVLB  0
13302:  ADDWF  x60,W
13304:  MOVLB  3
13306:  MOVWF  x41
13308:  MOVLW  00
1330A:  MOVLB  0
1330C:  ADDWFC x61,W
1330E:  MOVLB  3
13310:  MOVWF  x42
13312:  MOVLW  00
13314:  MOVLB  0
13316:  ADDWFC x62,W
13318:  MOVLB  3
1331A:  MOVWF  x43
1331C:  MOVLW  00
1331E:  MOVLB  0
13320:  ADDWFC x63,W
13322:  MOVLB  3
13324:  MOVWF  x44
13326:  BSF    FD0.6
13328:  MOVFF  343,FF8
1332C:  MOVFF  342,FF7
13330:  MOVFF  341,FF6
13334:  MOVLB  0
13336:  CALL   1F02
1333A:  MOVFF  341,FF6
1333E:  MOVFF  33F,FF5
13342:  TBLWT*+
13344:  MOVFF  340,FF5
13348:  TBLWT*
1334A:  CALL   1F18
1334E:  CLRF   FF8
13350:  CLRF   FF8
....................    DATA = (int16)AUTO_CAM_DONE; 
13352:  MOVLB  3
13354:  CLRF   x40
13356:  MOVFF  78,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
1335A:  MOVLW  14
1335C:  MOVLB  0
1335E:  ADDWF  x60,W
13360:  MOVLB  3
13362:  MOVWF  x41
13364:  MOVLW  00
13366:  MOVLB  0
13368:  ADDWFC x61,W
1336A:  MOVLB  3
1336C:  MOVWF  x42
1336E:  MOVLW  00
13370:  MOVLB  0
13372:  ADDWFC x62,W
13374:  MOVLB  3
13376:  MOVWF  x43
13378:  MOVLW  00
1337A:  MOVLB  0
1337C:  ADDWFC x63,W
1337E:  MOVLB  3
13380:  MOVWF  x44
13382:  BSF    FD0.6
13384:  MOVFF  343,FF8
13388:  MOVFF  342,FF7
1338C:  MOVFF  341,FF6
13390:  MOVLB  0
13392:  CALL   1F02
13396:  MOVFF  341,FF6
1339A:  MOVFF  33F,FF5
1339E:  TBLWT*+
133A0:  MOVFF  340,FF5
133A4:  TBLWT*
133A6:  CALL   1F18
133AA:  CLRF   FF8
133AC:  CLRF   FF8
....................    DATA = (int16)AUTO_MBP_DONE; 
133AE:  MOVLB  3
133B0:  CLRF   x40
133B2:  MOVFF  79,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
133B6:  MOVLW  16
133B8:  MOVLB  0
133BA:  ADDWF  x60,W
133BC:  MOVLB  3
133BE:  MOVWF  x41
133C0:  MOVLW  00
133C2:  MOVLB  0
133C4:  ADDWFC x61,W
133C6:  MOVLB  3
133C8:  MOVWF  x42
133CA:  MOVLW  00
133CC:  MOVLB  0
133CE:  ADDWFC x62,W
133D0:  MOVLB  3
133D2:  MOVWF  x43
133D4:  MOVLW  00
133D6:  MOVLB  0
133D8:  ADDWFC x63,W
133DA:  MOVLB  3
133DC:  MOVWF  x44
133DE:  BSF    FD0.6
133E0:  MOVFF  343,FF8
133E4:  MOVFF  342,FF7
133E8:  MOVFF  341,FF6
133EC:  MOVLB  0
133EE:  CALL   1F02
133F2:  MOVFF  341,FF6
133F6:  MOVFF  33F,FF5
133FA:  TBLWT*+
133FC:  MOVFF  340,FF5
13400:  TBLWT*
13402:  CALL   1F18
13406:  CLRF   FF8
13408:  CLRF   FF8
....................    DATA = (int16)AUTO_ADCS_DONE; 
1340A:  MOVLB  3
1340C:  CLRF   x40
1340E:  MOVFF  7A,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
13412:  MOVLW  18
13414:  MOVLB  0
13416:  ADDWF  x60,W
13418:  MOVLB  3
1341A:  MOVWF  x41
1341C:  MOVLW  00
1341E:  MOVLB  0
13420:  ADDWFC x61,W
13422:  MOVLB  3
13424:  MOVWF  x42
13426:  MOVLW  00
13428:  MOVLB  0
1342A:  ADDWFC x62,W
1342C:  MOVLB  3
1342E:  MOVWF  x43
13430:  MOVLW  00
13432:  MOVLB  0
13434:  ADDWFC x63,W
13436:  MOVLB  3
13438:  MOVWF  x44
1343A:  BSF    FD0.6
1343C:  MOVFF  343,FF8
13440:  MOVFF  342,FF7
13444:  MOVFF  341,FF6
13448:  MOVLB  0
1344A:  CALL   1F02
1344E:  MOVFF  341,FF6
13452:  MOVFF  33F,FF5
13456:  TBLWT*+
13458:  MOVFF  340,FF5
1345C:  TBLWT*
1345E:  CALL   1F18
13462:  CLRF   FF8
13464:  CLRF   FF8
....................    DATA = (int16)ANT_DEP_STATUS; 
13466:  MOVLB  3
13468:  CLRF   x40
1346A:  MOVFF  7B,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
1346E:  MOVLW  1A
13470:  MOVLB  0
13472:  ADDWF  x60,W
13474:  MOVLB  3
13476:  MOVWF  x41
13478:  MOVLW  00
1347A:  MOVLB  0
1347C:  ADDWFC x61,W
1347E:  MOVLB  3
13480:  MOVWF  x42
13482:  MOVLW  00
13484:  MOVLB  0
13486:  ADDWFC x62,W
13488:  MOVLB  3
1348A:  MOVWF  x43
1348C:  MOVLW  00
1348E:  MOVLB  0
13490:  ADDWFC x63,W
13492:  MOVLB  3
13494:  MOVWF  x44
13496:  BSF    FD0.6
13498:  MOVFF  343,FF8
1349C:  MOVFF  342,FF7
134A0:  MOVFF  341,FF6
134A4:  MOVLB  0
134A6:  CALL   1F02
134AA:  MOVFF  341,FF6
134AE:  MOVFF  33F,FF5
134B2:  TBLWT*+
134B4:  MOVFF  340,FF5
134B8:  TBLWT*
134BA:  CALL   1F18
134BE:  CLRF   FF8
134C0:  CLRF   FF8
....................    DATA = (int16)UPLINK_SUCCESS; 
134C2:  MOVLB  3
134C4:  CLRF   x40
134C6:  MOVFF  7C,33F
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
134CA:  MOVLW  1C
134CC:  MOVLB  0
134CE:  ADDWF  x60,W
134D0:  MOVLB  3
134D2:  MOVWF  x41
134D4:  MOVLW  00
134D6:  MOVLB  0
134D8:  ADDWFC x61,W
134DA:  MOVLB  3
134DC:  MOVWF  x42
134DE:  MOVLW  00
134E0:  MOVLB  0
134E2:  ADDWFC x62,W
134E4:  MOVLB  3
134E6:  MOVWF  x43
134E8:  MOVLW  00
134EA:  MOVLB  0
134EC:  ADDWFC x63,W
134EE:  MOVLB  3
134F0:  MOVWF  x44
134F2:  BSF    FD0.6
134F4:  MOVFF  343,FF8
134F8:  MOVFF  342,FF7
134FC:  MOVFF  341,FF6
13500:  MOVLB  0
13502:  CALL   1F02
13506:  MOVFF  341,FF6
1350A:  MOVFF  33F,FF5
1350E:  TBLWT*+
13510:  MOVFF  340,FF5
13514:  TBLWT*
13516:  CALL   1F18
1351A:  CLRF   FF8
1351C:  CLRF   FF8
....................    return; 
1351E:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
*
14C66:  MOVFF  FF2,32E
14C6A:  BCF    FF2.7
14C6C:  MOVFF  62,FF8
14C70:  MOVFF  61,FF7
14C74:  MOVFF  60,FF6
14C78:  TBLRD*+
14C7A:  MOVF   FF5,W
14C7C:  TBLRD*
14C7E:  MOVFF  FF5,03
14C82:  CLRF   FF8
14C84:  MOVLB  3
14C86:  BTFSC  x2E.7
14C88:  BSF    FF2.7
14C8A:  MOVWF  x2E
14C8C:  MOVFF  03,32F
14C90:  INCFSZ x2E,W
14C92:  BRA    14C9A
14C94:  INCFSZ x2F,W
14C96:  BRA    14C9A
14C98:  BRA    1512C
14C9A:  MOVLW  1A
14C9C:  MOVLB  0
14C9E:  ADDWF  x60,W
14CA0:  MOVLB  3
14CA2:  MOVWF  x2E
14CA4:  MOVLW  00
14CA6:  MOVLB  0
14CA8:  ADDWFC x61,W
14CAA:  MOVLB  3
14CAC:  MOVWF  x2F
14CAE:  MOVLW  00
14CB0:  MOVLB  0
14CB2:  ADDWFC x62,W
14CB4:  MOVLB  3
14CB6:  MOVWF  x30
14CB8:  MOVLW  00
14CBA:  MOVLB  0
14CBC:  ADDWFC x63,W
14CBE:  MOVLB  3
14CC0:  MOVWF  x31
14CC2:  MOVFF  FF2,332
14CC6:  BCF    FF2.7
14CC8:  MOVFF  330,FF8
14CCC:  MOVFF  32F,FF7
14CD0:  MOVFF  32E,FF6
14CD4:  TBLRD*+
14CD6:  MOVF   FF5,W
14CD8:  TBLRD*
14CDA:  MOVFF  FF5,03
14CDE:  CLRF   FF8
14CE0:  BTFSC  x32.7
14CE2:  BSF    FF2.7
14CE4:  MOVWF  x2E
14CE6:  MOVFF  03,32F
14CEA:  INCFSZ x2E,W
14CEC:  BRA    14CF4
14CEE:  INCFSZ x2F,W
14CF0:  BRA    14CF4
14CF2:  BRA    1512C
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
14CF4:  MOVFF  FF2,32E
14CF8:  BCF    FF2.7
14CFA:  MOVFF  62,FF8
14CFE:  MOVFF  61,FF7
14D02:  MOVFF  60,FF6
14D06:  TBLRD*+
14D08:  MOVF   FF5,W
14D0A:  TBLRD*
14D0C:  MOVFF  FF5,03
14D10:  CLRF   FF8
14D12:  BTFSC  x2E.7
14D14:  BSF    FF2.7
14D16:  MOVLB  0
14D18:  MOVWF  x68
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
14D1A:  MOVLW  02
14D1C:  ADDWF  x60,W
14D1E:  MOVLB  3
14D20:  MOVWF  x2E
14D22:  MOVLW  00
14D24:  MOVLB  0
14D26:  ADDWFC x61,W
14D28:  MOVLB  3
14D2A:  MOVWF  x2F
14D2C:  MOVLW  00
14D2E:  MOVLB  0
14D30:  ADDWFC x62,W
14D32:  MOVLB  3
14D34:  MOVWF  x30
14D36:  MOVLW  00
14D38:  MOVLB  0
14D3A:  ADDWFC x63,W
14D3C:  MOVLB  3
14D3E:  MOVFF  FF2,332
14D42:  BCF    FF2.7
14D44:  MOVFF  330,FF8
14D48:  MOVFF  32F,FF7
14D4C:  MOVFF  32E,FF6
14D50:  TBLRD*+
14D52:  MOVF   FF5,W
14D54:  TBLRD*
14D56:  MOVFF  FF5,03
14D5A:  CLRF   FF8
14D5C:  BTFSC  x32.7
14D5E:  BSF    FF2.7
14D60:  MOVLB  0
14D62:  MOVWF  x69
14D64:  MOVFF  03,6A
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
14D68:  MOVLW  04
14D6A:  ADDWF  x60,W
14D6C:  MOVLB  3
14D6E:  MOVWF  x2E
14D70:  MOVLW  00
14D72:  MOVLB  0
14D74:  ADDWFC x61,W
14D76:  MOVLB  3
14D78:  MOVWF  x2F
14D7A:  MOVLW  00
14D7C:  MOVLB  0
14D7E:  ADDWFC x62,W
14D80:  MOVLB  3
14D82:  MOVWF  x30
14D84:  MOVLW  00
14D86:  MOVLB  0
14D88:  ADDWFC x63,W
14D8A:  MOVLB  3
14D8C:  MOVFF  FF2,332
14D90:  BCF    FF2.7
14D92:  MOVFF  330,FF8
14D96:  MOVFF  32F,FF7
14D9A:  MOVFF  32E,FF6
14D9E:  TBLRD*+
14DA0:  MOVF   FF5,W
14DA2:  TBLRD*
14DA4:  MOVFF  FF5,03
14DA8:  CLRF   FF8
14DAA:  BTFSC  x32.7
14DAC:  BSF    FF2.7
14DAE:  MOVLB  0
14DB0:  MOVWF  x6B
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
14DB2:  MOVLW  06
14DB4:  ADDWF  x60,W
14DB6:  MOVLB  3
14DB8:  MOVWF  x2E
14DBA:  MOVLW  00
14DBC:  MOVLB  0
14DBE:  ADDWFC x61,W
14DC0:  MOVLB  3
14DC2:  MOVWF  x2F
14DC4:  MOVLW  00
14DC6:  MOVLB  0
14DC8:  ADDWFC x62,W
14DCA:  MOVLB  3
14DCC:  MOVWF  x30
14DCE:  MOVLW  00
14DD0:  MOVLB  0
14DD2:  ADDWFC x63,W
14DD4:  MOVLB  3
14DD6:  MOVFF  FF2,332
14DDA:  BCF    FF2.7
14DDC:  MOVFF  330,FF8
14DE0:  MOVFF  32F,FF7
14DE4:  MOVFF  32E,FF6
14DE8:  TBLRD*+
14DEA:  MOVF   FF5,W
14DEC:  TBLRD*
14DEE:  MOVFF  FF5,03
14DF2:  CLRF   FF8
14DF4:  BTFSC  x32.7
14DF6:  BSF    FF2.7
14DF8:  MOVLB  0
14DFA:  MOVWF  x6C
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
14DFC:  MOVLW  08
14DFE:  ADDWF  x60,W
14E00:  MOVLB  3
14E02:  MOVWF  x2E
14E04:  MOVLW  00
14E06:  MOVLB  0
14E08:  ADDWFC x61,W
14E0A:  MOVLB  3
14E0C:  MOVWF  x2F
14E0E:  MOVLW  00
14E10:  MOVLB  0
14E12:  ADDWFC x62,W
14E14:  MOVLB  3
14E16:  MOVWF  x30
14E18:  MOVLW  00
14E1A:  MOVLB  0
14E1C:  ADDWFC x63,W
14E1E:  MOVLB  3
14E20:  MOVFF  FF2,332
14E24:  BCF    FF2.7
14E26:  MOVFF  330,FF8
14E2A:  MOVFF  32F,FF7
14E2E:  MOVFF  32E,FF6
14E32:  TBLRD*+
14E34:  MOVF   FF5,W
14E36:  TBLRD*
14E38:  MOVFF  FF5,03
14E3C:  CLRF   FF8
14E3E:  BTFSC  x32.7
14E40:  BSF    FF2.7
14E42:  MOVLB  0
14E44:  MOVWF  x6D
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
14E46:  MOVLW  0A
14E48:  ADDWF  x60,W
14E4A:  MOVLB  3
14E4C:  MOVWF  x2E
14E4E:  MOVLW  00
14E50:  MOVLB  0
14E52:  ADDWFC x61,W
14E54:  MOVLB  3
14E56:  MOVWF  x2F
14E58:  MOVLW  00
14E5A:  MOVLB  0
14E5C:  ADDWFC x62,W
14E5E:  MOVLB  3
14E60:  MOVWF  x30
14E62:  MOVLW  00
14E64:  MOVLB  0
14E66:  ADDWFC x63,W
14E68:  MOVLB  3
14E6A:  MOVFF  FF2,332
14E6E:  BCF    FF2.7
14E70:  MOVFF  330,FF8
14E74:  MOVFF  32F,FF7
14E78:  MOVFF  32E,FF6
14E7C:  TBLRD*+
14E7E:  MOVF   FF5,W
14E80:  TBLRD*
14E82:  MOVFF  FF5,03
14E86:  CLRF   FF8
14E88:  BTFSC  x32.7
14E8A:  BSF    FF2.7
14E8C:  MOVLB  0
14E8E:  MOVWF  x6E
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
14E90:  MOVLW  0C
14E92:  ADDWF  x60,W
14E94:  MOVLB  3
14E96:  MOVWF  x2E
14E98:  MOVLW  00
14E9A:  MOVLB  0
14E9C:  ADDWFC x61,W
14E9E:  MOVLB  3
14EA0:  MOVWF  x2F
14EA2:  MOVLW  00
14EA4:  MOVLB  0
14EA6:  ADDWFC x62,W
14EA8:  MOVLB  3
14EAA:  MOVWF  x30
14EAC:  MOVLW  00
14EAE:  MOVLB  0
14EB0:  ADDWFC x63,W
14EB2:  MOVLB  3
14EB4:  MOVFF  FF2,332
14EB8:  BCF    FF2.7
14EBA:  MOVFF  330,FF8
14EBE:  MOVFF  32F,FF7
14EC2:  MOVFF  32E,FF6
14EC6:  TBLRD*+
14EC8:  MOVF   FF5,W
14ECA:  TBLRD*
14ECC:  MOVFF  FF5,03
14ED0:  CLRF   FF8
14ED2:  BTFSC  x32.7
14ED4:  BSF    FF2.7
14ED6:  MOVLB  0
14ED8:  MOVWF  x6F
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
14EDA:  MOVLW  0E
14EDC:  ADDWF  x60,W
14EDE:  MOVLB  3
14EE0:  MOVWF  x2E
14EE2:  MOVLW  00
14EE4:  MOVLB  0
14EE6:  ADDWFC x61,W
14EE8:  MOVLB  3
14EEA:  MOVWF  x2F
14EEC:  MOVLW  00
14EEE:  MOVLB  0
14EF0:  ADDWFC x62,W
14EF2:  MOVLB  3
14EF4:  MOVWF  x30
14EF6:  MOVLW  00
14EF8:  MOVLB  0
14EFA:  ADDWFC x63,W
14EFC:  MOVLB  3
14EFE:  MOVFF  FF2,332
14F02:  BCF    FF2.7
14F04:  MOVFF  330,FF8
14F08:  MOVFF  32F,FF7
14F0C:  MOVFF  32E,FF6
14F10:  TBLRD*+
14F12:  MOVF   FF5,W
14F14:  TBLRD*
14F16:  MOVFF  FF5,03
14F1A:  CLRF   FF8
14F1C:  BTFSC  x32.7
14F1E:  BSF    FF2.7
14F20:  MOVLB  0
14F22:  MOVWF  x75
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
14F24:  MOVLW  10
14F26:  ADDWF  x60,W
14F28:  MOVLB  3
14F2A:  MOVWF  x2E
14F2C:  MOVLW  00
14F2E:  MOVLB  0
14F30:  ADDWFC x61,W
14F32:  MOVLB  3
14F34:  MOVWF  x2F
14F36:  MOVLW  00
14F38:  MOVLB  0
14F3A:  ADDWFC x62,W
14F3C:  MOVLB  3
14F3E:  MOVWF  x30
14F40:  MOVLW  00
14F42:  MOVLB  0
14F44:  ADDWFC x63,W
14F46:  MOVLB  3
14F48:  MOVFF  FF2,332
14F4C:  BCF    FF2.7
14F4E:  MOVFF  330,FF8
14F52:  MOVFF  32F,FF7
14F56:  MOVFF  32E,FF6
14F5A:  TBLRD*+
14F5C:  MOVF   FF5,W
14F5E:  TBLRD*
14F60:  MOVFF  FF5,03
14F64:  CLRF   FF8
14F66:  BTFSC  x32.7
14F68:  BSF    FF2.7
14F6A:  MOVLB  0
14F6C:  MOVWF  x76
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
14F6E:  MOVLW  12
14F70:  ADDWF  x60,W
14F72:  MOVLB  3
14F74:  MOVWF  x2E
14F76:  MOVLW  00
14F78:  MOVLB  0
14F7A:  ADDWFC x61,W
14F7C:  MOVLB  3
14F7E:  MOVWF  x2F
14F80:  MOVLW  00
14F82:  MOVLB  0
14F84:  ADDWFC x62,W
14F86:  MOVLB  3
14F88:  MOVWF  x30
14F8A:  MOVLW  00
14F8C:  MOVLB  0
14F8E:  ADDWFC x63,W
14F90:  MOVLB  3
14F92:  MOVFF  FF2,332
14F96:  BCF    FF2.7
14F98:  MOVFF  330,FF8
14F9C:  MOVFF  32F,FF7
14FA0:  MOVFF  32E,FF6
14FA4:  TBLRD*+
14FA6:  MOVF   FF5,W
14FA8:  TBLRD*
14FAA:  MOVFF  FF5,03
14FAE:  CLRF   FF8
14FB0:  BTFSC  x32.7
14FB2:  BSF    FF2.7
14FB4:  MOVLB  0
14FB6:  MOVWF  x77
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
14FB8:  MOVLW  14
14FBA:  ADDWF  x60,W
14FBC:  MOVLB  3
14FBE:  MOVWF  x2E
14FC0:  MOVLW  00
14FC2:  MOVLB  0
14FC4:  ADDWFC x61,W
14FC6:  MOVLB  3
14FC8:  MOVWF  x2F
14FCA:  MOVLW  00
14FCC:  MOVLB  0
14FCE:  ADDWFC x62,W
14FD0:  MOVLB  3
14FD2:  MOVWF  x30
14FD4:  MOVLW  00
14FD6:  MOVLB  0
14FD8:  ADDWFC x63,W
14FDA:  MOVLB  3
14FDC:  MOVFF  FF2,332
14FE0:  BCF    FF2.7
14FE2:  MOVFF  330,FF8
14FE6:  MOVFF  32F,FF7
14FEA:  MOVFF  32E,FF6
14FEE:  TBLRD*+
14FF0:  MOVF   FF5,W
14FF2:  TBLRD*
14FF4:  MOVFF  FF5,03
14FF8:  CLRF   FF8
14FFA:  BTFSC  x32.7
14FFC:  BSF    FF2.7
14FFE:  MOVLB  0
15000:  MOVWF  x78
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
15002:  MOVLW  16
15004:  ADDWF  x60,W
15006:  MOVLB  3
15008:  MOVWF  x2E
1500A:  MOVLW  00
1500C:  MOVLB  0
1500E:  ADDWFC x61,W
15010:  MOVLB  3
15012:  MOVWF  x2F
15014:  MOVLW  00
15016:  MOVLB  0
15018:  ADDWFC x62,W
1501A:  MOVLB  3
1501C:  MOVWF  x30
1501E:  MOVLW  00
15020:  MOVLB  0
15022:  ADDWFC x63,W
15024:  MOVLB  3
15026:  MOVFF  FF2,332
1502A:  BCF    FF2.7
1502C:  MOVFF  330,FF8
15030:  MOVFF  32F,FF7
15034:  MOVFF  32E,FF6
15038:  TBLRD*+
1503A:  MOVF   FF5,W
1503C:  TBLRD*
1503E:  MOVFF  FF5,03
15042:  CLRF   FF8
15044:  BTFSC  x32.7
15046:  BSF    FF2.7
15048:  MOVLB  0
1504A:  MOVWF  x79
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
1504C:  MOVLW  18
1504E:  ADDWF  x60,W
15050:  MOVLB  3
15052:  MOVWF  x2E
15054:  MOVLW  00
15056:  MOVLB  0
15058:  ADDWFC x61,W
1505A:  MOVLB  3
1505C:  MOVWF  x2F
1505E:  MOVLW  00
15060:  MOVLB  0
15062:  ADDWFC x62,W
15064:  MOVLB  3
15066:  MOVWF  x30
15068:  MOVLW  00
1506A:  MOVLB  0
1506C:  ADDWFC x63,W
1506E:  MOVLB  3
15070:  MOVFF  FF2,332
15074:  BCF    FF2.7
15076:  MOVFF  330,FF8
1507A:  MOVFF  32F,FF7
1507E:  MOVFF  32E,FF6
15082:  TBLRD*+
15084:  MOVF   FF5,W
15086:  TBLRD*
15088:  MOVFF  FF5,03
1508C:  CLRF   FF8
1508E:  BTFSC  x32.7
15090:  BSF    FF2.7
15092:  MOVLB  0
15094:  MOVWF  x7A
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
15096:  MOVLW  1A
15098:  ADDWF  x60,W
1509A:  MOVLB  3
1509C:  MOVWF  x2E
1509E:  MOVLW  00
150A0:  MOVLB  0
150A2:  ADDWFC x61,W
150A4:  MOVLB  3
150A6:  MOVWF  x2F
150A8:  MOVLW  00
150AA:  MOVLB  0
150AC:  ADDWFC x62,W
150AE:  MOVLB  3
150B0:  MOVWF  x30
150B2:  MOVLW  00
150B4:  MOVLB  0
150B6:  ADDWFC x63,W
150B8:  MOVLB  3
150BA:  MOVFF  FF2,332
150BE:  BCF    FF2.7
150C0:  MOVFF  330,FF8
150C4:  MOVFF  32F,FF7
150C8:  MOVFF  32E,FF6
150CC:  TBLRD*+
150CE:  MOVF   FF5,W
150D0:  TBLRD*
150D2:  MOVFF  FF5,03
150D6:  CLRF   FF8
150D8:  BTFSC  x32.7
150DA:  BSF    FF2.7
150DC:  MOVLB  0
150DE:  MOVWF  x7B
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
150E0:  MOVLW  1C
150E2:  ADDWF  x60,W
150E4:  MOVLB  3
150E6:  MOVWF  x2E
150E8:  MOVLW  00
150EA:  MOVLB  0
150EC:  ADDWFC x61,W
150EE:  MOVLB  3
150F0:  MOVWF  x2F
150F2:  MOVLW  00
150F4:  MOVLB  0
150F6:  ADDWFC x62,W
150F8:  MOVLB  3
150FA:  MOVWF  x30
150FC:  MOVLW  00
150FE:  MOVLB  0
15100:  ADDWFC x63,W
15102:  MOVLB  3
15104:  MOVFF  FF2,332
15108:  BCF    FF2.7
1510A:  MOVFF  330,FF8
1510E:  MOVFF  32F,FF7
15112:  MOVFF  32E,FF6
15116:  TBLRD*+
15118:  MOVF   FF5,W
1511A:  TBLRD*
1511C:  MOVFF  FF5,03
15120:  CLRF   FF8
15122:  BTFSC  x32.7
15124:  BSF    FF2.7
15126:  MOVLB  0
15128:  MOVWF  x7C
1512A:  MOVLB  3
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
1512C:  MOVLW  10
1512E:  MOVWF  FF6
15130:  MOVLW  04
15132:  MOVWF  FF7
15134:  MOVLW  00
15136:  MOVWF  FF8
15138:  MOVLW  0E
1513A:  MOVWF  xA2
1513C:  MOVLB  0
1513E:  CALL   06CE
15142:  MOVFF  6A,3A2
15146:  MOVLW  57
15148:  MOVLB  3
1514A:  MOVWF  xA3
1514C:  MOVLB  0
1514E:  CALL   0700
15152:  MOVFF  69,3A2
15156:  MOVLW  57
15158:  MOVLB  3
1515A:  MOVWF  xA3
1515C:  MOVLB  0
1515E:  CALL   0700
15162:  MOVLW  0D
15164:  BTFSS  F9E.4
15166:  BRA    15164
15168:  MOVWF  FAD
1516A:  MOVLW  0A
1516C:  BTFSS  F9E.4
1516E:  BRA    1516C
15170:  MOVWF  FAD
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
15172:  MOVLW  24
15174:  MOVWF  FF6
15176:  MOVLW  04
15178:  MOVWF  FF7
1517A:  MOVLW  00
1517C:  MOVWF  FF8
1517E:  MOVLW  0E
15180:  MOVLB  3
15182:  MOVWF  xA2
15184:  MOVLB  0
15186:  CALL   06CE
1518A:  MOVFF  6B,3A2
1518E:  MOVLW  57
15190:  MOVLB  3
15192:  MOVWF  xA3
15194:  MOVLB  0
15196:  CALL   0700
1519A:  MOVLW  0D
1519C:  BTFSS  F9E.4
1519E:  BRA    1519C
151A0:  MOVWF  FAD
151A2:  MOVLW  0A
151A4:  BTFSS  F9E.4
151A6:  BRA    151A4
151A8:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
151AA:  MOVLW  38
151AC:  MOVWF  FF6
151AE:  MOVLW  04
151B0:  MOVWF  FF7
151B2:  MOVLW  00
151B4:  MOVWF  FF8
151B6:  MOVLW  0F
151B8:  MOVLB  3
151BA:  MOVWF  xA2
151BC:  MOVLB  0
151BE:  CALL   06CE
151C2:  MOVFF  75,3A2
151C6:  MOVLW  57
151C8:  MOVLB  3
151CA:  MOVWF  xA3
151CC:  MOVLB  0
151CE:  CALL   0700
151D2:  MOVLW  0D
151D4:  BTFSS  F9E.4
151D6:  BRA    151D4
151D8:  MOVWF  FAD
151DA:  MOVLW  0A
151DC:  BTFSS  F9E.4
151DE:  BRA    151DC
151E0:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
151E2:  MOVLW  4C
151E4:  MOVWF  FF6
151E6:  MOVLW  04
151E8:  MOVWF  FF7
151EA:  MOVLW  00
151EC:  MOVWF  FF8
151EE:  MOVLW  0E
151F0:  MOVLB  3
151F2:  MOVWF  xA2
151F4:  MOVLB  0
151F6:  CALL   06CE
151FA:  MOVFF  76,3A2
151FE:  MOVLW  57
15200:  MOVLB  3
15202:  MOVWF  xA3
15204:  MOVLB  0
15206:  CALL   0700
1520A:  MOVLW  0D
1520C:  BTFSS  F9E.4
1520E:  BRA    1520C
15210:  MOVWF  FAD
15212:  MOVLW  0A
15214:  BTFSS  F9E.4
15216:  BRA    15214
15218:  MOVWF  FAD
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
1521A:  MOVLW  60
1521C:  MOVWF  FF6
1521E:  MOVLW  04
15220:  MOVWF  FF7
15222:  MOVLW  00
15224:  MOVWF  FF8
15226:  MOVLW  13
15228:  MOVLB  3
1522A:  MOVWF  xA2
1522C:  MOVLB  0
1522E:  CALL   06CE
15232:  MOVFF  77,3A2
15236:  MOVLW  57
15238:  MOVLB  3
1523A:  MOVWF  xA3
1523C:  MOVLB  0
1523E:  CALL   0700
15242:  MOVLW  0D
15244:  BTFSS  F9E.4
15246:  BRA    15244
15248:  MOVWF  FAD
1524A:  MOVLW  0A
1524C:  BTFSS  F9E.4
1524E:  BRA    1524C
15250:  MOVWF  FAD
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
15252:  MOVLW  78
15254:  MOVWF  FF6
15256:  MOVLW  04
15258:  MOVWF  FF7
1525A:  MOVLW  00
1525C:  MOVWF  FF8
1525E:  MOVLW  09
15260:  MOVLB  3
15262:  MOVWF  xA2
15264:  MOVLB  0
15266:  CALL   06CE
1526A:  MOVFF  78,3A2
1526E:  MOVLW  57
15270:  MOVLB  3
15272:  MOVWF  xA3
15274:  MOVLB  0
15276:  CALL   0700
1527A:  MOVLW  0D
1527C:  BTFSS  F9E.4
1527E:  BRA    1527C
15280:  MOVWF  FAD
15282:  MOVLW  0A
15284:  BTFSS  F9E.4
15286:  BRA    15284
15288:  MOVWF  FAD
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
1528A:  MOVLW  86
1528C:  MOVWF  FF6
1528E:  MOVLW  04
15290:  MOVWF  FF7
15292:  MOVLW  00
15294:  MOVWF  FF8
15296:  MOVLW  09
15298:  MOVLB  3
1529A:  MOVWF  xA2
1529C:  MOVLB  0
1529E:  CALL   06CE
152A2:  MOVFF  79,3A2
152A6:  MOVLW  57
152A8:  MOVLB  3
152AA:  MOVWF  xA3
152AC:  MOVLB  0
152AE:  CALL   0700
152B2:  MOVLW  0D
152B4:  BTFSS  F9E.4
152B6:  BRA    152B4
152B8:  MOVWF  FAD
152BA:  MOVLW  0A
152BC:  BTFSS  F9E.4
152BE:  BRA    152BC
152C0:  MOVWF  FAD
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
152C2:  MOVLW  94
152C4:  MOVWF  FF6
152C6:  MOVLW  04
152C8:  MOVWF  FF7
152CA:  MOVLW  00
152CC:  MOVWF  FF8
152CE:  MOVLW  0A
152D0:  MOVLB  3
152D2:  MOVWF  xA2
152D4:  MOVLB  0
152D6:  CALL   06CE
152DA:  MOVFF  7A,3A2
152DE:  MOVLW  57
152E0:  MOVLB  3
152E2:  MOVWF  xA3
152E4:  MOVLB  0
152E6:  CALL   0700
152EA:  MOVLW  0D
152EC:  BTFSS  F9E.4
152EE:  BRA    152EC
152F0:  MOVWF  FAD
152F2:  MOVLW  0A
152F4:  BTFSS  F9E.4
152F6:  BRA    152F4
152F8:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
152FA:  MOVLW  A4
152FC:  MOVWF  FF6
152FE:  MOVLW  04
15300:  MOVWF  FF7
15302:  MOVLW  00
15304:  MOVWF  FF8
15306:  MOVLW  0F
15308:  MOVLB  3
1530A:  MOVWF  xA2
1530C:  MOVLB  0
1530E:  CALL   06CE
15312:  MOVFF  7B,3A2
15316:  MOVLW  57
15318:  MOVLB  3
1531A:  MOVWF  xA3
1531C:  MOVLB  0
1531E:  CALL   0700
15322:  MOVLW  0D
15324:  BTFSS  F9E.4
15326:  BRA    15324
15328:  MOVWF  FAD
1532A:  MOVLW  0A
1532C:  BTFSS  F9E.4
1532E:  BRA    1532C
15330:  MOVWF  FAD
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
15332:  MOVLW  B8
15334:  MOVWF  FF6
15336:  MOVLW  04
15338:  MOVWF  FF7
1533A:  MOVLW  00
1533C:  MOVWF  FF8
1533E:  MOVLW  0F
15340:  MOVLB  3
15342:  MOVWF  xA2
15344:  MOVLB  0
15346:  CALL   06CE
1534A:  MOVFF  7C,3A2
1534E:  MOVLW  57
15350:  MOVLB  3
15352:  MOVWF  xA3
15354:  MOVLB  0
15356:  CALL   0700
1535A:  MOVLW  C9
1535C:  MOVWF  FF6
1535E:  MOVLW  04
15360:  MOVWF  FF7
15362:  MOVLW  00
15364:  MOVWF  FF8
15366:  MOVLW  04
15368:  MOVLB  3
1536A:  MOVWF  xA2
1536C:  MOVLB  0
1536E:  CALL   06CE
....................     
....................    return; 
15372:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
*
148D2:  MOVFF  FF2,339
148D6:  BCF    FF2.7
148D8:  MOVFF  66,FF8
148DC:  MOVFF  65,FF7
148E0:  MOVFF  64,FF6
148E4:  TBLRD*+
148E6:  MOVF   FF5,W
148E8:  TBLRD*
148EA:  MOVFF  FF5,03
148EE:  CLRF   FF8
148F0:  MOVLB  3
148F2:  BTFSC  x39.7
148F4:  BSF    FF2.7
148F6:  MOVWF  x31
148F8:  MOVFF  03,332
148FC:  MOVLW  02
148FE:  MOVLB  0
14900:  ADDWF  x64,W
14902:  MOVLB  3
14904:  MOVWF  x39
14906:  MOVLW  00
14908:  MOVLB  0
1490A:  ADDWFC x65,W
1490C:  MOVLB  3
1490E:  MOVWF  x3A
14910:  MOVLW  00
14912:  MOVLB  0
14914:  ADDWFC x66,W
14916:  MOVLB  3
14918:  MOVWF  x3B
1491A:  MOVLW  00
1491C:  MOVLB  0
1491E:  ADDWFC x67,W
14920:  MOVLB  3
14922:  MOVWF  x3C
14924:  MOVFF  FF2,33D
14928:  BCF    FF2.7
1492A:  MOVFF  33B,FF8
1492E:  MOVFF  33A,FF7
14932:  MOVFF  339,FF6
14936:  TBLRD*+
14938:  MOVF   FF5,W
1493A:  TBLRD*
1493C:  MOVFF  FF5,03
14940:  CLRF   FF8
14942:  BTFSC  x3D.7
14944:  BSF    FF2.7
14946:  MOVWF  x33
14948:  MOVFF  03,334
1494C:  CLRF   x39
1494E:  CLRF   x3A
14950:  CLRF   02
14952:  CLRF   03
14954:  MOVF   x33,W
14956:  IORWF  x39,W
14958:  MOVWF  x35
1495A:  MOVF   x34,W
1495C:  IORWF  x3A,W
1495E:  MOVWF  x36
14960:  MOVF   02,W
14962:  IORWF  x31,W
14964:  MOVWF  x37
14966:  MOVF   03,W
14968:  IORWF  x32,W
1496A:  MOVWF  x38
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
1496C:  INCFSZ x35,W
1496E:  BRA    1497E
14970:  INCFSZ x36,W
14972:  BRA    1497E
14974:  INCFSZ x37,W
14976:  BRA    1497E
14978:  INCFSZ x38,W
1497A:  BRA    1497E
1497C:  BRA    1498E
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
1497E:  MOVFF  338,33
14982:  MOVFF  337,32
14986:  MOVFF  336,31
1498A:  MOVFF  335,30
....................    } 
....................    return; 
1498E:  MOVLB  0
14990:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
*
146F6:  MOVFF  68,D3
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
146FA:  MOVFF  6A,D4
....................    flag_info_bffr[2] = PASSED_DAYS; 
146FE:  MOVFF  69,D5
....................    flag_info_bffr[3] = RESERVE_CHECK; 
14702:  MOVFF  6B,D6
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
14706:  MOVFF  6D,D7
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
1470A:  MOVFF  6C,D8
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
1470E:  MOVFF  6E,D9
....................    flag_info_bffr[7] = MISSION_DETAIL; 
14712:  MOVFF  6F,DA
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
14716:  MOVFF  75,DB
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
1471A:  MOVFF  76,DC
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
1471E:  MOVFF  77,DD
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
14722:  MOVFF  78,DE
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
14726:  MOVFF  79,DF
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
1472A:  MOVFF  7A,E0
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
1472E:  MOVFF  7B,E1
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
14732:  MOVFF  7C,E2
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
14736:  BCF    F92.5
14738:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
1473A:  BCF    F94.4
1473C:  BCF    F8B.4
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
1473E:  MOVFF  3B,392
14742:  MOVFF  3A,391
14746:  MOVFF  39,390
1474A:  MOVFF  38,38F
1474E:  CALL   11914
....................    delay_ms(200); 
14752:  MOVLW  C8
14754:  MOVLB  3
14756:  MOVWF  x98
14758:  MOVLB  0
1475A:  CALL   063E
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
1475E:  MOVLB  3
14760:  CLRF   x85
14762:  MOVF   x85,W
14764:  SUBLW  0F
14766:  BNC   147B6
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
14768:  MOVF   x85,W
1476A:  ADDWF  38,W
1476C:  MOVWF  x86
1476E:  MOVLW  00
14770:  ADDWFC 39,W
14772:  MOVWF  x87
14774:  MOVLW  00
14776:  ADDWFC 3A,W
14778:  MOVWF  x88
1477A:  MOVLW  00
1477C:  ADDWFC 3B,W
1477E:  MOVWF  x89
14780:  CLRF   03
14782:  MOVF   x85,W
14784:  ADDLW  D3
14786:  MOVWF  FE9
14788:  MOVLW  00
1478A:  ADDWFC 03,W
1478C:  MOVWF  FEA
1478E:  MOVFF  FEF,394
14792:  MOVFF  389,393
14796:  MOVFF  388,392
1479A:  MOVFF  387,391
1479E:  MOVFF  386,390
147A2:  MOVLB  0
147A4:  CALL   11B8C
....................       delay_us(10); 
147A8:  MOVLW  0D
147AA:  MOVWF  00
147AC:  DECFSZ 00,F
147AE:  BRA    147AC
147B0:  MOVLB  3
147B2:  INCF   x85,F
147B4:  BRA    14762
....................    } 
....................    delay_ms(10); 
147B6:  MOVLW  0A
147B8:  MOVWF  x98
147BA:  MOVLB  0
147BC:  CALL   063E
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
147C0:  MOVFF  3B,392
147C4:  MOVFF  3A,391
147C8:  MOVFF  39,390
147CC:  MOVFF  38,38F
147D0:  CALL   119BE
....................    delay_ms(200); 
147D4:  MOVLW  C8
147D6:  MOVLB  3
147D8:  MOVWF  x98
147DA:  MOVLB  0
147DC:  CALL   063E
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
147E0:  MOVLB  3
147E2:  CLRF   x85
147E4:  MOVF   x85,W
147E6:  SUBLW  0F
147E8:  BNC   14838
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
147EA:  MOVF   x85,W
147EC:  ADDWF  38,W
147EE:  MOVWF  x86
147F0:  MOVLW  00
147F2:  ADDWFC 39,W
147F4:  MOVWF  x87
147F6:  MOVLW  00
147F8:  ADDWFC 3A,W
147FA:  MOVWF  x88
147FC:  MOVLW  00
147FE:  ADDWFC 3B,W
14800:  MOVWF  x89
14802:  CLRF   03
14804:  MOVF   x85,W
14806:  ADDLW  D3
14808:  MOVWF  FE9
1480A:  MOVLW  00
1480C:  ADDWFC 03,W
1480E:  MOVWF  FEA
14810:  MOVFF  FEF,394
14814:  MOVFF  389,393
14818:  MOVFF  388,392
1481C:  MOVFF  387,391
14820:  MOVFF  386,390
14824:  MOVLB  0
14826:  CALL   11C0C
....................       delay_us(10); 
1482A:  MOVLW  0D
1482C:  MOVWF  00
1482E:  DECFSZ 00,F
14830:  BRA    1482E
14832:  MOVLB  3
14834:  INCF   x85,F
14836:  BRA    147E4
....................    } 
....................    delay_ms(10); 
14838:  MOVLW  0A
1483A:  MOVWF  x98
1483C:  MOVLB  0
1483E:  CALL   063E
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
14842:  MOVFF  3B,392
14846:  MOVFF  3A,391
1484A:  MOVFF  39,390
1484E:  MOVFF  38,38F
14852:  CALL   11A68
....................    delay_ms(200); 
14856:  MOVLW  C8
14858:  MOVLB  3
1485A:  MOVWF  x98
1485C:  MOVLB  0
1485E:  CALL   063E
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
14862:  MOVLB  3
14864:  CLRF   x85
14866:  MOVF   x85,W
14868:  SUBLW  0F
1486A:  BNC   148BA
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
1486C:  MOVF   x85,W
1486E:  ADDWF  38,W
14870:  MOVWF  x86
14872:  MOVLW  00
14874:  ADDWFC 39,W
14876:  MOVWF  x87
14878:  MOVLW  00
1487A:  ADDWFC 3A,W
1487C:  MOVWF  x88
1487E:  MOVLW  00
14880:  ADDWFC 3B,W
14882:  MOVWF  x89
14884:  CLRF   03
14886:  MOVF   x85,W
14888:  ADDLW  D3
1488A:  MOVWF  FE9
1488C:  MOVLW  00
1488E:  ADDWFC 03,W
14890:  MOVWF  FEA
14892:  MOVFF  FEF,394
14896:  MOVFF  389,393
1489A:  MOVFF  388,392
1489E:  MOVFF  387,391
148A2:  MOVFF  386,390
148A6:  MOVLB  0
148A8:  CALL   11C8C
....................       delay_us(10); 
148AC:  MOVLW  0D
148AE:  MOVWF  00
148B0:  DECFSZ 00,F
148B2:  BRA    148B0
148B4:  MOVLB  3
148B6:  INCF   x85,F
148B8:  BRA    14866
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
148BA:  BCF    F94.4
148BC:  BSF    F8B.4
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
148BE:  MOVLW  CE
148C0:  MOVWF  FF6
148C2:  MOVLW  04
148C4:  MOVWF  FF7
148C6:  MOVLW  00
148C8:  MOVWF  FF8
148CA:  MOVLB  0
148CC:  CALL   06A4
....................    return; 
148D0:  RETURN 0
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
*
162AA:  CLRF   x6A
162AC:  CLRF   x69
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
162AE:  CLRF   x75
....................    Kill_FLAG_FAB = 0; 
162B0:  CLRF   x76
....................    FIRST_HSSC_DONE = 0; 
162B2:  CLRF   x77
....................    AUTO_CAM_DONE = 0; 
162B4:  CLRF   x78
....................    AUTO_MBP_DONE = 0; 
162B6:  CLRF   x79
....................    AUTO_ADCS_DONE = 0; 
162B8:  CLRF   x7A
....................    ANT_DEP_STATUS = 0; 
162BA:  CLRF   x7B
....................    UPLINK_SUCCESS = 0; 
162BC:  CLRF   x7C
....................    STORE_FLAG_INFO(); 
162BE:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM(); 
162C2:  CALL   12FE4
....................    return; 
162C6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
*
14992:  BCF    F94.4
14994:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //Main side 
14996:  BCF    F92.5
14998:  BCF    F89.5
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
1499A:  MOVLB  3
1499C:  CLRF   xAB
1499E:  CLRF   xAA
149A0:  CLRF   xA9
149A2:  CLRF   xA8
149A4:  MOVLB  0
149A6:  CALL   11B04
149AA:  INCFSZ 01,W
149AC:  BRA    14ABA
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
149AE:  MOVLB  3
149B0:  CLRF   x52
149B2:  CLRF   x51
149B4:  CLRF   x50
149B6:  CLRF   x4F
149B8:  MOVLB  0
149BA:  CALL   12442
149BE:  INCFSZ 01,W
149C0:  BRA    14A52
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
149C2:  MOVLB  3
149C4:  CLRF   x8C
149C6:  CLRF   x8B
149C8:  CLRF   x8A
149CA:  CLRF   x89
149CC:  MOVLB  0
149CE:  CALL   11800
149D2:  INCFSZ 01,W
149D4:  BRA    149EA
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
149D6:  RCALL  148D2
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
149D8:  MOVFF  33,32D
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
149DC:  MOVFF  32,32E
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
149E0:  MOVFF  31,32F
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
149E4:  MOVFF  30,330
....................          }else{ 
149E8:  BRA    14A50
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
149EA:  MOVLB  3
149EC:  CLRF   x8C
149EE:  CLRF   x8B
149F0:  CLRF   x8A
149F2:  CLRF   x89
149F4:  MOVLB  0
149F6:  CALL   11800
149FA:  MOVFF  01,32D
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
149FE:  MOVLB  3
14A00:  CLRF   x8C
14A02:  CLRF   x8B
14A04:  CLRF   x8A
14A06:  MOVLW  01
14A08:  MOVWF  x89
14A0A:  MOVLB  0
14A0C:  CALL   11800
14A10:  MOVFF  01,32E
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
14A14:  MOVLB  3
14A16:  CLRF   x8C
14A18:  CLRF   x8B
14A1A:  CLRF   x8A
14A1C:  MOVLW  02
14A1E:  MOVWF  x89
14A20:  MOVLB  0
14A22:  CALL   11800
14A26:  MOVFF  01,32F
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
14A2A:  MOVLB  3
14A2C:  CLRF   x8C
14A2E:  CLRF   x8B
14A30:  CLRF   x8A
14A32:  MOVLW  03
14A34:  MOVWF  x89
14A36:  MOVLB  0
14A38:  CALL   11800
14A3C:  MOVFF  01,330
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14A40:  MOVFF  32D,33
14A44:  MOVFF  32E,32
14A48:  MOVFF  32F,31
14A4C:  MOVFF  330,30
....................          } 
....................       }else{ 
14A50:  BRA    14AB8
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
14A52:  MOVLB  3
14A54:  CLRF   x52
14A56:  CLRF   x51
14A58:  CLRF   x50
14A5A:  CLRF   x4F
14A5C:  MOVLB  0
14A5E:  CALL   12442
14A62:  MOVFF  01,32D
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
14A66:  MOVLB  3
14A68:  CLRF   x52
14A6A:  CLRF   x51
14A6C:  CLRF   x50
14A6E:  MOVLW  01
14A70:  MOVWF  x4F
14A72:  MOVLB  0
14A74:  CALL   12442
14A78:  MOVFF  01,32E
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
14A7C:  MOVLB  3
14A7E:  CLRF   x52
14A80:  CLRF   x51
14A82:  CLRF   x50
14A84:  MOVLW  02
14A86:  MOVWF  x4F
14A88:  MOVLB  0
14A8A:  CALL   12442
14A8E:  MOVFF  01,32F
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
14A92:  MOVLB  3
14A94:  CLRF   x52
14A96:  CLRF   x51
14A98:  CLRF   x50
14A9A:  MOVLW  03
14A9C:  MOVWF  x4F
14A9E:  MOVLB  0
14AA0:  CALL   12442
14AA4:  MOVFF  01,330
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14AA8:  MOVFF  32D,33
14AAC:  MOVFF  32E,32
14AB0:  MOVFF  32F,31
14AB4:  MOVFF  330,30
....................       } 
....................    }else{ 
14AB8:  BRA    14B20
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
14ABA:  MOVLB  3
14ABC:  CLRF   xAB
14ABE:  CLRF   xAA
14AC0:  CLRF   xA9
14AC2:  CLRF   xA8
14AC4:  MOVLB  0
14AC6:  CALL   11B04
14ACA:  MOVFF  01,32D
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
14ACE:  MOVLB  3
14AD0:  CLRF   xAB
14AD2:  CLRF   xAA
14AD4:  CLRF   xA9
14AD6:  MOVLW  01
14AD8:  MOVWF  xA8
14ADA:  MOVLB  0
14ADC:  CALL   11B04
14AE0:  MOVFF  01,32E
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
14AE4:  MOVLB  3
14AE6:  CLRF   xAB
14AE8:  CLRF   xAA
14AEA:  CLRF   xA9
14AEC:  MOVLW  02
14AEE:  MOVWF  xA8
14AF0:  MOVLB  0
14AF2:  CALL   11B04
14AF6:  MOVFF  01,32F
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
14AFA:  MOVLB  3
14AFC:  CLRF   xAB
14AFE:  CLRF   xAA
14B00:  CLRF   xA9
14B02:  MOVLW  03
14B04:  MOVWF  xA8
14B06:  MOVLB  0
14B08:  CALL   11B04
14B0C:  MOVFF  01,330
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14B10:  MOVFF  32D,33
14B14:  MOVFF  32E,32
14B18:  MOVFF  32F,31
14B1C:  MOVFF  330,30
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
14B20:  MOVLB  3
14B22:  CLRF   x2C
14B24:  MOVF   x2C,W
14B26:  SUBLW  03
14B28:  BNC   14B9A
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
14B2A:  CLRF   03
14B2C:  MOVF   x2C,W
14B2E:  ADDLW  2D
14B30:  MOVWF  FE9
14B32:  MOVLW  03
14B34:  ADDWFC 03,W
14B36:  MOVWF  FEA
14B38:  MOVFF  FEF,394
14B3C:  CLRF   x93
14B3E:  CLRF   x92
14B40:  CLRF   x91
14B42:  MOVFF  32C,390
14B46:  MOVLB  0
14B48:  CALL   11B8C
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
14B4C:  CLRF   03
14B4E:  MOVLB  3
14B50:  MOVF   x2C,W
14B52:  ADDLW  2D
14B54:  MOVWF  FE9
14B56:  MOVLW  03
14B58:  ADDWFC 03,W
14B5A:  MOVWF  FEA
14B5C:  MOVFF  FEF,394
14B60:  CLRF   x93
14B62:  CLRF   x92
14B64:  CLRF   x91
14B66:  MOVFF  32C,390
14B6A:  MOVLB  0
14B6C:  CALL   11C0C
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
14B70:  CLRF   03
14B72:  MOVLB  3
14B74:  MOVF   x2C,W
14B76:  ADDLW  2D
14B78:  MOVWF  FE9
14B7A:  MOVLW  03
14B7C:  ADDWFC 03,W
14B7E:  MOVWF  FEA
14B80:  MOVFF  FEF,394
14B84:  CLRF   x93
14B86:  CLRF   x92
14B88:  CLRF   x91
14B8A:  MOVFF  32C,390
14B8E:  MOVLB  0
14B90:  CALL   11C8C
14B94:  MOVLB  3
14B96:  INCF   x2C,F
14B98:  BRA    14B24
....................    } 
....................    output_high(PIN_C4); 
14B9A:  BCF    F94.4
14B9C:  BSF    F8B.4
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
14B9E:  MOVLW  EA
14BA0:  MOVWF  FF6
14BA2:  MOVLW  04
14BA4:  MOVWF  FF7
14BA6:  MOVLW  00
14BA8:  MOVWF  FF8
14BAA:  MOVLW  18
14BAC:  MOVWF  xA2
14BAE:  MOVLB  0
14BB0:  CALL   06CE
14BB4:  MOVFF  33,3A2
14BB8:  MOVLW  57
14BBA:  MOVLB  3
14BBC:  MOVWF  xA3
14BBE:  MOVLB  0
14BC0:  CALL   0700
14BC4:  MOVFF  32,3A2
14BC8:  MOVLW  57
14BCA:  MOVLB  3
14BCC:  MOVWF  xA3
14BCE:  MOVLB  0
14BD0:  CALL   0700
14BD4:  MOVFF  31,3A2
14BD8:  MOVLW  57
14BDA:  MOVLB  3
14BDC:  MOVWF  xA3
14BDE:  MOVLB  0
14BE0:  CALL   0700
14BE4:  MOVFF  30,3A2
14BE8:  MOVLW  57
14BEA:  MOVLB  3
14BEC:  MOVWF  xA3
14BEE:  MOVLB  0
14BF0:  CALL   0700
14BF4:  MOVLW  0D
14BF6:  BTFSS  F9E.4
14BF8:  BRA    14BF6
14BFA:  MOVWF  FAD
14BFC:  MOVLW  0A
14BFE:  BTFSS  F9E.4
14C00:  BRA    14BFE
14C02:  MOVWF  FAD
....................    return; 
14C04:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
*
14000:  MOVLW  25
14002:  ADDWF  30,W
14004:  MOVLB  3
14006:  MOVWF  x8F
14008:  MOVLW  00
1400A:  ADDWFC 31,W
1400C:  MOVWF  x90
1400E:  MOVLW  00
14010:  ADDWFC 32,W
14012:  MOVWF  x91
14014:  MOVLW  00
14016:  ADDWFC 33,W
14018:  MOVWF  x92
1401A:  MOVWF  xAB
1401C:  MOVFF  391,3AA
14020:  MOVFF  390,3A9
14024:  MOVFF  38F,3A8
14028:  MOVLB  0
1402A:  CALL   11B04
1402E:  MOVFF  01,38F
14032:  MOVLW  26
14034:  ADDWF  30,W
14036:  MOVLB  3
14038:  MOVWF  x90
1403A:  MOVLW  00
1403C:  ADDWFC 31,W
1403E:  MOVWF  x91
14040:  MOVLW  00
14042:  ADDWFC 32,W
14044:  MOVWF  x92
14046:  MOVLW  00
14048:  ADDWFC 33,W
1404A:  MOVWF  x93
1404C:  MOVWF  xAB
1404E:  MOVFF  392,3AA
14052:  MOVFF  391,3A9
14056:  MOVFF  390,3A8
1405A:  MOVLB  0
1405C:  CALL   11B04
14060:  MOVFF  01,390
14064:  MOVLW  27
14066:  ADDWF  30,W
14068:  MOVLB  3
1406A:  MOVWF  x91
1406C:  MOVLW  00
1406E:  ADDWFC 31,W
14070:  MOVWF  x92
14072:  MOVLW  00
14074:  ADDWFC 32,W
14076:  MOVWF  x93
14078:  MOVLW  00
1407A:  ADDWFC 33,W
1407C:  MOVWF  x94
1407E:  MOVWF  xAB
14080:  MOVFF  393,3AA
14084:  MOVFF  392,3A9
14088:  MOVFF  391,3A8
1408C:  MOVLB  0
1408E:  CALL   11B04
14092:  MOVFF  01,391
14096:  MOVLW  28
14098:  ADDWF  30,W
1409A:  MOVLB  3
1409C:  MOVWF  x92
1409E:  MOVLW  00
140A0:  ADDWFC 31,W
140A2:  MOVWF  x93
140A4:  MOVLW  00
140A6:  ADDWFC 32,W
140A8:  MOVWF  x94
140AA:  MOVLW  00
140AC:  ADDWFC 33,W
140AE:  MOVWF  x95
140B0:  MOVWF  xAB
140B2:  MOVFF  394,3AA
140B6:  MOVFF  393,3A9
140BA:  MOVFF  392,3A8
140BE:  MOVLB  0
140C0:  CALL   11B04
140C4:  MOVFF  38F,389
140C8:  MOVFF  390,388
140CC:  MOVFF  391,387
140D0:  MOVFF  01,386
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
140D4:  MOVLW  08
140D6:  MOVWF  FF6
140D8:  MOVLW  05
140DA:  MOVWF  FF7
140DC:  MOVLW  00
140DE:  MOVWF  FF8
140E0:  MOVLW  0B
140E2:  MOVLB  3
140E4:  MOVWF  xA2
140E6:  MOVLB  0
140E8:  CALL   06CE
140EC:  MOVFF  389,3A2
140F0:  MOVLW  57
140F2:  MOVLB  3
140F4:  MOVWF  xA3
140F6:  MOVLB  0
140F8:  CALL   0700
140FC:  MOVFF  388,3A2
14100:  MOVLW  57
14102:  MOVLB  3
14104:  MOVWF  xA3
14106:  MOVLB  0
14108:  CALL   0700
1410C:  MOVFF  387,3A2
14110:  MOVLW  57
14112:  MOVLB  3
14114:  MOVWF  xA3
14116:  MOVLB  0
14118:  CALL   0700
1411C:  MOVFF  386,3A2
14120:  MOVLW  57
14122:  MOVLB  3
14124:  MOVWF  xA3
14126:  MOVLB  0
14128:  CALL   0700
1412C:  MOVLW  0D
1412E:  BTFSS  F9E.4
14130:  BRA    1412E
14132:  MOVWF  FAD
14134:  MOVLW  0A
14136:  BTFSS  F9E.4
14138:  BRA    14136
1413A:  MOVWF  FAD
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
1413C:  MOVLB  3
1413E:  MOVF   x89,F
14140:  BNZ   14162
14142:  MOVF   x88,W
14144:  SUBLW  00
14146:  BTFSC  FD8.0
14148:  BRA    142CC
1414A:  XORLW  FF
1414C:  BNZ   14162
1414E:  MOVF   x87,W
14150:  SUBLW  72
14152:  BTFSC  FD8.0
14154:  BRA    142CC
14156:  XORLW  FF
14158:  BNZ   14162
1415A:  MOVF   x86,W
1415C:  SUBLW  18
1415E:  BTFSC  FD8.0
14160:  BRA    142CC
14162:  INCFSZ x86,W
14164:  BRA    14174
14166:  INCFSZ x87,W
14168:  BRA    14174
1416A:  INCFSZ x88,W
1416C:  BRA    14174
1416E:  INCFSZ x89,W
14170:  BRA    14174
14172:  BRA    142CC
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
14174:  BCF    F92.5
14176:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
14178:  BCF    F94.4
1417A:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_OF(0); 
1417C:  CLRF   x92
1417E:  CLRF   x91
14180:  CLRF   x90
14182:  CLRF   x8F
14184:  MOVLB  0
14186:  CALL   11914
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
1418A:  MOVLB  3
1418C:  CLRF   x92
1418E:  CLRF   x91
14190:  CLRF   x90
14192:  CLRF   x8F
14194:  MOVLB  0
14196:  CALL   119BE
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
1419A:  MOVLB  3
1419C:  CLRF   x92
1419E:  CLRF   x91
141A0:  CLRF   x90
141A2:  CLRF   x8F
141A4:  MOVLB  0
141A6:  CALL   11A68
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
141AA:  CLRF   37
141AC:  CLRF   36
141AE:  CLRF   35
141B0:  CLRF   34
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
141B2:  MOVLW  10
141B4:  ADDWF  31,F
141B6:  MOVLW  00
141B8:  ADDWFC 32,F
141BA:  ADDWFC 33,F
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
141BC:  BCF    F94.4
141BE:  BSF    F8B.4
....................        
....................       unsigned int8 address_place[4] = {}; 
141C0:  MOVLB  3
141C2:  CLRF   x8A
141C4:  CLRF   x8B
141C6:  CLRF   x8C
141C8:  CLRF   x8D
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
141CA:  MOVFF  33,38A
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
141CE:  MOVFF  32,38B
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
141D2:  MOVFF  31,38C
....................       address_place[3] = ADD_INFO_ADDRESS; 
141D6:  MOVFF  30,38D
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
141DA:  BCF    F92.5
141DC:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
141DE:  BCF    F94.4
141E0:  BCF    F8B.4
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
141E2:  CLRF   x8E
141E4:  MOVF   x8E,W
141E6:  SUBLW  03
141E8:  BNC   14272
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
141EA:  CLRF   03
141EC:  MOVF   x8E,W
141EE:  ADDLW  8A
141F0:  MOVWF  FE9
141F2:  MOVLW  03
141F4:  ADDWFC 03,W
141F6:  MOVWF  FEA
141F8:  MOVFF  FEF,394
141FC:  CLRF   x93
141FE:  CLRF   x92
14200:  CLRF   x91
14202:  MOVFF  38E,390
14206:  MOVLB  0
14208:  CALL   11B8C
....................          delay_us(10); 
1420C:  MOVLW  0D
1420E:  MOVWF  00
14210:  DECFSZ 00,F
14212:  BRA    14210
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
14214:  CLRF   03
14216:  MOVLB  3
14218:  MOVF   x8E,W
1421A:  ADDLW  8A
1421C:  MOVWF  FE9
1421E:  MOVLW  03
14220:  ADDWFC 03,W
14222:  MOVWF  FEA
14224:  MOVFF  FEF,394
14228:  CLRF   x93
1422A:  CLRF   x92
1422C:  CLRF   x91
1422E:  MOVFF  38E,390
14232:  MOVLB  0
14234:  CALL   11C0C
....................          delay_us(10); 
14238:  MOVLW  0D
1423A:  MOVWF  00
1423C:  DECFSZ 00,F
1423E:  BRA    1423C
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
14240:  CLRF   03
14242:  MOVLB  3
14244:  MOVF   x8E,W
14246:  ADDLW  8A
14248:  MOVWF  FE9
1424A:  MOVLW  03
1424C:  ADDWFC 03,W
1424E:  MOVWF  FEA
14250:  MOVFF  FEF,394
14254:  CLRF   x93
14256:  CLRF   x92
14258:  CLRF   x91
1425A:  MOVFF  38E,390
1425E:  MOVLB  0
14260:  CALL   11C8C
....................          delay_us(10); 
14264:  MOVLW  0D
14266:  MOVWF  00
14268:  DECFSZ 00,F
1426A:  BRA    14268
1426C:  MOVLB  3
1426E:  INCF   x8E,F
14270:  BRA    141E4
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
14272:  BCF    F94.4
14274:  BSF    F8B.4
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
14276:  MOVLW  1A
14278:  MOVWF  FF6
1427A:  MOVLW  05
1427C:  MOVWF  FF7
1427E:  MOVLW  00
14280:  MOVWF  FF8
14282:  MOVLB  0
14284:  CALL   06A4
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
14288:  MOVLB  3
1428A:  CLRF   x8E
1428C:  MOVF   x8E,W
1428E:  SUBLW  03
14290:  BNC   142BC
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
14292:  CLRF   xAB
14294:  CLRF   xAA
14296:  CLRF   xA9
14298:  MOVFF  38E,3A8
1429C:  MOVLB  0
1429E:  CALL   11B04
142A2:  MOVFF  01,38F
142A6:  MOVFF  01,3A2
142AA:  MOVLW  57
142AC:  MOVLB  3
142AE:  MOVWF  xA3
142B0:  MOVLB  0
142B2:  CALL   0700
142B6:  MOVLB  3
142B8:  INCF   x8E,F
142BA:  BRA    1428C
....................       } 
....................       fprintf(PC,"\r\n"); 
142BC:  MOVLW  0D
142BE:  BTFSS  F9E.4
142C0:  BRA    142BE
142C2:  MOVWF  FAD
142C4:  MOVLW  0A
142C6:  BTFSS  F9E.4
142C8:  BRA    142C6
142CA:  MOVWF  FAD
....................    } 
....................     
....................    return; 
142CC:  MOVLB  0
142CE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
*
14C06:  MOVLB  3
14C08:  CLRF   x2E
14C0A:  MOVF   x2E,W
14C0C:  SUBLW  0F
14C0E:  BNC   14C62
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
14C10:  CLRF   03
14C12:  MOVF   x2E,W
14C14:  ADDLW  D3
14C16:  MOVWF  01
14C18:  MOVLW  00
14C1A:  ADDWFC 03,F
14C1C:  MOVFF  01,32F
14C20:  MOVFF  03,330
14C24:  MOVF   x2E,W
14C26:  ADDWF  38,W
14C28:  MOVWF  x31
14C2A:  MOVLW  00
14C2C:  ADDWFC 39,W
14C2E:  MOVWF  x32
14C30:  MOVLW  00
14C32:  ADDWFC 3A,W
14C34:  MOVWF  x33
14C36:  MOVLW  00
14C38:  ADDWFC 3B,W
14C3A:  MOVWF  x34
14C3C:  MOVWF  xAB
14C3E:  MOVFF  333,3AA
14C42:  MOVFF  332,3A9
14C46:  MOVFF  331,3A8
14C4A:  MOVLB  0
14C4C:  CALL   11B04
14C50:  MOVFF  330,FEA
14C54:  MOVFF  32F,FE9
14C58:  MOVFF  01,FEF
14C5C:  MOVLB  3
14C5E:  INCF   x2E,F
14C60:  BRA    14C0A
....................       //delay_ms(1); 
....................    } 
....................    return; 
14C62:  MOVLB  0
14C64:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
*
142D0:  MOVLW  32
142D2:  MOVWF  FF6
142D4:  MOVLW  05
142D6:  MOVWF  FF7
142D8:  MOVLW  00
142DA:  MOVWF  FF8
142DC:  CALL   06A4
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
142E0:  MOVLW  01
142E2:  ADDWF  34,F
142E4:  BTFSC  FD8.0
142E6:  INCF   35,F
142E8:  BTFSC  FD8.2
142EA:  INCF   36,F
142EC:  BTFSC  FD8.2
142EE:  INCF   37,F
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
142F0:  RCALL  14000
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
142F2:  MOVFF  3B,AA
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
142F6:  MOVFF  3A,AB
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
142FA:  MOVFF  39,AC
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
142FE:  MOVFF  38,AD
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
14302:  MOVFF  3F,AE
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
14306:  MOVFF  3E,AF
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
1430A:  MOVFF  3D,B0
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
1430E:  MOVFF  3C,B1
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
14312:  MOVFF  43,B2
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
14316:  MOVFF  42,B3
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
1431A:  MOVFF  41,B4
....................    sec_add_bfr[11] = SAT_LOG; 
1431E:  MOVFF  40,B5
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
14322:  MOVFF  47,B6
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
14326:  MOVFF  46,B7
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
1432A:  MOVFF  45,B8
....................    sec_add_bfr[15] = CAM_ADDRESS; 
1432E:  MOVFF  44,B9
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
14332:  MOVFF  4B,BA
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
14336:  MOVFF  4A,BB
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
1433A:  MOVFF  49,BC
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
1433E:  MOVFF  48,BD
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
14342:  MOVFF  4F,BE
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
14346:  MOVFF  4E,BF
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
1434A:  MOVFF  4D,C0
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
1434E:  MOVFF  4C,C1
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
14352:  MOVFF  53,C2
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
14356:  MOVFF  52,C3
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
1435A:  MOVFF  51,C4
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
1435E:  MOVFF  50,C5
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
14362:  MOVFF  5B,C6
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
14366:  MOVFF  5A,C7
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
1436A:  MOVFF  59,C8
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
1436E:  MOVFF  58,C9
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
14372:  MOVFF  5F,CA
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
14376:  MOVFF  5E,CB
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
1437A:  MOVFF  5D,CC
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
1437E:  MOVFF  5C,CD
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
14382:  MOVFF  68,CE
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
14386:  MOVFF  37,CF
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
1438A:  MOVFF  36,D0
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
1438E:  MOVFF  35,D1
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
14392:  MOVFF  34,D2
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
14396:  BCF    F92.5
14398:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
1439A:  BCF    F94.4
1439C:  BCF    F8B.4
....................    int8 num = 0; 
1439E:  MOVLB  3
143A0:  CLRF   x85
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
143A2:  MOVFF  33,392
143A6:  MOVFF  32,391
143AA:  MOVFF  31,390
143AE:  MOVFF  30,38F
143B2:  MOVLB  0
143B4:  CALL   11914
....................    delay_ms(200); 
143B8:  MOVLW  C8
143BA:  MOVLB  3
143BC:  MOVWF  x98
143BE:  MOVLB  0
143C0:  CALL   063E
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
143C4:  MOVLB  3
143C6:  CLRF   x85
143C8:  MOVF   x85,W
143CA:  SUBLW  28
143CC:  BNC   1441C
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
143CE:  MOVF   x85,W
143D0:  ADDWF  30,W
143D2:  MOVWF  x86
143D4:  MOVLW  00
143D6:  ADDWFC 31,W
143D8:  MOVWF  x87
143DA:  MOVLW  00
143DC:  ADDWFC 32,W
143DE:  MOVWF  x88
143E0:  MOVLW  00
143E2:  ADDWFC 33,W
143E4:  MOVWF  x89
143E6:  CLRF   03
143E8:  MOVF   x85,W
143EA:  ADDLW  AA
143EC:  MOVWF  FE9
143EE:  MOVLW  00
143F0:  ADDWFC 03,W
143F2:  MOVWF  FEA
143F4:  MOVFF  FEF,394
143F8:  MOVFF  389,393
143FC:  MOVFF  388,392
14400:  MOVFF  387,391
14404:  MOVFF  386,390
14408:  MOVLB  0
1440A:  CALL   11B8C
....................       delay_us(10); 
1440E:  MOVLW  0D
14410:  MOVWF  00
14412:  DECFSZ 00,F
14414:  BRA    14412
14416:  MOVLB  3
14418:  INCF   x85,F
1441A:  BRA    143C8
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
1441C:  MOVFF  33,392
14420:  MOVFF  32,391
14424:  MOVFF  31,390
14428:  MOVFF  30,38F
1442C:  MOVLB  0
1442E:  CALL   119BE
....................    delay_ms(200); 
14432:  MOVLW  C8
14434:  MOVLB  3
14436:  MOVWF  x98
14438:  MOVLB  0
1443A:  CALL   063E
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
1443E:  MOVLB  3
14440:  CLRF   x85
14442:  MOVF   x85,W
14444:  SUBLW  28
14446:  BNC   14496
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
14448:  MOVF   x85,W
1444A:  ADDWF  30,W
1444C:  MOVWF  x86
1444E:  MOVLW  00
14450:  ADDWFC 31,W
14452:  MOVWF  x87
14454:  MOVLW  00
14456:  ADDWFC 32,W
14458:  MOVWF  x88
1445A:  MOVLW  00
1445C:  ADDWFC 33,W
1445E:  MOVWF  x89
14460:  CLRF   03
14462:  MOVF   x85,W
14464:  ADDLW  AA
14466:  MOVWF  FE9
14468:  MOVLW  00
1446A:  ADDWFC 03,W
1446C:  MOVWF  FEA
1446E:  MOVFF  FEF,394
14472:  MOVFF  389,393
14476:  MOVFF  388,392
1447A:  MOVFF  387,391
1447E:  MOVFF  386,390
14482:  MOVLB  0
14484:  CALL   11C0C
....................       delay_us(10); 
14488:  MOVLW  0D
1448A:  MOVWF  00
1448C:  DECFSZ 00,F
1448E:  BRA    1448C
14490:  MOVLB  3
14492:  INCF   x85,F
14494:  BRA    14442
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
14496:  MOVFF  33,392
1449A:  MOVFF  32,391
1449E:  MOVFF  31,390
144A2:  MOVFF  30,38F
144A6:  MOVLB  0
144A8:  CALL   11A68
....................    delay_ms(200); 
144AC:  MOVLW  C8
144AE:  MOVLB  3
144B0:  MOVWF  x98
144B2:  MOVLB  0
144B4:  CALL   063E
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
144B8:  MOVLB  3
144BA:  CLRF   x85
144BC:  MOVF   x85,W
144BE:  SUBLW  28
144C0:  BNC   14510
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
144C2:  MOVF   x85,W
144C4:  ADDWF  30,W
144C6:  MOVWF  x86
144C8:  MOVLW  00
144CA:  ADDWFC 31,W
144CC:  MOVWF  x87
144CE:  MOVLW  00
144D0:  ADDWFC 32,W
144D2:  MOVWF  x88
144D4:  MOVLW  00
144D6:  ADDWFC 33,W
144D8:  MOVWF  x89
144DA:  CLRF   03
144DC:  MOVF   x85,W
144DE:  ADDLW  AA
144E0:  MOVWF  FE9
144E2:  MOVLW  00
144E4:  ADDWFC 03,W
144E6:  MOVWF  FEA
144E8:  MOVFF  FEF,394
144EC:  MOVFF  389,393
144F0:  MOVFF  388,392
144F4:  MOVFF  387,391
144F8:  MOVFF  386,390
144FC:  MOVLB  0
144FE:  CALL   11C8C
....................       delay_us(10); 
14502:  MOVLW  0D
14504:  MOVWF  00
14506:  DECFSZ 00,F
14508:  BRA    14506
1450A:  MOVLB  3
1450C:  INCF   x85,F
1450E:  BRA    144BC
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
14510:  BCF    F94.4
14512:  BSF    F8B.4
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
14514:  MOVLW  56
14516:  MOVWF  FF6
14518:  MOVLW  05
1451A:  MOVWF  FF7
1451C:  MOVLW  00
1451E:  MOVWF  FF8
14520:  MOVLW  18
14522:  MOVWF  xA2
14524:  MOVLB  0
14526:  CALL   06CE
1452A:  MOVFF  33,3A2
1452E:  MOVLW  57
14530:  MOVLB  3
14532:  MOVWF  xA3
14534:  MOVLB  0
14536:  CALL   0700
1453A:  MOVFF  32,3A2
1453E:  MOVLW  57
14540:  MOVLB  3
14542:  MOVWF  xA3
14544:  MOVLB  0
14546:  CALL   0700
1454A:  MOVFF  31,3A2
1454E:  MOVLW  57
14550:  MOVLB  3
14552:  MOVWF  xA3
14554:  MOVLB  0
14556:  CALL   0700
1455A:  MOVFF  30,3A2
1455E:  MOVLW  57
14560:  MOVLB  3
14562:  MOVWF  xA3
14564:  MOVLB  0
14566:  CALL   0700
1456A:  MOVLW  0D
1456C:  BTFSS  F9E.4
1456E:  BRA    1456C
14570:  MOVWF  FAD
14572:  MOVLW  0A
14574:  BTFSS  F9E.4
14576:  BRA    14574
14578:  MOVWF  FAD
....................    return; 
1457A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
*
15374:  MOVLB  3
15376:  CLRF   x2E
15378:  MOVF   x2E,W
1537A:  SUBLW  28
1537C:  BNC   153D0
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
1537E:  CLRF   03
15380:  MOVF   x2E,W
15382:  ADDLW  AA
15384:  MOVWF  01
15386:  MOVLW  00
15388:  ADDWFC 03,F
1538A:  MOVFF  01,32F
1538E:  MOVFF  03,330
15392:  MOVF   x2E,W
15394:  ADDWF  30,W
15396:  MOVWF  x31
15398:  MOVLW  00
1539A:  ADDWFC 31,W
1539C:  MOVWF  x32
1539E:  MOVLW  00
153A0:  ADDWFC 32,W
153A2:  MOVWF  x33
153A4:  MOVLW  00
153A6:  ADDWFC 33,W
153A8:  MOVWF  x34
153AA:  MOVWF  xAB
153AC:  MOVFF  333,3AA
153B0:  MOVFF  332,3A9
153B4:  MOVFF  331,3A8
153B8:  MOVLB  0
153BA:  CALL   11B04
153BE:  MOVFF  330,FEA
153C2:  MOVFF  32F,FE9
153C6:  MOVFF  01,FEF
153CA:  MOVLB  3
153CC:  INCF   x2E,F
153CE:  BRA    15378
....................    } 
....................    return; 
153D0:  MOVLB  0
153D2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
*
15476:  BCF    F94.4
15478:  BCF    F8B.4
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
1547A:  MOVLB  3
1547C:  CLRF   x2E
1547E:  MOVF   x2E,W
15480:  SUBLW  28
15482:  BNC   154D6
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
15484:  CLRF   03
15486:  MOVF   x2E,W
15488:  ADDLW  AA
1548A:  MOVWF  01
1548C:  MOVLW  00
1548E:  ADDWFC 03,F
15490:  MOVFF  01,32F
15494:  MOVFF  03,330
15498:  MOVF   x2E,W
1549A:  ADDWF  30,W
1549C:  MOVWF  x31
1549E:  MOVLW  00
154A0:  ADDWFC 31,W
154A2:  MOVWF  x32
154A4:  MOVLW  00
154A6:  ADDWFC 32,W
154A8:  MOVWF  x33
154AA:  MOVLW  00
154AC:  ADDWFC 33,W
154AE:  MOVWF  x34
154B0:  MOVWF  x52
154B2:  MOVFF  333,351
154B6:  MOVFF  332,350
154BA:  MOVFF  331,34F
154BE:  MOVLB  0
154C0:  CALL   12442
154C4:  MOVFF  330,FEA
154C8:  MOVFF  32F,FE9
154CC:  MOVFF  01,FEF
154D0:  MOVLB  3
154D2:  INCF   x2E,F
154D4:  BRA    1547E
....................    } 
....................    output_high(PIN_C4); 
154D6:  BCF    F94.4
154D8:  BSF    F8B.4
....................    return; 
154DA:  MOVLB  0
154DC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
154DE:  BCF    F92.5
154E0:  BCF    F89.5
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
154E2:  MOVLB  3
154E4:  CLRF   x2E
154E6:  MOVF   x2E,W
154E8:  SUBLW  28
154EA:  BNC   1553E
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
154EC:  CLRF   03
154EE:  MOVF   x2E,W
154F0:  ADDLW  AA
154F2:  MOVWF  01
154F4:  MOVLW  00
154F6:  ADDWFC 03,F
154F8:  MOVFF  01,32F
154FC:  MOVFF  03,330
15500:  MOVF   x2E,W
15502:  ADDWF  30,W
15504:  MOVWF  x31
15506:  MOVLW  00
15508:  ADDWFC 31,W
1550A:  MOVWF  x32
1550C:  MOVLW  00
1550E:  ADDWFC 32,W
15510:  MOVWF  x33
15512:  MOVLW  00
15514:  ADDWFC 33,W
15516:  MOVWF  x34
15518:  MOVWF  x8C
1551A:  MOVFF  333,38B
1551E:  MOVFF  332,38A
15522:  MOVFF  331,389
15526:  MOVLB  0
15528:  CALL   11800
1552C:  MOVFF  330,FEA
15530:  MOVFF  32F,FE9
15534:  MOVFF  01,FEF
15538:  MOVLB  3
1553A:  INCF   x2E,F
1553C:  BRA    154E6
....................    } 
....................    return; 
1553E:  MOVLB  0
15540:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
*
153D4:  MOVFF  AA,3B
153D8:  MOVFF  AB,3A
153DC:  MOVFF  AC,39
153E0:  MOVFF  AD,38
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
153E4:  MOVFF  AE,3F
153E8:  MOVFF  AF,3E
153EC:  MOVFF  B0,3D
153F0:  MOVFF  B1,3C
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
153F4:  MOVFF  B2,43
153F8:  MOVFF  B3,42
153FC:  MOVFF  B4,41
15400:  MOVFF  B5,40
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
15404:  MOVFF  B6,47
15408:  MOVFF  B7,46
1540C:  MOVFF  B8,45
15410:  MOVFF  B9,44
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
15414:  MOVFF  BA,4B
15418:  MOVFF  BB,4A
1541C:  MOVFF  BC,49
15420:  MOVFF  BD,48
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
15424:  MOVFF  BE,4F
15428:  MOVFF  BF,4E
1542C:  MOVFF  C0,4D
15430:  MOVFF  C1,4C
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
15434:  MOVFF  C2,53
15438:  MOVFF  C3,52
1543C:  MOVFF  C4,51
15440:  MOVFF  C5,50
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
15444:  MOVFF  C6,5B
15448:  MOVFF  C7,5A
1544C:  MOVFF  C8,59
15450:  MOVFF  C9,58
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
15454:  MOVFF  CA,5F
15458:  MOVFF  CB,5E
1545C:  MOVFF  CC,5D
15460:  MOVFF  CD,5C
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
15464:  MOVFF  CE,37
15468:  MOVFF  CF,36
1546C:  MOVFF  D0,35
15470:  MOVFF  D1,34
....................     
....................    return; 
15474:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
*
15542:  MOVLB  3
15544:  CLRF   x2C
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
15546:  MOVLB  0
15548:  RCALL  15374
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
1554A:  MOVLW  25
1554C:  MOVLB  3
1554E:  MOVWF  x2D
15550:  MOVF   x2D,W
15552:  SUBLW  28
15554:  BNC   1556E
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
15556:  CLRF   03
15558:  MOVF   x2D,W
1555A:  ADDLW  AA
1555C:  MOVWF  FE9
1555E:  MOVLW  00
15560:  ADDWFC 03,W
15562:  MOVWF  FEA
15564:  INCFSZ FEF,W
15566:  BRA    1556A
....................       { 
....................          checksum++; 
15568:  INCF   x2C,F
....................       } 
1556A:  INCF   x2D,F
1556C:  BRA    15550
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
1556E:  MOVF   x2C,W
15570:  SUBLW  04
15572:  BZ    155B6
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
15574:  CLRF   x2D
15576:  MOVF   x2D,W
15578:  SUBLW  28
1557A:  BNC   1559E
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
1557C:  CLRF   03
1557E:  MOVF   x2D,W
15580:  ADDLW  AA
15582:  MOVWF  FE9
15584:  MOVLW  00
15586:  ADDWFC 03,W
15588:  MOVWF  FEA
1558A:  MOVFF  FEF,3A2
1558E:  MOVLW  57
15590:  MOVWF  xA3
15592:  MOVLB  0
15594:  CALL   0700
15598:  MOVLB  3
1559A:  INCF   x2D,F
1559C:  BRA    15576
....................       } 
....................       fprintf(PC,"\r\n"); 
1559E:  MOVLW  0D
155A0:  BTFSS  F9E.4
155A2:  BRA    155A0
155A4:  MOVWF  FAD
155A6:  MOVLW  0A
155A8:  BTFSS  F9E.4
155AA:  BRA    155A8
155AC:  MOVWF  FAD
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
155AE:  MOVLB  0
155B0:  RCALL  153D4
....................    }else{                                                                        //if there is nothing, check from SCF 
155B2:  BRA    156A2
155B4:  MOVLB  3
....................       output_low(PIN_C4); 
155B6:  BCF    F94.4
155B8:  BCF    F8B.4
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
155BA:  MOVLB  0
155BC:  RCALL  15476
....................       output_high(PIN_C4); 
155BE:  BCF    F94.4
155C0:  BSF    F8B.4
....................       checksum = 0; 
155C2:  MOVLB  3
155C4:  CLRF   x2C
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
155C6:  MOVLW  25
155C8:  MOVWF  x2D
155CA:  MOVF   x2D,W
155CC:  SUBLW  28
155CE:  BNC   155E8
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
155D0:  CLRF   03
155D2:  MOVF   x2D,W
155D4:  ADDLW  AA
155D6:  MOVWF  FE9
155D8:  MOVLW  00
155DA:  ADDWFC 03,W
155DC:  MOVWF  FEA
155DE:  INCFSZ FEF,W
155E0:  BRA    155E4
....................          { 
....................             checksum++; 
155E2:  INCF   x2C,F
....................          } 
155E4:  INCF   x2D,F
155E6:  BRA    155CA
....................       } 
....................       if(checksum != 4) 
155E8:  MOVF   x2C,W
155EA:  SUBLW  04
155EC:  BZ    15630
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
155EE:  CLRF   x2D
155F0:  MOVF   x2D,W
155F2:  SUBLW  28
155F4:  BNC   15618
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
155F6:  CLRF   03
155F8:  MOVF   x2D,W
155FA:  ADDLW  AA
155FC:  MOVWF  FE9
155FE:  MOVLW  00
15600:  ADDWFC 03,W
15602:  MOVWF  FEA
15604:  MOVFF  FEF,3A2
15608:  MOVLW  57
1560A:  MOVWF  xA3
1560C:  MOVLB  0
1560E:  CALL   0700
15612:  MOVLB  3
15614:  INCF   x2D,F
15616:  BRA    155F0
....................          } 
....................          fprintf(PC,"\r\n"); 
15618:  MOVLW  0D
1561A:  BTFSS  F9E.4
1561C:  BRA    1561A
1561E:  MOVWF  FAD
15620:  MOVLW  0A
15622:  BTFSS  F9E.4
15624:  BRA    15622
15626:  MOVWF  FAD
....................          MAKE_ADDRESS_DATA(); 
15628:  MOVLB  0
1562A:  RCALL  153D4
....................       }else{                                                                     //if there is nothing, check from SMF 
1562C:  BRA    156A2
1562E:  MOVLB  3
....................          output_low(PIN_A5); 
15630:  BCF    F92.5
15632:  BCF    F89.5
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
15634:  MOVLB  0
15636:  RCALL  154DE
....................          checksum = 0; 
15638:  MOVLB  3
1563A:  CLRF   x2C
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
1563C:  MOVLW  25
1563E:  MOVWF  x2D
15640:  MOVF   x2D,W
15642:  SUBLW  28
15644:  BNC   1565E
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
15646:  CLRF   03
15648:  MOVF   x2D,W
1564A:  ADDLW  AA
1564C:  MOVWF  FE9
1564E:  MOVLW  00
15650:  ADDWFC 03,W
15652:  MOVWF  FEA
15654:  INCFSZ FEF,W
15656:  BRA    1565A
....................             { 
....................                checksum++; 
15658:  INCF   x2C,F
....................             } 
1565A:  INCF   x2D,F
1565C:  BRA    15640
....................          } 
....................          if(checksum != 4) 
1565E:  MOVF   x2C,W
15660:  SUBLW  04
15662:  BZ    156A4
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
15664:  CLRF   x2D
15666:  MOVF   x2D,W
15668:  SUBLW  28
1566A:  BNC   1568E
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
1566C:  CLRF   03
1566E:  MOVF   x2D,W
15670:  ADDLW  AA
15672:  MOVWF  FE9
15674:  MOVLW  00
15676:  ADDWFC 03,W
15678:  MOVWF  FEA
1567A:  MOVFF  FEF,3A2
1567E:  MOVLW  57
15680:  MOVWF  xA3
15682:  MOVLB  0
15684:  CALL   0700
15688:  MOVLB  3
1568A:  INCF   x2D,F
1568C:  BRA    15666
....................             } 
....................             fprintf(PC,"\r\n"); 
1568E:  MOVLW  0D
15690:  BTFSS  F9E.4
15692:  BRA    15690
15694:  MOVWF  FAD
15696:  MOVLW  0A
15698:  BTFSS  F9E.4
1569A:  BRA    15698
1569C:  MOVWF  FAD
....................             MAKE_ADDRESS_DATA(); 
1569E:  MOVLB  0
156A0:  RCALL  153D4
156A2:  MOVLB  3
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
156A4:  CLRF   x2C
....................    return; 
156A6:  MOVLB  0
156A8:  RETURN 0
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
*
15AEC:  MOVLW  74
15AEE:  MOVWF  FF6
15AF0:  MOVLW  05
15AF2:  MOVWF  FF7
15AF4:  MOVLW  00
15AF6:  MOVWF  FF8
15AF8:  CALL   06A4
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
15AFC:  BCF    F92.5
15AFE:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
15B00:  BCF    F94.4
15B02:  BCF    F8B.4
....................     
....................    sector_erase_OF(0); 
15B04:  MOVLB  3
15B06:  CLRF   x8C
15B08:  CLRF   x8B
15B0A:  CLRF   x8A
15B0C:  CLRF   x89
15B0E:  MOVLB  0
15B10:  CALL   12014
....................    sector_erase_SCF(0); 
15B14:  MOVLB  3
15B16:  CLRF   x8C
15B18:  CLRF   x8B
15B1A:  CLRF   x8A
15B1C:  CLRF   x89
15B1E:  MOVLB  0
15B20:  CALL   120B0
....................    sector_erase_SMF(0); 
15B24:  MOVLB  3
15B26:  CLRF   x8C
15B28:  CLRF   x8B
15B2A:  CLRF   x8A
15B2C:  CLRF   x89
15B2E:  MOVLB  0
15B30:  CALL   1214C
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
15B34:  MOVFF  4F,38C
15B38:  MOVFF  4E,38B
15B3C:  MOVFF  4D,38A
15B40:  MOVFF  4C,389
15B44:  CALL   12014
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
15B48:  MOVFF  4F,38C
15B4C:  MOVFF  4E,38B
15B50:  MOVFF  4D,38A
15B54:  MOVFF  4C,389
15B58:  CALL   120B0
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
15B5C:  MOVFF  4F,38C
15B60:  MOVFF  4E,38B
15B64:  MOVFF  4D,38A
15B68:  MOVFF  4C,389
15B6C:  CALL   1214C
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
15B70:  MOVLB  3
15B72:  CLRF   x37
15B74:  MOVF   x37,W
15B76:  SUBLW  04
15B78:  BTFSS  FD8.0
15B7A:  BRA    15FDC
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
15B7C:  CLRF   01
15B7E:  CLRF   02
15B80:  MOVFF  01,03
15B84:  MOVFF  337,02
15B88:  CLRF   00
15B8A:  CLRF   01
15B8C:  MOVF   00,W
15B8E:  ADDWF  38,W
15B90:  MOVWF  x39
15B92:  MOVF   01,W
15B94:  ADDWFC 39,W
15B96:  MOVWF  x3A
15B98:  MOVF   x37,W
15B9A:  ADDWFC 3A,W
15B9C:  MOVWF  x3B
15B9E:  MOVF   03,W
15BA0:  ADDWFC 3B,W
15BA2:  MOVWF  x3C
15BA4:  MOVWF  x8C
15BA6:  MOVFF  33B,38B
15BAA:  MOVFF  33A,38A
15BAE:  MOVFF  339,389
15BB2:  MOVLB  0
15BB4:  CALL   12014
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
15BB8:  CLRF   01
15BBA:  CLRF   02
15BBC:  MOVFF  01,03
15BC0:  MOVFF  337,02
15BC4:  CLRF   00
15BC6:  CLRF   01
15BC8:  MOVF   00,W
15BCA:  ADDWF  44,W
15BCC:  MOVLB  3
15BCE:  MOVWF  x39
15BD0:  MOVF   01,W
15BD2:  ADDWFC 45,W
15BD4:  MOVWF  x3A
15BD6:  MOVF   x37,W
15BD8:  ADDWFC 46,W
15BDA:  MOVWF  x3B
15BDC:  MOVF   03,W
15BDE:  ADDWFC 47,W
15BE0:  MOVWF  x3C
15BE2:  MOVWF  x8C
15BE4:  MOVFF  33B,38B
15BE8:  MOVFF  33A,38A
15BEC:  MOVFF  339,389
15BF0:  MOVLB  0
15BF2:  CALL   12014
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
15BF6:  CLRF   01
15BF8:  CLRF   02
15BFA:  MOVFF  01,03
15BFE:  MOVFF  337,02
15C02:  CLRF   00
15C04:  CLRF   01
15C06:  MOVF   00,W
15C08:  ADDWF  48,W
15C0A:  MOVLB  3
15C0C:  MOVWF  x39
15C0E:  MOVF   01,W
15C10:  ADDWFC 49,W
15C12:  MOVWF  x3A
15C14:  MOVF   x37,W
15C16:  ADDWFC 4A,W
15C18:  MOVWF  x3B
15C1A:  MOVF   03,W
15C1C:  ADDWFC 4B,W
15C1E:  MOVWF  x3C
15C20:  MOVWF  x8C
15C22:  MOVFF  33B,38B
15C26:  MOVFF  33A,38A
15C2A:  MOVFF  339,389
15C2E:  MOVLB  0
15C30:  CALL   12014
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
15C34:  CLRF   01
15C36:  CLRF   02
15C38:  MOVFF  01,03
15C3C:  MOVFF  337,02
15C40:  CLRF   00
15C42:  CLRF   01
15C44:  MOVF   00,W
15C46:  ADDWF  50,W
15C48:  MOVLB  3
15C4A:  MOVWF  x39
15C4C:  MOVF   01,W
15C4E:  ADDWFC 51,W
15C50:  MOVWF  x3A
15C52:  MOVF   x37,W
15C54:  ADDWFC 52,W
15C56:  MOVWF  x3B
15C58:  MOVF   03,W
15C5A:  ADDWFC 53,W
15C5C:  MOVWF  x3C
15C5E:  MOVWF  x8C
15C60:  MOVFF  33B,38B
15C64:  MOVFF  33A,38A
15C68:  MOVFF  339,389
15C6C:  MOVLB  0
15C6E:  CALL   12014
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
15C72:  CLRF   01
15C74:  CLRF   02
15C76:  MOVFF  01,03
15C7A:  MOVFF  337,02
15C7E:  CLRF   00
15C80:  CLRF   01
15C82:  MOVF   00,W
15C84:  ADDWF  58,W
15C86:  MOVLB  3
15C88:  MOVWF  x39
15C8A:  MOVF   01,W
15C8C:  ADDWFC 59,W
15C8E:  MOVWF  x3A
15C90:  MOVF   x37,W
15C92:  ADDWFC 5A,W
15C94:  MOVWF  x3B
15C96:  MOVF   03,W
15C98:  ADDWFC 5B,W
15C9A:  MOVWF  x3C
15C9C:  MOVWF  x8C
15C9E:  MOVFF  33B,38B
15CA2:  MOVFF  33A,38A
15CA6:  MOVFF  339,389
15CAA:  MOVLB  0
15CAC:  CALL   12014
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
15CB0:  CLRF   01
15CB2:  CLRF   02
15CB4:  MOVFF  01,03
15CB8:  MOVFF  337,02
15CBC:  CLRF   00
15CBE:  CLRF   01
15CC0:  MOVF   00,W
15CC2:  ADDWF  5C,W
15CC4:  MOVLB  3
15CC6:  MOVWF  x39
15CC8:  MOVF   01,W
15CCA:  ADDWFC 5D,W
15CCC:  MOVWF  x3A
15CCE:  MOVF   x37,W
15CD0:  ADDWFC 5E,W
15CD2:  MOVWF  x3B
15CD4:  MOVF   03,W
15CD6:  ADDWFC 5F,W
15CD8:  MOVWF  x3C
15CDA:  MOVWF  x8C
15CDC:  MOVFF  33B,38B
15CE0:  MOVFF  33A,38A
15CE4:  MOVFF  339,389
15CE8:  MOVLB  0
15CEA:  CALL   12014
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
15CEE:  CLRF   01
15CF0:  CLRF   02
15CF2:  MOVFF  01,03
15CF6:  MOVFF  337,02
15CFA:  CLRF   00
15CFC:  CLRF   01
15CFE:  MOVF   00,W
15D00:  ADDWF  38,W
15D02:  MOVLB  3
15D04:  MOVWF  x39
15D06:  MOVF   01,W
15D08:  ADDWFC 39,W
15D0A:  MOVWF  x3A
15D0C:  MOVF   x37,W
15D0E:  ADDWFC 3A,W
15D10:  MOVWF  x3B
15D12:  MOVF   03,W
15D14:  ADDWFC 3B,W
15D16:  MOVWF  x3C
15D18:  MOVWF  x8C
15D1A:  MOVFF  33B,38B
15D1E:  MOVFF  33A,38A
15D22:  MOVFF  339,389
15D26:  MOVLB  0
15D28:  CALL   120B0
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
15D2C:  CLRF   01
15D2E:  CLRF   02
15D30:  MOVFF  01,03
15D34:  MOVFF  337,02
15D38:  CLRF   00
15D3A:  CLRF   01
15D3C:  MOVF   00,W
15D3E:  ADDWF  44,W
15D40:  MOVLB  3
15D42:  MOVWF  x39
15D44:  MOVF   01,W
15D46:  ADDWFC 45,W
15D48:  MOVWF  x3A
15D4A:  MOVF   x37,W
15D4C:  ADDWFC 46,W
15D4E:  MOVWF  x3B
15D50:  MOVF   03,W
15D52:  ADDWFC 47,W
15D54:  MOVWF  x3C
15D56:  MOVWF  x8C
15D58:  MOVFF  33B,38B
15D5C:  MOVFF  33A,38A
15D60:  MOVFF  339,389
15D64:  MOVLB  0
15D66:  CALL   120B0
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
15D6A:  CLRF   01
15D6C:  CLRF   02
15D6E:  MOVFF  01,03
15D72:  MOVFF  337,02
15D76:  CLRF   00
15D78:  CLRF   01
15D7A:  MOVF   00,W
15D7C:  ADDWF  48,W
15D7E:  MOVLB  3
15D80:  MOVWF  x39
15D82:  MOVF   01,W
15D84:  ADDWFC 49,W
15D86:  MOVWF  x3A
15D88:  MOVF   x37,W
15D8A:  ADDWFC 4A,W
15D8C:  MOVWF  x3B
15D8E:  MOVF   03,W
15D90:  ADDWFC 4B,W
15D92:  MOVWF  x3C
15D94:  MOVWF  x8C
15D96:  MOVFF  33B,38B
15D9A:  MOVFF  33A,38A
15D9E:  MOVFF  339,389
15DA2:  MOVLB  0
15DA4:  CALL   120B0
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
15DA8:  CLRF   01
15DAA:  CLRF   02
15DAC:  MOVFF  01,03
15DB0:  MOVFF  337,02
15DB4:  CLRF   00
15DB6:  CLRF   01
15DB8:  MOVF   00,W
15DBA:  ADDWF  50,W
15DBC:  MOVLB  3
15DBE:  MOVWF  x39
15DC0:  MOVF   01,W
15DC2:  ADDWFC 51,W
15DC4:  MOVWF  x3A
15DC6:  MOVF   x37,W
15DC8:  ADDWFC 52,W
15DCA:  MOVWF  x3B
15DCC:  MOVF   03,W
15DCE:  ADDWFC 53,W
15DD0:  MOVWF  x3C
15DD2:  MOVWF  x8C
15DD4:  MOVFF  33B,38B
15DD8:  MOVFF  33A,38A
15DDC:  MOVFF  339,389
15DE0:  MOVLB  0
15DE2:  CALL   120B0
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
15DE6:  CLRF   01
15DE8:  CLRF   02
15DEA:  MOVFF  01,03
15DEE:  MOVFF  337,02
15DF2:  CLRF   00
15DF4:  CLRF   01
15DF6:  MOVF   00,W
15DF8:  ADDWF  58,W
15DFA:  MOVLB  3
15DFC:  MOVWF  x39
15DFE:  MOVF   01,W
15E00:  ADDWFC 59,W
15E02:  MOVWF  x3A
15E04:  MOVF   x37,W
15E06:  ADDWFC 5A,W
15E08:  MOVWF  x3B
15E0A:  MOVF   03,W
15E0C:  ADDWFC 5B,W
15E0E:  MOVWF  x3C
15E10:  MOVWF  x8C
15E12:  MOVFF  33B,38B
15E16:  MOVFF  33A,38A
15E1A:  MOVFF  339,389
15E1E:  MOVLB  0
15E20:  CALL   120B0
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
15E24:  CLRF   01
15E26:  CLRF   02
15E28:  MOVFF  01,03
15E2C:  MOVFF  337,02
15E30:  CLRF   00
15E32:  CLRF   01
15E34:  MOVF   00,W
15E36:  ADDWF  5C,W
15E38:  MOVLB  3
15E3A:  MOVWF  x39
15E3C:  MOVF   01,W
15E3E:  ADDWFC 5D,W
15E40:  MOVWF  x3A
15E42:  MOVF   x37,W
15E44:  ADDWFC 5E,W
15E46:  MOVWF  x3B
15E48:  MOVF   03,W
15E4A:  ADDWFC 5F,W
15E4C:  MOVWF  x3C
15E4E:  MOVWF  x8C
15E50:  MOVFF  33B,38B
15E54:  MOVFF  33A,38A
15E58:  MOVFF  339,389
15E5C:  MOVLB  0
15E5E:  CALL   120B0
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
15E62:  CLRF   01
15E64:  CLRF   02
15E66:  MOVFF  01,03
15E6A:  MOVFF  337,02
15E6E:  CLRF   00
15E70:  CLRF   01
15E72:  MOVF   00,W
15E74:  ADDWF  38,W
15E76:  MOVLB  3
15E78:  MOVWF  x39
15E7A:  MOVF   01,W
15E7C:  ADDWFC 39,W
15E7E:  MOVWF  x3A
15E80:  MOVF   x37,W
15E82:  ADDWFC 3A,W
15E84:  MOVWF  x3B
15E86:  MOVF   03,W
15E88:  ADDWFC 3B,W
15E8A:  MOVWF  x3C
15E8C:  MOVWF  x8C
15E8E:  MOVFF  33B,38B
15E92:  MOVFF  33A,38A
15E96:  MOVFF  339,389
15E9A:  MOVLB  0
15E9C:  CALL   1214C
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
15EA0:  CLRF   01
15EA2:  CLRF   02
15EA4:  MOVFF  01,03
15EA8:  MOVFF  337,02
15EAC:  CLRF   00
15EAE:  CLRF   01
15EB0:  MOVF   00,W
15EB2:  ADDWF  44,W
15EB4:  MOVLB  3
15EB6:  MOVWF  x39
15EB8:  MOVF   01,W
15EBA:  ADDWFC 45,W
15EBC:  MOVWF  x3A
15EBE:  MOVF   x37,W
15EC0:  ADDWFC 46,W
15EC2:  MOVWF  x3B
15EC4:  MOVF   03,W
15EC6:  ADDWFC 47,W
15EC8:  MOVWF  x3C
15ECA:  MOVWF  x8C
15ECC:  MOVFF  33B,38B
15ED0:  MOVFF  33A,38A
15ED4:  MOVFF  339,389
15ED8:  MOVLB  0
15EDA:  CALL   1214C
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
15EDE:  CLRF   01
15EE0:  CLRF   02
15EE2:  MOVFF  01,03
15EE6:  MOVFF  337,02
15EEA:  CLRF   00
15EEC:  CLRF   01
15EEE:  MOVF   00,W
15EF0:  ADDWF  48,W
15EF2:  MOVLB  3
15EF4:  MOVWF  x39
15EF6:  MOVF   01,W
15EF8:  ADDWFC 49,W
15EFA:  MOVWF  x3A
15EFC:  MOVF   x37,W
15EFE:  ADDWFC 4A,W
15F00:  MOVWF  x3B
15F02:  MOVF   03,W
15F04:  ADDWFC 4B,W
15F06:  MOVWF  x3C
15F08:  MOVWF  x8C
15F0A:  MOVFF  33B,38B
15F0E:  MOVFF  33A,38A
15F12:  MOVFF  339,389
15F16:  MOVLB  0
15F18:  CALL   1214C
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
15F1C:  CLRF   01
15F1E:  CLRF   02
15F20:  MOVFF  01,03
15F24:  MOVFF  337,02
15F28:  CLRF   00
15F2A:  CLRF   01
15F2C:  MOVF   00,W
15F2E:  ADDWF  50,W
15F30:  MOVLB  3
15F32:  MOVWF  x39
15F34:  MOVF   01,W
15F36:  ADDWFC 51,W
15F38:  MOVWF  x3A
15F3A:  MOVF   x37,W
15F3C:  ADDWFC 52,W
15F3E:  MOVWF  x3B
15F40:  MOVF   03,W
15F42:  ADDWFC 53,W
15F44:  MOVWF  x3C
15F46:  MOVWF  x8C
15F48:  MOVFF  33B,38B
15F4C:  MOVFF  33A,38A
15F50:  MOVFF  339,389
15F54:  MOVLB  0
15F56:  CALL   1214C
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
15F5A:  CLRF   01
15F5C:  CLRF   02
15F5E:  MOVFF  01,03
15F62:  MOVFF  337,02
15F66:  CLRF   00
15F68:  CLRF   01
15F6A:  MOVF   00,W
15F6C:  ADDWF  58,W
15F6E:  MOVLB  3
15F70:  MOVWF  x39
15F72:  MOVF   01,W
15F74:  ADDWFC 59,W
15F76:  MOVWF  x3A
15F78:  MOVF   x37,W
15F7A:  ADDWFC 5A,W
15F7C:  MOVWF  x3B
15F7E:  MOVF   03,W
15F80:  ADDWFC 5B,W
15F82:  MOVWF  x3C
15F84:  MOVWF  x8C
15F86:  MOVFF  33B,38B
15F8A:  MOVFF  33A,38A
15F8E:  MOVFF  339,389
15F92:  MOVLB  0
15F94:  CALL   1214C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
15F98:  CLRF   01
15F9A:  CLRF   02
15F9C:  MOVFF  01,03
15FA0:  MOVFF  337,02
15FA4:  CLRF   00
15FA6:  CLRF   01
15FA8:  MOVF   00,W
15FAA:  ADDWF  5C,W
15FAC:  MOVLB  3
15FAE:  MOVWF  x39
15FB0:  MOVF   01,W
15FB2:  ADDWFC 5D,W
15FB4:  MOVWF  x3A
15FB6:  MOVF   x37,W
15FB8:  ADDWFC 5E,W
15FBA:  MOVWF  x3B
15FBC:  MOVF   03,W
15FBE:  ADDWFC 5F,W
15FC0:  MOVWF  x3C
15FC2:  MOVWF  x8C
15FC4:  MOVFF  33B,38B
15FC8:  MOVFF  33A,38A
15FCC:  MOVFF  339,389
15FD0:  MOVLB  0
15FD2:  CALL   1214C
15FD6:  MOVLB  3
15FD8:  INCF   x37,F
15FDA:  BRA    15B74
....................    } 
....................    for(num = 5; num < 10; num++) 
15FDC:  MOVLW  05
15FDE:  MOVWF  x37
15FE0:  MOVF   x37,W
15FE2:  SUBLW  09
15FE4:  BTFSS  FD8.0
15FE6:  BRA    1621A
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
15FE8:  CLRF   01
15FEA:  CLRF   02
15FEC:  MOVFF  01,03
15FF0:  MOVFF  337,02
15FF4:  CLRF   00
15FF6:  CLRF   01
15FF8:  MOVF   00,W
15FFA:  ADDWF  44,W
15FFC:  MOVWF  x39
15FFE:  MOVF   01,W
16000:  ADDWFC 45,W
16002:  MOVWF  x3A
16004:  MOVF   x37,W
16006:  ADDWFC 46,W
16008:  MOVWF  x3B
1600A:  MOVF   03,W
1600C:  ADDWFC 47,W
1600E:  MOVWF  x3C
16010:  MOVWF  x8C
16012:  MOVFF  33B,38B
16016:  MOVFF  33A,38A
1601A:  MOVFF  339,389
1601E:  MOVLB  0
16020:  CALL   12014
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
16024:  CLRF   01
16026:  CLRF   02
16028:  MOVFF  01,03
1602C:  MOVFF  337,02
16030:  CLRF   00
16032:  CLRF   01
16034:  MOVF   00,W
16036:  ADDWF  48,W
16038:  MOVLB  3
1603A:  MOVWF  x39
1603C:  MOVF   01,W
1603E:  ADDWFC 49,W
16040:  MOVWF  x3A
16042:  MOVF   x37,W
16044:  ADDWFC 4A,W
16046:  MOVWF  x3B
16048:  MOVF   03,W
1604A:  ADDWFC 4B,W
1604C:  MOVWF  x3C
1604E:  MOVWF  x8C
16050:  MOVFF  33B,38B
16054:  MOVFF  33A,38A
16058:  MOVFF  339,389
1605C:  MOVLB  0
1605E:  CALL   12014
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
16062:  CLRF   01
16064:  CLRF   02
16066:  MOVFF  01,03
1606A:  MOVFF  337,02
1606E:  CLRF   00
16070:  CLRF   01
16072:  MOVF   00,W
16074:  ADDWF  5C,W
16076:  MOVLB  3
16078:  MOVWF  x39
1607A:  MOVF   01,W
1607C:  ADDWFC 5D,W
1607E:  MOVWF  x3A
16080:  MOVF   x37,W
16082:  ADDWFC 5E,W
16084:  MOVWF  x3B
16086:  MOVF   03,W
16088:  ADDWFC 5F,W
1608A:  MOVWF  x3C
1608C:  MOVWF  x8C
1608E:  MOVFF  33B,38B
16092:  MOVFF  33A,38A
16096:  MOVFF  339,389
1609A:  MOVLB  0
1609C:  CALL   12014
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
160A0:  CLRF   01
160A2:  CLRF   02
160A4:  MOVFF  01,03
160A8:  MOVFF  337,02
160AC:  CLRF   00
160AE:  CLRF   01
160B0:  MOVF   00,W
160B2:  ADDWF  44,W
160B4:  MOVLB  3
160B6:  MOVWF  x39
160B8:  MOVF   01,W
160BA:  ADDWFC 45,W
160BC:  MOVWF  x3A
160BE:  MOVF   x37,W
160C0:  ADDWFC 46,W
160C2:  MOVWF  x3B
160C4:  MOVF   03,W
160C6:  ADDWFC 47,W
160C8:  MOVWF  x3C
160CA:  MOVWF  x8C
160CC:  MOVFF  33B,38B
160D0:  MOVFF  33A,38A
160D4:  MOVFF  339,389
160D8:  MOVLB  0
160DA:  CALL   120B0
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
160DE:  CLRF   01
160E0:  CLRF   02
160E2:  MOVFF  01,03
160E6:  MOVFF  337,02
160EA:  CLRF   00
160EC:  CLRF   01
160EE:  MOVF   00,W
160F0:  ADDWF  48,W
160F2:  MOVLB  3
160F4:  MOVWF  x39
160F6:  MOVF   01,W
160F8:  ADDWFC 49,W
160FA:  MOVWF  x3A
160FC:  MOVF   x37,W
160FE:  ADDWFC 4A,W
16100:  MOVWF  x3B
16102:  MOVF   03,W
16104:  ADDWFC 4B,W
16106:  MOVWF  x3C
16108:  MOVWF  x8C
1610A:  MOVFF  33B,38B
1610E:  MOVFF  33A,38A
16112:  MOVFF  339,389
16116:  MOVLB  0
16118:  CALL   120B0
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
1611C:  CLRF   01
1611E:  CLRF   02
16120:  MOVFF  01,03
16124:  MOVFF  337,02
16128:  CLRF   00
1612A:  CLRF   01
1612C:  MOVF   00,W
1612E:  ADDWF  5C,W
16130:  MOVLB  3
16132:  MOVWF  x39
16134:  MOVF   01,W
16136:  ADDWFC 5D,W
16138:  MOVWF  x3A
1613A:  MOVF   x37,W
1613C:  ADDWFC 5E,W
1613E:  MOVWF  x3B
16140:  MOVF   03,W
16142:  ADDWFC 5F,W
16144:  MOVWF  x3C
16146:  MOVWF  x8C
16148:  MOVFF  33B,38B
1614C:  MOVFF  33A,38A
16150:  MOVFF  339,389
16154:  MOVLB  0
16156:  CALL   120B0
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
1615A:  CLRF   01
1615C:  CLRF   02
1615E:  MOVFF  01,03
16162:  MOVFF  337,02
16166:  CLRF   00
16168:  CLRF   01
1616A:  MOVF   00,W
1616C:  ADDWF  44,W
1616E:  MOVLB  3
16170:  MOVWF  x39
16172:  MOVF   01,W
16174:  ADDWFC 45,W
16176:  MOVWF  x3A
16178:  MOVF   x37,W
1617A:  ADDWFC 46,W
1617C:  MOVWF  x3B
1617E:  MOVF   03,W
16180:  ADDWFC 47,W
16182:  MOVWF  x3C
16184:  MOVWF  x8C
16186:  MOVFF  33B,38B
1618A:  MOVFF  33A,38A
1618E:  MOVFF  339,389
16192:  MOVLB  0
16194:  CALL   1214C
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
16198:  CLRF   01
1619A:  CLRF   02
1619C:  MOVFF  01,03
161A0:  MOVFF  337,02
161A4:  CLRF   00
161A6:  CLRF   01
161A8:  MOVF   00,W
161AA:  ADDWF  48,W
161AC:  MOVLB  3
161AE:  MOVWF  x39
161B0:  MOVF   01,W
161B2:  ADDWFC 49,W
161B4:  MOVWF  x3A
161B6:  MOVF   x37,W
161B8:  ADDWFC 4A,W
161BA:  MOVWF  x3B
161BC:  MOVF   03,W
161BE:  ADDWFC 4B,W
161C0:  MOVWF  x3C
161C2:  MOVWF  x8C
161C4:  MOVFF  33B,38B
161C8:  MOVFF  33A,38A
161CC:  MOVFF  339,389
161D0:  MOVLB  0
161D2:  CALL   1214C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
161D6:  CLRF   01
161D8:  CLRF   02
161DA:  MOVFF  01,03
161DE:  MOVFF  337,02
161E2:  CLRF   00
161E4:  CLRF   01
161E6:  MOVF   00,W
161E8:  ADDWF  5C,W
161EA:  MOVLB  3
161EC:  MOVWF  x39
161EE:  MOVF   01,W
161F0:  ADDWFC 5D,W
161F2:  MOVWF  x3A
161F4:  MOVF   x37,W
161F6:  ADDWFC 5E,W
161F8:  MOVWF  x3B
161FA:  MOVF   03,W
161FC:  ADDWFC 5F,W
161FE:  MOVWF  x3C
16200:  MOVWF  x8C
16202:  MOVFF  33B,38B
16206:  MOVFF  33A,38A
1620A:  MOVFF  339,389
1620E:  MOVLB  0
16210:  CALL   1214C
16214:  MOVLB  3
16216:  INCF   x37,F
16218:  BRA    15FE0
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
1621A:  BCF    F94.4
1621C:  BSF    F8B.4
....................    delay_ms(10000); 
1621E:  MOVLW  28
16220:  MOVWF  x39
16222:  MOVLW  FA
16224:  MOVWF  x98
16226:  MOVLB  0
16228:  CALL   063E
1622C:  MOVLB  3
1622E:  DECFSZ x39,F
16230:  BRA    16222
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
16232:  MOVLW  90
16234:  MOVWF  FF6
16236:  MOVLW  05
16238:  MOVWF  FF7
1623A:  MOVLW  00
1623C:  MOVWF  FF8
1623E:  MOVLB  0
16240:  CALL   06A4
....................    for(int t=60; t>0; t--){ 
16244:  MOVLW  3C
16246:  MOVLB  3
16248:  MOVWF  x38
1624A:  MOVF   x38,F
1624C:  BZ    162A6
....................    fprintf(PC,"Remaining time: %d  \r", t); 
1624E:  MOVLW  AA
16250:  MOVWF  FF6
16252:  MOVLW  05
16254:  MOVWF  FF7
16256:  MOVLW  00
16258:  MOVWF  FF8
1625A:  MOVLW  10
1625C:  MOVWF  xA2
1625E:  MOVLB  0
16260:  CALL   06CE
16264:  MOVFF  338,33E
16268:  MOVLW  18
1626A:  MOVLB  3
1626C:  MOVWF  x3F
1626E:  MOVLB  0
16270:  CALL   2404
16274:  MOVLW  BC
16276:  MOVWF  FF6
16278:  MOVLW  05
1627A:  MOVWF  FF7
1627C:  MOVLW  00
1627E:  MOVWF  FF8
16280:  MOVLW  03
16282:  MOVLB  3
16284:  MOVWF  xA2
16286:  MOVLB  0
16288:  CALL   06CE
....................    delay_ms(1000); 
1628C:  MOVLW  04
1628E:  MOVLB  3
16290:  MOVWF  x39
16292:  MOVLW  FA
16294:  MOVWF  x98
16296:  MOVLB  0
16298:  CALL   063E
1629C:  MOVLB  3
1629E:  DECFSZ x39,F
162A0:  BRA    16292
162A2:  DECF   x38,F
162A4:  BRA    1624A
....................    } 
....................    //delay_ms(60000); 
....................    return; 
162A6:  MOVLB  0
162A8:  RETURN 0
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
*
156AA:  MOVF   43,F
156AC:  BNZ   156C8
156AE:  MOVF   42,W
156B0:  SUBLW  06
156B2:  BC    15718
156B4:  XORLW  FF
156B6:  BNZ   156C8
156B8:  MOVF   41,W
156BA:  SUBLW  FE
156BC:  BC    15718
156BE:  XORLW  FF
156C0:  BNZ   156C8
156C2:  MOVF   40,W
156C4:  SUBLW  E9
156C6:  BC    15718
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
156C8:  MOVLB  3
156CA:  CLRF   x8C
156CC:  MOVLW  07
156CE:  MOVWF  x8B
156D0:  CLRF   x8A
156D2:  CLRF   x89
156D4:  MOVLB  0
156D6:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
156DA:  BCF    F94.4
156DC:  BCF    F8B.4
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
156DE:  MOVLB  3
156E0:  CLRF   x8C
156E2:  MOVLW  07
156E4:  MOVWF  x8B
156E6:  CLRF   x8A
156E8:  CLRF   x89
156EA:  MOVLB  0
156EC:  CALL   120B0
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
156F0:  BCF    F94.4
156F2:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
156F4:  BCF    F92.5
156F6:  BCF    F89.5
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
156F8:  MOVLB  3
156FA:  CLRF   x8C
156FC:  MOVLW  07
156FE:  MOVWF  x8B
15700:  CLRF   x8A
15702:  CLRF   x89
15704:  MOVLB  0
15706:  CALL   1214C
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
1570A:  CLRF   43
1570C:  MOVLW  07
1570E:  MOVWF  42
15710:  CLRF   41
15712:  CLRF   40
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
15714:  CALL   142D0
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
15718:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
*
1587E:  MOVF   47,F
15880:  BNZ   15888
15882:  MOVF   46,W
15884:  SUBLW  5F
15886:  BC    158D8
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
15888:  MOVLB  3
1588A:  CLRF   x8C
1588C:  MOVLW  09
1588E:  MOVWF  x8B
15890:  CLRF   x8A
15892:  CLRF   x89
15894:  MOVLB  0
15896:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
1589A:  BCF    F94.4
1589C:  BCF    F8B.4
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
1589E:  MOVLB  3
158A0:  CLRF   x8C
158A2:  MOVLW  09
158A4:  MOVWF  x8B
158A6:  CLRF   x8A
158A8:  CLRF   x89
158AA:  MOVLB  0
158AC:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
158B0:  BCF    F94.4
158B2:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
158B4:  BCF    F92.5
158B6:  BCF    F89.5
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
158B8:  MOVLB  3
158BA:  CLRF   x8C
158BC:  MOVLW  09
158BE:  MOVWF  x8B
158C0:  CLRF   x8A
158C2:  CLRF   x89
158C4:  MOVLB  0
158C6:  CALL   1214C
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
158CA:  CLRF   47
158CC:  MOVLW  09
158CE:  MOVWF  46
158D0:  CLRF   45
158D2:  CLRF   44
....................       STORE_ADRESS_DATA_TO_FLASH(); 
158D4:  CALL   142D0
....................    } 
....................    return; 
158D8:  RETURN 0
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
*
1571A:  MOVF   48,F
1571C:  BNZ   1572E
1571E:  MOVF   49,F
15720:  BNZ   1572E
15722:  MOVF   4A,F
15724:  BNZ   1572E
15726:  MOVF   4B,F
15728:  BNZ   1572E
1572A:  MOVLW  00
1572C:  BRA    15730
1572E:  MOVLW  01
15730:  MOVLB  3
15732:  CLRF   x31
15734:  CLRF   x30
15736:  CLRF   x2F
15738:  MOVWF  x2E
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
1573A:  MOVF   4B,W
1573C:  SUBLW  03
1573E:  BC    157B0
15740:  XORLW  FF
15742:  BNZ   1575E
15744:  MOVF   4A,W
15746:  SUBLW  47
15748:  BC    157B0
1574A:  XORLW  FF
1574C:  BNZ   1575E
1574E:  MOVF   49,W
15750:  SUBLW  FE
15752:  BC    157B0
15754:  XORLW  FF
15756:  BNZ   1575E
15758:  MOVF   48,W
1575A:  SUBLW  07
1575C:  BC    157B0
....................    { 
....................       sector_erase_OF(SECT*98); 
1575E:  CLRF   x8C
15760:  MOVLW  62
15762:  MOVWF  x8B
15764:  CLRF   x8A
15766:  CLRF   x89
15768:  MOVLB  0
1576A:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
1576E:  BCF    F94.4
15770:  BCF    F8B.4
....................       sector_erase_SCF(SECT*98); 
15772:  MOVLB  3
15774:  CLRF   x8C
15776:  MOVLW  62
15778:  MOVWF  x8B
1577A:  CLRF   x8A
1577C:  CLRF   x89
1577E:  MOVLB  0
15780:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15784:  BCF    F94.4
15786:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
15788:  BCF    F92.5
1578A:  BCF    F89.5
....................       sector_erase_SMF(SECT*98); 
1578C:  MOVLB  3
1578E:  CLRF   x8C
15790:  MOVLW  62
15792:  MOVWF  x8B
15794:  CLRF   x8A
15796:  CLRF   x89
15798:  MOVLB  0
1579A:  CALL   1214C
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
1579E:  CLRF   4B
157A0:  MOVLW  08
157A2:  MOVWF  4A
157A4:  CLRF   49
157A6:  CLRF   48
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
157A8:  CALL   142D0
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
157AC:  BRA    15878
157AE:  MOVLB  3
157B0:  MOVLW  00
157B2:  BSF    FD8.0
157B4:  SUBFWB x2E,W
157B6:  MOVWF  x32
157B8:  MOVLW  00
157BA:  SUBFWB x2F,W
157BC:  MOVWF  x33
157BE:  MOVLW  01
157C0:  SUBFWB x30,W
157C2:  MOVWF  x34
157C4:  MOVLW  00
157C6:  SUBFWB x31,W
157C8:  MOVWF  x35
157CA:  MOVF   x35,F
157CC:  BNZ   1587A
157CE:  MOVF   x34,F
157D0:  BNZ   1587A
157D2:  MOVF   x33,F
157D4:  BNZ   1587A
157D6:  MOVF   x32,W
157D8:  SUBLW  76
157DA:  BNC   1587A
....................       fprintf(PC,"erasing next sector\r\n"); 
157DC:  MOVLW  C0
157DE:  MOVWF  FF6
157E0:  MOVLW  05
157E2:  MOVWF  FF7
157E4:  MOVLW  00
157E6:  MOVWF  FF8
157E8:  MOVLB  0
157EA:  CALL   06A4
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
157EE:  MOVFF  48,332
157F2:  MOVLB  3
157F4:  MOVFF  49,333
157F8:  MOVLW  01
157FA:  ADDWF  4A,W
157FC:  MOVWF  x34
157FE:  MOVLW  00
15800:  ADDWFC 4B,W
15802:  MOVWF  x35
15804:  MOVWF  x8C
15806:  MOVFF  334,38B
1580A:  MOVFF  49,38A
1580E:  MOVFF  48,389
15812:  MOVLB  0
15814:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
15818:  BCF    F94.4
1581A:  BCF    F8B.4
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
1581C:  MOVFF  48,332
15820:  MOVLB  3
15822:  MOVFF  49,333
15826:  MOVLW  01
15828:  ADDWF  4A,W
1582A:  MOVWF  x34
1582C:  MOVLW  00
1582E:  ADDWFC 4B,W
15830:  MOVWF  x35
15832:  MOVWF  x8C
15834:  MOVFF  334,38B
15838:  MOVFF  49,38A
1583C:  MOVFF  48,389
15840:  MOVLB  0
15842:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15846:  BCF    F94.4
15848:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
1584A:  BCF    F92.5
1584C:  BCF    F89.5
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
1584E:  MOVFF  48,332
15852:  MOVLB  3
15854:  MOVFF  49,333
15858:  MOVLW  01
1585A:  ADDWF  4A,W
1585C:  MOVWF  x34
1585E:  MOVLW  00
15860:  ADDWFC 4B,W
15862:  MOVWF  x35
15864:  MOVWF  x8C
15866:  MOVFF  334,38B
1586A:  MOVFF  49,38A
1586E:  MOVFF  48,389
15872:  MOVLB  0
15874:  CALL   1214C
15878:  MOVLB  3
....................    } 
....................    return; 
1587A:  MOVLB  0
1587C:  RETURN 0
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
*
0186A:  MOVF   4C,F
0186C:  BNZ   187E
0186E:  MOVF   4D,F
01870:  BNZ   187E
01872:  MOVF   4E,F
01874:  BNZ   187E
01876:  MOVF   4F,F
01878:  BNZ   187E
0187A:  MOVLW  00
0187C:  BRA    1880
0187E:  MOVLW  01
01880:  MOVLB  3
01882:  CLRF   x31
01884:  CLRF   x30
01886:  CLRF   x2F
01888:  MOVWF  x2E
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
0188A:  MOVF   4F,W
0188C:  SUBLW  03
0188E:  BC    1908
01890:  XORLW  FF
01892:  BNZ   18AE
01894:  MOVF   4E,W
01896:  SUBLW  70
01898:  BC    1908
0189A:  XORLW  FF
0189C:  BNZ   18AE
0189E:  MOVF   4D,W
018A0:  SUBLW  FE
018A2:  BC    1908
018A4:  XORLW  FF
018A6:  BNZ   18AE
018A8:  MOVF   4C,W
018AA:  SUBLW  F5
018AC:  BC    1908
....................    {   
....................       sector_erase_OF(SECT*1098); 
018AE:  MOVLW  04
018B0:  MOVWF  x8C
018B2:  MOVLW  4A
018B4:  MOVWF  x8B
018B6:  CLRF   x8A
018B8:  CLRF   x89
018BA:  MOVLB  0
018BC:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
018C0:  BCF    F94.4
018C2:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1098); 
018C4:  MOVLW  04
018C6:  MOVLB  3
018C8:  MOVWF  x8C
018CA:  MOVLW  4A
018CC:  MOVWF  x8B
018CE:  CLRF   x8A
018D0:  CLRF   x89
018D2:  MOVLB  0
018D4:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
018D8:  BCF    F94.4
018DA:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
018DC:  BCF    F92.5
018DE:  BCF    F89.5
....................       sector_erase_SMF(SECT*1098); 
018E0:  MOVLW  04
018E2:  MOVLB  3
018E4:  MOVWF  x8C
018E6:  MOVLW  4A
018E8:  MOVWF  x8B
018EA:  CLRF   x8A
018EC:  CLRF   x89
018EE:  MOVLB  0
018F0:  CALL   1214C
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
018F4:  MOVLW  04
018F6:  MOVWF  4F
018F8:  MOVLW  4A
018FA:  MOVWF  4E
018FC:  CLRF   4D
018FE:  CLRF   4C
....................       STORE_ADRESS_DATA_TO_FLASH(); 
01900:  CALL   142D0
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
01904:  BRA    19D0
01906:  MOVLB  3
01908:  MOVLW  00
0190A:  BSF    FD8.0
0190C:  SUBFWB x2E,W
0190E:  MOVWF  x32
01910:  MOVLW  00
01912:  SUBFWB x2F,W
01914:  MOVWF  x33
01916:  MOVLW  01
01918:  SUBFWB x30,W
0191A:  MOVWF  x34
0191C:  MOVLW  00
0191E:  SUBFWB x31,W
01920:  MOVWF  x35
01922:  MOVF   x35,F
01924:  BNZ   19D2
01926:  MOVF   x34,F
01928:  BNZ   19D2
0192A:  MOVF   x33,F
0192C:  BNZ   19D2
0192E:  MOVF   x32,W
01930:  SUBLW  04
01932:  BNC   19D2
....................       fprintf(PC,"erasing next sector\r\n"); 
01934:  MOVLW  D6
01936:  MOVWF  FF6
01938:  MOVLW  05
0193A:  MOVWF  FF7
0193C:  MOVLW  00
0193E:  MOVWF  FF8
01940:  MOVLB  0
01942:  CALL   06A4
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
01946:  MOVFF  4C,332
0194A:  MOVLB  3
0194C:  MOVFF  4D,333
01950:  MOVLW  01
01952:  ADDWF  4E,W
01954:  MOVWF  x34
01956:  MOVLW  00
01958:  ADDWFC 4F,W
0195A:  MOVWF  x35
0195C:  MOVWF  x8C
0195E:  MOVFF  334,38B
01962:  MOVFF  4D,38A
01966:  MOVFF  4C,389
0196A:  MOVLB  0
0196C:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
01970:  BCF    F94.4
01972:  BCF    F8B.4
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
01974:  MOVFF  4C,332
01978:  MOVLB  3
0197A:  MOVFF  4D,333
0197E:  MOVLW  01
01980:  ADDWF  4E,W
01982:  MOVWF  x34
01984:  MOVLW  00
01986:  ADDWFC 4F,W
01988:  MOVWF  x35
0198A:  MOVWF  x8C
0198C:  MOVFF  334,38B
01990:  MOVFF  4D,38A
01994:  MOVFF  4C,389
01998:  MOVLB  0
0199A:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
0199E:  BCF    F94.4
019A0:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
019A2:  BCF    F92.5
019A4:  BCF    F89.5
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
019A6:  MOVFF  4C,332
019AA:  MOVLB  3
019AC:  MOVFF  4D,333
019B0:  MOVLW  01
019B2:  ADDWF  4E,W
019B4:  MOVWF  x34
019B6:  MOVLW  00
019B8:  ADDWFC 4F,W
019BA:  MOVWF  x35
019BC:  MOVWF  x8C
019BE:  MOVFF  334,38B
019C2:  MOVFF  4D,38A
019C6:  MOVFF  4C,389
019CA:  MOVLB  0
019CC:  CALL   1214C
019D0:  MOVLB  3
....................        
....................    } 
....................    return; 
019D2:  MOVLB  0
019D4:  RETURN 0
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
*
01320:  MOVF   53,W
01322:  SUBLW  05
01324:  BC    139E
01326:  XORLW  FF
01328:  BNZ   1344
0132A:  MOVF   52,W
0132C:  SUBLW  5E
0132E:  BC    139E
01330:  XORLW  FF
01332:  BNZ   1344
01334:  MOVF   51,W
01336:  SUBLW  C5
01338:  BC    139E
0133A:  XORLW  FF
0133C:  BNZ   1344
0133E:  MOVF   50,W
01340:  SUBLW  3F
01342:  BC    139E
....................    { 
....................       sector_erase_OF(SECT*1140); 
01344:  MOVLW  04
01346:  MOVLB  3
01348:  MOVWF  x8C
0134A:  MOVLW  74
0134C:  MOVWF  x8B
0134E:  CLRF   x8A
01350:  CLRF   x89
01352:  MOVLB  0
01354:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
01358:  BCF    F94.4
0135A:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1140); 
0135C:  MOVLW  04
0135E:  MOVLB  3
01360:  MOVWF  x8C
01362:  MOVLW  74
01364:  MOVWF  x8B
01366:  CLRF   x8A
01368:  CLRF   x89
0136A:  MOVLB  0
0136C:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
01370:  BCF    F94.4
01372:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
01374:  BCF    F92.5
01376:  BCF    F89.5
....................       sector_erase_SMF(SECT*1140); 
01378:  MOVLW  04
0137A:  MOVLB  3
0137C:  MOVWF  x8C
0137E:  MOVLW  74
01380:  MOVWF  x8B
01382:  CLRF   x8A
01384:  CLRF   x89
01386:  MOVLB  0
01388:  CALL   1214C
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
0138C:  MOVLW  04
0138E:  MOVWF  53
01390:  MOVLW  74
01392:  MOVWF  52
01394:  CLRF   51
01396:  CLRF   50
....................       STORE_ADRESS_DATA_TO_FLASH(); 
01398:  CALL   142D0
....................    }else{                                                                        //if value will be close to the sector 
0139C:  BRA    14A0
....................       fprintf(PC,"erasing next sector\r\n"); 
0139E:  MOVLW  EC
013A0:  MOVWF  FF6
013A2:  MOVLW  05
013A4:  MOVWF  FF7
013A6:  MOVLW  00
013A8:  MOVWF  FF8
013AA:  CALL   06A4
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
013AE:  MOVLW  01
013B0:  MOVLB  3
013B2:  MOVWF  x84
013B4:  MOVF   x84,W
013B6:  SUBLW  09
013B8:  BNC   13FC
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
013BA:  CLRF   01
013BC:  CLRF   02
013BE:  MOVFF  01,03
013C2:  MOVFF  384,02
013C6:  CLRF   00
013C8:  CLRF   01
013CA:  MOVF   00,W
013CC:  ADDWF  50,W
013CE:  MOVWF  x85
013D0:  MOVF   01,W
013D2:  ADDWFC 51,W
013D4:  MOVWF  x86
013D6:  MOVF   x84,W
013D8:  ADDWFC 52,W
013DA:  MOVWF  x87
013DC:  MOVF   03,W
013DE:  ADDWFC 53,W
013E0:  MOVWF  x88
013E2:  MOVWF  x8C
013E4:  MOVFF  387,38B
013E8:  MOVFF  386,38A
013EC:  MOVFF  385,389
013F0:  MOVLB  0
013F2:  CALL   12014
013F6:  MOVLB  3
013F8:  INCF   x84,F
013FA:  BRA    13B4
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
013FC:  BCF    F94.4
013FE:  BCF    F8B.4
....................       for(i = 1; i < 10; i++) 
01400:  MOVLW  01
01402:  MOVWF  x84
01404:  MOVF   x84,W
01406:  SUBLW  09
01408:  BNC   144C
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
0140A:  CLRF   01
0140C:  CLRF   02
0140E:  MOVFF  01,03
01412:  MOVFF  384,02
01416:  CLRF   00
01418:  CLRF   01
0141A:  MOVF   00,W
0141C:  ADDWF  50,W
0141E:  MOVWF  x85
01420:  MOVF   01,W
01422:  ADDWFC 51,W
01424:  MOVWF  x86
01426:  MOVF   x84,W
01428:  ADDWFC 52,W
0142A:  MOVWF  x87
0142C:  MOVF   03,W
0142E:  ADDWFC 53,W
01430:  MOVWF  x88
01432:  MOVWF  x8C
01434:  MOVFF  387,38B
01438:  MOVFF  386,38A
0143C:  MOVFF  385,389
01440:  MOVLB  0
01442:  CALL   120B0
01446:  MOVLB  3
01448:  INCF   x84,F
0144A:  BRA    1404
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
0144C:  BCF    F94.4
0144E:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
01450:  BCF    F92.5
01452:  BCF    F89.5
....................       for(i = 1; i < 10; i++) 
01454:  MOVLW  01
01456:  MOVWF  x84
01458:  MOVF   x84,W
0145A:  SUBLW  09
0145C:  BNC   14A0
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
0145E:  CLRF   01
01460:  CLRF   02
01462:  MOVFF  01,03
01466:  MOVFF  384,02
0146A:  CLRF   00
0146C:  CLRF   01
0146E:  MOVF   00,W
01470:  ADDWF  50,W
01472:  MOVWF  x85
01474:  MOVF   01,W
01476:  ADDWFC 51,W
01478:  MOVWF  x86
0147A:  MOVF   x84,W
0147C:  ADDWFC 52,W
0147E:  MOVWF  x87
01480:  MOVF   03,W
01482:  ADDWFC 53,W
01484:  MOVWF  x88
01486:  MOVWF  x8C
01488:  MOVFF  387,38B
0148C:  MOVFF  386,38A
01490:  MOVFF  385,389
01494:  MOVLB  0
01496:  CALL   1214C
0149A:  MOVLB  3
0149C:  INCF   x84,F
0149E:  BRA    1458
014A0:  MOVLB  0
....................       } 
....................    } 
....................    return; 
014A2:  GOTO   1229C (RETURN)
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
*
1457C:  MOVF   58,F
1457E:  BNZ   14590
14580:  MOVF   59,F
14582:  BNZ   14590
14584:  MOVF   5A,F
14586:  BNZ   14590
14588:  MOVF   5B,F
1458A:  BNZ   14590
1458C:  MOVLW  00
1458E:  BRA    14592
14590:  MOVLW  01
14592:  MOVLB  3
14594:  CLRF   x80
14596:  CLRF   x7F
14598:  CLRF   x7E
1459A:  MOVWF  x7D
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
1459C:  MOVF   5B,W
1459E:  SUBLW  05
145A0:  BC    1461E
145A2:  XORLW  FF
145A4:  BNZ   145C0
145A6:  MOVF   5A,W
145A8:  SUBLW  65
145AA:  BC    1461E
145AC:  XORLW  FF
145AE:  BNZ   145C0
145B0:  MOVF   59,W
145B2:  SUBLW  FD
145B4:  BC    1461E
145B6:  XORLW  FF
145B8:  BNZ   145C0
145BA:  MOVF   58,W
145BC:  SUBLW  60
145BE:  BC    1461E
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
145C0:  MOVLW  06
145C2:  MOVWF  x92
145C4:  MOVLW  67
145C6:  MOVWF  x91
145C8:  MOVLW  10
145CA:  MOVWF  x90
145CC:  CLRF   x8F
145CE:  MOVLB  0
145D0:  CALL   11914
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
145D4:  BCF    F94.4
145D6:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
145D8:  MOVLW  27
145DA:  MOVLB  3
145DC:  MOVWF  x92
145DE:  MOVLW  70
145E0:  MOVWF  x91
145E2:  CLRF   x90
145E4:  CLRF   x8F
145E6:  MOVLB  0
145E8:  CALL   119BE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
145EC:  BCF    F94.4
145EE:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
145F0:  BCF    F92.5
145F2:  BCF    F89.5
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
145F4:  MOVLW  06
145F6:  MOVLB  3
145F8:  MOVWF  x92
145FA:  MOVLW  67
145FC:  MOVWF  x91
145FE:  MOVLW  10
14600:  MOVWF  x90
14602:  CLRF   x8F
14604:  MOVLB  0
14606:  CALL   11A68
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
1460A:  MOVLW  06
1460C:  MOVWF  5B
1460E:  MOVLW  67
14610:  MOVWF  5A
14612:  MOVLW  10
14614:  MOVWF  59
14616:  CLRF   58
....................       STORE_ADRESS_DATA_TO_FLASH(); 
14618:  RCALL  142D0
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
1461A:  BRA    146F0
1461C:  MOVLB  3
1461E:  MOVLW  00
14620:  BSF    FD8.0
14622:  SUBFWB x7D,W
14624:  MOVWF  x81
14626:  MOVLW  10
14628:  SUBFWB x7E,W
1462A:  MOVWF  x82
1462C:  MOVLW  00
1462E:  SUBFWB x7F,W
14630:  MOVWF  x83
14632:  MOVLW  00
14634:  SUBFWB x80,W
14636:  MOVWF  x84
14638:  MOVF   x84,F
1463A:  BNZ   146F2
1463C:  MOVF   x83,F
1463E:  BNZ   146F2
14640:  MOVF   x82,W
14642:  SUBLW  03
14644:  BNC   146F2
14646:  BNZ   1464E
14648:  MOVF   x81,W
1464A:  SUBLW  1F
1464C:  BNC   146F2
....................       fprintf(PC,"erasing next sector\r\n"); 
1464E:  MOVLW  46
14650:  MOVWF  FF6
14652:  MOVLW  07
14654:  MOVWF  FF7
14656:  MOVLW  00
14658:  MOVWF  FF8
1465A:  MOVLB  0
1465C:  CALL   06A4
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
14660:  MOVFF  58,381
14664:  MOVLB  3
14666:  MOVLW  10
14668:  ADDWF  59,W
1466A:  MOVWF  x82
1466C:  MOVLW  00
1466E:  ADDWFC 5A,W
14670:  MOVWF  x83
14672:  MOVLW  00
14674:  ADDWFC 5B,W
14676:  MOVWF  x84
14678:  MOVWF  x92
1467A:  MOVFF  383,391
1467E:  MOVFF  382,390
14682:  MOVFF  58,38F
14686:  MOVLB  0
14688:  CALL   11914
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
1468C:  BCF    F94.4
1468E:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
14690:  MOVFF  58,381
14694:  MOVLB  3
14696:  MOVLW  10
14698:  ADDWF  59,W
1469A:  MOVWF  x82
1469C:  MOVLW  00
1469E:  ADDWFC 5A,W
146A0:  MOVWF  x83
146A2:  MOVLW  00
146A4:  ADDWFC 5B,W
146A6:  MOVWF  x84
146A8:  MOVWF  x92
146AA:  MOVFF  383,391
146AE:  MOVFF  382,390
146B2:  MOVFF  58,38F
146B6:  MOVLB  0
146B8:  CALL   119BE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
146BC:  BCF    F94.4
146BE:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
146C0:  BCF    F92.5
146C2:  BCF    F89.5
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
146C4:  MOVFF  58,381
146C8:  MOVLB  3
146CA:  MOVLW  10
146CC:  ADDWF  59,W
146CE:  MOVWF  x82
146D0:  MOVLW  00
146D2:  ADDWFC 5A,W
146D4:  MOVWF  x83
146D6:  MOVLW  00
146D8:  ADDWFC 5B,W
146DA:  MOVWF  x84
146DC:  MOVWF  x92
146DE:  MOVFF  383,391
146E2:  MOVFF  382,390
146E6:  MOVFF  58,38F
146EA:  MOVLB  0
146EC:  CALL   11A68
146F0:  MOVLB  3
....................    } 
....................    return; 
146F2:  MOVLB  0
146F4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
*
158DA:  MOVF   5F,W
158DC:  SUBLW  06
158DE:  BC    15954
158E0:  XORLW  FF
158E2:  BNZ   158FE
158E4:  MOVF   5E,W
158E6:  SUBLW  FB
158E8:  BC    15954
158EA:  XORLW  FF
158EC:  BNZ   158FE
158EE:  MOVF   5D,W
158F0:  SUBLW  45
158F2:  BC    15954
158F4:  XORLW  FF
158F6:  BNZ   158FE
158F8:  MOVF   5C,W
158FA:  SUBLW  7F
158FC:  BC    15954
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
158FE:  MOVLW  06
15900:  MOVLB  3
15902:  MOVWF  x8C
15904:  MOVLW  6A
15906:  MOVWF  x8B
15908:  CLRF   x8A
1590A:  CLRF   x89
1590C:  MOVLB  0
1590E:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
15912:  BCF    F94.4
15914:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1642); 
15916:  MOVLW  06
15918:  MOVLB  3
1591A:  MOVWF  x8C
1591C:  MOVLW  6A
1591E:  MOVWF  x8B
15920:  CLRF   x8A
15922:  CLRF   x89
15924:  MOVLB  0
15926:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
1592A:  BCF    F94.4
1592C:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
1592E:  BCF    F92.5
15930:  BCF    F89.5
....................       sector_erase_SMF(SECT*1642); 
15932:  MOVLW  06
15934:  MOVLB  3
15936:  MOVWF  x8C
15938:  MOVLW  6A
1593A:  MOVWF  x8B
1593C:  CLRF   x8A
1593E:  CLRF   x89
15940:  MOVLB  0
15942:  CALL   1214C
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
15946:  MOVLW  06
15948:  MOVWF  5F
1594A:  MOVLW  6A
1594C:  MOVWF  5E
1594E:  CLRF   5D
15950:  CLRF   5C
....................    }else{                                                                        //if value will be close to the sector 
15952:  BRA    15AEA
....................       fprintf(PC,"erasing next sector\r\n"); 
15954:  MOVLW  5C
15956:  MOVWF  FF6
15958:  MOVLW  07
1595A:  MOVWF  FF7
1595C:  MOVLW  00
1595E:  MOVWF  FF8
15960:  CALL   06A4
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
15964:  MOVFF  5C,33D
15968:  MOVLB  3
1596A:  MOVFF  5D,33E
1596E:  MOVLW  01
15970:  ADDWF  5E,W
15972:  MOVWF  x3F
15974:  MOVLW  00
15976:  ADDWFC 5F,W
15978:  MOVWF  x40
1597A:  MOVWF  x8C
1597C:  MOVFF  33F,38B
15980:  MOVFF  5D,38A
15984:  MOVFF  5C,389
15988:  MOVLB  0
1598A:  CALL   12014
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
1598E:  MOVFF  5C,33D
15992:  MOVLB  3
15994:  MOVFF  5D,33E
15998:  MOVLW  02
1599A:  ADDWF  5E,W
1599C:  MOVWF  x3F
1599E:  MOVLW  00
159A0:  ADDWFC 5F,W
159A2:  MOVWF  x40
159A4:  MOVWF  x8C
159A6:  MOVFF  33F,38B
159AA:  MOVFF  5D,38A
159AE:  MOVFF  5C,389
159B2:  MOVLB  0
159B4:  CALL   12014
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
159B8:  MOVFF  5C,33D
159BC:  MOVLB  3
159BE:  MOVFF  5D,33E
159C2:  MOVLW  03
159C4:  ADDWF  5E,W
159C6:  MOVWF  x3F
159C8:  MOVLW  00
159CA:  ADDWFC 5F,W
159CC:  MOVWF  x40
159CE:  MOVWF  x8C
159D0:  MOVFF  33F,38B
159D4:  MOVFF  5D,38A
159D8:  MOVFF  5C,389
159DC:  MOVLB  0
159DE:  CALL   12014
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
159E2:  BCF    F94.4
159E4:  BCF    F8B.4
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
159E6:  MOVFF  5C,33D
159EA:  MOVLB  3
159EC:  MOVFF  5D,33E
159F0:  MOVLW  01
159F2:  ADDWF  5E,W
159F4:  MOVWF  x3F
159F6:  MOVLW  00
159F8:  ADDWFC 5F,W
159FA:  MOVWF  x40
159FC:  MOVWF  x8C
159FE:  MOVFF  33F,38B
15A02:  MOVFF  5D,38A
15A06:  MOVFF  5C,389
15A0A:  MOVLB  0
15A0C:  CALL   120B0
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
15A10:  MOVFF  5C,33D
15A14:  MOVLB  3
15A16:  MOVFF  5D,33E
15A1A:  MOVLW  02
15A1C:  ADDWF  5E,W
15A1E:  MOVWF  x3F
15A20:  MOVLW  00
15A22:  ADDWFC 5F,W
15A24:  MOVWF  x40
15A26:  MOVWF  x8C
15A28:  MOVFF  33F,38B
15A2C:  MOVFF  5D,38A
15A30:  MOVFF  5C,389
15A34:  MOVLB  0
15A36:  CALL   120B0
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
15A3A:  MOVFF  5C,33D
15A3E:  MOVLB  3
15A40:  MOVFF  5D,33E
15A44:  MOVLW  03
15A46:  ADDWF  5E,W
15A48:  MOVWF  x3F
15A4A:  MOVLW  00
15A4C:  ADDWFC 5F,W
15A4E:  MOVWF  x40
15A50:  MOVWF  x8C
15A52:  MOVFF  33F,38B
15A56:  MOVFF  5D,38A
15A5A:  MOVFF  5C,389
15A5E:  MOVLB  0
15A60:  CALL   120B0
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15A64:  BCF    F94.4
15A66:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
15A68:  BCF    F92.5
15A6A:  BCF    F89.5
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
15A6C:  MOVFF  5C,33D
15A70:  MOVLB  3
15A72:  MOVFF  5D,33E
15A76:  MOVLW  01
15A78:  ADDWF  5E,W
15A7A:  MOVWF  x3F
15A7C:  MOVLW  00
15A7E:  ADDWFC 5F,W
15A80:  MOVWF  x40
15A82:  MOVWF  x8C
15A84:  MOVFF  33F,38B
15A88:  MOVFF  5D,38A
15A8C:  MOVFF  5C,389
15A90:  MOVLB  0
15A92:  CALL   1214C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
15A96:  MOVFF  5C,33D
15A9A:  MOVLB  3
15A9C:  MOVFF  5D,33E
15AA0:  MOVLW  02
15AA2:  ADDWF  5E,W
15AA4:  MOVWF  x3F
15AA6:  MOVLW  00
15AA8:  ADDWFC 5F,W
15AAA:  MOVWF  x40
15AAC:  MOVWF  x8C
15AAE:  MOVFF  33F,38B
15AB2:  MOVFF  5D,38A
15AB6:  MOVFF  5C,389
15ABA:  MOVLB  0
15ABC:  CALL   1214C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
15AC0:  MOVFF  5C,33D
15AC4:  MOVLB  3
15AC6:  MOVFF  5D,33E
15ACA:  MOVLW  03
15ACC:  ADDWF  5E,W
15ACE:  MOVWF  x3F
15AD0:  MOVLW  00
15AD2:  ADDWFC 5F,W
15AD4:  MOVWF  x40
15AD6:  MOVWF  x8C
15AD8:  MOVFF  33F,38B
15ADC:  MOVFF  5D,38A
15AE0:  MOVFF  5C,389
15AE4:  MOVLB  0
15AE6:  CALL   1214C
....................    } 
....................    return; 
15AEA:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<reserve_function.c> 
.................... #ifndef RESERVE_FUNCTION_C 
.................... #define RESERVE_FUNCTION_C 
....................  
.................... #define table_size 80 
.................... unsigned int8 reserve_table[table_size+1] = {}; 
.................... unsigned int8 table_num = 0; 
.................... #ORG 0x00016800 
.................... void initialize_table()                                                          //Funcion que inicializa una tabla 
.................... {                                                                                //completa todas las posiciones con 0xff 
....................    for(int num = 0; num < table_size; num++) 
*
16DC0:  MOVLB  3
16DC2:  CLRF   x39
16DC4:  MOVF   x39,W
16DC6:  SUBLW  4F
16DC8:  BNC   16DDE
....................    { 
....................       reserve_table[num] = 0xff; 
16DCA:  CLRF   03
16DCC:  MOVF   x39,W
16DCE:  ADDLW  E5
16DD0:  MOVWF  FE9
16DD2:  MOVLW  00
16DD4:  ADDWFC 03,W
16DD6:  MOVWF  FEA
16DD8:  SETF   FEF
16DDA:  INCF   x39,F
16DDC:  BRA    16DC4
....................    } 
....................    reserve_table[80] = 0;                                                        //Coloca en la ultima posicion 0 como cantidad de espacios utilizados 
16DDE:  MOVLB  1
16DE0:  CLRF   x35
....................    return; 
16DE2:  MOVLB  0
16DE4:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //                          ***Sort Function*** 
.................... //This is for sorting the saved reservation commands in ascending order. 
.................... // 
.................... //reserved_table[j-9] reserved_table[j-8] reserved_table[j-7] reserved_table[j-6] reserved_table[j-5] reserved_table[j-4] reserved_table[j-3] reserved_table[j-2] 
.................... //reserved_table[j-1]  reserved_table[j]  reserved_table[j+1] reserved_table[j+2] reserved_table[j+3] reserved_table[j+4] reserved_table[j+5] reserved_table[j+6]  
.................... // 
.................... //j-9 and j-1 data are the contents information(like mission) 
.................... //j-8 and j data are the time data(execute the command reserved_table[j] min later ) 
.................... //j-7 and j+1 data are the contents detail information 
.................... // 
.................... //by comapring j-8 and j data,if it is needed, swhich j-9 and j-1, j-8 and j, j-7 and j+1....etc 
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #ORG 0x00016800 
.................... int8 count_reservation()                                                         //Funcion que cuenta la cantidad de posiciones en la tabla con datos distintos de 0xFF  
*
16D88:  MOVLB  3
16D8A:  CLRF   x39
.................... { 
....................    int8 counter = 0; 
....................    for(int num = 1; num < table_size - 6; num = num + 8) 
16D8C:  MOVLW  01
16D8E:  MOVWF  x3A
16D90:  MOVF   x3A,W
16D92:  SUBLW  49
16D94:  BNC   16DB4
....................    { 
....................       if(reserve_table[num-1] != 0xff) 
16D96:  MOVLW  01
16D98:  SUBWF  x3A,W
16D9A:  CLRF   03
16D9C:  ADDLW  E5
16D9E:  MOVWF  FE9
16DA0:  MOVLW  00
16DA2:  ADDWFC 03,W
16DA4:  MOVWF  FEA
16DA6:  INCFSZ FEF,W
16DA8:  BRA    16DAC
16DAA:  BRA    16DAE
....................       { 
....................          counter++; 
16DAC:  INCF   x39,F
....................       } 
16DAE:  MOVLW  08
16DB0:  ADDWF  x3A,F
16DB2:  BRA    16D90
....................    } 
....................    return counter * 8; 
16DB4:  MOVF   x39,W
16DB6:  MULLW  08
16DB8:  MOVFF  FF3,01
16DBC:  MOVLB  0
16DBE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void sort_table()                                                                //(command info, time info, mission mode)~10compare the time and so in ascending formrt 
.................... { 
....................    for(int i = 1; i < table_size - 7; i = i + 8){ 
*
17D0A:  MOVLW  01
17D0C:  MOVLB  3
17D0E:  MOVWF  x2D
17D10:  MOVF   x2D,W
17D12:  SUBLW  48
17D14:  BTFSS  FD8.0
17D16:  BRA    18026
....................  
....................       //compare from lower site 
....................       for(int j = table_size - 7; j > i; j = j - 8){ 
17D18:  MOVLW  49
17D1A:  MOVWF  x2E
17D1C:  MOVF   x2E,W
17D1E:  SUBWF  x2D,W
17D20:  BTFSC  FD8.0
17D22:  BRA    18020
....................  
....................          // if upper value is larger, switch the values 
....................          if(reserve_table[j] < reserve_table[j-8]){                              //compare the time of [j]th and [j-8]th 
17D24:  CLRF   03
17D26:  MOVF   x2E,W
17D28:  ADDLW  E5
17D2A:  MOVWF  FE9
17D2C:  MOVLW  00
17D2E:  ADDWFC 03,W
17D30:  MOVWF  FEA
17D32:  MOVFF  FEF,337
17D36:  MOVLW  08
17D38:  SUBWF  x2E,W
17D3A:  CLRF   03
17D3C:  ADDLW  E5
17D3E:  MOVWF  FE9
17D40:  MOVLW  00
17D42:  ADDWFC 03,W
17D44:  MOVWF  FEA
17D46:  MOVF   FEF,W
17D48:  SUBWF  x37,W
17D4A:  BTFSC  FD8.0
17D4C:  BRA    1801A
....................             int t1 = reserve_table[j+6]; 
....................             int t2 = reserve_table[j+5]; 
....................             int t3 = reserve_table[j+4]; 
....................             int t4 = reserve_table[j+3]; 
....................             int t5 = reserve_table[j+2]; 
....................             int t6 = reserve_table[j+1]; 
....................             int t7 = reserve_table[j]; 
....................             int t8 = reserve_table[j-1]; 
17D4E:  MOVLW  06
17D50:  ADDWF  x2E,W
17D52:  CLRF   03
17D54:  ADDLW  E5
17D56:  MOVWF  FE9
17D58:  MOVLW  00
17D5A:  ADDWFC 03,W
17D5C:  MOVWF  FEA
17D5E:  MOVFF  FEF,32F
17D62:  MOVLW  05
17D64:  ADDWF  x2E,W
17D66:  CLRF   03
17D68:  ADDLW  E5
17D6A:  MOVWF  FE9
17D6C:  MOVLW  00
17D6E:  ADDWFC 03,W
17D70:  MOVWF  FEA
17D72:  MOVFF  FEF,330
17D76:  MOVLW  04
17D78:  ADDWF  x2E,W
17D7A:  CLRF   03
17D7C:  ADDLW  E5
17D7E:  MOVWF  FE9
17D80:  MOVLW  00
17D82:  ADDWFC 03,W
17D84:  MOVWF  FEA
17D86:  MOVFF  FEF,331
17D8A:  MOVLW  03
17D8C:  ADDWF  x2E,W
17D8E:  CLRF   03
17D90:  ADDLW  E5
17D92:  MOVWF  FE9
17D94:  MOVLW  00
17D96:  ADDWFC 03,W
17D98:  MOVWF  FEA
17D9A:  MOVFF  FEF,332
17D9E:  MOVLW  02
17DA0:  ADDWF  x2E,W
17DA2:  CLRF   03
17DA4:  ADDLW  E5
17DA6:  MOVWF  FE9
17DA8:  MOVLW  00
17DAA:  ADDWFC 03,W
17DAC:  MOVWF  FEA
17DAE:  MOVFF  FEF,333
17DB2:  MOVLW  01
17DB4:  ADDWF  x2E,W
17DB6:  CLRF   03
17DB8:  ADDLW  E5
17DBA:  MOVWF  FE9
17DBC:  MOVLW  00
17DBE:  ADDWFC 03,W
17DC0:  MOVWF  FEA
17DC2:  MOVFF  FEF,334
17DC6:  CLRF   03
17DC8:  MOVF   x2E,W
17DCA:  ADDLW  E5
17DCC:  MOVWF  FE9
17DCE:  MOVLW  00
17DD0:  ADDWFC 03,W
17DD2:  MOVWF  FEA
17DD4:  MOVFF  FEF,335
17DD8:  MOVLW  01
17DDA:  SUBWF  x2E,W
17DDC:  CLRF   03
17DDE:  ADDLW  E5
17DE0:  MOVWF  FE9
17DE2:  MOVLW  00
17DE4:  ADDWFC 03,W
17DE6:  MOVWF  FEA
17DE8:  MOVFF  FEF,336
....................  
....................             reserve_table[j+6] = reserve_table[j-2]; 
17DEC:  MOVLW  06
17DEE:  ADDWF  x2E,W
17DF0:  CLRF   03
17DF2:  ADDLW  E5
17DF4:  MOVWF  01
17DF6:  MOVLW  00
17DF8:  ADDWFC 03,F
17DFA:  MOVFF  03,338
17DFE:  MOVLW  02
17E00:  SUBWF  x2E,W
17E02:  CLRF   03
17E04:  ADDLW  E5
17E06:  MOVWF  FE9
17E08:  MOVLW  00
17E0A:  ADDWFC 03,W
17E0C:  MOVWF  FEA
17E0E:  MOVFF  FEF,339
17E12:  MOVFF  338,FEA
17E16:  MOVFF  01,FE9
17E1A:  MOVFF  339,FEF
....................             reserve_table[j+5] = reserve_table[j-3]; 
17E1E:  MOVLW  05
17E20:  ADDWF  x2E,W
17E22:  CLRF   03
17E24:  ADDLW  E5
17E26:  MOVWF  01
17E28:  MOVLW  00
17E2A:  ADDWFC 03,F
17E2C:  MOVFF  03,338
17E30:  MOVLW  03
17E32:  SUBWF  x2E,W
17E34:  CLRF   03
17E36:  ADDLW  E5
17E38:  MOVWF  FE9
17E3A:  MOVLW  00
17E3C:  ADDWFC 03,W
17E3E:  MOVWF  FEA
17E40:  MOVFF  FEF,339
17E44:  MOVFF  338,FEA
17E48:  MOVFF  01,FE9
17E4C:  MOVFF  339,FEF
....................             reserve_table[j+4] = reserve_table[j-4]; 
17E50:  MOVLW  04
17E52:  ADDWF  x2E,W
17E54:  CLRF   03
17E56:  ADDLW  E5
17E58:  MOVWF  01
17E5A:  MOVLW  00
17E5C:  ADDWFC 03,F
17E5E:  MOVFF  03,338
17E62:  MOVLW  04
17E64:  SUBWF  x2E,W
17E66:  CLRF   03
17E68:  ADDLW  E5
17E6A:  MOVWF  FE9
17E6C:  MOVLW  00
17E6E:  ADDWFC 03,W
17E70:  MOVWF  FEA
17E72:  MOVFF  FEF,339
17E76:  MOVFF  338,FEA
17E7A:  MOVFF  01,FE9
17E7E:  MOVFF  339,FEF
....................             reserve_table[j+3] = reserve_table[j-5]; 
17E82:  MOVLW  03
17E84:  ADDWF  x2E,W
17E86:  CLRF   03
17E88:  ADDLW  E5
17E8A:  MOVWF  01
17E8C:  MOVLW  00
17E8E:  ADDWFC 03,F
17E90:  MOVFF  03,338
17E94:  MOVLW  05
17E96:  SUBWF  x2E,W
17E98:  CLRF   03
17E9A:  ADDLW  E5
17E9C:  MOVWF  FE9
17E9E:  MOVLW  00
17EA0:  ADDWFC 03,W
17EA2:  MOVWF  FEA
17EA4:  MOVFF  FEF,339
17EA8:  MOVFF  338,FEA
17EAC:  MOVFF  01,FE9
17EB0:  MOVFF  339,FEF
....................             reserve_table[j+2] = reserve_table[j-6]; 
17EB4:  MOVLW  02
17EB6:  ADDWF  x2E,W
17EB8:  CLRF   03
17EBA:  ADDLW  E5
17EBC:  MOVWF  01
17EBE:  MOVLW  00
17EC0:  ADDWFC 03,F
17EC2:  MOVFF  03,338
17EC6:  MOVLW  06
17EC8:  SUBWF  x2E,W
17ECA:  CLRF   03
17ECC:  ADDLW  E5
17ECE:  MOVWF  FE9
17ED0:  MOVLW  00
17ED2:  ADDWFC 03,W
17ED4:  MOVWF  FEA
17ED6:  MOVFF  FEF,339
17EDA:  MOVFF  338,FEA
17EDE:  MOVFF  01,FE9
17EE2:  MOVFF  339,FEF
....................             reserve_table[j+1] = reserve_table[j-7]; 
17EE6:  MOVLW  01
17EE8:  ADDWF  x2E,W
17EEA:  CLRF   03
17EEC:  ADDLW  E5
17EEE:  MOVWF  01
17EF0:  MOVLW  00
17EF2:  ADDWFC 03,F
17EF4:  MOVFF  03,338
17EF8:  MOVLW  07
17EFA:  SUBWF  x2E,W
17EFC:  CLRF   03
17EFE:  ADDLW  E5
17F00:  MOVWF  FE9
17F02:  MOVLW  00
17F04:  ADDWFC 03,W
17F06:  MOVWF  FEA
17F08:  MOVFF  FEF,339
17F0C:  MOVFF  338,FEA
17F10:  MOVFF  01,FE9
17F14:  MOVFF  339,FEF
....................             reserve_table[j] = reserve_table[j-8]; 
17F18:  CLRF   03
17F1A:  MOVF   x2E,W
17F1C:  ADDLW  E5
17F1E:  MOVWF  01
17F20:  MOVLW  00
17F22:  ADDWFC 03,F
17F24:  MOVFF  03,338
17F28:  MOVLW  08
17F2A:  SUBWF  x2E,W
17F2C:  CLRF   03
17F2E:  ADDLW  E5
17F30:  MOVWF  FE9
17F32:  MOVLW  00
17F34:  ADDWFC 03,W
17F36:  MOVWF  FEA
17F38:  MOVFF  FEF,339
17F3C:  MOVFF  338,FEA
17F40:  MOVFF  01,FE9
17F44:  MOVFF  339,FEF
....................             reserve_table[j-1] = reserve_table[j-9]; 
17F48:  MOVLW  01
17F4A:  SUBWF  x2E,W
17F4C:  CLRF   03
17F4E:  ADDLW  E5
17F50:  MOVWF  01
17F52:  MOVLW  00
17F54:  ADDWFC 03,F
17F56:  MOVFF  03,338
17F5A:  MOVLW  09
17F5C:  SUBWF  x2E,W
17F5E:  CLRF   03
17F60:  ADDLW  E5
17F62:  MOVWF  FE9
17F64:  MOVLW  00
17F66:  ADDWFC 03,W
17F68:  MOVWF  FEA
17F6A:  MOVFF  FEF,339
17F6E:  MOVFF  338,FEA
17F72:  MOVFF  01,FE9
17F76:  MOVFF  339,FEF
....................  
....................             reserve_table[j-2] = t1; 
17F7A:  MOVLW  02
17F7C:  SUBWF  x2E,W
17F7E:  CLRF   03
17F80:  ADDLW  E5
17F82:  MOVWF  FE9
17F84:  MOVLW  00
17F86:  ADDWFC 03,W
17F88:  MOVWF  FEA
17F8A:  MOVFF  32F,FEF
....................             reserve_table[j-3] = t2; 
17F8E:  MOVLW  03
17F90:  SUBWF  x2E,W
17F92:  CLRF   03
17F94:  ADDLW  E5
17F96:  MOVWF  FE9
17F98:  MOVLW  00
17F9A:  ADDWFC 03,W
17F9C:  MOVWF  FEA
17F9E:  MOVFF  330,FEF
....................             reserve_table[j-4] = t3; 
17FA2:  MOVLW  04
17FA4:  SUBWF  x2E,W
17FA6:  CLRF   03
17FA8:  ADDLW  E5
17FAA:  MOVWF  FE9
17FAC:  MOVLW  00
17FAE:  ADDWFC 03,W
17FB0:  MOVWF  FEA
17FB2:  MOVFF  331,FEF
....................             reserve_table[j-5] = t4; 
17FB6:  MOVLW  05
17FB8:  SUBWF  x2E,W
17FBA:  CLRF   03
17FBC:  ADDLW  E5
17FBE:  MOVWF  FE9
17FC0:  MOVLW  00
17FC2:  ADDWFC 03,W
17FC4:  MOVWF  FEA
17FC6:  MOVFF  332,FEF
....................             reserve_table[j-6] = t5; 
17FCA:  MOVLW  06
17FCC:  SUBWF  x2E,W
17FCE:  CLRF   03
17FD0:  ADDLW  E5
17FD2:  MOVWF  FE9
17FD4:  MOVLW  00
17FD6:  ADDWFC 03,W
17FD8:  MOVWF  FEA
17FDA:  MOVFF  333,FEF
....................             reserve_table[j-7] = t6; 
17FDE:  MOVLW  07
17FE0:  SUBWF  x2E,W
17FE2:  CLRF   03
17FE4:  ADDLW  E5
17FE6:  MOVWF  FE9
17FE8:  MOVLW  00
17FEA:  ADDWFC 03,W
17FEC:  MOVWF  FEA
17FEE:  MOVFF  334,FEF
....................             reserve_table[j-8] = t7; 
17FF2:  MOVLW  08
17FF4:  SUBWF  x2E,W
17FF6:  CLRF   03
17FF8:  ADDLW  E5
17FFA:  MOVWF  FE9
17FFC:  MOVLW  00
17FFE:  ADDWFC 03,W
18000:  MOVWF  FEA
18002:  MOVFF  335,FEF
....................             reserve_table[j-9] = t8; 
18006:  MOVLW  09
18008:  SUBWF  x2E,W
1800A:  CLRF   03
1800C:  ADDLW  E5
1800E:  MOVWF  FE9
18010:  MOVLW  00
18012:  ADDWFC 03,W
18014:  MOVWF  FEA
18016:  MOVFF  336,FEF
....................  
....................  
....................          } 
1801A:  MOVLW  08
1801C:  SUBWF  x2E,F
1801E:  BRA    17D1C
....................       } 
18020:  MOVLW  08
18022:  ADDWF  x2D,F
18024:  BRA    17D10
....................    } 
.................... return; 
18026:  MOVLB  0
18028:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Save_RSV() 
.................... { 
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
*
168AA:  BCF    F92.5
168AC:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
168AE:  BCF    F94.4
168B0:  BCF    F8B.4
....................    SUBSECTOR_4KB_ERASE_OF(RSV_DATA_ADDRESS); 
168B2:  MOVFF  3F,392
168B6:  MOVFF  3E,391
168BA:  MOVFF  3D,390
168BE:  MOVFF  3C,38F
168C2:  CALL   11914
....................    delay_ms(100); 
168C6:  MOVLW  64
168C8:  MOVLB  3
168CA:  MOVWF  x98
168CC:  MOVLB  0
168CE:  CALL   063E
....................    SUBSECTOR_4KB_ERASE_SCF(RSV_DATA_ADDRESS); 
168D2:  MOVFF  3F,392
168D6:  MOVFF  3E,391
168DA:  MOVFF  3D,390
168DE:  MOVFF  3C,38F
168E2:  CALL   119BE
....................    delay_ms(100); 
168E6:  MOVLW  64
168E8:  MOVLB  3
168EA:  MOVWF  x98
168EC:  MOVLB  0
168EE:  CALL   063E
....................    SUBSECTOR_4KB_ERASE_SMF(RSV_DATA_ADDRESS); 
168F2:  MOVFF  3F,392
168F6:  MOVFF  3E,391
168FA:  MOVFF  3D,390
168FE:  MOVFF  3C,38F
16902:  CALL   11A68
....................    delay_ms(100); 
16906:  MOVLW  64
16908:  MOVLB  3
1690A:  MOVWF  x98
1690C:  MOVLB  0
1690E:  CALL   063E
....................     
....................    for(int num = 0; num < table_size + 1; num++)                                 //save in flash memory reserve_table[] content 
16912:  MOVLB  3
16914:  CLRF   x85
16916:  MOVF   x85,W
16918:  SUBLW  50
1691A:  BNC   169E6
....................    { 
....................       WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
1691C:  MOVF   x85,W
1691E:  ADDWF  3C,W
16920:  MOVWF  x86
16922:  MOVLW  00
16924:  ADDWFC 3D,W
16926:  MOVWF  x87
16928:  MOVLW  00
1692A:  ADDWFC 3E,W
1692C:  MOVWF  x88
1692E:  MOVLW  00
16930:  ADDWFC 3F,W
16932:  MOVWF  x89
16934:  CLRF   03
16936:  MOVF   x85,W
16938:  ADDLW  E5
1693A:  MOVWF  FE9
1693C:  MOVLW  00
1693E:  ADDWFC 03,W
16940:  MOVWF  FEA
16942:  MOVFF  FEF,394
16946:  MOVFF  389,393
1694A:  MOVFF  388,392
1694E:  MOVFF  387,391
16952:  MOVFF  386,390
16956:  MOVLB  0
16958:  CALL   11B8C
....................       WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
1695C:  MOVLB  3
1695E:  MOVF   x85,W
16960:  ADDWF  3C,W
16962:  MOVWF  x86
16964:  MOVLW  00
16966:  ADDWFC 3D,W
16968:  MOVWF  x87
1696A:  MOVLW  00
1696C:  ADDWFC 3E,W
1696E:  MOVWF  x88
16970:  MOVLW  00
16972:  ADDWFC 3F,W
16974:  MOVWF  x89
16976:  CLRF   03
16978:  MOVF   x85,W
1697A:  ADDLW  E5
1697C:  MOVWF  FE9
1697E:  MOVLW  00
16980:  ADDWFC 03,W
16982:  MOVWF  FEA
16984:  MOVFF  FEF,394
16988:  MOVFF  389,393
1698C:  MOVFF  388,392
16990:  MOVFF  387,391
16994:  MOVFF  386,390
16998:  MOVLB  0
1699A:  CALL   11C8C
....................       WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
1699E:  MOVLB  3
169A0:  MOVF   x85,W
169A2:  ADDWF  3C,W
169A4:  MOVWF  x86
169A6:  MOVLW  00
169A8:  ADDWFC 3D,W
169AA:  MOVWF  x87
169AC:  MOVLW  00
169AE:  ADDWFC 3E,W
169B0:  MOVWF  x88
169B2:  MOVLW  00
169B4:  ADDWFC 3F,W
169B6:  MOVWF  x89
169B8:  CLRF   03
169BA:  MOVF   x85,W
169BC:  ADDLW  E5
169BE:  MOVWF  FE9
169C0:  MOVLW  00
169C2:  ADDWFC 03,W
169C4:  MOVWF  FEA
169C6:  MOVFF  FEF,394
169CA:  MOVFF  389,393
169CE:  MOVFF  388,392
169D2:  MOVFF  387,391
169D6:  MOVFF  386,390
169DA:  MOVLB  0
169DC:  CALL   11C0C
169E0:  MOVLB  3
169E2:  INCF   x85,F
169E4:  BRA    16916
....................    } 
....................     
....................    WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG);                     // save reserve flag 
169E6:  MOVLW  51
169E8:  ADDWF  3C,W
169EA:  MOVWF  x86
169EC:  MOVLW  00
169EE:  ADDWFC 3D,W
169F0:  MOVWF  x87
169F2:  MOVLW  00
169F4:  ADDWFC 3E,W
169F6:  MOVWF  x88
169F8:  MOVLW  00
169FA:  ADDWFC 3F,W
169FC:  MOVWF  x89
169FE:  MOVWF  x93
16A00:  MOVFF  388,392
16A04:  MOVFF  387,391
16A08:  MOVFF  386,390
16A0C:  MOVFF  6C,394
16A10:  MOVLB  0
16A12:  CALL   11B8C
....................    WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG); 
16A16:  MOVLW  51
16A18:  ADDWF  3C,W
16A1A:  MOVLB  3
16A1C:  MOVWF  x86
16A1E:  MOVLW  00
16A20:  ADDWFC 3D,W
16A22:  MOVWF  x87
16A24:  MOVLW  00
16A26:  ADDWFC 3E,W
16A28:  MOVWF  x88
16A2A:  MOVLW  00
16A2C:  ADDWFC 3F,W
16A2E:  MOVWF  x89
16A30:  MOVWF  x93
16A32:  MOVFF  388,392
16A36:  MOVFF  387,391
16A3A:  MOVFF  386,390
16A3E:  MOVFF  6C,394
16A42:  MOVLB  0
16A44:  CALL   11C0C
....................    WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG); 
16A48:  MOVLW  51
16A4A:  ADDWF  3C,W
16A4C:  MOVLB  3
16A4E:  MOVWF  x86
16A50:  MOVLW  00
16A52:  ADDWFC 3D,W
16A54:  MOVWF  x87
16A56:  MOVLW  00
16A58:  ADDWFC 3E,W
16A5A:  MOVWF  x88
16A5C:  MOVLW  00
16A5E:  ADDWFC 3F,W
16A60:  MOVWF  x89
16A62:  MOVWF  x93
16A64:  MOVFF  388,392
16A68:  MOVFF  387,391
16A6C:  MOVFF  386,390
16A70:  MOVFF  6C,394
16A74:  MOVLB  0
16A76:  CALL   11C8C
....................    for(num = 0; num < table_size + 1; num++)                                     //show in PC RSV DATA 
16A7A:  MOVLB  3
16A7C:  CLRF   x85
16A7E:  MOVF   x85,W
16A80:  SUBLW  50
16A82:  BNC   16ACA
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num)); 
16A84:  MOVF   x85,W
16A86:  ADDWF  3C,W
16A88:  MOVWF  x86
16A8A:  MOVLW  00
16A8C:  ADDWFC 3D,W
16A8E:  MOVWF  x87
16A90:  MOVLW  00
16A92:  ADDWFC 3E,W
16A94:  MOVWF  x88
16A96:  MOVLW  00
16A98:  ADDWFC 3F,W
16A9A:  MOVWF  x89
16A9C:  MOVWF  xAB
16A9E:  MOVFF  388,3AA
16AA2:  MOVFF  387,3A9
16AA6:  MOVFF  386,3A8
16AAA:  MOVLB  0
16AAC:  CALL   11B04
16AB0:  MOVFF  01,386
16AB4:  MOVFF  01,3A2
16AB8:  MOVLW  57
16ABA:  MOVLB  3
16ABC:  MOVWF  xA3
16ABE:  MOVLB  0
16AC0:  CALL   0700
16AC4:  MOVLB  3
16AC6:  INCF   x85,F
16AC8:  BRA    16A7E
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX MAINSIDE 
16ACA:  BCF    F94.4
16ACC:  BSF    F8B.4
....................    fprintf(PC,"\r\n"); 
16ACE:  MOVLW  0D
16AD0:  BTFSS  F9E.4
16AD2:  BRA    16AD0
16AD4:  MOVWF  FAD
16AD6:  MOVLW  0A
16AD8:  BTFSS  F9E.4
16ADA:  BRA    16AD8
16ADC:  MOVWF  FAD
....................    return; 
16ADE:  MOVLB  0
16AE0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void table_refresh()                                                             //table and flags are come back to default  
.................... { 
....................    for(int i = 0; i < table_size; i++) 
*
18356:  MOVLB  3
18358:  CLRF   x37
1835A:  MOVF   x37,W
1835C:  SUBLW  4F
1835E:  BNC   18374
....................    { 
....................       reserve_table[i] = 0xff; 
18360:  CLRF   03
18362:  MOVF   x37,W
18364:  ADDLW  E5
18366:  MOVWF  FE9
18368:  MOVLW  00
1836A:  ADDWFC 03,W
1836C:  MOVWF  FEA
1836E:  SETF   FEF
18370:  INCF   x37,F
18372:  BRA    1835A
....................    } 
....................    reserve_table[80] = 0; 
18374:  MOVLB  1
18376:  CLRF   x35
....................    RESERVE_MIN_FLAG = 0; 
18378:  MOVLB  0
1837A:  CLRF   x6C
....................    RESERVE_SEC_FLAG = 0; 
1837C:  CLRF   x7D
....................    RESERVE_CHECK = 0; 
1837E:  CLRF   x6B
....................    MISSION_CONTENTS = 0;                                                         //closest mission command 
18380:  CLRF   x6E
....................    RESERVE_TARGET_FLAG = 0;                                                      //closest time data 
18382:  CLRF   x6D
....................    MISSION_DETAIL = 0;                                                           //closest mission command detail 
18384:  CLRF   x6F
....................    RESERVE_ADDRESS_1 = 0;                                                        //closest mission address 
18386:  CLRF   x70
....................    RESERVE_ADDRESS_2 = 0;                                                        //closest mission address 
18388:  CLRF   x71
....................    RESERVE_ADDRESS_3 = 0;                                                        //closest mission address 
1838A:  CLRF   x72
....................    RESERVE_ADDRESS_4 = 0;                                                        //closest mission address 
1838C:  CLRF   x73
....................    RESERVE_PACKET_NUM = 0;                                                       //closest mission pckt number 
1838E:  CLRF   x74
....................    Save_RSV(); 
18390:  CALL   168AA
....................    return; 
18394:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Get_RSV() 
.................... { 
....................    //fprintf(PC,"%x"); 
....................    for(int num = 0; num < table_size+1; num++)                                   //Carga en el vector reserve_table[] los datos leidos de la flash memory  
*
16DE6:  MOVLB  3
16DE8:  CLRF   x38
16DEA:  MOVF   x38,W
16DEC:  SUBLW  50
16DEE:  BNC   16E42
....................    {                                                                             //desde la posicion RSV_DATA_ADDRESS hasta el tamao de la tabla 
....................       reserve_table[num]=READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num);              //import reservation table info 
16DF0:  CLRF   03
16DF2:  MOVF   x38,W
16DF4:  ADDLW  E5
16DF6:  MOVWF  01
16DF8:  MOVLW  00
16DFA:  ADDWFC 03,F
16DFC:  MOVFF  01,339
16E00:  MOVFF  03,33A
16E04:  MOVF   x38,W
16E06:  ADDWF  3C,W
16E08:  MOVWF  x3B
16E0A:  MOVLW  00
16E0C:  ADDWFC 3D,W
16E0E:  MOVWF  x3C
16E10:  MOVLW  00
16E12:  ADDWFC 3E,W
16E14:  MOVWF  x3D
16E16:  MOVLW  00
16E18:  ADDWFC 3F,W
16E1A:  MOVWF  x3E
16E1C:  MOVWF  xAB
16E1E:  MOVFF  33D,3AA
16E22:  MOVFF  33C,3A9
16E26:  MOVFF  33B,3A8
16E2A:  MOVLB  0
16E2C:  CALL   11B04
16E30:  MOVFF  33A,FEA
16E34:  MOVFF  339,FE9
16E38:  MOVFF  01,FEF
16E3C:  MOVLB  3
16E3E:  INCF   x38,F
16E40:  BRA    16DEA
....................    } 
....................    reserve_table[80] = count_reservation();                                      //Carga en la posicion 30 la cantidad de posiciones ocupadas con datos 
16E42:  MOVLB  0
16E44:  RCALL  16D88
16E46:  MOVFF  01,135
....................    //   RESERVE_MIN_FLAG = READ_DATA_BYTE_OF(RSV_DATA_ADDRESS+31); 
....................    if(reserve_table[80] == 0xFF || reserve_table[80] == 0x00)                    //Si la tabla no tiene datos almacenados 
16E4A:  MOVLB  1
16E4C:  INCFSZ x35,W
16E4E:  BRA    16E52
16E50:  BRA    16E56
16E52:  MOVF   x35,F
16E54:  BNZ   16E5C
....................    { 
....................       initialize_table();                                                        //completa con 0xff toda la tabla 
16E56:  MOVLB  0
16E58:  RCALL  16DC0
16E5A:  MOVLB  1
....................    } 
....................    table_num = reserve_table[80];                                                //guarda en table_num la cantidad de datos que contiene la tabla 
16E5C:  MOVFF  135,136
....................    if(table_num != 0x00)                                                         //yes-->get reserved command and target time 
16E60:  MOVF   x36,F
16E62:  BZ    16E8E
....................    { 
....................       RESERVE_CHECK = 1;                                                         //LA tabla esta utilizada 
16E64:  MOVLW  01
16E66:  MOVLB  0
16E68:  MOVWF  x6B
....................       MISSION_CONTENTS = reserve_table[0];                                       //closest mission command 
16E6A:  MOVFF  E5,6E
....................       RESERVE_TARGET_FLAG = reserve_table[1];                                    //closest time data 
16E6E:  MOVFF  E6,6D
....................       MISSION_DETAIL = reserve_table[2];                                         //closest mission command detail 
16E72:  MOVFF  E7,6F
....................       RESERVE_ADDRESS_1 = reserve_table[3];                                      //closest mission address 
16E76:  MOVFF  E8,70
....................       RESERVE_ADDRESS_2 = reserve_table[4];                                      //closest mission address 
16E7A:  MOVFF  E9,71
....................       RESERVE_ADDRESS_3 = reserve_table[5];                                      //closest mission address 
16E7E:  MOVFF  EA,72
....................       RESERVE_ADDRESS_4 = reserve_table[6];                                      //closest mission address 
16E82:  MOVFF  EB,73
....................       RESERVE_PACKET_NUM = reserve_table[7];                                     //closest mission pckt number 
16E86:  MOVFF  EC,74
....................    }else{ 
16E8A:  BRA    16EA2
16E8C:  MOVLB  1
....................       RESERVE_CHECK = 0;                                                         //la tabla no esta utilizada 
16E8E:  MOVLB  0
16E90:  CLRF   x6B
....................       MISSION_CONTENTS = 0xff;                                                   //closest mission command 
16E92:  SETF   x6E
....................       RESERVE_TARGET_FLAG = 0xff;                                                //closest time data 
16E94:  SETF   x6D
....................       MISSION_DETAIL = 0xff;                                                     //closest mission command detail 
16E96:  SETF   x6F
....................       RESERVE_ADDRESS_1 = 0xff;                                                  //closest mission address 
16E98:  SETF   x70
....................       RESERVE_ADDRESS_2 = 0xff;                                                  //closest mission address 
16E9A:  SETF   x71
....................       RESERVE_ADDRESS_3 = 0xff;                                                  //closest mission address 
16E9C:  SETF   x72
....................       RESERVE_ADDRESS_4 = 0xff;                                                  //closest mission address 
16E9E:  SETF   x73
....................       RESERVE_PACKET_NUM = 0xff;                                                 //closest mission pckt number 
16EA0:  SETF   x74
....................    } 
....................    return; 
16EA2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Disp_RSV()                                                                  //show the reserve status (reserve command and reserve table) 
.................... { 
....................    Get_RSV();                                                                    //get the info from the main flash 
*
171FC:  RCALL  16DE6
....................    for(int num = 0; num < table_size + 1; num++) 
171FE:  MOVLB  3
17200:  CLRF   x37
17202:  MOVF   x37,W
17204:  SUBLW  50
17206:  BNC   1722A
....................    { 
....................       fprintf(PC,"%x",reserve_table[num]); 
17208:  CLRF   03
1720A:  MOVF   x37,W
1720C:  ADDLW  E5
1720E:  MOVWF  FE9
17210:  MOVLW  00
17212:  ADDWFC 03,W
17214:  MOVWF  FEA
17216:  MOVFF  FEF,3A2
1721A:  MOVLW  57
1721C:  MOVWF  xA3
1721E:  MOVLB  0
17220:  CALL   0700
17224:  MOVLB  3
17226:  INCF   x37,F
17228:  BRA    17202
....................    } 
....................    fprintf(PC,"\r\n"); 
1722A:  MOVLW  0D
1722C:  BTFSS  F9E.4
1722E:  BRA    1722C
17230:  MOVWF  FAD
17232:  MOVLW  0A
17234:  BTFSS  F9E.4
17236:  BRA    17234
17238:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_CHECK = %x\r\n",RESERVE_CHECK); 
1723A:  MOVLW  72
1723C:  MOVWF  FF6
1723E:  MOVLW  07
17240:  MOVWF  FF7
17242:  MOVLW  00
17244:  MOVWF  FF8
17246:  MOVLW  10
17248:  MOVWF  xA2
1724A:  MOVLB  0
1724C:  CALL   06CE
17250:  MOVFF  6B,3A2
17254:  MOVLW  57
17256:  MOVLB  3
17258:  MOVWF  xA3
1725A:  MOVLB  0
1725C:  CALL   0700
17260:  MOVLW  0D
17262:  BTFSS  F9E.4
17264:  BRA    17262
17266:  MOVWF  FAD
17268:  MOVLW  0A
1726A:  BTFSS  F9E.4
1726C:  BRA    1726A
1726E:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION_CONTENTS = %x\r\n",MISSION_CONTENTS); 
17270:  MOVLW  88
17272:  MOVWF  FF6
17274:  MOVLW  07
17276:  MOVWF  FF7
17278:  MOVLW  00
1727A:  MOVWF  FF8
1727C:  MOVLW  19
1727E:  MOVLB  3
17280:  MOVWF  xA2
17282:  MOVLB  0
17284:  CALL   06CE
17288:  MOVFF  6E,3A2
1728C:  MOVLW  57
1728E:  MOVLB  3
17290:  MOVWF  xA3
17292:  MOVLB  0
17294:  CALL   0700
17298:  MOVLW  0D
1729A:  BTFSS  F9E.4
1729C:  BRA    1729A
1729E:  MOVWF  FAD
172A0:  MOVLW  0A
172A2:  BTFSS  F9E.4
172A4:  BRA    172A2
172A6:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_TARGET_FLAG = %x\r\n",RESERVE_TARGET_FLAG); 
172A8:  MOVLW  A6
172AA:  MOVWF  FF6
172AC:  MOVLW  07
172AE:  MOVWF  FF7
172B0:  MOVLW  00
172B2:  MOVWF  FF8
172B4:  MOVLW  16
172B6:  MOVLB  3
172B8:  MOVWF  xA2
172BA:  MOVLB  0
172BC:  CALL   06CE
172C0:  MOVFF  6D,3A2
172C4:  MOVLW  57
172C6:  MOVLB  3
172C8:  MOVWF  xA3
172CA:  MOVLB  0
172CC:  CALL   0700
172D0:  MOVLW  0D
172D2:  BTFSS  F9E.4
172D4:  BRA    172D2
172D6:  MOVWF  FAD
172D8:  MOVLW  0A
172DA:  BTFSS  F9E.4
172DC:  BRA    172DA
172DE:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION DETAIL = %x\r\n",MISSION_DETAIL); 
172E0:  MOVLW  C2
172E2:  MOVWF  FF6
172E4:  MOVLW  07
172E6:  MOVWF  FF7
172E8:  MOVLW  00
172EA:  MOVWF  FF8
172EC:  MOVLW  17
172EE:  MOVLB  3
172F0:  MOVWF  xA2
172F2:  MOVLB  0
172F4:  CALL   06CE
172F8:  MOVFF  6F,3A2
172FC:  MOVLW  57
172FE:  MOVLB  3
17300:  MOVWF  xA3
17302:  MOVLB  0
17304:  CALL   0700
17308:  MOVLW  0D
1730A:  BTFSS  F9E.4
1730C:  BRA    1730A
1730E:  MOVWF  FAD
17310:  MOVLW  0A
17312:  BTFSS  F9E.4
17314:  BRA    17312
17316:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION ADDRESS = %x%x%x%x\r\n",RESERVE_ADDRESS_1,RESERVE_ADDRESS_2,RESERVE_ADDRESS_3,RESERVE_ADDRESS_4); 
17318:  MOVLW  DE
1731A:  MOVWF  FF6
1731C:  MOVLW  07
1731E:  MOVWF  FF7
17320:  MOVLW  00
17322:  MOVWF  FF8
17324:  MOVLW  18
17326:  MOVLB  3
17328:  MOVWF  xA2
1732A:  MOVLB  0
1732C:  CALL   06CE
17330:  MOVFF  70,3A2
17334:  MOVLW  57
17336:  MOVLB  3
17338:  MOVWF  xA3
1733A:  MOVLB  0
1733C:  CALL   0700
17340:  MOVFF  71,3A2
17344:  MOVLW  57
17346:  MOVLB  3
17348:  MOVWF  xA3
1734A:  MOVLB  0
1734C:  CALL   0700
17350:  MOVFF  72,3A2
17354:  MOVLW  57
17356:  MOVLB  3
17358:  MOVWF  xA3
1735A:  MOVLB  0
1735C:  CALL   0700
17360:  MOVFF  73,3A2
17364:  MOVLW  57
17366:  MOVLB  3
17368:  MOVWF  xA3
1736A:  MOVLB  0
1736C:  CALL   0700
17370:  MOVLW  0D
17372:  BTFSS  F9E.4
17374:  BRA    17372
17376:  MOVWF  FAD
17378:  MOVLW  0A
1737A:  BTFSS  F9E.4
1737C:  BRA    1737A
1737E:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION PCKT NUMBER = %x\r\n",RESERVE_MIN_FLAG); 
17380:  MOVLW  02
17382:  MOVWF  FF6
17384:  MOVLW  08
17386:  MOVWF  FF7
17388:  MOVLW  00
1738A:  MOVWF  FF8
1738C:  MOVLW  1C
1738E:  MOVLB  3
17390:  MOVWF  xA2
17392:  MOVLB  0
17394:  CALL   06CE
17398:  MOVFF  6C,3A2
1739C:  MOVLW  57
1739E:  MOVLB  3
173A0:  MOVWF  xA3
173A2:  MOVLB  0
173A4:  CALL   0700
173A8:  MOVLW  0D
173AA:  BTFSS  F9E.4
173AC:  BRA    173AA
173AE:  MOVWF  FAD
173B0:  MOVLW  0A
173B2:  BTFSS  F9E.4
173B4:  BRA    173B2
173B6:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_MIN_FLAG = %x\r\n",RESERVE_MIN_FLAG); 
173B8:  MOVLW  24
173BA:  MOVWF  FF6
173BC:  MOVLW  08
173BE:  MOVWF  FF7
173C0:  MOVLW  00
173C2:  MOVWF  FF8
173C4:  MOVLW  13
173C6:  MOVLB  3
173C8:  MOVWF  xA2
173CA:  MOVLB  0
173CC:  CALL   06CE
173D0:  MOVFF  6C,3A2
173D4:  MOVLW  57
173D6:  MOVLB  3
173D8:  MOVWF  xA3
173DA:  MOVLB  0
173DC:  CALL   0700
173E0:  MOVLW  0D
173E2:  BTFSS  F9E.4
173E4:  BRA    173E2
173E6:  MOVWF  FAD
173E8:  MOVLW  0A
173EA:  BTFSS  F9E.4
173EC:  BRA    173EA
173EE:  MOVWF  FAD
....................    fprintf(PC,"TABLE NUM = %x\r\n",table_num); 
173F0:  MOVLW  3C
173F2:  MOVWF  FF6
173F4:  MOVLW  08
173F6:  MOVWF  FF7
173F8:  MOVLW  00
173FA:  MOVWF  FF8
173FC:  MOVLW  0C
173FE:  MOVLB  3
17400:  MOVWF  xA2
17402:  MOVLB  0
17404:  CALL   06CE
17408:  MOVFF  136,3A2
1740C:  MOVLW  57
1740E:  MOVLB  3
17410:  MOVWF  xA3
17412:  MOVLB  0
17414:  CALL   0700
17418:  MOVLW  0D
1741A:  BTFSS  F9E.4
1741C:  BRA    1741A
1741E:  MOVWF  FAD
17420:  MOVLW  0A
17422:  BTFSS  F9E.4
17424:  BRA    17422
17426:  MOVWF  FAD
....................     
....................    return; 
17428:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void input_reservation_COM()                                                     //put the command from COM into the table and sort in ascending form 
.................... { 
....................    //!   reserve_table[table_num] = CMD_FROM_PC[0];                                 //input the data about mission content 
....................    //!   reserve_table[table_num + 1] = CMD_FROM_PC[1];                             //input the data about time data 
....................    //!   reserve_table[table_num + 2] = CMD_FROM_PC[2];                             //input the data about mission detail mode 
....................    //fprintf(PC,"Table num: %x\r\n",reserve_table[80]);                          //show the amount of bytes ocupied in the table 
....................    table_num = reserve_table[80]; 
*
180F8:  MOVFF  135,136
....................    if(reserve_table[80] == 80) 
180FC:  MOVLB  1
180FE:  MOVF   x35,W
18100:  SUBLW  50
18102:  BNZ   1811A
....................    { 
....................       fprintf(PC,"Reservation table is Full!\r\n\r\n"); 
18104:  MOVLW  4E
18106:  MOVWF  FF6
18108:  MOVLW  08
1810A:  MOVWF  FF7
1810C:  MOVLW  00
1810E:  MOVWF  FF8
18110:  MOVLB  0
18112:  CALL   06A4
....................    }else{ 
18116:  BRA    182FE
18118:  MOVLB  1
....................       if(RESERVE_CHECK != 0x00)                                                  //if the table is in use 
1811A:  MOVLB  0
1811C:  MOVF   x6B,F
1811E:  BTFSC  FD8.2
18120:  BRA    18256
....................       { 
....................          for(int num = 1; num < table_size - 6; num = num + 8)                   //check all command data placed in the table and update the time 
18122:  MOVLW  01
18124:  MOVLB  3
18126:  MOVWF  x2C
18128:  MOVF   x2C,W
1812A:  SUBLW  49
1812C:  BNC   181A8
....................          { 
....................             if(reserve_table[num-1] != 0xff)                                      
1812E:  MOVLW  01
18130:  SUBWF  x2C,W
18132:  CLRF   03
18134:  ADDLW  E5
18136:  MOVWF  FE9
18138:  MOVLW  00
1813A:  ADDWFC 03,W
1813C:  MOVWF  FEA
1813E:  INCFSZ FEF,W
18140:  BRA    18144
18142:  BRA    181A2
....................             { 
....................                if(reserve_table[num] > RESERVE_MIN_FLAG) 
18144:  CLRF   03
18146:  MOVF   x2C,W
18148:  ADDLW  E5
1814A:  MOVWF  FE9
1814C:  MOVLW  00
1814E:  ADDWFC 03,W
18150:  MOVWF  FEA
18152:  MOVF   FEF,W
18154:  MOVLB  0
18156:  SUBWF  x6C,W
18158:  BC    18190
....................                { 
....................                   reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;    //update the time of all commands 
1815A:  CLRF   03
1815C:  MOVLB  3
1815E:  MOVF   x2C,W
18160:  ADDLW  E5
18162:  MOVWF  01
18164:  MOVLW  00
18166:  ADDWFC 03,F
18168:  MOVFF  03,32E
1816C:  CLRF   03
1816E:  MOVF   x2C,W
18170:  ADDLW  E5
18172:  MOVWF  FE9
18174:  MOVLW  00
18176:  ADDWFC 03,W
18178:  MOVWF  FEA
1817A:  MOVLB  0
1817C:  MOVF   x6C,W
1817E:  SUBWF  FEF,W
18180:  MOVLB  3
18182:  MOVFF  32E,FEA
18186:  MOVFF  01,FE9
1818A:  MOVWF  FEF
....................                }else{ 
1818C:  BRA    181A2
1818E:  MOVLB  0
....................                   reserve_table[num] = 0; 
18190:  CLRF   03
18192:  MOVLB  3
18194:  MOVF   x2C,W
18196:  ADDLW  E5
18198:  MOVWF  FE9
1819A:  MOVLW  00
1819C:  ADDWFC 03,W
1819E:  MOVWF  FEA
181A0:  CLRF   FEF
....................                } 
....................             } 
181A2:  MOVLW  08
181A4:  ADDWF  x2C,F
181A6:  BRA    18128
....................          } 
....................          reserve_table[table_num] = in_bffr_main[4];                             //input the data about mission content 
181A8:  CLRF   03
181AA:  MOVLB  1
181AC:  MOVF   x36,W
181AE:  ADDLW  E5
181B0:  MOVWF  FE9
181B2:  MOVLW  00
181B4:  ADDWFC 03,W
181B6:  MOVWF  FEA
181B8:  MOVFF  8A,FEF
....................          reserve_table[table_num + 1] = in_bffr_main[5];                         //input data about time 
181BC:  MOVLW  01
181BE:  ADDWF  x36,W
181C0:  CLRF   03
181C2:  ADDLW  E5
181C4:  MOVWF  FE9
181C6:  MOVLW  00
181C8:  ADDWFC 03,W
181CA:  MOVWF  FEA
181CC:  MOVFF  8B,FEF
....................          reserve_table[table_num + 2] = in_bffr_main[6];                         //input the data about mission detail mode 
181D0:  MOVLW  02
181D2:  ADDWF  x36,W
181D4:  CLRF   03
181D6:  ADDLW  E5
181D8:  MOVWF  FE9
181DA:  MOVLW  00
181DC:  ADDWFC 03,W
181DE:  MOVWF  FEA
181E0:  MOVFF  8C,FEF
....................          reserve_table[table_num + 3] = in_bffr_main[7];                         //input address 
181E4:  MOVLW  03
181E6:  ADDWF  x36,W
181E8:  CLRF   03
181EA:  ADDLW  E5
181EC:  MOVWF  FE9
181EE:  MOVLW  00
181F0:  ADDWFC 03,W
181F2:  MOVWF  FEA
181F4:  MOVFF  8D,FEF
....................          reserve_table[table_num + 4] = in_bffr_main[8];                         //input address 
181F8:  MOVLW  04
181FA:  ADDWF  x36,W
181FC:  CLRF   03
181FE:  ADDLW  E5
18200:  MOVWF  FE9
18202:  MOVLW  00
18204:  ADDWFC 03,W
18206:  MOVWF  FEA
18208:  MOVFF  8E,FEF
....................          reserve_table[table_num + 5] = in_bffr_main[9];                         //input address 
1820C:  MOVLW  05
1820E:  ADDWF  x36,W
18210:  CLRF   03
18212:  ADDLW  E5
18214:  MOVWF  FE9
18216:  MOVLW  00
18218:  ADDWFC 03,W
1821A:  MOVWF  FEA
1821C:  MOVFF  8F,FEF
....................          reserve_table[table_num + 6] = in_bffr_main[10];                        //input address 
18220:  MOVLW  06
18222:  ADDWF  x36,W
18224:  CLRF   03
18226:  ADDLW  E5
18228:  MOVWF  FE9
1822A:  MOVLW  00
1822C:  ADDWFC 03,W
1822E:  MOVWF  FEA
18230:  MOVFF  90,FEF
....................          reserve_table[table_num + 7] = in_bffr_main[11];                        //input packet number 
18234:  MOVLW  07
18236:  ADDWF  x36,W
18238:  CLRF   03
1823A:  ADDLW  E5
1823C:  MOVWF  FE9
1823E:  MOVLW  00
18240:  ADDWFC 03,W
18242:  MOVWF  FEA
18244:  MOVFF  91,FEF
....................          if(RESERVE_MIN_FLAG != 0)                                               //RESERVE_MIN_FLAG = 0 --> no need to update the target flag 
18248:  MOVLB  0
1824A:  MOVF   x6C,F
1824C:  BZ    18254
....................          { 
....................             RESERVE_TARGET_FLAG = RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG; 
1824E:  MOVF   x6C,W
18250:  SUBWF  x6D,F
....................             RESERVE_MIN_FLAG = 0; 
18252:  CLRF   x6C
....................          } 
....................       }else{                                                                     //if first reservation 
18254:  BRA    182FC
....................          RESERVE_MIN_FLAG = 0; 
18256:  CLRF   x6C
....................          RESERVE_SEC_FLAG = 0; 
18258:  CLRF   x7D
....................          reserve_table[table_num] = in_bffr_main[4];                             //input the data about mission content 
1825A:  CLRF   03
1825C:  MOVLB  1
1825E:  MOVF   x36,W
18260:  ADDLW  E5
18262:  MOVWF  FE9
18264:  MOVLW  00
18266:  ADDWFC 03,W
18268:  MOVWF  FEA
1826A:  MOVFF  8A,FEF
....................          reserve_table[table_num + 1] = in_bffr_main[5];                         //input time data 
1826E:  MOVLW  01
18270:  ADDWF  x36,W
18272:  CLRF   03
18274:  ADDLW  E5
18276:  MOVWF  FE9
18278:  MOVLW  00
1827A:  ADDWFC 03,W
1827C:  MOVWF  FEA
1827E:  MOVFF  8B,FEF
....................          reserve_table[table_num + 2] = in_bffr_main[6];                         //input the data about mission mode detail 
18282:  MOVLW  02
18284:  ADDWF  x36,W
18286:  CLRF   03
18288:  ADDLW  E5
1828A:  MOVWF  FE9
1828C:  MOVLW  00
1828E:  ADDWFC 03,W
18290:  MOVWF  FEA
18292:  MOVFF  8C,FEF
....................          reserve_table[table_num + 3] = in_bffr_main[7];                         //input address 
18296:  MOVLW  03
18298:  ADDWF  x36,W
1829A:  CLRF   03
1829C:  ADDLW  E5
1829E:  MOVWF  FE9
182A0:  MOVLW  00
182A2:  ADDWFC 03,W
182A4:  MOVWF  FEA
182A6:  MOVFF  8D,FEF
....................          reserve_table[table_num + 4] = in_bffr_main[8];                         //input address 
182AA:  MOVLW  04
182AC:  ADDWF  x36,W
182AE:  CLRF   03
182B0:  ADDLW  E5
182B2:  MOVWF  FE9
182B4:  MOVLW  00
182B6:  ADDWFC 03,W
182B8:  MOVWF  FEA
182BA:  MOVFF  8E,FEF
....................          reserve_table[table_num + 5] = in_bffr_main[9];                         //input address 
182BE:  MOVLW  05
182C0:  ADDWF  x36,W
182C2:  CLRF   03
182C4:  ADDLW  E5
182C6:  MOVWF  FE9
182C8:  MOVLW  00
182CA:  ADDWFC 03,W
182CC:  MOVWF  FEA
182CE:  MOVFF  8F,FEF
....................          reserve_table[table_num + 6] = in_bffr_main[10];                        //input address 
182D2:  MOVLW  06
182D4:  ADDWF  x36,W
182D6:  CLRF   03
182D8:  ADDLW  E5
182DA:  MOVWF  FE9
182DC:  MOVLW  00
182DE:  ADDWFC 03,W
182E0:  MOVWF  FEA
182E2:  MOVFF  90,FEF
....................          reserve_table[table_num + 7] = in_bffr_main[11];                        //input packet number 
182E6:  MOVLW  07
182E8:  ADDWF  x36,W
182EA:  CLRF   03
182EC:  ADDLW  E5
182EE:  MOVWF  FE9
182F0:  MOVLW  00
182F2:  ADDWFC 03,W
182F4:  MOVWF  FEA
182F6:  MOVFF  91,FEF
182FA:  MOVLB  0
....................       } 
....................       //table_num = table_num + 3; 
....................       //reserve_table[30] = table_num; 
....................       sort_table(); 
182FC:  RCALL  17D0A
....................       //!      for(int num = 0; num < table_size+1; num++) 
....................       //!      { 
....................       //!         fprintf(PC,"%x",reserve_table[num]);//show for the test 
....................       //!      } 
....................    } 
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
182FE:  CALL   16D88
18302:  MOVFF  01,135
....................    return; 
18306:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void input_reservation_PC()                                                      //put the command from PC into the table and sort 
.................... { 
....................    fprintf(PC,"Table num: %x\r\n",reserve_table[80]);                            //print the table 
*
18396:  MOVLW  6E
18398:  MOVWF  FF6
1839A:  MOVLW  08
1839C:  MOVWF  FF7
1839E:  MOVLW  00
183A0:  MOVWF  FF8
183A2:  MOVLW  0B
183A4:  MOVLB  3
183A6:  MOVWF  xA2
183A8:  MOVLB  0
183AA:  CALL   06CE
183AE:  MOVFF  135,3A2
183B2:  MOVLW  57
183B4:  MOVLB  3
183B6:  MOVWF  xA3
183B8:  MOVLB  0
183BA:  CALL   0700
183BE:  MOVLW  0D
183C0:  BTFSS  F9E.4
183C2:  BRA    183C0
183C4:  MOVWF  FAD
183C6:  MOVLW  0A
183C8:  BTFSS  F9E.4
183CA:  BRA    183C8
183CC:  MOVWF  FAD
....................    table_num = reserve_table[80]; 
183CE:  MOVFF  135,136
....................    if(reserve_table[80] == 80) 
183D2:  MOVLB  1
183D4:  MOVF   x35,W
183D6:  SUBLW  50
183D8:  BNZ   183F0
....................    { 
....................       fprintf(PC,"Reservation table is Full!\r\n\r\n"); 
183DA:  MOVLW  7E
183DC:  MOVWF  FF6
183DE:  MOVLW  08
183E0:  MOVWF  FF7
183E2:  MOVLW  00
183E4:  MOVWF  FF8
183E6:  MOVLB  0
183E8:  CALL   06A4
....................    }else{ 
183EC:  BRA    185D6
183EE:  MOVLB  1
....................       if(RESERVE_CHECK != 0x00)                                                  //if new reservation is faster than target time 
183F0:  MOVLB  0
183F2:  MOVF   x6B,F
183F4:  BTFSC  FD8.2
183F6:  BRA    1852C
....................       { 
....................          for(int num = 1; num < table_size - 6; num = num + 8) 
183F8:  MOVLW  01
183FA:  MOVLB  3
183FC:  MOVWF  x2C
183FE:  MOVF   x2C,W
18400:  SUBLW  49
18402:  BNC   1847E
....................          { 
....................             if(reserve_table[num-1] != 0xff)                                     //check all command data placed in the table and update the time 
18404:  MOVLW  01
18406:  SUBWF  x2C,W
18408:  CLRF   03
1840A:  ADDLW  E5
1840C:  MOVWF  FE9
1840E:  MOVLW  00
18410:  ADDWFC 03,W
18412:  MOVWF  FEA
18414:  INCFSZ FEF,W
18416:  BRA    1841A
18418:  BRA    18478
....................             { 
....................                if(reserve_table[num] > RESERVE_MIN_FLAG) 
1841A:  CLRF   03
1841C:  MOVF   x2C,W
1841E:  ADDLW  E5
18420:  MOVWF  FE9
18422:  MOVLW  00
18424:  ADDWFC 03,W
18426:  MOVWF  FEA
18428:  MOVF   FEF,W
1842A:  MOVLB  0
1842C:  SUBWF  x6C,W
1842E:  BC    18466
....................                { 
....................                   reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;    //update the time of all commands 
18430:  CLRF   03
18432:  MOVLB  3
18434:  MOVF   x2C,W
18436:  ADDLW  E5
18438:  MOVWF  01
1843A:  MOVLW  00
1843C:  ADDWFC 03,F
1843E:  MOVFF  03,32E
18442:  CLRF   03
18444:  MOVF   x2C,W
18446:  ADDLW  E5
18448:  MOVWF  FE9
1844A:  MOVLW  00
1844C:  ADDWFC 03,W
1844E:  MOVWF  FEA
18450:  MOVLB  0
18452:  MOVF   x6C,W
18454:  SUBWF  FEF,W
18456:  MOVLB  3
18458:  MOVFF  32E,FEA
1845C:  MOVFF  01,FE9
18460:  MOVWF  FEF
....................                }else{ 
18462:  BRA    18478
18464:  MOVLB  0
....................                   reserve_table[num] = 0; 
18466:  CLRF   03
18468:  MOVLB  3
1846A:  MOVF   x2C,W
1846C:  ADDLW  E5
1846E:  MOVWF  FE9
18470:  MOVLW  00
18472:  ADDWFC 03,W
18474:  MOVWF  FEA
18476:  CLRF   FEF
....................                } 
....................             } 
18478:  MOVLW  08
1847A:  ADDWF  x2C,F
1847C:  BRA    183FE
....................          } 
....................          reserve_table[table_num] = CMD_FROM_PC[0];                              //input the data about mission content 
1847E:  CLRF   03
18480:  MOVLB  1
18482:  MOVF   x36,W
18484:  ADDLW  E5
18486:  MOVWF  FE9
18488:  MOVLW  00
1848A:  ADDWFC 03,W
1848C:  MOVWF  FEA
1848E:  MOVFF  7E,FEF
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1];                          //input reservation time 
18492:  MOVLW  01
18494:  ADDWF  x36,W
18496:  CLRF   03
18498:  ADDLW  E5
1849A:  MOVWF  FE9
1849C:  MOVLW  00
1849E:  ADDWFC 03,W
184A0:  MOVWF  FEA
184A2:  MOVFF  7F,FEF
....................          reserve_table[table_num + 2] = CMD_FROM_PC[2];                          //input the data about mission detail mode 
184A6:  MOVLW  02
184A8:  ADDWF  x36,W
184AA:  CLRF   03
184AC:  ADDLW  E5
184AE:  MOVWF  FE9
184B0:  MOVLW  00
184B2:  ADDWFC 03,W
184B4:  MOVWF  FEA
184B6:  MOVFF  80,FEF
....................          reserve_table[table_num + 3] = CMD_FROM_PC[3];                          //input address 
184BA:  MOVLW  03
184BC:  ADDWF  x36,W
184BE:  CLRF   03
184C0:  ADDLW  E5
184C2:  MOVWF  FE9
184C4:  MOVLW  00
184C6:  ADDWFC 03,W
184C8:  MOVWF  FEA
184CA:  MOVFF  81,FEF
....................          reserve_table[table_num + 4] = CMD_FROM_PC[4];                          //input address 
184CE:  MOVLW  04
184D0:  ADDWF  x36,W
184D2:  CLRF   03
184D4:  ADDLW  E5
184D6:  MOVWF  FE9
184D8:  MOVLW  00
184DA:  ADDWFC 03,W
184DC:  MOVWF  FEA
184DE:  MOVFF  82,FEF
....................          reserve_table[table_num + 5] = CMD_FROM_PC[5];                          //input address 
184E2:  MOVLW  05
184E4:  ADDWF  x36,W
184E6:  CLRF   03
184E8:  ADDLW  E5
184EA:  MOVWF  FE9
184EC:  MOVLW  00
184EE:  ADDWFC 03,W
184F0:  MOVWF  FEA
184F2:  MOVFF  83,FEF
....................          reserve_table[table_num + 6] = CMD_FROM_PC[6];                          //input address 
184F6:  MOVLW  06
184F8:  ADDWF  x36,W
184FA:  CLRF   03
184FC:  ADDLW  E5
184FE:  MOVWF  FE9
18500:  MOVLW  00
18502:  ADDWFC 03,W
18504:  MOVWF  FEA
18506:  MOVFF  84,FEF
....................          reserve_table[table_num + 7] = CMD_FROM_PC[7];                          //input packet number 
1850A:  MOVLW  07
1850C:  ADDWF  x36,W
1850E:  CLRF   03
18510:  ADDLW  E5
18512:  MOVWF  FE9
18514:  MOVLW  00
18516:  ADDWFC 03,W
18518:  MOVWF  FEA
1851A:  MOVFF  85,FEF
....................           
....................          if(RESERVE_MIN_FLAG != 0)                                               //RESERVE_MIN_FLAG = 0 --> no need to update the target flag 
1851E:  MOVLB  0
18520:  MOVF   x6C,F
18522:  BZ    1852A
....................          { 
....................             RESERVE_TARGET_FLAG = RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG; 
18524:  MOVF   x6C,W
18526:  SUBWF  x6D,F
....................             RESERVE_MIN_FLAG = 0; 
18528:  CLRF   x6C
....................          } 
....................       }else{                                                                     //if first reservation 
1852A:  BRA    185D2
....................          RESERVE_MIN_FLAG = 0; 
1852C:  CLRF   x6C
....................          RESERVE_SEC_FLAG = 0; 
1852E:  CLRF   x7D
....................          reserve_table[table_num] = CMD_FROM_PC[0];                              //input the data about mission content 
18530:  CLRF   03
18532:  MOVLB  1
18534:  MOVF   x36,W
18536:  ADDLW  E5
18538:  MOVWF  FE9
1853A:  MOVLW  00
1853C:  ADDWFC 03,W
1853E:  MOVWF  FEA
18540:  MOVFF  7E,FEF
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1]; 
18544:  MOVLW  01
18546:  ADDWF  x36,W
18548:  CLRF   03
1854A:  ADDLW  E5
1854C:  MOVWF  FE9
1854E:  MOVLW  00
18550:  ADDWFC 03,W
18552:  MOVWF  FEA
18554:  MOVFF  7F,FEF
....................          reserve_table[table_num + 2] = CMD_FROM_PC[2];                          //input the data about mission detail mode 
18558:  MOVLW  02
1855A:  ADDWF  x36,W
1855C:  CLRF   03
1855E:  ADDLW  E5
18560:  MOVWF  FE9
18562:  MOVLW  00
18564:  ADDWFC 03,W
18566:  MOVWF  FEA
18568:  MOVFF  80,FEF
....................          reserve_table[table_num + 3] = CMD_FROM_PC[3];                          //input address 
1856C:  MOVLW  03
1856E:  ADDWF  x36,W
18570:  CLRF   03
18572:  ADDLW  E5
18574:  MOVWF  FE9
18576:  MOVLW  00
18578:  ADDWFC 03,W
1857A:  MOVWF  FEA
1857C:  MOVFF  81,FEF
....................          reserve_table[table_num + 4] = CMD_FROM_PC[4];                          //input address 
18580:  MOVLW  04
18582:  ADDWF  x36,W
18584:  CLRF   03
18586:  ADDLW  E5
18588:  MOVWF  FE9
1858A:  MOVLW  00
1858C:  ADDWFC 03,W
1858E:  MOVWF  FEA
18590:  MOVFF  82,FEF
....................          reserve_table[table_num + 5] = CMD_FROM_PC[5];                          //input address 
18594:  MOVLW  05
18596:  ADDWF  x36,W
18598:  CLRF   03
1859A:  ADDLW  E5
1859C:  MOVWF  FE9
1859E:  MOVLW  00
185A0:  ADDWFC 03,W
185A2:  MOVWF  FEA
185A4:  MOVFF  83,FEF
....................          reserve_table[table_num + 6] = CMD_FROM_PC[6];                          //input address 
185A8:  MOVLW  06
185AA:  ADDWF  x36,W
185AC:  CLRF   03
185AE:  ADDLW  E5
185B0:  MOVWF  FE9
185B2:  MOVLW  00
185B4:  ADDWFC 03,W
185B6:  MOVWF  FEA
185B8:  MOVFF  84,FEF
....................          reserve_table[table_num + 7] = CMD_FROM_PC[7];                          //input packet number 
185BC:  MOVLW  07
185BE:  ADDWF  x36,W
185C0:  CLRF   03
185C2:  ADDLW  E5
185C4:  MOVWF  FE9
185C6:  MOVLW  00
185C8:  ADDWFC 03,W
185CA:  MOVWF  FEA
185CC:  MOVFF  85,FEF
185D0:  MOVLB  0
....................       }       
....................       sort_table(); 
185D2:  CALL   17D0A
....................    } 
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
185D6:  CALL   16D88
185DA:  MOVFF  01,135
....................    return; 
185DE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Remove_1_Reservation()                                                      //after executing the mission, it should be finished 
.................... { 
....................    for(int i = 1; i < table_size - 6; i = i + 8) 
*
1802A:  MOVLW  01
1802C:  MOVLB  3
1802E:  MOVWF  x2C
18030:  MOVF   x2C,W
18032:  SUBLW  49
18034:  BNC   18082
....................    { 
....................       if(reserve_table[i-1] != 0xff)                                             //check whether command data is placed 
18036:  MOVLW  01
18038:  SUBWF  x2C,W
1803A:  CLRF   03
1803C:  ADDLW  E5
1803E:  MOVWF  FE9
18040:  MOVLW  00
18042:  ADDWFC 03,W
18044:  MOVWF  FEA
18046:  INCFSZ FEF,W
18048:  BRA    1804C
1804A:  BRA    1807C
....................       { 
....................          reserve_table[i] = reserve_table[i] - RESERVE_TARGET_FLAG;              //update the time of all commands 
1804C:  CLRF   03
1804E:  MOVF   x2C,W
18050:  ADDLW  E5
18052:  MOVWF  01
18054:  MOVLW  00
18056:  ADDWFC 03,F
18058:  MOVFF  03,32E
1805C:  CLRF   03
1805E:  MOVF   x2C,W
18060:  ADDLW  E5
18062:  MOVWF  FE9
18064:  MOVLW  00
18066:  ADDWFC 03,W
18068:  MOVWF  FEA
1806A:  MOVLB  0
1806C:  MOVF   x6D,W
1806E:  SUBWF  FEF,W
18070:  MOVLB  3
18072:  MOVFF  32E,FEA
18076:  MOVFF  01,FE9
1807A:  MOVWF  FEF
....................       } 
1807C:  MOVLW  08
1807E:  ADDWF  x2C,F
18080:  BRA    18030
....................    } 
....................    reserve_table[0] = 0xff;                                                      //delete the finished mission data, put 0xFF to move at the end of the table 
18082:  MOVLB  0
18084:  SETF   xE5
....................    reserve_table[1] = 0xff;                                                      //delete the finished mission data 
18086:  SETF   xE6
....................    reserve_table[2] = 0xff;                                                      //delete the finished mission data  
18088:  SETF   xE7
....................    reserve_table[3] = 0xff;                                                      //delete the finished mission data 
1808A:  SETF   xE8
....................    reserve_table[4] = 0xff;                                                      //delete the finished mission data 
1808C:  SETF   xE9
....................    reserve_table[5] = 0xff;                                                      //delete the finished mission data 
1808E:  SETF   xEA
....................    reserve_table[6] = 0xff;                                                      //delete the finished mission data 
18090:  SETF   xEB
....................    reserve_table[7] = 0xff;                                                      //delete the finished mission data 
18092:  SETF   xEC
....................    sort_table(); 
18094:  RCALL  17D0A
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
18096:  CALL   16D88
1809A:  MOVFF  01,135
....................     
....................    fprintf(PC,"Removed finished mission command:"); 
1809E:  MOVLW  9E
180A0:  MOVWF  FF6
180A2:  MOVLW  08
180A4:  MOVWF  FF7
180A6:  MOVLW  00
180A8:  MOVWF  FF8
180AA:  CALL   06A4
....................    Save_RSV(); 
180AE:  CALL   168AA
....................    fprintf(PC,"\r\n"); 
180B2:  MOVLW  0D
180B4:  BTFSS  F9E.4
180B6:  BRA    180B4
180B8:  MOVWF  FAD
180BA:  MOVLW  0A
180BC:  BTFSS  F9E.4
180BE:  BRA    180BC
180C0:  MOVWF  FAD
....................    return; 
180C2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_command_COM()                                                       //reservation from COM 
.................... { 
....................    fprintf(PC,"Reserve CMD from COM\r\n"); 
*
18308:  MOVLW  C0
1830A:  MOVWF  FF6
1830C:  MOVLW  08
1830E:  MOVWF  FF7
18310:  MOVLW  00
18312:  MOVWF  FF8
18314:  CALL   06A4
....................    input_reservation_COM();                                                      //put the command from COM into the table and sort in ascending form 
18318:  RCALL  180F8
....................    Save_RSV();                                                                   //save reserve table to flash memory 
1831A:  CALL   168AA
....................    RESERVE_CHECK = 1;                                                            // table check flag in HIGH 
1831E:  MOVLW  01
18320:  MOVWF  x6B
....................    if(reserve_table[80] == 0x00 || reserve_table[80] == 0xff) 
18322:  MOVLB  1
18324:  MOVF   x35,F
18326:  BZ    1832C
18328:  INCFSZ x35,W
1832A:  BRA    18332
....................    { 
....................       RESERVE_MIN_FLAG = 0;                                                      //reset time flag 
1832C:  MOVLB  0
1832E:  CLRF   x6C
18330:  MOVLB  1
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];                                          //closest mission command 
18332:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //closest time data 
18336:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
1833A:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
1833E:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
18342:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
18346:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
1834A:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
1834E:  MOVFF  EC,74
18352:  MOVLB  0
18354:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_command_PC()                                                        //reservation from PC 
.................... { 
....................    fprintf(PC,"Reserve CMD from PC\r\n"); 
*
185E0:  MOVLW  D8
185E2:  MOVWF  FF6
185E4:  MOVLW  08
185E6:  MOVWF  FF7
185E8:  MOVLW  00
185EA:  MOVWF  FF8
185EC:  CALL   06A4
....................    input_reservation_PC();                                                       //put the command from PC into the table and sort in ascending form 
185F0:  RCALL  18396
....................    Save_RSV();                                                                   //save reserve table to flash memory 
185F2:  CALL   168AA
....................    RESERVE_CHECK = 1; 
185F6:  MOVLW  01
185F8:  MOVWF  x6B
....................    if(reserve_table[80] == 0x00 || reserve_table[80] == 0xff)                    //for only first reservation 
185FA:  MOVLB  1
185FC:  MOVF   x35,F
185FE:  BZ    18604
18600:  INCFSZ x35,W
18602:  BRA    1860A
....................    { 
....................       RESERVE_MIN_FLAG = 0;                                                      //reset time flag 
18604:  MOVLB  0
18606:  CLRF   x6C
18608:  MOVLB  1
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];                                          //closest mission command 
1860A:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //closest time data 
1860E:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
18612:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
18616:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
1861A:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
1861E:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
18622:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
18626:  MOVFF  EC,74
1862A:  MOVLB  0
1862C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_next()                                                              //after finish execution of reservation command, this function should be execute 
.................... { 
....................    fprintf(PC,"Reserve next\r\n"); 
*
180C4:  MOVLW  EE
180C6:  MOVWF  FF6
180C8:  MOVLW  08
180CA:  MOVWF  FF7
180CC:  MOVLW  00
180CE:  MOVWF  FF8
180D0:  CALL   06A4
....................    //Save_RSV();//save reserve table to flash memory 
....................     
....................    //RESERVE_CHECK = 1; 
....................    RESERVE_MIN_FLAG = 0;                                                         //reset time flag 
180D4:  CLRF   x6C
....................    MISSION_CONTENTS = reserve_table[0];                                          //update closest mission command 
180D6:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //update closest time data (it is the time after 1 mission) 
180DA:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
180DE:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
180E2:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
180E6:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
180EA:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
180EE:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
180F2:  MOVFF  EC,74
180F6:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<SATELLITE_LOG.c> 
.................... #ifndef SATELLITE_LOG_C 
.................... #define SATELLITE_LOG_C 
....................  
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {};                                            //Satelite Log Length 
.................... #ORG 0x00016800 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
*
16822:  MOVLB  3
16824:  CLRF   x8C
16826:  CLRF   x8B
16828:  CLRF   x8A
1682A:  CLRF   x89
1682C:  MOVF   x8C,W
1682E:  SUBWF  x88,W
16830:  BNC   1685C
16832:  BNZ   1684A
16834:  MOVF   x8B,W
16836:  SUBWF  x87,W
16838:  BNC   1685C
1683A:  BNZ   1684A
1683C:  MOVF   x8A,W
1683E:  SUBWF  x86,W
16840:  BNC   1685C
16842:  BNZ   1684A
16844:  MOVF   x85,W
16846:  SUBWF  x89,W
16848:  BC    1685C
....................    {} 
1684A:  MOVLW  01
1684C:  ADDWF  x89,F
1684E:  BTFSC  FD8.0
16850:  INCF   x8A,F
16852:  BTFSC  FD8.2
16854:  INCF   x8B,F
16856:  BTFSC  FD8.2
16858:  INCF   x8C,F
1685A:  BRA    1682C
....................    return; 
1685C:  MOVLB  0
1685E:  RETURN 0
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
.................... #ORG 0x00016800 
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
*
16800:  MOVLB  3
16802:  CLRF   x85
16804:  MOVF   x85,W
16806:  SUBLW  0A
16808:  BNC   1681E
....................    { 
....................       reset_bffr[num] = 0; 
1680A:  CLRF   03
1680C:  MOVF   x85,W
1680E:  ADDLW  9E
16810:  MOVWF  FE9
16812:  MOVLW  00
16814:  ADDWFC 03,W
16816:  MOVWF  FEA
16818:  CLRF   FEF
1681A:  INCF   x85,F
1681C:  BRA    16804
....................    } 
....................    return; 
1681E:  MOVLB  0
16820:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
*
16AE2:  CALL   146F6
....................    Save_RSV();                                                                   //save in flash memory reserve_table[] content 
16AE6:  RCALL  168AA
....................    STORE_ADRESS_DATA_TO_FLASH(); 
16AE8:  CALL   142D0
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
16AEC:  MOVLW  7A
16AEE:  SUBWF  48,W
16AF0:  MOVLB  3
16AF2:  MOVWF  x85
16AF4:  MOVLW  00
16AF6:  SUBWFB 49,W
16AF8:  MOVWF  x86
16AFA:  MOVLW  00
16AFC:  SUBWFB 4A,W
16AFE:  MOVWF  x87
16B00:  MOVLW  00
16B02:  SUBWFB 4B,W
16B04:  MOVWF  x88
16B06:  MOVWF  xAB
16B08:  MOVFF  387,3AA
16B0C:  MOVFF  386,3A9
16B10:  MOVFF  385,3A8
16B14:  MOVLB  0
16B16:  CALL   11B04
16B1A:  MOVFF  01,385
16B1E:  MOVFF  01,3A2
16B22:  MOVLW  57
16B24:  MOVLB  3
16B26:  MOVWF  xA3
16B28:  MOVLB  0
16B2A:  CALL   0700
16B2E:  MOVLW  2C
16B30:  BTFSS  F9E.4
16B32:  BRA    16B30
16B34:  MOVWF  FAD
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
16B36:  MOVLW  79
16B38:  SUBWF  48,W
16B3A:  MOVLB  3
16B3C:  MOVWF  x85
16B3E:  MOVLW  00
16B40:  SUBWFB 49,W
16B42:  MOVWF  x86
16B44:  MOVLW  00
16B46:  SUBWFB 4A,W
16B48:  MOVWF  x87
16B4A:  MOVLW  00
16B4C:  SUBWFB 4B,W
16B4E:  MOVWF  x88
16B50:  MOVWF  xAB
16B52:  MOVFF  387,3AA
16B56:  MOVFF  386,3A9
16B5A:  MOVFF  385,3A8
16B5E:  MOVLB  0
16B60:  CALL   11B04
16B64:  MOVFF  01,385
16B68:  MOVFF  01,3A2
16B6C:  MOVLW  57
16B6E:  MOVLB  3
16B70:  MOVWF  xA3
16B72:  MOVLB  0
16B74:  CALL   0700
16B78:  MOVLW  2C
16B7A:  BTFSS  F9E.4
16B7C:  BRA    16B7A
16B7E:  MOVWF  FAD
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
16B80:  MOVLW  78
16B82:  SUBWF  48,W
16B84:  MOVLB  3
16B86:  MOVWF  x85
16B88:  MOVLW  00
16B8A:  SUBWFB 49,W
16B8C:  MOVWF  x86
16B8E:  MOVLW  00
16B90:  SUBWFB 4A,W
16B92:  MOVWF  x87
16B94:  MOVLW  00
16B96:  SUBWFB 4B,W
16B98:  MOVWF  x88
16B9A:  MOVWF  xAB
16B9C:  MOVFF  387,3AA
16BA0:  MOVFF  386,3A9
16BA4:  MOVFF  385,3A8
16BA8:  MOVLB  0
16BAA:  CALL   11B04
16BAE:  MOVFF  01,385
16BB2:  MOVFF  01,3A2
16BB6:  MOVLW  57
16BB8:  MOVLB  3
16BBA:  MOVWF  xA3
16BBC:  MOVLB  0
16BBE:  CALL   0700
16BC2:  MOVLW  2C
16BC4:  BTFSS  F9E.4
16BC6:  BRA    16BC4
16BC8:  MOVWF  FAD
....................    fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
16BCA:  MOVLW  77
16BCC:  SUBWF  48,W
16BCE:  MOVLB  3
16BD0:  MOVWF  x85
16BD2:  MOVLW  00
16BD4:  SUBWFB 49,W
16BD6:  MOVWF  x86
16BD8:  MOVLW  00
16BDA:  SUBWFB 4A,W
16BDC:  MOVWF  x87
16BDE:  MOVLW  00
16BE0:  SUBWFB 4B,W
16BE2:  MOVWF  x88
16BE4:  MOVWF  xAB
16BE6:  MOVFF  387,3AA
16BEA:  MOVFF  386,3A9
16BEE:  MOVFF  385,3A8
16BF2:  MOVLB  0
16BF4:  CALL   11B04
16BF8:  MOVFF  01,385
16BFC:  MOVFF  01,3A2
16C00:  MOVLW  57
16C02:  MOVLB  3
16C04:  MOVWF  xA3
16C06:  MOVLB  0
16C08:  CALL   0700
....................    fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
16C0C:  MOVLW  76
16C0E:  SUBWF  48,W
16C10:  MOVLB  3
16C12:  MOVWF  x85
16C14:  MOVLW  00
16C16:  SUBWFB 49,W
16C18:  MOVWF  x86
16C1A:  MOVLW  00
16C1C:  SUBWFB 4A,W
16C1E:  MOVWF  x87
16C20:  MOVLW  00
16C22:  SUBWFB 4B,W
16C24:  MOVWF  x88
16C26:  MOVWF  xAB
16C28:  MOVFF  387,3AA
16C2C:  MOVFF  386,3A9
16C30:  MOVFF  385,3A8
16C34:  MOVLB  0
16C36:  CALL   11B04
16C3A:  MOVFF  01,385
16C3E:  MOVFF  01,3A2
16C42:  MOVLW  57
16C44:  MOVLB  3
16C46:  MOVWF  xA3
16C48:  MOVLB  0
16C4A:  CALL   0700
16C4E:  MOVLW  0D
16C50:  BTFSS  F9E.4
16C52:  BRA    16C50
16C54:  MOVWF  FAD
16C56:  MOVLW  0A
16C58:  BTFSS  F9E.4
16C5A:  BRA    16C58
16C5C:  MOVWF  FAD
....................    for(int i = 0; i<100; i++) 
16C5E:  MOVLB  3
16C60:  CLRF   x84
16C62:  MOVF   x84,W
16C64:  SUBLW  63
16C66:  BNC   16C82
....................    { 
....................       fputc(0x27,reset);                                                      //send command for satellite reset 
16C68:  MOVLW  27
16C6A:  MOVLB  0
16C6C:  CALL   157C
....................       delay_ms(10); 
16C70:  MOVLW  0A
16C72:  MOVLB  3
16C74:  MOVWF  x98
16C76:  MOVLB  0
16C78:  CALL   063E
16C7C:  MOVLB  3
16C7E:  INCF   x84,F
16C80:  BRA    16C62
....................    } 
....................  
....................    RESET_DATA = 0; 
16C82:  MOVLB  0
16C84:  CLRF   x9D
....................    fprintf(PC,"Ready for reset"); 
16C86:  MOVLW  FE
16C88:  MOVWF  FF6
16C8A:  MOVLW  08
16C8C:  MOVWF  FF7
16C8E:  MOVLW  00
16C90:  MOVWF  FF8
16C92:  CALL   06A4
....................    delay_ms(1000); 
16C96:  MOVLW  04
16C98:  MOVLB  3
16C9A:  MOVWF  x85
16C9C:  MOVLW  FA
16C9E:  MOVWF  x98
16CA0:  MOVLB  0
16CA2:  CALL   063E
16CA6:  MOVLB  3
16CA8:  DECFSZ x85,F
16CAA:  BRA    16C9C
....................    return; 
16CAC:  MOVLB  0
16CAE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
16CB0:  DECFSZ xA9,W
16CB2:  BRA    16CB6
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
16CB4:  RCALL  16AE2
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
16CB6:  RCALL  16800
....................    RESET_DATA = 0; 
16CB8:  CLRF   x9D
....................    return; 
16CBA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
*
16860:  RCALL  16800
....................    RESET_DATA = 0; 
16862:  CLRF   x9D
....................    for(int m=0; m<10; m++) 
16864:  MOVLB  3
16866:  CLRF   x84
16868:  MOVF   x84,W
1686A:  SUBLW  09
1686C:  BNC   168A6
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
1686E:  MOVLW  28
16870:  MOVLB  0
16872:  CALL   157C
....................       delay_ms(10); 
16876:  MOVLW  0A
16878:  MOVLB  3
1687A:  MOVWF  x98
1687C:  MOVLB  0
1687E:  CALL   063E
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
16882:  MOVLB  3
16884:  CLRF   x88
16886:  CLRF   x87
16888:  MOVLW  27
1688A:  MOVWF  x86
1688C:  MOVLW  10
1688E:  MOVWF  x85
16890:  MOVLB  0
16892:  RCALL  16822
....................       if(RESET_bffr[0] == 0x8e) 
16894:  MOVF   x9E,W
16896:  SUBLW  8E
16898:  BNZ   168A0
....................       { 
....................          break; 
1689A:  MOVLB  3
1689C:  BRA    168A6
1689E:  MOVLB  0
....................       } 
168A0:  MOVLB  3
168A2:  INCF   x84,F
168A4:  BRA    16868
....................    } 
....................    return; 
168A6:  MOVLB  0
168A8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
*
16CBC:  MOVFF  D3,68
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
16CC0:  MOVFF  D4,6A
16CC4:  MOVFF  D5,69
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
16CC8:  MOVFF  D6,6B
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
16CCC:  MOVFF  D7,6D
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
16CD0:  MOVFF  D8,6C
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
16CD4:  MOVFF  D9,6E
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
16CD8:  MOVFF  DA,6F
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
16CDC:  MOVFF  DB,75
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
16CE0:  MOVFF  DC,76
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
16CE4:  MOVFF  DD,77
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
16CE8:  MOVFF  DE,78
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
16CEC:  MOVFF  DF,79
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
16CF0:  MOVFF  E0,7A
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
16CF4:  MOVFF  E1,7B
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
16CF8:  MOVFF  E2,7C
....................    if(PASSED_DAYS == 0xffff) 
16CFC:  INCFSZ x69,W
16CFE:  BRA    16D0E
16D00:  INCFSZ x6A,W
16D02:  BRA    16D0E
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
16D04:  RCALL  16860
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
16D06:  MOVFF  A2,6A
16D0A:  MOVFF  A3,69
....................    } 
....................    return; 
16D0E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
16D10:  MOVLB  3
16D12:  CLRF   x2C
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
16D14:  MOVLB  0
16D16:  CALL   14C06
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
16D1A:  MOVLB  3
16D1C:  CLRF   x2D
16D1E:  MOVF   x2D,W
16D20:  SUBLW  0F
16D22:  BNC   16D3C
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
16D24:  CLRF   03
16D26:  MOVF   x2D,W
16D28:  ADDLW  D3
16D2A:  MOVWF  FE9
16D2C:  MOVLW  00
16D2E:  ADDWFC 03,W
16D30:  MOVWF  FEA
16D32:  INCFSZ FEF,W
16D34:  BRA    16D38
....................       { 
....................          checksum++; 
16D36:  INCF   x2C,F
....................       } 
16D38:  INCF   x2D,F
16D3A:  BRA    16D1E
....................    }    
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
16D3C:  MOVLB  0
16D3E:  INCFSZ xD3,W
16D40:  BRA    16D44
16D42:  BRA    16D7C
16D44:  INCFSZ xE2,W
16D46:  BRA    16D4A
16D48:  BRA    16D7C
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
16D4A:  MOVLB  3
16D4C:  CLRF   x2D
16D4E:  MOVF   x2D,W
16D50:  SUBLW  0F
16D52:  BNC   16D76
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
16D54:  CLRF   03
16D56:  MOVF   x2D,W
16D58:  ADDLW  D3
16D5A:  MOVWF  FE9
16D5C:  MOVLW  00
16D5E:  ADDWFC 03,W
16D60:  MOVWF  FEA
16D62:  MOVFF  FEF,3A2
16D66:  MOVLW  57
16D68:  MOVWF  xA3
16D6A:  MOVLB  0
16D6C:  CALL   0700
16D70:  MOVLB  3
16D72:  INCF   x2D,F
16D74:  BRA    16D4E
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
16D76:  MOVLB  0
16D78:  RCALL  16CBC
....................    }else{                                                                        //if nothing stored 
16D7A:  BRA    16D80
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
16D7C:  CALL   14C66
....................    } 
....................    checksum = 0; 
16D80:  MOVLB  3
16D82:  CLRF   x2C
....................    return; 
16D84:  MOVLB  0
16D86:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... #ORG 0x00016800 
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
*
16EA4:  CALL   156AA
....................    RESET_DATA = 0; 
16EA8:  CLRF   x9D
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
16EAA:  RCALL  16860
....................    if(RESET_bffr[0] == 0x8e) 
16EAC:  MOVF   x9E,W
16EAE:  SUBLW  8E
16EB0:  BTFSS  FD8.2
16EB2:  BRA    16FDE
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
16EB4:  MOVLW  DA
16EB6:  MOVLB  1
16EB8:  MOVWF  x37
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
16EBA:  MOVWF  x38
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
16EBC:  MOVFF  9F,139
....................       satellitelog[3] = RESET_bffr[2]; 
16EC0:  MOVFF  A0,13A
....................       satellitelog[4] = RESET_bffr[3]; 
16EC4:  MOVFF  A1,13B
....................       satellitelog[5] = RESET_bffr[4]; 
16EC8:  MOVFF  A2,13C
....................       satellitelog[6] = RESET_bffr[5]; 
16ECC:  MOVFF  A3,13D
....................        
....................       satellitelog[7] = data1; 
16ED0:  MOVFF  353,13E
....................       satellitelog[8] = data2; 
16ED4:  MOVFF  354,13F
....................       satellitelog[9] = data3; 
16ED8:  MOVFF  355,140
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
16EDC:  MOVLW  EF
16EDE:  MOVWF  x41
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
16EE0:  BCF    F92.5
16EE2:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
16EE4:  BCF    F94.4
16EE6:  BCF    F8B.4
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
16EE8:  MOVLB  3
16EEA:  CLRF   x56
16EEC:  MOVF   x56,W
16EEE:  SUBLW  0A
16EF0:  BNC   16FBC
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
16EF2:  MOVF   x56,W
16EF4:  ADDWF  40,W
16EF6:  MOVWF  x57
16EF8:  MOVLW  00
16EFA:  ADDWFC 41,W
16EFC:  MOVWF  x58
16EFE:  MOVLW  00
16F00:  ADDWFC 42,W
16F02:  MOVWF  x59
16F04:  MOVLW  00
16F06:  ADDWFC 43,W
16F08:  MOVWF  x5A
16F0A:  CLRF   03
16F0C:  MOVF   x56,W
16F0E:  ADDLW  37
16F10:  MOVWF  FE9
16F12:  MOVLW  01
16F14:  ADDWFC 03,W
16F16:  MOVWF  FEA
16F18:  MOVFF  FEF,394
16F1C:  MOVFF  35A,393
16F20:  MOVFF  359,392
16F24:  MOVFF  358,391
16F28:  MOVFF  357,390
16F2C:  MOVLB  0
16F2E:  CALL   11B8C
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
16F32:  MOVLB  3
16F34:  MOVF   x56,W
16F36:  ADDWF  40,W
16F38:  MOVWF  x57
16F3A:  MOVLW  00
16F3C:  ADDWFC 41,W
16F3E:  MOVWF  x58
16F40:  MOVLW  00
16F42:  ADDWFC 42,W
16F44:  MOVWF  x59
16F46:  MOVLW  00
16F48:  ADDWFC 43,W
16F4A:  MOVWF  x5A
16F4C:  CLRF   03
16F4E:  MOVF   x56,W
16F50:  ADDLW  37
16F52:  MOVWF  FE9
16F54:  MOVLW  01
16F56:  ADDWFC 03,W
16F58:  MOVWF  FEA
16F5A:  MOVFF  FEF,394
16F5E:  MOVFF  35A,393
16F62:  MOVFF  359,392
16F66:  MOVFF  358,391
16F6A:  MOVFF  357,390
16F6E:  MOVLB  0
16F70:  CALL   11C0C
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
16F74:  MOVLB  3
16F76:  MOVF   x56,W
16F78:  ADDWF  40,W
16F7A:  MOVWF  x57
16F7C:  MOVLW  00
16F7E:  ADDWFC 41,W
16F80:  MOVWF  x58
16F82:  MOVLW  00
16F84:  ADDWFC 42,W
16F86:  MOVWF  x59
16F88:  MOVLW  00
16F8A:  ADDWFC 43,W
16F8C:  MOVWF  x5A
16F8E:  CLRF   03
16F90:  MOVF   x56,W
16F92:  ADDLW  37
16F94:  MOVWF  FE9
16F96:  MOVLW  01
16F98:  ADDWFC 03,W
16F9A:  MOVWF  FEA
16F9C:  MOVFF  FEF,394
16FA0:  MOVFF  35A,393
16FA4:  MOVFF  359,392
16FA8:  MOVFF  358,391
16FAC:  MOVFF  357,390
16FB0:  MOVLB  0
16FB2:  CALL   11C8C
16FB6:  MOVLB  3
16FB8:  INCF   x56,F
16FBA:  BRA    16EEC
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
16FBC:  BCF    F94.4
16FBE:  BSF    F8B.4
....................       SAT_LOG = SAT_LOG + logdata_size; 
16FC0:  MOVLW  0B
16FC2:  ADDWF  40,F
16FC4:  MOVLW  00
16FC6:  ADDWFC 41,F
16FC8:  ADDWFC 42,F
16FCA:  ADDWFC 43,F
....................       fprintf(PC,"LOG saving done\r\n"); 
16FCC:  MOVLW  0E
16FCE:  MOVWF  FF6
16FD0:  MOVLW  09
16FD2:  MOVWF  FF7
16FD4:  MOVLW  00
16FD6:  MOVWF  FF8
16FD8:  MOVLB  0
16FDA:  CALL   06A4
....................    } 
....................     
....................    return; 
16FDE:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<FLASH_OPERATION.c>                                                      //erase or transfer 
.................... #ifndef FLASH_OPERATION_C 
.................... #define FLASH_OPERATION_C 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
*
17094:  MOVLW  20
17096:  MOVWF  FF6
17098:  MOVLW  09
1709A:  MOVWF  FF7
1709C:  MOVLW  00
1709E:  MOVWF  FF8
170A0:  MOVLW  09
170A2:  MOVLB  3
170A4:  MOVWF  xA2
170A6:  MOVLB  0
170A8:  CALL   06CE
170AC:  MOVFF  347,3A2
170B0:  MOVLW  57
170B2:  MOVLB  3
170B4:  MOVWF  xA3
170B6:  MOVLB  0
170B8:  CALL   0700
170BC:  MOVFF  348,3A2
170C0:  MOVLW  57
170C2:  MOVLB  3
170C4:  MOVWF  xA3
170C6:  MOVLB  0
170C8:  CALL   0700
170CC:  MOVFF  349,3A2
170D0:  MOVLW  57
170D2:  MOVLB  3
170D4:  MOVWF  xA3
170D6:  MOVLB  0
170D8:  CALL   0700
170DC:  MOVFF  34A,3A2
170E0:  MOVLW  57
170E2:  MOVLB  3
170E4:  MOVWF  xA3
170E6:  MOVLB  0
170E8:  CALL   0700
170EC:  MOVLW  0D
170EE:  BTFSS  F9E.4
170F0:  BRA    170EE
170F2:  MOVWF  FAD
170F4:  MOVLW  0A
170F6:  BTFSS  F9E.4
170F8:  BRA    170F6
170FA:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
170FC:  MOVFF  347,34E
17100:  MOVFF  348,34D
17104:  MOVFF  349,34C
17108:  MOVFF  34A,34B
....................    sector_erase_OF(address);                                                     //erase 1 sector 
1710C:  MOVFF  34E,38C
17110:  MOVFF  34D,38B
17114:  MOVFF  34C,38A
17118:  MOVFF  34B,389
1711C:  CALL   12014
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17120:  MOVFF  34D,34F
17124:  MOVFF  34E,350
17128:  MOVFF  350,351
1712C:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe0, D1, D2);                                                   //0xE0+16bit sector info 
17130:  MOVLW  E0
17132:  MOVLB  3
17134:  MOVWF  x53
17136:  MOVFF  351,354
1713A:  MOVFF  352,355
1713E:  MOVLB  0
17140:  RCALL  16EA4
....................     
....................    return; 
17142:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_SCF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17144:  MOVLW  34
17146:  MOVWF  FF6
17148:  MOVLW  09
1714A:  MOVWF  FF7
1714C:  MOVLW  00
1714E:  MOVWF  FF8
17150:  MOVLW  0A
17152:  MOVLB  3
17154:  MOVWF  xA2
17156:  MOVLB  0
17158:  CALL   06CE
1715C:  MOVFF  347,3A2
17160:  MOVLW  57
17162:  MOVLB  3
17164:  MOVWF  xA3
17166:  MOVLB  0
17168:  CALL   0700
1716C:  MOVFF  348,3A2
17170:  MOVLW  57
17172:  MOVLB  3
17174:  MOVWF  xA3
17176:  MOVLB  0
17178:  CALL   0700
1717C:  MOVFF  349,3A2
17180:  MOVLW  57
17182:  MOVLB  3
17184:  MOVWF  xA3
17186:  MOVLB  0
17188:  CALL   0700
1718C:  MOVFF  34A,3A2
17190:  MOVLW  57
17192:  MOVLB  3
17194:  MOVWF  xA3
17196:  MOVLB  0
17198:  CALL   0700
1719C:  MOVLW  0D
1719E:  BTFSS  F9E.4
171A0:  BRA    1719E
171A2:  MOVWF  FAD
171A4:  MOVLW  0A
171A6:  BTFSS  F9E.4
171A8:  BRA    171A6
171AA:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
171AC:  MOVFF  347,34E
171B0:  MOVFF  348,34D
171B4:  MOVFF  349,34C
171B8:  MOVFF  34A,34B
....................    output_low(PIN_C4);                                                           //multiplexor OBC side 
171BC:  BCF    F94.4
171BE:  BCF    F8B.4
....................    sector_erase_SCF(address);                                                    //erase 1 sector 
171C0:  MOVFF  34E,38C
171C4:  MOVFF  34D,38B
171C8:  MOVFF  34C,38A
171CC:  MOVFF  34B,389
171D0:  CALL   120B0
....................    output_high(PIN_C4); 
171D4:  BCF    F94.4
171D6:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
171D8:  MOVFF  34D,34F
171DC:  MOVFF  34E,350
171E0:  MOVFF  350,351
171E4:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe1, D1, D2);                                                   //0xE0+16bit sector info 
171E8:  MOVLW  E1
171EA:  MOVLB  3
171EC:  MOVWF  x53
171EE:  MOVFF  351,354
171F2:  MOVFF  352,355
171F6:  MOVLB  0
171F8:  RCALL  16EA4
....................    return; 
171FA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
*
16FE0:  MOVLW  4A
16FE2:  MOVWF  FF6
16FE4:  MOVLW  09
16FE6:  MOVWF  FF7
16FE8:  MOVLW  00
16FEA:  MOVWF  FF8
16FEC:  MOVLW  0A
16FEE:  MOVLB  3
16FF0:  MOVWF  xA2
16FF2:  MOVLB  0
16FF4:  CALL   06CE
16FF8:  MOVFF  347,3A2
16FFC:  MOVLW  57
16FFE:  MOVLB  3
17000:  MOVWF  xA3
17002:  MOVLB  0
17004:  CALL   0700
17008:  MOVFF  348,3A2
1700C:  MOVLW  57
1700E:  MOVLB  3
17010:  MOVWF  xA3
17012:  MOVLB  0
17014:  CALL   0700
17018:  MOVFF  349,3A2
1701C:  MOVLW  57
1701E:  MOVLB  3
17020:  MOVWF  xA3
17022:  MOVLB  0
17024:  CALL   0700
17028:  MOVFF  34A,3A2
1702C:  MOVLW  57
1702E:  MOVLB  3
17030:  MOVWF  xA3
17032:  MOVLB  0
17034:  CALL   0700
17038:  MOVLW  0D
1703A:  BTFSS  F9E.4
1703C:  BRA    1703A
1703E:  MOVWF  FAD
17040:  MOVLW  0A
17042:  BTFSS  F9E.4
17044:  BRA    17042
17046:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17048:  MOVFF  347,34E
1704C:  MOVFF  348,34D
17050:  MOVFF  349,34C
17054:  MOVFF  34A,34B
....................    output_low(PIN_A5);                                                           //multiplexor OBC side 
17058:  BCF    F92.5
1705A:  BCF    F89.5
....................    sector_erase_SMF(address);                                                    //erase 1 sector 
1705C:  MOVFF  34E,38C
17060:  MOVFF  34D,38B
17064:  MOVFF  34C,38A
17068:  MOVFF  34B,389
1706C:  CALL   1214C
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17070:  MOVFF  34D,34F
17074:  MOVFF  34E,350
17078:  MOVFF  350,351
1707C:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe2, D1, D2);                                                   //0xE0+16bit sector info 
17080:  MOVLW  E2
17082:  MOVLB  3
17084:  MOVWF  x53
17086:  MOVFF  351,354
1708A:  MOVFF  352,355
1708E:  MOVLB  0
17090:  RCALL  16EA4
....................    return; 
17092:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_OF2SCF(int8 data1,int8 data2,int8 data3,int8 data4)         //command 0x12 
.................... { 
....................    REFRESH_SECTOR_SCF(data1,data2,data3,data4);                                  //erase 1 sector SCF 
*
1742A:  MOVFF  337,347
1742E:  MOVFF  338,348
17432:  MOVFF  339,349
17436:  MOVFF  33A,34A
1743A:  RCALL  17144
....................    delay_ms(500); 
1743C:  MOVLW  02
1743E:  MOVLB  3
17440:  MOVWF  x47
17442:  MOVLW  FA
17444:  MOVWF  x98
17446:  MOVLB  0
17448:  CALL   063E
1744C:  MOVLB  3
1744E:  DECFSZ x47,F
17450:  BRA    17442
....................    fprintf(PC,"transfer OF2SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17452:  MOVLW  60
17454:  MOVWF  FF6
17456:  MOVLW  09
17458:  MOVWF  FF7
1745A:  MOVLW  00
1745C:  MOVWF  FF8
1745E:  MOVLW  10
17460:  MOVWF  xA2
17462:  MOVLB  0
17464:  CALL   06CE
17468:  MOVFF  337,3A2
1746C:  MOVLW  57
1746E:  MOVLB  3
17470:  MOVWF  xA3
17472:  MOVLB  0
17474:  CALL   0700
17478:  MOVFF  338,3A2
1747C:  MOVLW  57
1747E:  MOVLB  3
17480:  MOVWF  xA3
17482:  MOVLB  0
17484:  CALL   0700
17488:  MOVFF  339,3A2
1748C:  MOVLW  57
1748E:  MOVLB  3
17490:  MOVWF  xA3
17492:  MOVLB  0
17494:  CALL   0700
17498:  MOVFF  33A,3A2
1749C:  MOVLW  57
1749E:  MOVLB  3
174A0:  MOVWF  xA3
174A2:  MOVLB  0
174A4:  CALL   0700
174A8:  MOVLW  0D
174AA:  BTFSS  F9E.4
174AC:  BRA    174AA
174AE:  MOVWF  FAD
174B0:  MOVLW  0A
174B2:  BTFSS  F9E.4
174B4:  BRA    174B2
174B6:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
174B8:  MOVFF  337,33E
174BC:  MOVFF  338,33D
174C0:  MOVFF  339,33C
174C4:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
174C8:  MOVLB  3
174CA:  MOVFF  33B,00
174CE:  MOVFF  33C,01
174D2:  CLRF   02
174D4:  CLRF   03
174D6:  MOVF   x3B,W
174D8:  SUBWF  x3B,F
174DA:  MOVF   x3C,W
174DC:  SUBWFB x3C,F
174DE:  MOVF   02,W
174E0:  SUBWFB x3D,F
174E2:  MOVF   03,W
174E4:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //OBC side 
174E6:  BCF    F94.4
174E8:  BCF    F8B.4
....................    for(int32 i = 0; i < SECT; i++) 
174EA:  CLRF   x42
174EC:  CLRF   x41
174EE:  CLRF   x40
174F0:  CLRF   x3F
174F2:  MOVF   x42,F
174F4:  BNZ   17570
174F6:  MOVF   x41,W
174F8:  SUBLW  00
174FA:  BNC   17570
....................    { 
....................       WRITE_DATA_BYTE_SCF(address + i, READ_DATA_BYTE_OF(address + i)); 
174FC:  MOVF   x3F,W
174FE:  ADDWF  x3B,W
17500:  MOVWF  x47
17502:  MOVF   x40,W
17504:  ADDWFC x3C,W
17506:  MOVWF  x48
17508:  MOVF   x41,W
1750A:  ADDWFC x3D,W
1750C:  MOVWF  x49
1750E:  MOVF   x42,W
17510:  ADDWFC x3E,W
17512:  MOVWF  x4A
17514:  MOVF   x3F,W
17516:  ADDWF  x3B,W
17518:  MOVWF  x4B
1751A:  MOVF   x40,W
1751C:  ADDWFC x3C,W
1751E:  MOVWF  x4C
17520:  MOVF   x41,W
17522:  ADDWFC x3D,W
17524:  MOVWF  x4D
17526:  MOVF   x42,W
17528:  ADDWFC x3E,W
1752A:  MOVWF  x4E
1752C:  MOVWF  xAB
1752E:  MOVFF  34D,3AA
17532:  MOVFF  34C,3A9
17536:  MOVFF  34B,3A8
1753A:  MOVLB  0
1753C:  CALL   11B04
17540:  MOVFF  01,34B
17544:  MOVFF  34A,393
17548:  MOVFF  349,392
1754C:  MOVFF  348,391
17550:  MOVFF  347,390
17554:  MOVFF  01,394
17558:  CALL   11C0C
1755C:  MOVLW  01
1755E:  MOVLB  3
17560:  ADDWF  x3F,F
17562:  BTFSC  FD8.0
17564:  INCF   x40,F
17566:  BTFSC  FD8.2
17568:  INCF   x41,F
1756A:  BTFSC  FD8.2
1756C:  INCF   x42,F
1756E:  BRA    174F2
....................    } 
....................    delay_ms(100); 
17570:  MOVLW  64
17572:  MOVWF  x98
17574:  MOVLB  0
17576:  CALL   063E
....................    output_high(PIN_C4);                                                          //COM side 
1757A:  BCF    F94.4
1757C:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
1757E:  MOVFF  33D,343
17582:  MOVFF  33E,344
17586:  MOVFF  344,345
1758A:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x12, D1, D2);                                                   //0xE0+16bit sector info 
1758E:  MOVLW  12
17590:  MOVLB  3
17592:  MOVWF  x53
17594:  MOVFF  345,354
17598:  MOVFF  346,355
1759C:  MOVLB  0
1759E:  RCALL  16EA4
....................    return; 
175A0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_OF2SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_SMF(data1,data2,data3,data4);                                  //erase 1 sector SMF 
175A2:  MOVFF  337,347
175A6:  MOVFF  338,348
175AA:  MOVFF  339,349
175AE:  MOVFF  33A,34A
175B2:  RCALL  16FE0
....................    delay_ms(500); 
175B4:  MOVLW  02
175B6:  MOVLB  3
175B8:  MOVWF  x47
175BA:  MOVLW  FA
175BC:  MOVWF  x98
175BE:  MOVLB  0
175C0:  CALL   063E
175C4:  MOVLB  3
175C6:  DECFSZ x47,F
175C8:  BRA    175BA
....................    fprintf(PC,"transfer OF2SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
175CA:  MOVLW  7C
175CC:  MOVWF  FF6
175CE:  MOVLW  09
175D0:  MOVWF  FF7
175D2:  MOVLW  00
175D4:  MOVWF  FF8
175D6:  MOVLW  10
175D8:  MOVWF  xA2
175DA:  MOVLB  0
175DC:  CALL   06CE
175E0:  MOVFF  337,3A2
175E4:  MOVLW  57
175E6:  MOVLB  3
175E8:  MOVWF  xA3
175EA:  MOVLB  0
175EC:  CALL   0700
175F0:  MOVFF  338,3A2
175F4:  MOVLW  57
175F6:  MOVLB  3
175F8:  MOVWF  xA3
175FA:  MOVLB  0
175FC:  CALL   0700
17600:  MOVFF  339,3A2
17604:  MOVLW  57
17606:  MOVLB  3
17608:  MOVWF  xA3
1760A:  MOVLB  0
1760C:  CALL   0700
17610:  MOVFF  33A,3A2
17614:  MOVLW  57
17616:  MOVLB  3
17618:  MOVWF  xA3
1761A:  MOVLB  0
1761C:  CALL   0700
17620:  MOVLW  0D
17622:  BTFSS  F9E.4
17624:  BRA    17622
17626:  MOVWF  FAD
17628:  MOVLW  0A
1762A:  BTFSS  F9E.4
1762C:  BRA    1762A
1762E:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17630:  MOVFF  337,33E
17634:  MOVFF  338,33D
17638:  MOVFF  339,33C
1763C:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17640:  MOVLB  3
17642:  MOVFF  33B,00
17646:  MOVFF  33C,01
1764A:  CLRF   02
1764C:  CLRF   03
1764E:  MOVF   x3B,W
17650:  SUBWF  x3B,F
17652:  MOVF   x3C,W
17654:  SUBWFB x3C,F
17656:  MOVF   02,W
17658:  SUBWFB x3D,F
1765A:  MOVF   03,W
1765C:  SUBWFB x3E,F
....................    output_low(PIN_A5);                                                           //OBC side 
1765E:  BCF    F92.5
17660:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17662:  CLRF   x42
17664:  CLRF   x41
17666:  CLRF   x40
17668:  CLRF   x3F
1766A:  MOVF   x42,F
1766C:  BNZ   176E8
1766E:  MOVF   x41,W
17670:  SUBLW  00
17672:  BNC   176E8
....................    { 
....................       WRITE_DATA_BYTE_SMF(address + i, READ_DATA_BYTE_OF(address + i)); 
17674:  MOVF   x3F,W
17676:  ADDWF  x3B,W
17678:  MOVWF  x47
1767A:  MOVF   x40,W
1767C:  ADDWFC x3C,W
1767E:  MOVWF  x48
17680:  MOVF   x41,W
17682:  ADDWFC x3D,W
17684:  MOVWF  x49
17686:  MOVF   x42,W
17688:  ADDWFC x3E,W
1768A:  MOVWF  x4A
1768C:  MOVF   x3F,W
1768E:  ADDWF  x3B,W
17690:  MOVWF  x4B
17692:  MOVF   x40,W
17694:  ADDWFC x3C,W
17696:  MOVWF  x4C
17698:  MOVF   x41,W
1769A:  ADDWFC x3D,W
1769C:  MOVWF  x4D
1769E:  MOVF   x42,W
176A0:  ADDWFC x3E,W
176A2:  MOVWF  x4E
176A4:  MOVWF  xAB
176A6:  MOVFF  34D,3AA
176AA:  MOVFF  34C,3A9
176AE:  MOVFF  34B,3A8
176B2:  MOVLB  0
176B4:  CALL   11B04
176B8:  MOVFF  01,34B
176BC:  MOVFF  34A,393
176C0:  MOVFF  349,392
176C4:  MOVFF  348,391
176C8:  MOVFF  347,390
176CC:  MOVFF  01,394
176D0:  CALL   11C8C
176D4:  MOVLW  01
176D6:  MOVLB  3
176D8:  ADDWF  x3F,F
176DA:  BTFSC  FD8.0
176DC:  INCF   x40,F
176DE:  BTFSC  FD8.2
176E0:  INCF   x41,F
176E2:  BTFSC  FD8.2
176E4:  INCF   x42,F
176E6:  BRA    1766A
....................    } 
....................    delay_ms(100); 
176E8:  MOVLW  64
176EA:  MOVWF  x98
176EC:  MOVLB  0
176EE:  CALL   063E
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
176F2:  MOVFF  33D,343
176F6:  MOVFF  33E,344
176FA:  MOVFF  344,345
176FE:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x13, D1, D2);                                                   //0xE0+16bit sector info 
17702:  MOVLW  13
17704:  MOVLB  3
17706:  MOVWF  x53
17708:  MOVFF  345,354
1770C:  MOVFF  346,355
17710:  MOVLB  0
17712:  CALL   16EA4
....................     
....................    return; 
17716:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SCF2OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_OF(data1,data2,data3,data4);                                   //erase 1 sector OBC flash 
17718:  MOVFF  337,347
1771C:  MOVFF  338,348
17720:  MOVFF  339,349
17724:  MOVFF  33A,34A
17728:  RCALL  17094
....................    delay_ms(500); 
1772A:  MOVLW  02
1772C:  MOVLB  3
1772E:  MOVWF  x47
17730:  MOVLW  FA
17732:  MOVWF  x98
17734:  MOVLB  0
17736:  CALL   063E
1773A:  MOVLB  3
1773C:  DECFSZ x47,F
1773E:  BRA    17730
....................    fprintf(PC,"transfer SCF2OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17740:  MOVLW  98
17742:  MOVWF  FF6
17744:  MOVLW  09
17746:  MOVWF  FF7
17748:  MOVLW  00
1774A:  MOVWF  FF8
1774C:  MOVLW  10
1774E:  MOVWF  xA2
17750:  MOVLB  0
17752:  CALL   06CE
17756:  MOVFF  337,3A2
1775A:  MOVLW  57
1775C:  MOVLB  3
1775E:  MOVWF  xA3
17760:  MOVLB  0
17762:  CALL   0700
17766:  MOVFF  338,3A2
1776A:  MOVLW  57
1776C:  MOVLB  3
1776E:  MOVWF  xA3
17770:  MOVLB  0
17772:  CALL   0700
17776:  MOVFF  339,3A2
1777A:  MOVLW  57
1777C:  MOVLB  3
1777E:  MOVWF  xA3
17780:  MOVLB  0
17782:  CALL   0700
17786:  MOVFF  33A,3A2
1778A:  MOVLW  57
1778C:  MOVLB  3
1778E:  MOVWF  xA3
17790:  MOVLB  0
17792:  CALL   0700
17796:  MOVLW  0D
17798:  BTFSS  F9E.4
1779A:  BRA    17798
1779C:  MOVWF  FAD
1779E:  MOVLW  0A
177A0:  BTFSS  F9E.4
177A2:  BRA    177A0
177A4:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
177A6:  MOVFF  337,33E
177AA:  MOVFF  338,33D
177AE:  MOVFF  339,33C
177B2:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
177B6:  MOVLB  3
177B8:  MOVFF  33B,00
177BC:  MOVFF  33C,01
177C0:  CLRF   02
177C2:  CLRF   03
177C4:  MOVF   x3B,W
177C6:  SUBWF  x3B,F
177C8:  MOVF   x3C,W
177CA:  SUBWFB x3C,F
177CC:  MOVF   02,W
177CE:  SUBWFB x3D,F
177D0:  MOVF   03,W
177D2:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
177D4:  BCF    F94.4
177D6:  BCF    F8B.4
....................    for(int32 i = 0; i < SECT; i++) 
177D8:  CLRF   x42
177DA:  CLRF   x41
177DC:  CLRF   x40
177DE:  CLRF   x3F
177E0:  MOVF   x42,F
177E2:  BNZ   1785E
177E4:  MOVF   x41,W
177E6:  SUBLW  00
177E8:  BNC   1785E
....................    { 
....................       WRITE_DATA_BYTE_OF(address + i, READ_DATA_BYTE_SCF(address + i)); 
177EA:  MOVF   x3F,W
177EC:  ADDWF  x3B,W
177EE:  MOVWF  x47
177F0:  MOVF   x40,W
177F2:  ADDWFC x3C,W
177F4:  MOVWF  x48
177F6:  MOVF   x41,W
177F8:  ADDWFC x3D,W
177FA:  MOVWF  x49
177FC:  MOVF   x42,W
177FE:  ADDWFC x3E,W
17800:  MOVWF  x4A
17802:  MOVF   x3F,W
17804:  ADDWF  x3B,W
17806:  MOVWF  x4B
17808:  MOVF   x40,W
1780A:  ADDWFC x3C,W
1780C:  MOVWF  x4C
1780E:  MOVF   x41,W
17810:  ADDWFC x3D,W
17812:  MOVWF  x4D
17814:  MOVF   x42,W
17816:  ADDWFC x3E,W
17818:  MOVWF  x4E
1781A:  MOVWF  x52
1781C:  MOVFF  34D,351
17820:  MOVFF  34C,350
17824:  MOVFF  34B,34F
17828:  MOVLB  0
1782A:  CALL   12442
1782E:  MOVFF  01,34B
17832:  MOVFF  34A,393
17836:  MOVFF  349,392
1783A:  MOVFF  348,391
1783E:  MOVFF  347,390
17842:  MOVFF  01,394
17846:  CALL   11B8C
1784A:  MOVLW  01
1784C:  MOVLB  3
1784E:  ADDWF  x3F,F
17850:  BTFSC  FD8.0
17852:  INCF   x40,F
17854:  BTFSC  FD8.2
17856:  INCF   x41,F
17858:  BTFSC  FD8.2
1785A:  INCF   x42,F
1785C:  BRA    177E0
....................    } 
....................    delay_ms(100); 
1785E:  MOVLW  64
17860:  MOVWF  x98
17862:  MOVLB  0
17864:  CALL   063E
....................    output_high(PIN_C4); 
17868:  BCF    F94.4
1786A:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
1786C:  MOVFF  33D,343
17870:  MOVFF  33E,344
17874:  MOVFF  344,345
17878:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x21, D1, D2);                                                   //0xE0+16bit sector info 
1787C:  MOVLW  21
1787E:  MOVLB  3
17880:  MOVWF  x53
17882:  MOVFF  345,354
17886:  MOVFF  346,355
1788A:  MOVLB  0
1788C:  CALL   16EA4
....................     
....................    return; 
17890:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SCF2SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_SMF(data1,data2,data3,data4);                                  //erase 1 sector SMF 
17892:  MOVFF  337,347
17896:  MOVFF  338,348
1789A:  MOVFF  339,349
1789E:  MOVFF  33A,34A
178A2:  CALL   16FE0
....................    delay_ms(500); 
178A6:  MOVLW  02
178A8:  MOVLB  3
178AA:  MOVWF  x47
178AC:  MOVLW  FA
178AE:  MOVWF  x98
178B0:  MOVLB  0
178B2:  CALL   063E
178B6:  MOVLB  3
178B8:  DECFSZ x47,F
178BA:  BRA    178AC
....................    fprintf(PC,"transfer SCF2SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
178BC:  MOVLW  B4
178BE:  MOVWF  FF6
178C0:  MOVLW  09
178C2:  MOVWF  FF7
178C4:  MOVLW  00
178C6:  MOVWF  FF8
178C8:  MOVLW  11
178CA:  MOVWF  xA2
178CC:  MOVLB  0
178CE:  CALL   06CE
178D2:  MOVFF  337,3A2
178D6:  MOVLW  57
178D8:  MOVLB  3
178DA:  MOVWF  xA3
178DC:  MOVLB  0
178DE:  CALL   0700
178E2:  MOVFF  338,3A2
178E6:  MOVLW  57
178E8:  MOVLB  3
178EA:  MOVWF  xA3
178EC:  MOVLB  0
178EE:  CALL   0700
178F2:  MOVFF  339,3A2
178F6:  MOVLW  57
178F8:  MOVLB  3
178FA:  MOVWF  xA3
178FC:  MOVLB  0
178FE:  CALL   0700
17902:  MOVFF  33A,3A2
17906:  MOVLW  57
17908:  MOVLB  3
1790A:  MOVWF  xA3
1790C:  MOVLB  0
1790E:  CALL   0700
17912:  MOVLW  0D
17914:  BTFSS  F9E.4
17916:  BRA    17914
17918:  MOVWF  FAD
1791A:  MOVLW  0A
1791C:  BTFSS  F9E.4
1791E:  BRA    1791C
17920:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17922:  MOVFF  337,33E
17926:  MOVFF  338,33D
1792A:  MOVFF  339,33C
1792E:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17932:  MOVLB  3
17934:  MOVFF  33B,00
17938:  MOVFF  33C,01
1793C:  CLRF   02
1793E:  CLRF   03
17940:  MOVF   x3B,W
17942:  SUBWF  x3B,F
17944:  MOVF   x3C,W
17946:  SUBWFB x3C,F
17948:  MOVF   02,W
1794A:  SUBWFB x3D,F
1794C:  MOVF   03,W
1794E:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
17950:  BCF    F94.4
17952:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17954:  BCF    F92.5
17956:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17958:  CLRF   x42
1795A:  CLRF   x41
1795C:  CLRF   x40
1795E:  CLRF   x3F
17960:  MOVF   x42,F
17962:  BNZ   179DE
17964:  MOVF   x41,W
17966:  SUBLW  00
17968:  BNC   179DE
....................    { 
....................       WRITE_DATA_BYTE_SMF(address + i, READ_DATA_BYTE_SCF(address + i)); 
1796A:  MOVF   x3F,W
1796C:  ADDWF  x3B,W
1796E:  MOVWF  x47
17970:  MOVF   x40,W
17972:  ADDWFC x3C,W
17974:  MOVWF  x48
17976:  MOVF   x41,W
17978:  ADDWFC x3D,W
1797A:  MOVWF  x49
1797C:  MOVF   x42,W
1797E:  ADDWFC x3E,W
17980:  MOVWF  x4A
17982:  MOVF   x3F,W
17984:  ADDWF  x3B,W
17986:  MOVWF  x4B
17988:  MOVF   x40,W
1798A:  ADDWFC x3C,W
1798C:  MOVWF  x4C
1798E:  MOVF   x41,W
17990:  ADDWFC x3D,W
17992:  MOVWF  x4D
17994:  MOVF   x42,W
17996:  ADDWFC x3E,W
17998:  MOVWF  x4E
1799A:  MOVWF  x52
1799C:  MOVFF  34D,351
179A0:  MOVFF  34C,350
179A4:  MOVFF  34B,34F
179A8:  MOVLB  0
179AA:  CALL   12442
179AE:  MOVFF  01,34B
179B2:  MOVFF  34A,393
179B6:  MOVFF  349,392
179BA:  MOVFF  348,391
179BE:  MOVFF  347,390
179C2:  MOVFF  01,394
179C6:  CALL   11C8C
179CA:  MOVLW  01
179CC:  MOVLB  3
179CE:  ADDWF  x3F,F
179D0:  BTFSC  FD8.0
179D2:  INCF   x40,F
179D4:  BTFSC  FD8.2
179D6:  INCF   x41,F
179D8:  BTFSC  FD8.2
179DA:  INCF   x42,F
179DC:  BRA    17960
....................    } 
....................    delay_ms(100); 
179DE:  MOVLW  64
179E0:  MOVWF  x98
179E2:  MOVLB  0
179E4:  CALL   063E
....................    output_high(PIN_C4); 
179E8:  BCF    F94.4
179EA:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
179EC:  MOVFF  33D,343
179F0:  MOVFF  33E,344
179F4:  MOVFF  344,345
179F8:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x23, D1, D2);                                                   //0xE0+16bit sector info 
179FC:  MOVLW  23
179FE:  MOVLB  3
17A00:  MOVWF  x53
17A02:  MOVFF  345,354
17A06:  MOVFF  346,355
17A0A:  MOVLB  0
17A0C:  CALL   16EA4
....................     
....................    return; 
17A10:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SMF2OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_OF(data1,data2,data3,data4);                                   //erase 1 sector OBC flash 
17A12:  MOVFF  337,347
17A16:  MOVFF  338,348
17A1A:  MOVFF  339,349
17A1E:  MOVFF  33A,34A
17A22:  CALL   17094
....................    delay_ms(500); 
17A26:  MOVLW  02
17A28:  MOVLB  3
17A2A:  MOVWF  x47
17A2C:  MOVLW  FA
17A2E:  MOVWF  x98
17A30:  MOVLB  0
17A32:  CALL   063E
17A36:  MOVLB  3
17A38:  DECFSZ x47,F
17A3A:  BRA    17A2C
....................    fprintf(PC,"transfer SMF2OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17A3C:  MOVLW  D0
17A3E:  MOVWF  FF6
17A40:  MOVLW  09
17A42:  MOVWF  FF7
17A44:  MOVLW  00
17A46:  MOVWF  FF8
17A48:  MOVLW  10
17A4A:  MOVWF  xA2
17A4C:  MOVLB  0
17A4E:  CALL   06CE
17A52:  MOVFF  337,3A2
17A56:  MOVLW  57
17A58:  MOVLB  3
17A5A:  MOVWF  xA3
17A5C:  MOVLB  0
17A5E:  CALL   0700
17A62:  MOVFF  338,3A2
17A66:  MOVLW  57
17A68:  MOVLB  3
17A6A:  MOVWF  xA3
17A6C:  MOVLB  0
17A6E:  CALL   0700
17A72:  MOVFF  339,3A2
17A76:  MOVLW  57
17A78:  MOVLB  3
17A7A:  MOVWF  xA3
17A7C:  MOVLB  0
17A7E:  CALL   0700
17A82:  MOVFF  33A,3A2
17A86:  MOVLW  57
17A88:  MOVLB  3
17A8A:  MOVWF  xA3
17A8C:  MOVLB  0
17A8E:  CALL   0700
17A92:  MOVLW  0D
17A94:  BTFSS  F9E.4
17A96:  BRA    17A94
17A98:  MOVWF  FAD
17A9A:  MOVLW  0A
17A9C:  BTFSS  F9E.4
17A9E:  BRA    17A9C
17AA0:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17AA2:  MOVFF  337,33E
17AA6:  MOVFF  338,33D
17AAA:  MOVFF  339,33C
17AAE:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17AB2:  MOVLB  3
17AB4:  MOVFF  33B,00
17AB8:  MOVFF  33C,01
17ABC:  CLRF   02
17ABE:  CLRF   03
17AC0:  MOVF   x3B,W
17AC2:  SUBWF  x3B,F
17AC4:  MOVF   x3C,W
17AC6:  SUBWFB x3C,F
17AC8:  MOVF   02,W
17ACA:  SUBWFB x3D,F
17ACC:  MOVF   03,W
17ACE:  SUBWFB x3E,F
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17AD0:  BCF    F92.5
17AD2:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17AD4:  CLRF   x42
17AD6:  CLRF   x41
17AD8:  CLRF   x40
17ADA:  CLRF   x3F
17ADC:  MOVF   x42,F
17ADE:  BNZ   17B5A
17AE0:  MOVF   x41,W
17AE2:  SUBLW  00
17AE4:  BNC   17B5A
....................    { 
....................       WRITE_DATA_BYTE_OF(address + i, READ_DATA_BYTE_SMF(address + i)); 
17AE6:  MOVF   x3F,W
17AE8:  ADDWF  x3B,W
17AEA:  MOVWF  x47
17AEC:  MOVF   x40,W
17AEE:  ADDWFC x3C,W
17AF0:  MOVWF  x48
17AF2:  MOVF   x41,W
17AF4:  ADDWFC x3D,W
17AF6:  MOVWF  x49
17AF8:  MOVF   x42,W
17AFA:  ADDWFC x3E,W
17AFC:  MOVWF  x4A
17AFE:  MOVF   x3F,W
17B00:  ADDWF  x3B,W
17B02:  MOVWF  x4B
17B04:  MOVF   x40,W
17B06:  ADDWFC x3C,W
17B08:  MOVWF  x4C
17B0A:  MOVF   x41,W
17B0C:  ADDWFC x3D,W
17B0E:  MOVWF  x4D
17B10:  MOVF   x42,W
17B12:  ADDWFC x3E,W
17B14:  MOVWF  x4E
17B16:  MOVWF  x8C
17B18:  MOVFF  34D,38B
17B1C:  MOVFF  34C,38A
17B20:  MOVFF  34B,389
17B24:  MOVLB  0
17B26:  CALL   11800
17B2A:  MOVFF  01,34B
17B2E:  MOVFF  34A,393
17B32:  MOVFF  349,392
17B36:  MOVFF  348,391
17B3A:  MOVFF  347,390
17B3E:  MOVFF  01,394
17B42:  CALL   11B8C
17B46:  MOVLW  01
17B48:  MOVLB  3
17B4A:  ADDWF  x3F,F
17B4C:  BTFSC  FD8.0
17B4E:  INCF   x40,F
17B50:  BTFSC  FD8.2
17B52:  INCF   x41,F
17B54:  BTFSC  FD8.2
17B56:  INCF   x42,F
17B58:  BRA    17ADC
....................    } 
....................    delay_ms(100); 
17B5A:  MOVLW  64
17B5C:  MOVWF  x98
17B5E:  MOVLB  0
17B60:  CALL   063E
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17B64:  MOVFF  33D,343
17B68:  MOVFF  33E,344
17B6C:  MOVFF  344,345
17B70:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x31, D1, D2);                                                   //0xE0+16bit sector info 
17B74:  MOVLW  31
17B76:  MOVLB  3
17B78:  MOVWF  x53
17B7A:  MOVFF  345,354
17B7E:  MOVFF  346,355
17B82:  MOVLB  0
17B84:  CALL   16EA4
....................     
....................    return; 
17B88:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SMF2SCF(int8 data1,int8 data2,int8 data3,int8 data4)        //0x32 
.................... { 
....................    REFRESH_SECTOR_SCF(data1,data2,data3,data4);                                  //erase 1 sector SCF 
17B8A:  MOVFF  337,347
17B8E:  MOVFF  338,348
17B92:  MOVFF  339,349
17B96:  MOVFF  33A,34A
17B9A:  CALL   17144
....................    delay_ms(500); 
17B9E:  MOVLW  02
17BA0:  MOVLB  3
17BA2:  MOVWF  x47
17BA4:  MOVLW  FA
17BA6:  MOVWF  x98
17BA8:  MOVLB  0
17BAA:  CALL   063E
17BAE:  MOVLB  3
17BB0:  DECFSZ x47,F
17BB2:  BRA    17BA4
....................    fprintf(PC,"transfer SMF2SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17BB4:  MOVLW  EC
17BB6:  MOVWF  FF6
17BB8:  MOVLW  09
17BBA:  MOVWF  FF7
17BBC:  MOVLW  00
17BBE:  MOVWF  FF8
17BC0:  MOVLW  11
17BC2:  MOVWF  xA2
17BC4:  MOVLB  0
17BC6:  CALL   06CE
17BCA:  MOVFF  337,3A2
17BCE:  MOVLW  57
17BD0:  MOVLB  3
17BD2:  MOVWF  xA3
17BD4:  MOVLB  0
17BD6:  CALL   0700
17BDA:  MOVFF  338,3A2
17BDE:  MOVLW  57
17BE0:  MOVLB  3
17BE2:  MOVWF  xA3
17BE4:  MOVLB  0
17BE6:  CALL   0700
17BEA:  MOVFF  339,3A2
17BEE:  MOVLW  57
17BF0:  MOVLB  3
17BF2:  MOVWF  xA3
17BF4:  MOVLB  0
17BF6:  CALL   0700
17BFA:  MOVFF  33A,3A2
17BFE:  MOVLW  57
17C00:  MOVLB  3
17C02:  MOVWF  xA3
17C04:  MOVLB  0
17C06:  CALL   0700
17C0A:  MOVLW  0D
17C0C:  BTFSS  F9E.4
17C0E:  BRA    17C0C
17C10:  MOVWF  FAD
17C12:  MOVLW  0A
17C14:  BTFSS  F9E.4
17C16:  BRA    17C14
17C18:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17C1A:  MOVFF  337,33E
17C1E:  MOVFF  338,33D
17C22:  MOVFF  339,33C
17C26:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17C2A:  MOVLB  3
17C2C:  MOVFF  33B,00
17C30:  MOVFF  33C,01
17C34:  CLRF   02
17C36:  CLRF   03
17C38:  MOVF   x3B,W
17C3A:  SUBWF  x3B,F
17C3C:  MOVF   x3C,W
17C3E:  SUBWFB x3C,F
17C40:  MOVF   02,W
17C42:  SUBWFB x3D,F
17C44:  MOVF   03,W
17C46:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
17C48:  BCF    F94.4
17C4A:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17C4C:  BCF    F92.5
17C4E:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17C50:  CLRF   x42
17C52:  CLRF   x41
17C54:  CLRF   x40
17C56:  CLRF   x3F
17C58:  MOVF   x42,F
17C5A:  BNZ   17CD6
17C5C:  MOVF   x41,W
17C5E:  SUBLW  00
17C60:  BNC   17CD6
....................    { 
....................       WRITE_DATA_BYTE_SCF(address + i, READ_DATA_BYTE_SMF(address + i)); 
17C62:  MOVF   x3F,W
17C64:  ADDWF  x3B,W
17C66:  MOVWF  x47
17C68:  MOVF   x40,W
17C6A:  ADDWFC x3C,W
17C6C:  MOVWF  x48
17C6E:  MOVF   x41,W
17C70:  ADDWFC x3D,W
17C72:  MOVWF  x49
17C74:  MOVF   x42,W
17C76:  ADDWFC x3E,W
17C78:  MOVWF  x4A
17C7A:  MOVF   x3F,W
17C7C:  ADDWF  x3B,W
17C7E:  MOVWF  x4B
17C80:  MOVF   x40,W
17C82:  ADDWFC x3C,W
17C84:  MOVWF  x4C
17C86:  MOVF   x41,W
17C88:  ADDWFC x3D,W
17C8A:  MOVWF  x4D
17C8C:  MOVF   x42,W
17C8E:  ADDWFC x3E,W
17C90:  MOVWF  x4E
17C92:  MOVWF  x8C
17C94:  MOVFF  34D,38B
17C98:  MOVFF  34C,38A
17C9C:  MOVFF  34B,389
17CA0:  MOVLB  0
17CA2:  CALL   11800
17CA6:  MOVFF  01,34B
17CAA:  MOVFF  34A,393
17CAE:  MOVFF  349,392
17CB2:  MOVFF  348,391
17CB6:  MOVFF  347,390
17CBA:  MOVFF  01,394
17CBE:  CALL   11C0C
17CC2:  MOVLW  01
17CC4:  MOVLB  3
17CC6:  ADDWF  x3F,F
17CC8:  BTFSC  FD8.0
17CCA:  INCF   x40,F
17CCC:  BTFSC  FD8.2
17CCE:  INCF   x41,F
17CD0:  BTFSC  FD8.2
17CD2:  INCF   x42,F
17CD4:  BRA    17C58
....................    } 
....................    delay_ms(100); 
17CD6:  MOVLW  64
17CD8:  MOVWF  x98
17CDA:  MOVLB  0
17CDC:  CALL   063E
....................    output_high(PIN_C4);                                                          //SCF COM side 
17CE0:  BCF    F94.4
17CE2:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17CE4:  MOVFF  33D,343
17CE8:  MOVFF  33E,344
17CEC:  MOVFF  344,345
17CF0:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x32, D1, D2);                                                   //0xE0+16bit sector info 
17CF4:  MOVLW  32
17CF6:  MOVLB  3
17CF8:  MOVWF  x53
17CFA:  MOVFF  345,354
17CFE:  MOVFF  346,355
17D02:  MOVLB  0
17D04:  CALL   16EA4
....................    return; 
17D08:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<mainpic_function.c> 
.................... #ifndef MAINPIC_FUNCTION_C 
.................... #define MAINPIC_FUNCTION_C 
....................  
.................... /* 
.................... //caution 
.................... //port of kbhit in CAMTurn_OFF_BC Mission is PC-- 
.................... //TRANSFER_DATA_NBYTE_TOPC_SCF(65536,65536); is comment out-- 
.................... //adcs address test make32 function-- 
.................... // 
.................... //reset battery voltage 0x87, over 0x87 is nomal mode 
.................... //reset  
.................... */ 
....................  
.................... #include "mbp.c" 
.................... #ifndef MBP_C 
.................... #define MBP_C 
....................  
.................... #include "MEMORY_OPERATION.c" 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "SATELLITE_LOG.c" 
.................... #ifndef SATELLITE_LOG_C 
.................... #define SATELLITE_LOG_C 
....................  
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {};                                            //Satelite Log Length 
.................... #ORG 0x00016800 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
....................    {} 
....................    return; 
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
.................... #ORG 0x00016800 
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
....................    { 
....................       reset_bffr[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
....................    Save_RSV();                                                                   //save in flash memory reserve_table[] content 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
....................    fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
....................    fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
....................    for(int i = 0; i<100; i++) 
....................    { 
....................       fputc(0x27,reset);                                                      //send command for satellite reset 
....................       delay_ms(10); 
....................    } 
....................  
....................    RESET_DATA = 0; 
....................    fprintf(PC,"Ready for reset"); 
....................    delay_ms(1000); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
....................    RESET_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
....................    RESET_DATA = 0; 
....................    for(int m=0; m<10; m++) 
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
....................       delay_ms(10); 
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
....................       if(RESET_bffr[0] == 0x8e) 
....................       { 
....................          break; 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
....................    if(PASSED_DAYS == 0xffff) 
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    }    
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
....................    }else{                                                                        //if nothing stored 
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... #ORG 0x00016800 
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
....................    RESET_DATA = 0; 
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
....................       satellitelog[3] = RESET_bffr[2]; 
....................       satellitelog[4] = RESET_bffr[3]; 
....................       satellitelog[5] = RESET_bffr[4]; 
....................       satellitelog[6] = RESET_bffr[5]; 
....................        
....................       satellitelog[7] = data1; 
....................       satellitelog[8] = data2; 
....................       satellitelog[9] = data3; 
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
....................       SAT_LOG = SAT_LOG + logdata_size; 
....................       fprintf(PC,"LOG saving done\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... int8 MBP_DATA[83] = {}; 
.................... int8 DC_ACK = 0; 
....................  
.................... #ORG 0x00011800 
.................... void Turn_On_MBP() 
.................... { 
....................    output_high(PIN_F5); 
*
124CA:  BCF    F97.5
124CC:  BSF    F8E.5
....................    return; 
124CE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Turn_Off_MBP() 
.................... { 
....................    output_low(PIN_F5); 
*
13A80:  BCF    F97.5
13A82:  BCF    F8E.5
....................    return; 
13A84:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void DELETE_MBP_DATA()                                                           //Clear MBP array to receive data 
.................... { 
....................    for(int8 i = 0; i < 81; i++) 
*
137A8:  MOVLB  3
137AA:  CLRF   x42
137AC:  MOVF   x42,W
137AE:  SUBLW  50
137B0:  BNC   137C6
....................    { 
....................       MBP_DATA[i] = 0; 
137B2:  CLRF   03
137B4:  MOVF   x42,W
137B6:  ADDLW  42
137B8:  MOVWF  FE9
137BA:  MOVLW  01
137BC:  ADDWFC 03,W
137BE:  MOVWF  FEA
137C0:  CLRF   FEF
137C2:  INCF   x42,F
137C4:  BRA    137AC
....................    } 
....................    return; 
137C6:  MOVLB  0
137C8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CHECK_ACK_FROM_DC_10k()                                                     //Wait ACK from DC for 10s 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
12D9C:  MOVLB  3
12D9E:  CLRF   x52
12DA0:  CLRF   x51
12DA2:  CLRF   x50
12DA4:  CLRF   x4F
12DA6:  MOVF   x52,F
12DA8:  BNZ   12DE4
12DAA:  MOVF   x51,W
12DAC:  SUBLW  0F
12DAE:  BNC   12DE4
12DB0:  BNZ   12DC0
12DB2:  MOVF   x50,W
12DB4:  SUBLW  42
12DB6:  BNC   12DE4
12DB8:  BNZ   12DC0
12DBA:  MOVF   x4F,W
12DBC:  SUBLW  3F
12DBE:  BNC   12DE4
....................    { 
....................       if(kbhit(DC))                                                              //kbhit(PC) 
12DC0:  BTFSC  F86.1
12DC2:  BRA    12DD2
....................       { 
....................          DC_ACK = fgetc(DC);                                                     //PC    
12DC4:  MOVLB  0
12DC6:  CALL   1A28
12DCA:  MOVFF  01,195
....................          break; 
12DCE:  MOVLB  3
12DD0:  BRA    12DE4
....................       }                                                                          //delay_ms(1); 
12DD2:  MOVLW  01
12DD4:  ADDWF  x4F,F
12DD6:  BTFSC  FD8.0
12DD8:  INCF   x50,F
12DDA:  BTFSC  FD8.2
12DDC:  INCF   x51,F
12DDE:  BTFSC  FD8.2
12DE0:  INCF   x52,F
12DE2:  BRA    12DA6
....................    } 
....................    return; 
12DE4:  MOVLB  0
12DE6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void GET_MBP_DATA(int16 transf_size) 
*
137CA:  MOVLB  3
137CC:  CLRF   x45
137CE:  CLRF   x44
137D0:  CLRF   x46
.................... { 
....................    int16 n = 0; 
....................    int8 input = 0; 
....................    for(int32 i = 0; i < 99000000; i++)                                            //1000000 
137D2:  CLRF   x4A
137D4:  CLRF   x49
137D6:  CLRF   x48
137D8:  CLRF   x47
137DA:  MOVF   x4A,W
137DC:  SUBLW  05
137DE:  BNC   13882
137E0:  BNZ   137F8
137E2:  MOVF   x49,W
137E4:  SUBLW  E6
137E6:  BNC   13882
137E8:  BNZ   137F8
137EA:  MOVF   x48,W
137EC:  SUBLW  9E
137EE:  BNC   13882
137F0:  BNZ   137F8
137F2:  MOVF   x47,W
137F4:  SUBLW  BF
137F6:  BNC   13882
....................    {                                                                              //99000000 es tiempo suficiente para transferir un sector 
....................       if(kbhit(DC)) 
137F8:  BTFSC  F86.1
137FA:  BRA    13870
....................       { 
....................          input = fgetc(DC);                                                      //get data from MBP 
137FC:  MOVLB  0
137FE:  CALL   1A28
13802:  MOVFF  01,346
....................          WRITE_DATA_BYTE_OF(DC_STATUS_ADDRESS,input);                            //Save data on OF, SCF, SMF 
13806:  MOVFF  5B,393
1380A:  MOVFF  5A,392
1380E:  MOVFF  59,391
13812:  MOVFF  58,390
13816:  MOVFF  346,394
1381A:  CALL   11B8C
....................          WRITE_DATA_BYTE_SCF(DC_STATUS_ADDRESS,input); 
1381E:  MOVFF  5B,393
13822:  MOVFF  5A,392
13826:  MOVFF  59,391
1382A:  MOVFF  58,390
1382E:  MOVFF  346,394
13832:  CALL   11C0C
....................          WRITE_DATA_BYTE_SMF(DC_STATUS_ADDRESS,input); 
13836:  MOVFF  5B,393
1383A:  MOVFF  5A,392
1383E:  MOVFF  59,391
13842:  MOVFF  58,390
13846:  MOVFF  346,394
1384A:  CALL   11C8C
....................          n++; 
1384E:  MOVLB  3
13850:  INCF   x44,F
13852:  BTFSC  FD8.2
13854:  INCF   x45,F
....................          DC_STATUS_ADDRESS = DC_STATUS_ADDRESS + 1; 
13856:  MOVLW  01
13858:  ADDWF  58,F
1385A:  MOVLW  00
1385C:  ADDWFC 59,F
1385E:  ADDWFC 5A,F
13860:  ADDWFC 5B,F
....................          if(n==transf_size)                                                      //sale del for cuando se completa la cantidad de bytes 
13862:  MOVF   x42,W
13864:  SUBWF  x44,W
13866:  BNZ   13870
13868:  MOVF   x43,W
1386A:  SUBWF  x45,W
1386C:  BNZ   13870
....................          { 
....................          break; 
1386E:  BRA    13882
....................          } 
....................       } 
13870:  MOVLW  01
13872:  ADDWF  x47,F
13874:  BTFSC  FD8.0
13876:  INCF   x48,F
13878:  BTFSC  FD8.2
1387A:  INCF   x49,F
1387C:  BTFSC  FD8.2
1387E:  INCF   x4A,F
13880:  BRA    137DA
....................    } 
....................  
....................    DC_STATUS_ADDRESS=0x06660000; 
13882:  MOVLW  06
13884:  MOVWF  5B
13886:  MOVLW  66
13888:  MOVWF  5A
1388A:  CLRF   59
1388C:  CLRF   58
....................    
....................    fprintf(PC,"Transferred %ld Bytes",n); 
1388E:  MOVLW  08
13890:  MOVWF  FF6
13892:  MOVLW  0A
13894:  MOVWF  FF7
13896:  MOVLW  00
13898:  MOVWF  FF8
1389A:  MOVLW  0C
1389C:  MOVWF  xA2
1389E:  MOVLB  0
138A0:  CALL   06CE
138A4:  MOVLW  10
138A6:  MOVWF  FE9
138A8:  MOVFF  345,34C
138AC:  MOVFF  344,34B
138B0:  GOTO   25C0
138B4:  MOVLW  17
138B6:  MOVWF  FF6
138B8:  MOVLW  0A
138BA:  MOVWF  FF7
138BC:  MOVLW  00
138BE:  MOVWF  FF8
138C0:  MOVLW  06
138C2:  MOVLB  3
138C4:  MOVWF  xA2
138C6:  MOVLB  0
138C8:  CALL   06CE
....................    n=0; 
138CC:  MOVLB  3
138CE:  CLRF   x45
138D0:  CLRF   x44
....................    output_high(PIN_C4);                                                          //COM_MUX COM side 
138D2:  BCF    F94.4
138D4:  BSF    F8B.4
....................    return; 
138D6:  MOVLB  0
138D8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void DATACOLLECTION_TEST_OPERATION(int8 cmd1,int8 cmd2,int8 cmd3,int8 cmd4,int8 cmd5,int8 cmd6,int8 cmd7) 
.................... { 
....................    DELETE_MBP_DATA();                                                            //Clear MBP array to receive data 
138DA:  RCALL  137A8
....................    // LOOP_DC_STATUS_ADDRESS();                                                   //realiza un loop verificando si se esta por alcanzar el limite de espacio asignado 
....................    REFRESH_SECTOR_OF(0x06,0x66,0x00,0x00);                                       //clear 1 sector OBC flash DC part 
138DC:  MOVLW  06
138DE:  MOVLB  3
138E0:  MOVWF  x47
138E2:  MOVLW  66
138E4:  MOVWF  x48
138E6:  CLRF   x49
138E8:  CLRF   x4A
138EA:  MOVLB  0
138EC:  CALL   17094
....................    REFRESH_SECTOR_SCF(0x06,0x66,0x00,0x00);                                      //clear 1 sector COM flash DC part  
138F0:  MOVLW  06
138F2:  MOVLB  3
138F4:  MOVWF  x47
138F6:  MOVLW  66
138F8:  MOVWF  x48
138FA:  CLRF   x49
138FC:  CLRF   x4A
138FE:  MOVLB  0
13900:  CALL   17144
....................    REFRESH_SECTOR_SMF(0x06,0x66,0x00,0x00);                                      //clear 1 sector MISSION flash DC part 
13904:  MOVLW  06
13906:  MOVLB  3
13908:  MOVWF  x47
1390A:  MOVLW  66
1390C:  MOVWF  x48
1390E:  CLRF   x49
13910:  CLRF   x4A
13912:  MOVLB  0
13914:  CALL   16FE0
....................     
....................    int16 data_pckts = make16(cmd6,cmd7); 
....................    int16 data_size = data_pckts*81; 
13918:  MOVFF  33C,33F
1391C:  MOVFF  33D,33E
13920:  MOVFF  33F,343
13924:  MOVFF  33E,342
13928:  MOVLB  3
1392A:  CLRF   x45
1392C:  MOVLW  51
1392E:  MOVWF  x44
13930:  MOVLB  0
13932:  CALL   253A
13936:  MOVFF  02,341
1393A:  MOVFF  01,340
....................     
....................    fprintf(PC,"sending commands to MBP\r\n"); 
1393E:  MOVLW  1E
13940:  MOVWF  FF6
13942:  MOVLW  0A
13944:  MOVWF  FF7
13946:  MOVLW  00
13948:  MOVWF  FF8
1394A:  CALL   06A4
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
1394E:  CALL   124CA
....................    delay_ms(30); 
13952:  MOVLW  1E
13954:  MOVLB  3
13956:  MOVWF  x98
13958:  MOVLB  0
1395A:  CALL   063E
....................  
....................    fputc(cmd1,DC); 
1395E:  MOVFF  337,34F
13962:  CALL   19E2
....................    delay_ms(100); 
13966:  MOVLW  64
13968:  MOVLB  3
1396A:  MOVWF  x98
1396C:  MOVLB  0
1396E:  CALL   063E
....................    fputc(cmd2,DC); 
13972:  MOVFF  338,34F
13976:  CALL   19E2
....................    delay_ms(100); 
1397A:  MOVLW  64
1397C:  MOVLB  3
1397E:  MOVWF  x98
13980:  MOVLB  0
13982:  CALL   063E
....................    fputc(cmd3,DC); 
13986:  MOVFF  339,34F
1398A:  CALL   19E2
....................    delay_ms(100); 
1398E:  MOVLW  64
13990:  MOVLB  3
13992:  MOVWF  x98
13994:  MOVLB  0
13996:  CALL   063E
....................    fputc(cmd4,DC); 
1399A:  MOVFF  33A,34F
1399E:  CALL   19E2
....................    delay_ms(100); 
139A2:  MOVLW  64
139A4:  MOVLB  3
139A6:  MOVWF  x98
139A8:  MOVLB  0
139AA:  CALL   063E
....................    fputc(cmd5,DC); 
139AE:  MOVFF  33B,34F
139B2:  CALL   19E2
....................    delay_ms(100); 
139B6:  MOVLW  64
139B8:  MOVLB  3
139BA:  MOVWF  x98
139BC:  MOVLB  0
139BE:  CALL   063E
....................    fputc(cmd6,DC); 
139C2:  MOVFF  33C,34F
139C6:  CALL   19E2
....................    delay_ms(100); 
139CA:  MOVLW  64
139CC:  MOVLB  3
139CE:  MOVWF  x98
139D0:  MOVLB  0
139D2:  CALL   063E
....................    fputc(cmd7,DC); 
139D6:  MOVFF  33D,34F
139DA:  CALL   19E2
....................  
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from MBP for 10s 
139DE:  CALL   12D9C
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
139E2:  MOVLB  1
139E4:  MOVF   x95,W
139E6:  SUBLW  20
139E8:  BNZ   13A66
....................    { 
....................       fprintf(PC,"Received ACK From MBP\r\n"); 
139EA:  MOVLW  38
139EC:  MOVWF  FF6
139EE:  MOVLW  0A
139F0:  MOVWF  FF7
139F2:  MOVLW  00
139F4:  MOVWF  FF8
139F6:  MOVLB  0
139F8:  CALL   06A4
....................       //delay_ms(1000); 
....................       DC_ACK = 0; 
139FC:  MOVLB  1
139FE:  CLRF   x95
....................       output_low(PIN_C4);                                                        //SCF main side 
13A00:  BCF    F94.4
13A02:  BCF    F8B.4
....................       output_low(PIN_A5);                                                        //SMF main side 
13A04:  BCF    F92.5
13A06:  BCF    F89.5
....................       fprintf(PC,"TRANSFERRING %lx PACKETS\r\n",data_pckts); 
13A08:  MOVLW  50
13A0A:  MOVWF  FF6
13A0C:  MOVLW  0A
13A0E:  MOVWF  FF7
13A10:  MOVLW  00
13A12:  MOVWF  FF8
13A14:  MOVLW  0D
13A16:  MOVLB  3
13A18:  MOVWF  xA2
13A1A:  MOVLB  0
13A1C:  CALL   06CE
13A20:  MOVFF  33F,3A2
13A24:  MOVLW  57
13A26:  MOVLB  3
13A28:  MOVWF  xA3
13A2A:  MOVLB  0
13A2C:  CALL   0700
13A30:  MOVFF  33E,3A2
13A34:  MOVLW  57
13A36:  MOVLB  3
13A38:  MOVWF  xA3
13A3A:  MOVLB  0
13A3C:  CALL   0700
13A40:  MOVLW  60
13A42:  MOVWF  FF6
13A44:  MOVLW  0A
13A46:  MOVWF  FF7
13A48:  MOVLW  00
13A4A:  MOVWF  FF8
13A4C:  MOVLW  0A
13A4E:  MOVLB  3
13A50:  MOVWF  xA2
13A52:  MOVLB  0
13A54:  CALL   06CE
....................        
....................       GET_MBP_DATA(data_size); 
13A58:  MOVFF  341,343
13A5C:  MOVFF  340,342
13A60:  RCALL  137CA
....................  
....................    }else{ 
13A62:  BRA    13A7A
13A64:  MOVLB  1
....................       DC_ACK = 0; 
13A66:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
13A68:  MOVLW  6C
13A6A:  MOVWF  FF6
13A6C:  MOVLW  0A
13A6E:  MOVWF  FF7
13A70:  MOVLW  00
13A72:  MOVWF  FF8
13A74:  MOVLB  0
13A76:  CALL   06A4
....................    } 
....................  
....................    output_high(PIN_C4);                                                          //COM_MUX COM side 
13A7A:  BCF    F94.4
13A7C:  BSF    F8B.4
....................     
....................    return; 
13A7E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void MISSION_TEST_OPERATION(int8 cmd1,int8 cmd2,int8 cmd3,int8 cmd4,int8 cmd5,int8 cmd6,int8 cmd7)                                                    //send array of commnands to MBP 
.................... { 
....................    fprintf(PC,"sending commands to MBP\r\n"); 
*
13A86:  MOVLW  8C
13A88:  MOVWF  FF6
13A8A:  MOVLW  0A
13A8C:  MOVWF  FF7
13A8E:  MOVLW  00
13A90:  MOVWF  FF8
13A92:  CALL   06A4
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
13A96:  CALL   124CA
....................    delay_ms(30); 
13A9A:  MOVLW  1E
13A9C:  MOVLB  3
13A9E:  MOVWF  x98
13AA0:  MOVLB  0
13AA2:  CALL   063E
....................  
....................       fputc(cmd1,DC); 
13AA6:  MOVFF  337,34F
13AAA:  CALL   19E2
....................       delay_ms(100); 
13AAE:  MOVLW  64
13AB0:  MOVLB  3
13AB2:  MOVWF  x98
13AB4:  MOVLB  0
13AB6:  CALL   063E
....................       fputc(cmd2,DC); 
13ABA:  MOVFF  338,34F
13ABE:  CALL   19E2
....................       delay_ms(100); 
13AC2:  MOVLW  64
13AC4:  MOVLB  3
13AC6:  MOVWF  x98
13AC8:  MOVLB  0
13ACA:  CALL   063E
....................       fputc(cmd3,DC); 
13ACE:  MOVFF  339,34F
13AD2:  CALL   19E2
....................       delay_ms(100); 
13AD6:  MOVLW  64
13AD8:  MOVLB  3
13ADA:  MOVWF  x98
13ADC:  MOVLB  0
13ADE:  CALL   063E
....................       fputc(cmd4,DC); 
13AE2:  MOVFF  33A,34F
13AE6:  CALL   19E2
....................       delay_ms(100); 
13AEA:  MOVLW  64
13AEC:  MOVLB  3
13AEE:  MOVWF  x98
13AF0:  MOVLB  0
13AF2:  CALL   063E
....................       fputc(cmd5,DC); 
13AF6:  MOVFF  33B,34F
13AFA:  CALL   19E2
....................       delay_ms(100); 
13AFE:  MOVLW  64
13B00:  MOVLB  3
13B02:  MOVWF  x98
13B04:  MOVLB  0
13B06:  CALL   063E
....................       fputc(cmd6,DC); 
13B0A:  MOVFF  33C,34F
13B0E:  CALL   19E2
....................       delay_ms(100); 
13B12:  MOVLW  64
13B14:  MOVLB  3
13B16:  MOVWF  x98
13B18:  MOVLB  0
13B1A:  CALL   063E
....................       fputc(cmd7,DC); 
13B1E:  MOVFF  33D,34F
13B22:  CALL   19E2
....................  
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from DC for 10s 
13B26:  CALL   12D9C
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
13B2A:  MOVLB  1
13B2C:  MOVF   x95,W
13B2E:  SUBLW  20
13B30:  BNZ   13B4A
....................    { 
....................       fprintf(PC,"Received ACK From MBP\r\n"); 
13B32:  MOVLW  A6
13B34:  MOVWF  FF6
13B36:  MOVLW  0A
13B38:  MOVWF  FF7
13B3A:  MOVLW  00
13B3C:  MOVWF  FF8
13B3E:  MOVLB  0
13B40:  CALL   06A4
....................       DC_ACK = 0; 
13B44:  MOVLB  1
13B46:  CLRF   x95
....................        
....................    } 
13B48:  BRA    13C26
....................    else 
....................    { 
....................       DC_ACK = 0; 
13B4A:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
13B4C:  MOVLW  BE
13B4E:  MOVWF  FF6
13B50:  MOVLW  0A
13B52:  MOVWF  FF7
13B54:  MOVLW  00
13B56:  MOVWF  FF8
13B58:  MOVLB  0
13B5A:  CALL   06A4
....................       fprintf(PC,"PWR cycle and sending commands again\r\n"); 
13B5E:  MOVLW  DE
13B60:  MOVWF  FF6
13B62:  MOVLW  0A
13B64:  MOVWF  FF7
13B66:  MOVLW  00
13B68:  MOVWF  FF8
13B6A:  CALL   06A4
....................       Turn_Off_MBP(); 
13B6E:  RCALL  13A80
....................       delay_ms(1000); 
13B70:  MOVLW  04
13B72:  MOVLB  3
13B74:  MOVWF  x3E
13B76:  MOVLW  FA
13B78:  MOVWF  x98
13B7A:  MOVLB  0
13B7C:  CALL   063E
13B80:  MOVLB  3
13B82:  DECFSZ x3E,F
13B84:  BRA    13B76
....................       Turn_On_MBP();                                                              //RF5=HIGH 
13B86:  MOVLB  0
13B88:  CALL   124CA
....................       delay_ms(1000); 
13B8C:  MOVLW  04
13B8E:  MOVLB  3
13B90:  MOVWF  x3E
13B92:  MOVLW  FA
13B94:  MOVWF  x98
13B96:  MOVLB  0
13B98:  CALL   063E
13B9C:  MOVLB  3
13B9E:  DECFSZ x3E,F
13BA0:  BRA    13B92
....................  
....................       fputc(cmd1,DC); 
13BA2:  MOVFF  337,34F
13BA6:  MOVLB  0
13BA8:  CALL   19E2
....................       delay_ms(100); 
13BAC:  MOVLW  64
13BAE:  MOVLB  3
13BB0:  MOVWF  x98
13BB2:  MOVLB  0
13BB4:  CALL   063E
....................       fputc(cmd2,DC); 
13BB8:  MOVFF  338,34F
13BBC:  CALL   19E2
....................       delay_ms(100); 
13BC0:  MOVLW  64
13BC2:  MOVLB  3
13BC4:  MOVWF  x98
13BC6:  MOVLB  0
13BC8:  CALL   063E
....................       fputc(cmd3,DC); 
13BCC:  MOVFF  339,34F
13BD0:  CALL   19E2
....................       delay_ms(100); 
13BD4:  MOVLW  64
13BD6:  MOVLB  3
13BD8:  MOVWF  x98
13BDA:  MOVLB  0
13BDC:  CALL   063E
....................       fputc(cmd4,DC); 
13BE0:  MOVFF  33A,34F
13BE4:  CALL   19E2
....................       delay_ms(100); 
13BE8:  MOVLW  64
13BEA:  MOVLB  3
13BEC:  MOVWF  x98
13BEE:  MOVLB  0
13BF0:  CALL   063E
....................       fputc(cmd5,DC); 
13BF4:  MOVFF  33B,34F
13BF8:  CALL   19E2
....................       delay_ms(100); 
13BFC:  MOVLW  64
13BFE:  MOVLB  3
13C00:  MOVWF  x98
13C02:  MOVLB  0
13C04:  CALL   063E
....................       fputc(cmd6,DC); 
13C08:  MOVFF  33C,34F
13C0C:  CALL   19E2
....................       delay_ms(100); 
13C10:  MOVLW  64
13C12:  MOVLB  3
13C14:  MOVWF  x98
13C16:  MOVLB  0
13C18:  CALL   063E
....................       fputc(cmd7,DC);    
13C1C:  MOVFF  33D,34F
13C20:  CALL   19E2
13C24:  MOVLB  1
....................    } 
....................    return; 
13C26:  MOVLB  0
13C28:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void MBP_SYNC() 
.................... { 
....................    fprintf(PC,"\r\nsending SYNC time to MBP\r\n"); 
*
12DE8:  MOVLW  06
12DEA:  MOVWF  FF6
12DEC:  MOVLW  0B
12DEE:  MOVWF  FF7
12DF0:  MOVLW  00
12DF2:  MOVWF  FF8
12DF4:  CALL   06A4
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
12DF8:  CALL   124CA
....................    delay_ms(30); 
12DFC:  MOVLW  1E
12DFE:  MOVLB  3
12E00:  MOVWF  x98
12E02:  MOVLB  0
12E04:  CALL   063E
....................    COLLECT_RESET_DATA(); 
12E08:  CALL   16860
....................       if(RESET_bffr[0] == 0x8e) 
12E0C:  MOVF   x9E,W
12E0E:  SUBLW  8E
12E10:  BNZ   12E24
....................    { 
....................       fprintf(PC,"Time received from RESET\r\n"); 
12E12:  MOVLW  24
12E14:  MOVWF  FF6
12E16:  MOVLW  0B
12E18:  MOVWF  FF7
12E1A:  MOVLW  00
12E1C:  MOVWF  FF8
12E1E:  CALL   06A4
....................  
....................    } 
12E22:  BRA    12E34
....................    else 
....................    { 
....................       fprintf(PC,"NO RESET time\r\n"); 
12E24:  MOVLW  40
12E26:  MOVWF  FF6
12E28:  MOVLW  0B
12E2A:  MOVWF  FF7
12E2C:  MOVLW  00
12E2E:  MOVWF  FF8
12E30:  CALL   06A4
....................    } 
....................        
....................       fputc(0XAA,DC); 
12E34:  MOVLW  AA
12E36:  MOVLB  3
12E38:  MOVWF  x4F
12E3A:  MOVLB  0
12E3C:  CALL   19E2
....................       delay_ms(100); 
12E40:  MOVLW  64
12E42:  MOVLB  3
12E44:  MOVWF  x98
12E46:  MOVLB  0
12E48:  CALL   063E
....................       fputc(reset_bffr[1],DC);                                                       //sec 
12E4C:  MOVFF  9F,34F
12E50:  CALL   19E2
....................       delay_ms(100); 
12E54:  MOVLW  64
12E56:  MOVLB  3
12E58:  MOVWF  x98
12E5A:  MOVLB  0
12E5C:  CALL   063E
....................       fputc(reset_bffr[2],DC);                                                       //minutes 
12E60:  MOVFF  A0,34F
12E64:  CALL   19E2
....................       delay_ms(100); 
12E68:  MOVLW  64
12E6A:  MOVLB  3
12E6C:  MOVWF  x98
12E6E:  MOVLB  0
12E70:  CALL   063E
....................       fputc(reset_bffr[3],DC);                                                       //hours 
12E74:  MOVFF  A1,34F
12E78:  CALL   19E2
....................       delay_ms(100); 
12E7C:  MOVLW  64
12E7E:  MOVLB  3
12E80:  MOVWF  x98
12E82:  MOVLB  0
12E84:  CALL   063E
....................       fputc(reset_bffr[4],DC);                                                       //day_H 
12E88:  MOVFF  A2,34F
12E8C:  CALL   19E2
....................       delay_ms(100); 
12E90:  MOVLW  64
12E92:  MOVLB  3
12E94:  MOVWF  x98
12E96:  MOVLB  0
12E98:  CALL   063E
....................       fputc(reset_bffr[5],DC);                                                       //day_L 
12E9C:  MOVFF  A3,34F
12EA0:  CALL   19E2
....................       delay_ms(100); 
12EA4:  MOVLW  64
12EA6:  MOVLB  3
12EA8:  MOVWF  x98
12EAA:  MOVLB  0
12EAC:  CALL   063E
....................       fputc(0XBB,DC); 
12EB0:  MOVLW  BB
12EB2:  MOVLB  3
12EB4:  MOVWF  x4F
12EB6:  MOVLB  0
12EB8:  CALL   19E2
....................    fprintf(PC,"%x:%x:%x,%x%x\r\n",reset_bffr[1], reset_bffr[2], reset_bffr[3], reset_bffr[4], reset_bffr[5]); 
12EBC:  MOVFF  9F,3A2
12EC0:  MOVLW  57
12EC2:  MOVLB  3
12EC4:  MOVWF  xA3
12EC6:  MOVLB  0
12EC8:  CALL   0700
12ECC:  MOVLW  3A
12ECE:  BTFSS  F9E.4
12ED0:  BRA    12ECE
12ED2:  MOVWF  FAD
12ED4:  MOVFF  A0,3A2
12ED8:  MOVLW  57
12EDA:  MOVLB  3
12EDC:  MOVWF  xA3
12EDE:  MOVLB  0
12EE0:  CALL   0700
12EE4:  MOVLW  3A
12EE6:  BTFSS  F9E.4
12EE8:  BRA    12EE6
12EEA:  MOVWF  FAD
12EEC:  MOVFF  A1,3A2
12EF0:  MOVLW  57
12EF2:  MOVLB  3
12EF4:  MOVWF  xA3
12EF6:  MOVLB  0
12EF8:  CALL   0700
12EFC:  MOVLW  2C
12EFE:  BTFSS  F9E.4
12F00:  BRA    12EFE
12F02:  MOVWF  FAD
12F04:  MOVFF  A2,3A2
12F08:  MOVLW  57
12F0A:  MOVLB  3
12F0C:  MOVWF  xA3
12F0E:  MOVLB  0
12F10:  CALL   0700
12F14:  MOVFF  A3,3A2
12F18:  MOVLW  57
12F1A:  MOVLB  3
12F1C:  MOVWF  xA3
12F1E:  MOVLB  0
12F20:  CALL   0700
12F24:  MOVLW  0D
12F26:  BTFSS  F9E.4
12F28:  BRA    12F26
12F2A:  MOVWF  FAD
12F2C:  MOVLW  0A
12F2E:  BTFSS  F9E.4
12F30:  BRA    12F2E
12F32:  MOVWF  FAD
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from DC for 10s 
12F34:  RCALL  12D9C
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
12F36:  MOVLB  1
12F38:  MOVF   x95,W
12F3A:  SUBLW  20
12F3C:  BNZ   12F56
....................    { 
....................       fprintf(PC,"Time Received for MBP\r\n"); 
12F3E:  MOVLW  50
12F40:  MOVWF  FF6
12F42:  MOVLW  0B
12F44:  MOVWF  FF7
12F46:  MOVLW  00
12F48:  MOVWF  FF8
12F4A:  MOVLB  0
12F4C:  CALL   06A4
....................       DC_ACK = 0; 
12F50:  MOVLB  1
12F52:  CLRF   x95
....................        
....................    } 
12F54:  BRA    12F6C
....................    else 
....................    { 
....................       DC_ACK = 0; 
12F56:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
12F58:  MOVLW  68
12F5A:  MOVWF  FF6
12F5C:  MOVLW  0B
12F5E:  MOVWF  FF7
12F60:  MOVLW  00
12F62:  MOVWF  FF8
12F64:  MOVLB  0
12F66:  CALL   06A4
12F6A:  MOVLB  1
....................    } 
....................    return; 
12F6C:  MOVLB  0
12F6E:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include "adcs_test.c" 
.................... #ifndef ADCS_TEST_C 
.................... #define ADCS_TEST_C 
....................  
.................... #include "adcs.c" 
.................... #ifndef ADCS_C 
.................... #define ADCS_C 
....................  
.................... #include "adcs.h" 
.................... #ifndef ADCS_H 
.................... #define ADCS_H 
....................  
.................... #define ADCS_SENSOR_SIZE 78                                                      //for testing additional 6byte for checking duty 
.................... #define TLE_size 77                                                              //TLE FORMAT ARRAY SIZE 
....................  
.................... unsigned int8 TLE[TLE_size] = {0xAA,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, //TLE data array 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0xBB}; 
....................                                   
.................... unsigned int8 ACK_for_COM[24] = {0xAA,0,0,0,0,0,0,0,0,0, 
....................                                  0,0,0,0,0,0,0,0,0,0, 
....................                                  0,0,0,0xBB}; 
....................                                   
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... static int16 currenttime = 0; 
....................  
.................... #endif 
....................  
.................... #include "MEMORY_OPERATION.c" 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "cw.c" 
.................... #ifndef CW_C 
.................... #define CW_C 
....................  
.................... #include "fab.h" 
.................... #ifndef FAB_h 
.................... #define FAB_h 
....................  
.................... #define HK_size 124                                                              //HK FORMAT ARRAY SIZE 
.................... #define CW_size 5                                                                //CW FORMAT ARRAY SIZE 
.................... #define HIGH_SAMP_HK_size 124                                                    //High Sampling HK FORMAT ARRAY SIZE 
.................... #define FAB_SENSOR_size 45                                                       //HK FAB Part 
.................... #define buffer_from_FAB  (in_bffr_main[0]==0x33) 
....................  
.................... static unsigned int8 CW_FORMAT[CW_size] = {}; 
.................... unsigned int8 in_HK[FAB_SENSOR_size] = {}; 
.................... unsigned int8 HKDATA[HK_size] ={}; 
.................... BYTE FAB_DATA = 0; 
.................... static int8 FAB_MEASUERING_FLAG= 0; 
.................... static int8 HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
.................... int32 FAB_FLAG = 0; 
.................... int8 CHECK_FAB_RESPONSE = 0; 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x0001E000 
.................... void REFLESH_CW_ACK_for_COM()                                                    //carga con 0x00 el array ACK_for_COM[7] 
.................... { 
....................    for(int i = 1; i < 7; i++) 
*
1E000:  MOVLW  01
1E002:  MOVLB  3
1E004:  MOVWF  x4F
1E006:  MOVF   x4F,W
1E008:  SUBLW  06
1E00A:  BNC   1E020
....................    { 
....................       ACK_for_COM[i] = 0x00; 
1E00C:  CLRF   03
1E00E:  MOVF   x4F,W
1E010:  ADDLW  E3
1E012:  MOVWF  FE9
1E014:  MOVLW  01
1E016:  ADDWFC 03,W
1E018:  MOVWF  FEA
1E01A:  CLRF   FEF
1E01C:  INCF   x4F,F
1E01E:  BRA    1E006
....................    } 
....................    return; 
1E020:  MOVLB  0
1E022:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void CW_RESPOND()                                                                //carga el array ACK_for_COM[] con el dato del array CW_FORMAT[] y envia a COM PIC 
.................... { 
....................    REFLESH_CW_ACK_for_COM();                                                     //carga con 0x00 el array ACK_for_COM[] desde la pos 1 a la 6 
1E024:  RCALL  1E000
....................    delay_ms(100); 
1E026:  MOVLW  64
1E028:  MOVLB  3
1E02A:  MOVWF  x98
1E02C:  MOVLB  0
1E02E:  CALL   063E
....................    ACK_for_COM[0] = 0xAA; 
1E032:  MOVLW  AA
1E034:  MOVLB  1
1E036:  MOVWF  xE3
....................    ACK_for_COM[1] = 0x50; 
1E038:  MOVLW  50
1E03A:  MOVWF  xE4
....................    ACK_for_COM[2] = CW_FORMAT[0]; 
1E03C:  MOVFF  24B,1E5
....................    ACK_for_COM[3] = CW_FORMAT[1]; 
1E040:  MOVFF  24C,1E6
....................    ACK_for_COM[4] = CW_FORMAT[2]; 
1E044:  MOVFF  24D,1E7
....................    ACK_for_COM[5] = CW_FORMAT[3]; 
1E048:  MOVFF  24E,1E8
....................    ACK_for_COM[6] = CW_FORMAT[4]; 
1E04C:  MOVFF  24F,1E9
....................    ACK_for_COM[23] = 0xBB; 
1E050:  MOVLW  BB
1E052:  MOVWF  xFA
....................    for(int a = 0; a < 24; a++)                                                   //send the latest CW data to COM PIC 
1E054:  MOVLB  3
1E056:  CLRF   x4D
1E058:  MOVF   x4D,W
1E05A:  SUBLW  17
1E05C:  BNC   1E07E
....................    { 
....................       fputc(ACK_for_COM[a],COM); 
1E05E:  CLRF   03
1E060:  MOVF   x4D,W
1E062:  ADDLW  E3
1E064:  MOVWF  FE9
1E066:  MOVLW  01
1E068:  ADDWFC 03,W
1E06A:  MOVWF  FEA
1E06C:  MOVFF  FEF,34F
1E070:  MOVF   x4F,W
1E072:  MOVLB  0
1E074:  CALL   19D6
1E078:  MOVLB  3
1E07A:  INCF   x4D,F
1E07C:  BRA    1E058
....................    } 
....................    MBP_SYNC();                                                                   //Send time data to MBP for syncronization 
1E07E:  MOVLB  0
1E080:  CALL   12DE8
....................    fprintf(PC,"\r\nCW ANS:"); 
1E084:  MOVLW  88
1E086:  MOVWF  FF6
1E088:  MOVLW  0B
1E08A:  MOVWF  FF7
1E08C:  MOVLW  00
1E08E:  MOVWF  FF8
1E090:  CALL   06A4
....................    for(a = 0; a < 23; a++)                                                       //send the latest CW data to PC 
1E094:  MOVLB  3
1E096:  CLRF   x4D
1E098:  MOVF   x4D,W
1E09A:  SUBLW  16
1E09C:  BNC   1E0C8
....................    { 
....................       fprintf(PC,"%x,",ACK_for_COM[a]); 
1E09E:  CLRF   03
1E0A0:  MOVF   x4D,W
1E0A2:  ADDLW  E3
1E0A4:  MOVWF  FE9
1E0A6:  MOVLW  01
1E0A8:  ADDWFC 03,W
1E0AA:  MOVWF  FEA
1E0AC:  MOVFF  FEF,3A2
1E0B0:  MOVLW  57
1E0B2:  MOVWF  xA3
1E0B4:  MOVLB  0
1E0B6:  CALL   0700
1E0BA:  MOVLW  2C
1E0BC:  BTFSS  F9E.4
1E0BE:  BRA    1E0BC
1E0C0:  MOVWF  FAD
1E0C2:  MOVLB  3
1E0C4:  INCF   x4D,F
1E0C6:  BRA    1E098
....................    } 
....................    fprintf(PC,"%x\r\n",ACK_for_COM[23]); 
1E0C8:  MOVFF  1FA,3A2
1E0CC:  MOVLW  57
1E0CE:  MOVWF  xA3
1E0D0:  MOVLB  0
1E0D2:  CALL   0700
1E0D6:  MOVLW  0D
1E0D8:  BTFSS  F9E.4
1E0DA:  BRA    1E0D8
1E0DC:  MOVWF  FAD
1E0DE:  MOVLW  0A
1E0E0:  BTFSS  F9E.4
1E0E2:  BRA    1E0E0
1E0E4:  MOVWF  FAD
....................     
....................    for(int k = 14; k < 23; k++)                                                   //clear RSV part 
1E0E6:  MOVLW  0E
1E0E8:  MOVLB  3
1E0EA:  MOVWF  x4E
1E0EC:  MOVF   x4E,W
1E0EE:  SUBLW  16
1E0F0:  BNC   1E106
....................    { 
....................       ACK_for_COM[k] = 0x00; 
1E0F2:  CLRF   03
1E0F4:  MOVF   x4E,W
1E0F6:  ADDLW  E3
1E0F8:  MOVWF  FE9
1E0FA:  MOVLW  01
1E0FC:  ADDWFC 03,W
1E0FE:  MOVWF  FEA
1E100:  CLRF   FEF
1E102:  INCF   x4E,F
1E104:  BRA    1E0EC
....................    } 
....................    return; 
1E106:  MOVLB  0
1E108:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00011800 
.................... void Turn_On_ADCS() 
.................... { 
....................    output_high(PIN_D6);                                                          //ADCS switch ON, RD6=1 
*
1223A:  BCF    F95.6
1223C:  BSF    F8C.6
....................    return; 
1223E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Turn_Off_ADCS() 
.................... { 
....................    output_low(PIN_D6);                                                           //ADCS switch OFF, RD6=0 
*
1228C:  BCF    F95.6
1228E:  BCF    F8C.6
....................    return; 
12290:  RETURN 0
.................... } 
....................  
.................... /*void Send_Command_to_ADCS(int8 data)                                             //testing for EM integration 
.................... { 
....................    fputc(data,ADCS); 
....................    return; 
.................... }*/ 
....................  
.................... #ORG 0x00011800 
.................... void DELETE_ADCS_SENSOR() 
.................... { 
....................    for(int a = 0; a < ADCS_SENSOR_SIZE; a++) 
*
1220E:  MOVLB  3
12210:  CLRF   x84
12212:  MOVF   x84,W
12214:  SUBLW  4D
12216:  BNC   1222C
....................    { 
....................       ADCS_SENSOR_DATA[a] = 0; 
12218:  CLRF   03
1221A:  MOVF   x84,W
1221C:  ADDLW  FB
1221E:  MOVWF  FE9
12220:  MOVLW  01
12222:  ADDWFC 03,W
12224:  MOVWF  FEA
12226:  CLRF   FEF
12228:  INCF   x84,F
1222A:  BRA    12212
....................    } 
....................    return; 
1222C:  MOVLB  0
1222E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Delete_Buffer()                                                             //delete com command buffer 
*
121E8:  MOVLB  3
121EA:  CLRF   x84
.................... { 
....................    int num = 0; 
....................    for(num = 0;num < 16; num++) 
121EC:  CLRF   x84
121EE:  MOVF   x84,W
121F0:  SUBLW  0F
121F2:  BNC   12208
....................    { 
....................     in_bffr_main[num] = 0x00; 
121F4:  CLRF   03
121F6:  MOVF   x84,W
121F8:  ADDLW  86
121FA:  MOVWF  FE9
121FC:  MOVLW  00
121FE:  ADDWFC 03,W
12200:  MOVWF  FEA
12202:  CLRF   FEF
12204:  INCF   x84,F
12206:  BRA    121EE
....................    } 
....................    COM_DATA = 0; 
12208:  MOVLB  0
1220A:  CLRF   x96
....................    return; 
1220C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ADCS_SETTINGS()                                                             //initiallize 
.................... { 
....................    output_high(PIN_C4);                                                          //flash COM side 
*
12230:  BCF    F94.4
12232:  BSF    F8B.4
....................    Delete_Buffer();                                                              //delete in_bffr_main[] (com command buffer) 
12234:  RCALL  121E8
....................    DELETE_ADCS_SENSOR();                                                         //delet ADCS_SENSOR_DATA[] array 
12236:  RCALL  1220E
....................    return; 
12238:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CHECK_ACK_FROM_ADCS_10k()                                                     //Wait ACK from DC for 10s 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
12240:  MOVLB  3
12242:  CLRF   x87
12244:  CLRF   x86
12246:  CLRF   x85
12248:  CLRF   x84
1224A:  MOVF   x87,F
1224C:  BNZ   12288
1224E:  MOVF   x86,W
12250:  SUBLW  0F
12252:  BNC   12288
12254:  BNZ   12264
12256:  MOVF   x85,W
12258:  SUBLW  42
1225A:  BNC   12288
1225C:  BNZ   12264
1225E:  MOVF   x84,W
12260:  SUBLW  3F
12262:  BNC   12288
....................    { 
....................       if(kbhit(ADCS))                                                              
12264:  BTFSC  F85.6
12266:  BRA    12276
....................       { 
....................          ADCS_ACK = fgetc(ADCS);                                                    //PC    
12268:  MOVLB  0
1226A:  CALL   14EC
1226E:  MOVFF  01,9B
....................          break; 
12272:  MOVLB  3
12274:  BRA    12288
....................       } 
12276:  MOVLW  01
12278:  ADDWF  x84,F
1227A:  BTFSC  FD8.0
1227C:  INCF   x85,F
1227E:  BTFSC  FD8.2
12280:  INCF   x86,F
12282:  BTFSC  FD8.2
12284:  INCF   x87,F
12286:  BRA    1224A
....................       //delay_ms(1); 
....................    } 
....................    return; 
12288:  MOVLB  0
1228A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ADCS_TLE_TRANSFER()                                                         //send TLE data to ADCS 
.................... { 
....................  
....................    fprintf(PC,"Turn On ADCS \r\n"); 
*
136BE:  MOVLW  92
136C0:  MOVWF  FF6
136C2:  MOVLW  0B
136C4:  MOVWF  FF7
136C6:  MOVLW  00
136C8:  MOVWF  FF8
136CA:  CALL   06A4
....................    Turn_On_ADCS();                                                               //Turn on ADCS 
136CE:  CALL   1223A
....................    /*delay_ms(8000);*/ 
....................    for(int c = 0; c < TLE_size; c++)                                           // Read TLE data from flash and put in TLE[] array 
136D2:  MOVLB  3
136D4:  CLRF   x37
136D6:  MOVF   x37,W
136D8:  SUBLW  4C
136DA:  BNC   1372E
....................       { 
....................          TLE[c]=READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+c); 
136DC:  CLRF   03
136DE:  MOVF   x37,W
136E0:  ADDLW  96
136E2:  MOVWF  01
136E4:  MOVLW  01
136E6:  ADDWFC 03,F
136E8:  MOVFF  01,339
136EC:  MOVFF  03,33A
136F0:  MOVF   x37,W
136F2:  ADDWF  54,W
136F4:  MOVWF  x3B
136F6:  MOVLW  00
136F8:  ADDWFC 55,W
136FA:  MOVWF  x3C
136FC:  MOVLW  00
136FE:  ADDWFC 56,W
13700:  MOVWF  x3D
13702:  MOVLW  00
13704:  ADDWFC 57,W
13706:  MOVWF  x3E
13708:  MOVWF  xAB
1370A:  MOVFF  33D,3AA
1370E:  MOVFF  33C,3A9
13712:  MOVFF  33B,3A8
13716:  MOVLB  0
13718:  CALL   11B04
1371C:  MOVFF  33A,FEA
13720:  MOVFF  339,FE9
13724:  MOVFF  01,FEF
13728:  MOVLB  3
1372A:  INCF   x37,F
1372C:  BRA    136D6
....................       } 
....................     
....................    fputc(0x21,ADCS);                                                             //ADCS hand shake 
1372E:  MOVLW  21
13730:  MOVWF  x84
13732:  MOVLB  0
13734:  CALL   14A6
....................  
....................    CHECK_ACK_FROM_ADCS_10k(); 
13738:  CALL   12240
....................    if(ADCS_ACK == 0x55)                                                            //Success ACK 
1373C:  MOVF   x9B,W
1373E:  SUBLW  55
13740:  BNZ   13790
....................    { 
....................       fprintf(PC,"Received ACK From ADCS\r\n"); 
13742:  MOVLW  A2
13744:  MOVWF  FF6
13746:  MOVLW  0B
13748:  MOVWF  FF7
1374A:  MOVLW  00
1374C:  MOVWF  FF8
1374E:  CALL   06A4
....................       //delay_ms(1000); 
....................       ADCS_ACK = 0;       
13752:  CLRF   x9B
....................       for(int t = 0; t < TLE_size; t++)                                           // Read TLE data from flash and put in TLE[] array 
13754:  MOVLB  3
13756:  CLRF   x38
13758:  MOVF   x38,W
1375A:  SUBLW  4C
1375C:  BNC   1377C
....................       { 
....................          fputc(TLE[t],ADCS); 
1375E:  CLRF   03
13760:  MOVF   x38,W
13762:  ADDLW  96
13764:  MOVWF  FE9
13766:  MOVLW  01
13768:  ADDWFC 03,W
1376A:  MOVWF  FEA
1376C:  MOVFF  FEF,384
13770:  MOVLB  0
13772:  CALL   14A6
13776:  MOVLB  3
13778:  INCF   x38,F
1377A:  BRA    13758
....................       } 
....................       fprintf(PC,"Sent TLE data to ADCS\r\n"); 
1377C:  MOVLW  BC
1377E:  MOVWF  FF6
13780:  MOVLW  0B
13782:  MOVWF  FF7
13784:  MOVLW  00
13786:  MOVWF  FF8
13788:  MOVLB  0
1378A:  CALL   06A4
....................    }else{ 
1378E:  BRA    137A2
....................       ADCS_ACK = 0; 
13790:  CLRF   x9B
....................       fprintf(PC,"FAILURED GETTING ACK From ADCS\r\n"); 
13792:  MOVLW  D4
13794:  MOVWF  FF6
13796:  MOVLW  0B
13798:  MOVWF  FF7
1379A:  MOVLW  00
1379C:  MOVWF  FF8
1379E:  CALL   06A4
....................    } 
....................    CMD_FROM_PC[0] = 0;                                                           //prepare to get MAIN command 
137A2:  CLRF   x7E
....................    PC_DATA = 0;                                                                  //prepare to get MAIN command 
137A4:  CLRF   x99
....................    return; 
137A6:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include "adcs_test.h" 
.................... #ifndef ADCS_TEST_H 
.................... #define ADCS_TEST_H 
....................  
.................... int32 beginning_of_operation = 0; 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00011800 
.................... void ADCS_TEST_OPERATION(unsigned int16 duration, int8 OPERATION_MODE)           //Integration Testing With ADCS 
*
12292:  MOVLB  3
12294:  CLRF   x83
.................... { 
....................    int8 count = 0; 
....................    LOOP_ADCS_SENSOR_ADDRESS(); 
12296:  MOVLB  0
12298:  GOTO   1320
....................    ADCS_SETTINGS(); 
1229C:  RCALL  12230
....................    beginning_of_operation = ADCS_SENSOR_ADDRESS; 
1229E:  MOVFF  53,304
122A2:  MOVFF  52,303
122A6:  MOVFF  51,302
122AA:  MOVFF  50,301
....................     
....................    /*   GET_INITIAL_TIME(); */ 
....................    fprintf(PC,"Turn On ADCS \r\n"); 
122AE:  MOVLW  F6
122B0:  MOVWF  FF6
122B2:  MOVLW  0B
122B4:  MOVWF  FF7
122B6:  MOVLW  00
122B8:  MOVWF  FF8
122BA:  CALL   06A4
....................    Turn_On_ADCS();                                                               //Turn on ADCS 
122BE:  RCALL  1223A
....................    /*delay_ms(8000);*/ 
....................     
....................    fputc(0x21,ADCS);                                                             //ADCS hand shake 
122C0:  MOVLW  21
122C2:  MOVLB  3
122C4:  MOVWF  x84
122C6:  MOVLB  0
122C8:  CALL   14A6
....................  
....................    CHECK_ACK_FROM_ADCS_10k(); 
122CC:  RCALL  12240
....................    if(ADCS_ACK == 0x55)                                                            //Success ACK 
122CE:  MOVF   x9B,W
122D0:  SUBLW  55
122D2:  BNZ   12300
....................    { 
....................       fprintf(PC,"Received ACK From ADCS\r\n"); 
122D4:  MOVLW  06
122D6:  MOVWF  FF6
122D8:  MOVLW  0C
122DA:  MOVWF  FF7
122DC:  MOVLW  00
122DE:  MOVWF  FF8
122E0:  CALL   06A4
....................       //delay_ms(1000); 
....................       ADCS_ACK = 0; 
122E4:  CLRF   x9B
....................       fputc(OPERATION_MODE,adcs);                                                   //for execute stabilize mission 
122E6:  MOVFF  382,384
122EA:  CALL   14A6
....................       fprintf(PC,"Sent OPERATION MODE to ADCS\r\n"); 
122EE:  MOVLW  20
122F0:  MOVWF  FF6
122F2:  MOVLW  0C
122F4:  MOVWF  FF7
122F6:  MOVLW  00
122F8:  MOVWF  FF8
122FA:  CALL   06A4
....................    }else{ 
122FE:  BRA    12312
....................       ADCS_ACK = 0; 
12300:  CLRF   x9B
....................       fprintf(PC,"FAILURED GETTING ACK From ADCS\r\n"); 
12302:  MOVLW  3E
12304:  MOVWF  FF6
12306:  MOVLW  0C
12308:  MOVWF  FF7
1230A:  MOVLW  00
1230C:  MOVWF  FF8
1230E:  CALL   06A4
....................    } 
....................     
....................  
....................  
....................    CMD_FROM_PC[0] = 0;                                                           //prepare to get MAIN command 
12312:  CLRF   x7E
....................    PC_DATA = 0;                                                                  //prepare to get MAIN command 
12314:  CLRF   x99
....................    currenttime = 0;                                                              //prepare to measure the operation time 
12316:  MOVLB  2
12318:  CLRF   x4A
1231A:  CLRF   x49
....................    while(true) 
....................    { 
....................       /*  for(int safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       if(currenttime > duration)                                                 //600-->600 seconds (10min) 
1231C:  MOVLB  3
1231E:  MOVF   x81,W
12320:  MOVLB  2
12322:  SUBWF  x4A,W
12324:  BNC   1234E
12326:  BNZ   12338
12328:  MOVF   x49,W
1232A:  MOVLB  3
1232C:  SUBWF  x80,W
1232E:  BTFSS  FD8.0
12330:  BRA    12336
12332:  MOVLB  2
12334:  BRA    1234E
12336:  MOVLB  2
....................       { 
....................          fprintf(PC,"done\r\n"); 
12338:  MOVLW  60
1233A:  MOVWF  FF6
1233C:  MOVLW  0C
1233E:  MOVWF  FF7
12340:  MOVLW  00
12342:  MOVWF  FF8
12344:  MOVLB  0
12346:  CALL   06A4
....................          break; 
1234A:  BRA    123A8
1234C:  MOVLB  2
....................       } 
....................        /*  for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       if((currenttime%90)==0) 
1234E:  MOVFF  24A,385
12352:  MOVFF  249,384
12356:  MOVLB  3
12358:  CLRF   x87
1235A:  MOVLW  5A
1235C:  MOVWF  x86
1235E:  MOVLB  0
12360:  CALL   1536
12364:  MOVFF  00,384
12368:  MOVLB  3
1236A:  MOVFF  03,385
1236E:  MOVF   x84,F
12370:  BNZ   1237E
12372:  MOVF   x85,F
12374:  BNZ   1237E
....................       { 
....................          COLLECT_RESET_DATA(); 
12376:  MOVLB  0
12378:  CALL   16860
1237C:  MOVLB  3
....................       } 
....................        
....................       /* for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................        
....................       if(CMD_FROM_PC[0] == 0xab) 
1237E:  MOVLB  0
12380:  MOVF   x7E,W
12382:  SUBLW  AB
12384:  BNZ   1239E
....................       { 
....................          CMD_FROM_PC[0] = 0; 
12386:  CLRF   x7E
....................          PC_DATA = 0; 
12388:  CLRF   x99
....................          Turn_off_ADCS(); 
1238A:  RCALL  1228C
....................          fprintf(PC,"Stop ADCS Mission\r\n"); 
1238C:  MOVLW  68
1238E:  MOVWF  FF6
12390:  MOVLW  0C
12392:  MOVWF  FF7
12394:  MOVLW  00
12396:  MOVWF  FF8
12398:  CALL   06A4
....................          break; 
1239C:  BRA    123A8
....................       } 
....................       /* for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       RESET_SATELLITE();                                                         //if reset pic send command for resetting the satellite, OBC will response soon 
1239E:  CALL   16CB0
123A2:  MOVLB  2
123A4:  BRA    1231C
123A6:  MOVLB  0
....................    }   
....................    Turn_OFF_ADCS();                                                              //turn off ADCS OCP 
123A8:  RCALL  1228C
....................    fprintf(PC,"\r\n\r\nTurned_OFF_ADCS\r\n\r\n\r\n");                                                        
123AA:  MOVLW  7C
123AC:  MOVWF  FF6
123AE:  MOVLW  0C
123B0:  MOVWF  FF7
123B2:  MOVLW  00
123B4:  MOVWF  FF8
123B6:  CALL   06A4
....................    fprintf(PC,"%lx",beginning_of_operation); 
123BA:  MOVFF  304,3A2
123BE:  MOVLW  57
123C0:  MOVLB  3
123C2:  MOVWF  xA3
123C4:  MOVLB  0
123C6:  CALL   0700
123CA:  MOVFF  303,3A2
123CE:  MOVLW  57
123D0:  MOVLB  3
123D2:  MOVWF  xA3
123D4:  MOVLB  0
123D6:  CALL   0700
123DA:  MOVFF  302,3A2
123DE:  MOVLW  57
123E0:  MOVLB  3
123E2:  MOVWF  xA3
123E4:  MOVLB  0
123E6:  CALL   0700
123EA:  MOVFF  301,3A2
123EE:  MOVLW  57
123F0:  MOVLB  3
123F2:  MOVWF  xA3
123F4:  MOVLB  0
123F6:  CALL   0700
....................    delay_ms(1000); 
123FA:  MOVLW  04
123FC:  MOVLB  3
123FE:  MOVWF  x84
12400:  MOVLW  FA
12402:  MOVWF  x98
12404:  MOVLB  0
12406:  CALL   063E
1240A:  MOVLB  3
1240C:  DECFSZ x84,F
1240E:  BRA    12400
....................    Turn_On_ADCS(); 
12410:  MOVLB  0
12412:  RCALL  1223A
....................    fprintf(PC,"\r\n\r\nTurned_ON_ADCS\r\n\r\n\r\n"); 
12414:  MOVLW  96
12416:  MOVWF  FF6
12418:  MOVLW  0C
1241A:  MOVWF  FF7
1241C:  MOVLW  00
1241E:  MOVWF  FF8
12420:  CALL   06A4
....................    //ADCS debe estar siempre encendido 
....................    /*  SAVE_ADCS_INITIAL_and_FINAL(beginning_of_operation); 
....................    output_low(PIN_C4); 
....................    for(int32 num = 0; num < 81+90; num++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(beginning_of_operation + num)); 
....................    } 
....................    //TRANSFER_DATA_NBYTE_TOPC_SCF(ADCS_SENSOR_ADDRESS-ATTEMPT_TIME*100, ATTEMPT_TIME*100); 
....................    output_high(PIN_C4);*/ 
....................    RESET_SATELLITE();                                                            //if reset pic send command for resetting the satellite, OBC will response soon 
12424:  CALL   16CB0
....................    if(count > 89) 
12428:  MOVLB  3
1242A:  MOVF   x83,W
1242C:  SUBLW  59
1242E:  BC    1243C
....................    { 
....................       count = 0; 
12430:  CLRF   x83
....................       COLLECT_RESET_DATA(); 
12432:  MOVLB  0
12434:  CALL   16860
....................    }else{ 
12438:  BRA    12440
1243A:  MOVLB  3
....................       count++; 
1243C:  INCF   x83,F
1243E:  MOVLB  0
....................    }  
....................    return; 
12440:  RETURN 0
.................... } 
....................  
.................... void DISPLAY_ADCS_SENSOR_TO_PC()//for testing 
.................... { 
....................    for(int b = 0; b < ADCS_SENSOR_SIZE; b++)//for checking 
....................    { 
....................       fputc(ADCS_SENSOR_DATA[b],PC); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void CHECK_50_and_CW_RESPOND()                                                   //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
.................... { 
....................    if(in_bffr_main[4] == 0x50) 
*
01A72:  MOVF   x8A,W
01A74:  SUBLW  50
01A76:  BNZ   1A82
....................    { 
....................       CW_RESPOND();                                                              //carga el array ACK_for_COM[] con el dato del array CW_FORMAT[] y envia a COM PIC 
01A78:  CALL   1E024
....................       Delete_Buffer();                                                           //delete in_bffr_main[] (com command buffer) 
01A7C:  CALL   121E8
....................       COM_DATA = 0;                                                              //flag to cero 
01A80:  CLRF   x96
....................    } 
....................    return; 
01A82:  RETURN 0
.................... } 
....................  
.................... void Get_ADCS_MISSION_Data() 
.................... { 
....................     
....................    Delete_ADCS_SENSOR(); //initialize 
....................    CHECK_50_and_CW_RESPOND(); 
....................    fputc(0x55,ADCS); 
....................    fputc(0x55,PC); 
....................    int i = 0; 
....................    for(int32 num = 0; num < 1000000 ;num++) 
....................    { 
....................       if(kbhit(ADCS) && fgetc(ADCS) == 0x67) 
....................       { 
....................          for(num = 0; num < 10000; num++) 
....................          { 
....................             if(Kbhit(ADCS)) 
....................             { 
....................                ADCS_SENSOR_DATA[i] = fgetc(ADCS); 
....................                i++; 
....................                if(i == 60) 
....................                { 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................          ADCS_ACK = 0x67; 
....................          break; 
....................       } 
....................    } 
....................    if(num == 1000000) 
....................    { 
....................       fprintf(PC,"NO DATA\r\n"); 
....................    } 
....................    CHECK_50_and_CW_RESPOND(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 compare_before_after(int32 beginning, int32 end) 
.................... { 
....................    int8 data[12] = {}; 
*
11D0C:  MOVLB  3
11D0E:  CLRF   x85
11D10:  CLRF   x86
11D12:  CLRF   x87
11D14:  CLRF   x88
11D16:  CLRF   x89
11D18:  CLRF   x8A
11D1A:  CLRF   x8B
11D1C:  CLRF   x8C
11D1E:  CLRF   x8D
11D20:  CLRF   x8E
11D22:  CLRF   x8F
11D24:  CLRF   x90
....................    for(int i = 0; i < 6; i++) 
11D26:  CLRF   x91
11D28:  MOVF   x91,W
11D2A:  SUBLW  05
11D2C:  BNC   11D98
....................    { 
....................       data[i] = READ_DATA_BYTE_OF(beginning+222+10+i); 
11D2E:  CLRF   03
11D30:  MOVF   x91,W
11D32:  ADDLW  85
11D34:  MOVWF  01
11D36:  MOVLW  03
11D38:  ADDWFC 03,F
11D3A:  MOVFF  01,3A2
11D3E:  MOVFF  03,3A3
11D42:  MOVLW  DE
11D44:  ADDWF  x7D,W
11D46:  MOVWF  xA4
11D48:  MOVLW  00
11D4A:  ADDWFC x7E,W
11D4C:  MOVWF  xA5
11D4E:  MOVLW  00
11D50:  ADDWFC x7F,W
11D52:  MOVWF  xA6
11D54:  MOVLW  00
11D56:  ADDWFC x80,W
11D58:  MOVWF  xA7
11D5A:  MOVLW  0A
11D5C:  ADDWF  xA4,F
11D5E:  MOVLW  00
11D60:  ADDWFC xA5,F
11D62:  ADDWFC xA6,F
11D64:  ADDWFC xA7,F
11D66:  MOVF   x91,W
11D68:  ADDWF  xA4,F
11D6A:  MOVLW  00
11D6C:  ADDWFC xA5,F
11D6E:  ADDWFC xA6,F
11D70:  ADDWFC xA7,F
11D72:  MOVFF  3A7,3AB
11D76:  MOVFF  3A6,3AA
11D7A:  MOVFF  3A5,3A9
11D7E:  MOVFF  3A4,3A8
11D82:  MOVLB  0
11D84:  RCALL  11B04
11D86:  MOVFF  3A3,FEA
11D8A:  MOVFF  3A2,FE9
11D8E:  MOVFF  01,FEF
11D92:  MOVLB  3
11D94:  INCF   x91,F
11D96:  BRA    11D28
....................    } 
....................    for(i = 0; i < 6; i++) 
11D98:  CLRF   x91
11D9A:  MOVF   x91,W
11D9C:  SUBLW  05
11D9E:  BNC   11E00
....................    { 
....................       data[i+6] = READ_DATA_BYTE_OF(end-101+i); 
11DA0:  MOVLW  06
11DA2:  ADDWF  x91,W
11DA4:  CLRF   03
11DA6:  ADDLW  85
11DA8:  MOVWF  01
11DAA:  MOVLW  03
11DAC:  ADDWFC 03,F
11DAE:  MOVFF  01,3A2
11DB2:  MOVFF  03,3A3
11DB6:  MOVLW  65
11DB8:  SUBWF  x81,W
11DBA:  MOVWF  xA4
11DBC:  MOVLW  00
11DBE:  SUBWFB x82,W
11DC0:  MOVWF  xA5
11DC2:  MOVLW  00
11DC4:  SUBWFB x83,W
11DC6:  MOVWF  xA6
11DC8:  MOVLW  00
11DCA:  SUBWFB x84,W
11DCC:  MOVWF  xA7
11DCE:  MOVF   x91,W
11DD0:  ADDWF  xA4,F
11DD2:  MOVLW  00
11DD4:  ADDWFC xA5,F
11DD6:  ADDWFC xA6,F
11DD8:  ADDWFC xA7,F
11DDA:  MOVFF  3A7,3AB
11DDE:  MOVFF  3A6,3AA
11DE2:  MOVFF  3A5,3A9
11DE6:  MOVFF  3A4,3A8
11DEA:  MOVLB  0
11DEC:  RCALL  11B04
11DEE:  MOVFF  3A3,FEA
11DF2:  MOVFF  3A2,FE9
11DF6:  MOVFF  01,FEF
11DFA:  MOVLB  3
11DFC:  INCF   x91,F
11DFE:  BRA    11D9A
....................    } 
....................    signed int16 Bx = make16(data[0],data[1]); 
....................    signed int16 By = make16(data[2],data[3]); 
....................    signed int16 Bz = make16(data[4],data[5]); 
....................     
....................    signed int16 Ax = make16(data[6],data[7]); 
....................    signed int16 Ay = make16(data[8],data[9]); 
....................    signed int16 Az = make16(data[10],data[11]); 
....................     
....................    signed int16 Total_B = Bx + By + Bz; 
....................    signed int16 Total_A = Ax + Ay + Az; 
11E00:  MOVFF  385,393
11E04:  MOVFF  386,392
11E08:  MOVFF  387,395
11E0C:  MOVFF  388,394
11E10:  MOVFF  389,397
11E14:  MOVFF  38A,396
11E18:  MOVFF  38B,399
11E1C:  MOVFF  38C,398
11E20:  MOVFF  38D,39B
11E24:  MOVFF  38E,39A
11E28:  MOVFF  38F,39D
11E2C:  MOVFF  390,39C
11E30:  MOVF   x94,W
11E32:  ADDWF  x92,W
11E34:  MOVWF  xA2
11E36:  MOVF   x95,W
11E38:  ADDWFC x93,W
11E3A:  MOVWF  xA3
11E3C:  MOVF   x96,W
11E3E:  ADDWF  xA2,W
11E40:  MOVWF  x9E
11E42:  MOVF   x97,W
11E44:  ADDWFC xA3,W
11E46:  MOVWF  x9F
11E48:  MOVF   x9A,W
11E4A:  ADDWF  x98,W
11E4C:  MOVWF  xA2
11E4E:  MOVF   x9B,W
11E50:  ADDWFC x99,W
11E52:  MOVWF  xA3
11E54:  MOVF   x9C,W
11E56:  ADDWF  xA2,W
11E58:  MOVWF  xA0
11E5A:  MOVF   x9D,W
11E5C:  ADDWFC xA3,W
11E5E:  MOVWF  xA1
....................    Total_B = abs(Total_B); 
11E60:  MOVFF  39F,03
11E64:  MOVF   x9E,W
11E66:  BTFSS  x9F.7
11E68:  BRA    11E7A
11E6A:  MOVLW  00
11E6C:  BSF    FD8.0
11E6E:  SUBFWB x9E,W
11E70:  MOVWF  00
11E72:  MOVLW  00
11E74:  SUBFWB x9F,W
11E76:  MOVWF  03
11E78:  MOVF   00,W
11E7A:  MOVWF  x9E
11E7C:  MOVFF  03,39F
....................    Total_A = abs(Total_A); 
11E80:  MOVFF  3A1,03
11E84:  MOVF   xA0,W
11E86:  BTFSS  xA1.7
11E88:  BRA    11E9A
11E8A:  MOVLW  00
11E8C:  BSF    FD8.0
11E8E:  SUBFWB xA0,W
11E90:  MOVWF  00
11E92:  MOVLW  00
11E94:  SUBFWB xA1,W
11E96:  MOVWF  03
11E98:  MOVF   00,W
11E9A:  MOVWF  xA0
11E9C:  MOVFF  03,3A1
....................    fprintf(PC,"%lx,%lx,%lx\r\n",Bx,By,Bz); 
11EA0:  MOVFF  393,3A2
11EA4:  MOVLW  57
11EA6:  MOVWF  xA3
11EA8:  MOVLB  0
11EAA:  CALL   0700
11EAE:  MOVFF  392,3A2
11EB2:  MOVLW  57
11EB4:  MOVLB  3
11EB6:  MOVWF  xA3
11EB8:  MOVLB  0
11EBA:  CALL   0700
11EBE:  MOVLW  2C
11EC0:  BTFSS  F9E.4
11EC2:  BRA    11EC0
11EC4:  MOVWF  FAD
11EC6:  MOVFF  395,3A2
11ECA:  MOVLW  57
11ECC:  MOVLB  3
11ECE:  MOVWF  xA3
11ED0:  MOVLB  0
11ED2:  CALL   0700
11ED6:  MOVFF  394,3A2
11EDA:  MOVLW  57
11EDC:  MOVLB  3
11EDE:  MOVWF  xA3
11EE0:  MOVLB  0
11EE2:  CALL   0700
11EE6:  MOVLW  2C
11EE8:  BTFSS  F9E.4
11EEA:  BRA    11EE8
11EEC:  MOVWF  FAD
11EEE:  MOVFF  397,3A2
11EF2:  MOVLW  57
11EF4:  MOVLB  3
11EF6:  MOVWF  xA3
11EF8:  MOVLB  0
11EFA:  CALL   0700
11EFE:  MOVFF  396,3A2
11F02:  MOVLW  57
11F04:  MOVLB  3
11F06:  MOVWF  xA3
11F08:  MOVLB  0
11F0A:  CALL   0700
11F0E:  MOVLW  0D
11F10:  BTFSS  F9E.4
11F12:  BRA    11F10
11F14:  MOVWF  FAD
11F16:  MOVLW  0A
11F18:  BTFSS  F9E.4
11F1A:  BRA    11F18
11F1C:  MOVWF  FAD
....................    fprintf(PC,"%lx,%lx,%lx\r\n",Ax,Ay,Az); 
11F1E:  MOVFF  399,3A2
11F22:  MOVLW  57
11F24:  MOVLB  3
11F26:  MOVWF  xA3
11F28:  MOVLB  0
11F2A:  CALL   0700
11F2E:  MOVFF  398,3A2
11F32:  MOVLW  57
11F34:  MOVLB  3
11F36:  MOVWF  xA3
11F38:  MOVLB  0
11F3A:  CALL   0700
11F3E:  MOVLW  2C
11F40:  BTFSS  F9E.4
11F42:  BRA    11F40
11F44:  MOVWF  FAD
11F46:  MOVFF  39B,3A2
11F4A:  MOVLW  57
11F4C:  MOVLB  3
11F4E:  MOVWF  xA3
11F50:  MOVLB  0
11F52:  CALL   0700
11F56:  MOVFF  39A,3A2
11F5A:  MOVLW  57
11F5C:  MOVLB  3
11F5E:  MOVWF  xA3
11F60:  MOVLB  0
11F62:  CALL   0700
11F66:  MOVLW  2C
11F68:  BTFSS  F9E.4
11F6A:  BRA    11F68
11F6C:  MOVWF  FAD
11F6E:  MOVFF  39D,3A2
11F72:  MOVLW  57
11F74:  MOVLB  3
11F76:  MOVWF  xA3
11F78:  MOVLB  0
11F7A:  CALL   0700
11F7E:  MOVFF  39C,3A2
11F82:  MOVLW  57
11F84:  MOVLB  3
11F86:  MOVWF  xA3
11F88:  MOVLB  0
11F8A:  CALL   0700
11F8E:  MOVLW  0D
11F90:  BTFSS  F9E.4
11F92:  BRA    11F90
11F94:  MOVWF  FAD
11F96:  MOVLW  0A
11F98:  BTFSS  F9E.4
11F9A:  BRA    11F98
11F9C:  MOVWF  FAD
....................    fprintf(PC,"%lud,%lud\r\n",Total_B,Total_A); 
11F9E:  MOVLW  10
11FA0:  MOVWF  FE9
11FA2:  MOVFF  39F,3A3
11FA6:  MOVFF  39E,3A2
11FAA:  CALL   0CBA
11FAE:  MOVLW  64
11FB0:  BTFSS  F9E.4
11FB2:  BRA    11FB0
11FB4:  MOVWF  FAD
11FB6:  MOVLW  2C
11FB8:  BTFSS  F9E.4
11FBA:  BRA    11FB8
11FBC:  MOVWF  FAD
11FBE:  MOVLW  10
11FC0:  MOVWF  FE9
11FC2:  MOVFF  3A1,3A3
11FC6:  MOVFF  3A0,3A2
11FCA:  CALL   0CBA
11FCE:  MOVLW  76
11FD0:  MOVWF  FF6
11FD2:  MOVLW  0D
11FD4:  MOVWF  FF7
11FD6:  MOVLW  00
11FD8:  MOVWF  FF8
11FDA:  MOVLW  03
11FDC:  MOVLB  3
11FDE:  MOVWF  xA2
11FE0:  MOVLB  0
11FE2:  CALL   06CE
....................    if(Total_B >= Total_A) 
11FE6:  MOVLB  3
11FE8:  BTFSS  xA1.7
11FEA:  BRA    11FF2
11FEC:  BTFSS  x9F.7
11FEE:  BRA    12004
11FF0:  BRA    11FF6
11FF2:  BTFSC  x9F.7
11FF4:  BRA    1200C
11FF6:  MOVF   xA1,W
11FF8:  SUBWF  x9F,W
11FFA:  BNC   1200C
11FFC:  BNZ   12004
11FFE:  MOVF   xA0,W
12000:  SUBWF  x9E,W
12002:  BNC   1200C
....................    { 
....................       return 1;//declease --> continue 
12004:  MOVLW  01
12006:  MOVWF  01
12008:  BRA    12010
....................    }else{ 
1200A:  BRA    12010
....................       return 0;//inclease --> stop 
1200C:  MOVLW  00
1200E:  MOVWF  01
....................    } 
12010:  MOVLB  0
12012:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00019000 
.................... void GIVE_ACCESS_SCF_Nsec(int8 min) 
.................... { 
....................    fprintf(PC,"giving access to COM for %d min\r\n", min); 
*
1B4E4:  MOVLW  7A
1B4E6:  MOVWF  FF6
1B4E8:  MOVLW  0D
1B4EA:  MOVWF  FF7
1B4EC:  MOVLW  00
1B4EE:  MOVWF  FF8
1B4F0:  MOVLW  19
1B4F2:  MOVLB  3
1B4F4:  MOVWF  xA2
1B4F6:  MOVLB  0
1B4F8:  CALL   06CE
1B4FC:  MOVFF  337,33E
1B500:  MOVLW  18
1B502:  MOVLB  3
1B504:  MOVWF  x3F
1B506:  MOVLB  0
1B508:  CALL   2404
1B50C:  MOVLW  95
1B50E:  MOVWF  FF6
1B510:  MOVLW  0D
1B512:  MOVWF  FF7
1B514:  MOVLW  00
1B516:  MOVWF  FF8
1B518:  MOVLW  06
1B51A:  MOVLB  3
1B51C:  MOVWF  xA2
1B51E:  MOVLB  0
1B520:  CALL   06CE
....................    fputc(0x35,COM); 
1B524:  MOVLW  35
1B526:  CALL   19D6
....................    output_high(PIN_C4); 
1B52A:  BCF    F94.4
1B52C:  BSF    F8B.4
....................    if(min > 5)                                                                   //for accidentaly send the long time delay, maximum should be 5 min 
1B52E:  MOVLB  3
1B530:  MOVF   x37,W
1B532:  SUBLW  05
1B534:  BC    1B53A
....................    { 
....................       min = 5; 
1B536:  MOVLW  05
1B538:  MOVWF  x37
....................    } 
....................    for(int16 i = 0; i < min * 60; i++) 
1B53A:  CLRF   x39
1B53C:  CLRF   x38
1B53E:  MOVF   x37,W
1B540:  MULLW  3C
1B542:  MOVF   FF3,W
1B544:  MOVF   x39,F
1B546:  BNZ   1B584
1B548:  SUBWF  x38,W
1B54A:  BC    1B584
....................    { 
....................       delay_ms(1000);                                                            //wait 1 sec 
1B54C:  MOVLW  04
1B54E:  MOVWF  x3A
1B550:  MOVLW  FA
1B552:  MOVWF  x98
1B554:  MOVLB  0
1B556:  CALL   063E
1B55A:  MOVLB  3
1B55C:  DECFSZ x3A,F
1B55E:  BRA    1B550
....................       if(in_bffr_main[4] == 0xab || CMD_FROM_PC[0] == 0xab) 
1B560:  MOVLB  0
1B562:  MOVF   x8A,W
1B564:  SUBLW  AB
1B566:  BZ    1B56E
1B568:  MOVF   x7E,W
1B56A:  SUBLW  AB
1B56C:  BNZ   1B57A
....................       { 
....................          CMD_FROM_PC[0] = 0; 
1B56E:  CLRF   x7E
....................          CMD_FROM_PC[1] = 0; 
1B570:  CLRF   x7F
....................          PC_DATA = 0; 
1B572:  CLRF   x99
....................          break; 
1B574:  MOVLB  3
1B576:  BRA    1B584
1B578:  MOVLB  0
....................       } 
1B57A:  MOVLB  3
1B57C:  INCF   x38,F
1B57E:  BTFSC  FD8.2
1B580:  INCF   x39,F
1B582:  BRA    1B53E
....................    } 
....................    fprintf(PC,"\r\nBack to Nomal Operation\r\n"); 
1B584:  MOVLW  9C
1B586:  MOVWF  FF6
1B588:  MOVLW  0D
1B58A:  MOVWF  FF7
1B58C:  MOVLW  00
1B58E:  MOVWF  FF8
1B590:  MOVLB  0
1B592:  CALL   06A4
....................    return; 
1B596:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void DELETE_CMD_FROM_PC() 
.................... { 
....................    for(int num = 0; num < 8; num++) 
*
1B0BA:  MOVLB  3
1B0BC:  CLRF   x2C
1B0BE:  MOVF   x2C,W
1B0C0:  SUBLW  07
1B0C2:  BNC   1B0D8
....................    { 
....................       CMD_FROM_PC[num] = 0; 
1B0C4:  CLRF   03
1B0C6:  MOVF   x2C,W
1B0C8:  ADDLW  7E
1B0CA:  MOVWF  FE9
1B0CC:  MOVLW  00
1B0CE:  ADDWFC 03,W
1B0D0:  MOVWF  FEA
1B0D2:  CLRF   FEF
1B0D4:  INCF   x2C,F
1B0D6:  BRA    1B0BE
....................    } 
....................    return; 
1B0D8:  MOVLB  0
1B0DA:  RETURN 0
.................... } 
....................  
....................  
.................... //--------BC Function---------------------------------------------------------- 
....................  
.................... //unsigned int8 BC_temp_data[2] = {}; 
.................... unsigned int16 BC_temp_data_h = 0; 
.................... unsigned int16 BC_temp_data_l = 0; 
.................... unsigned int16 BC_TEMP = 0; 
.................... float  temp = 0; 
.................... float initial_temp = 0; 
.................... float MAXTEMP = 0; 
.................... int16 UNLEG2 = 0; 
....................  
.................... #ORG 0x00019000 
.................... void BC_SETUP()                                                                  //Analog read configuration (AN9) 
.................... { 
....................    ANCON2= 0x01;                                                                 // PIN RC2 Analog enable 
*
190A0:  MOVLW  01
190A2:  MOVLB  E
190A4:  MOVWF  x46
....................    ADCON1L = 0x00;                                                               // SAMP bit must be cleared by software to start conversion (ends sampling and starts converting) 
190A6:  CLRF   FC0
....................    ADCHS0L = 0x09;                                                               // Connect AN9 as S/H+ input 
190A8:  MOVLW  09
190AA:  MOVWF  x86
....................                                                                                  // AN9 is the input 
....................    ADCON2H = 0x00;                                                               //A/D control register 2H 
190AC:  CLRF   x8D
....................    ADRC = 1;                                                                     //RC Clock source 
190AE:  BSF    x8B.7
....................    ADCSS0L = 0;                                                                  //Sample select register 
190B0:  CLRF   x82
....................    ADCON3L = 0x02;                                                               // Conversion clock select bits, Tad = 3.2/Fosc    
190B2:  MOVLW  02
190B4:  MOVWF  x8A
....................    ADCON2L = 0;                                                                  //A/D control register 2L 
190B6:  CLRF   x8C
....................    return; 
190B8:  MOVLB  0
190BA:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void BC_READ_TO_PC() 
.................... { 
....................    ADON = 1; 
....................    SAMP = 1; 
....................    delay_ms(100); 
....................     
....................    SAMP = 0; // start converting 
....................    while (!DONE){}; 
....................    delay_ms(100); 
....................    //BC_temp_data[0] = ADCBUF0H;//read_adc(); 
....................    //BC_temp_data[1] = ADCBUF0L; 
....................     
....................    BC_temp_data_h = ADCBUF0H; 
....................    BC_temp_data_l = ADCBUF0L; 
....................    //temp = ((data_h << 8 ) | data_l); 
....................    fprintf(PC,"data_l:%x \r\n", BC_temp_data_l); 
....................    fprintf(PC,"data_h:%x \r\n", BC_temp_data_h); 
....................    BC_TEMP = BC_temp_data_h | BC_temp_data_l; 
....................    //fprintf(PC,"temp:%f\r\n",temp); 
....................    temp = BC_TEMP/1024*3.31*100-50;    //VDD: 3.31V(MEASURED) 
....................    //fprintf(PC,"%1.1f \r\n", temp); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_BC_TEMP()                                                             //lee la temperatura del BC y lo guarda en MAXTEMP 
.................... { 
....................    BC_SETUP();                                                                   //Analog read configuration (AN9) 
*
19FC2:  CALL   190A0
....................    ADON = 1; 
19FC6:  BSF    FC1.7
....................    SAMP = 1; 
19FC8:  BSF    FC0.1
....................    delay_ms(10); 
19FCA:  MOVLW  0A
19FCC:  MOVLB  3
19FCE:  MOVWF  x98
19FD0:  MOVLB  0
19FD2:  CALL   063E
....................     
....................    SAMP = 0;                                                                     // start converting 
19FD6:  BCF    FC0.1
....................    while (!DONE){}; 
19FD8:  BTFSS  FC0.0
19FDA:  BRA    19FD8
....................    delay_ms(10); 
19FDC:  MOVLW  0A
19FDE:  MOVLB  3
19FE0:  MOVWF  x98
19FE2:  MOVLB  0
19FE4:  CALL   063E
....................    BC_temp_data_h = ADCBUF0H;                                                    //read_adc(); 
19FE8:  MOVLB  3
19FEA:  CLRF   x06
19FEC:  MOVFF  FC3,305
....................    BC_temp_data_l = ADCBUF0L; 
19FF0:  CLRF   x08
19FF2:  MOVFF  FC2,307
....................    //fprintf(PC,"%x%x\r\n",ADCBUF0H,BC_temp_data_l); 
....................    BC_temp = BC_temp_data_h<<8 | BC_temp_data_l;                                 //convierte en un int16 
19FF6:  CLRF   x41
19FF8:  MOVF   x41,W
19FFA:  IORWF  x07,W
19FFC:  MOVWF  x09
19FFE:  MOVF   x05,W
1A000:  IORWF  x08,W
1A002:  MOVWF  x0A
....................    //fprintf(PC,"HEX : %x%x\r\n",BC_temp>>8,BC_temp); 
....................  
....................    temp = BC_temp;                                                               //convierte a float 
1A004:  MOVFF  30A,342
1A008:  MOVFF  309,341
1A00C:  MOVLB  0
1A00E:  GOTO   1F36
1A012:  MOVFF  03,30E
1A016:  MOVFF  02,30D
1A01A:  MOVFF  01,30C
1A01E:  MOVFF  00,30B
....................    //temp = temp/1024*3.25*100-50; 
....................    temp = (temp*3.3/1023); 
1A022:  MOVFF  30E,351
1A026:  MOVFF  30D,350
1A02A:  MOVFF  30C,34F
1A02E:  MOVFF  30B,34E
1A032:  MOVLW  33
1A034:  MOVLB  3
1A036:  MOVWF  x55
1A038:  MOVWF  x54
1A03A:  MOVLW  53
1A03C:  MOVWF  x53
1A03E:  MOVLW  80
1A040:  MOVWF  x52
1A042:  MOVLB  0
1A044:  CALL   1B58
1A048:  MOVFF  03,344
1A04C:  MOVFF  02,343
1A050:  MOVFF  01,342
1A054:  MOVFF  00,341
1A058:  MOVFF  03,348
1A05C:  MOVFF  02,347
1A060:  MOVFF  01,346
1A064:  MOVFF  00,345
1A068:  MOVLB  3
1A06A:  CLRF   x4C
1A06C:  MOVLW  C0
1A06E:  MOVWF  x4B
1A070:  MOVLW  7F
1A072:  MOVWF  x4A
1A074:  MOVLW  88
1A076:  MOVWF  x49
1A078:  MOVLB  0
1A07A:  GOTO   1F6E
1A07E:  MOVFF  03,30E
1A082:  MOVFF  02,30D
1A086:  MOVFF  01,30C
1A08A:  MOVFF  00,30B
....................    temp = temp*100-50; 
1A08E:  MOVFF  30E,351
1A092:  MOVFF  30D,350
1A096:  MOVFF  30C,34F
1A09A:  MOVFF  30B,34E
1A09E:  MOVLB  3
1A0A0:  CLRF   x55
1A0A2:  CLRF   x54
1A0A4:  MOVLW  48
1A0A6:  MOVWF  x53
1A0A8:  MOVLW  85
1A0AA:  MOVWF  x52
1A0AC:  MOVLB  0
1A0AE:  CALL   1B58
1A0B2:  MOVFF  03,344
1A0B6:  MOVFF  02,343
1A0BA:  MOVFF  01,342
1A0BE:  MOVFF  00,341
1A0C2:  BSF    FD8.1
1A0C4:  MOVFF  03,34D
1A0C8:  MOVFF  02,34C
1A0CC:  MOVFF  01,34B
1A0D0:  MOVFF  00,34A
1A0D4:  MOVLB  3
1A0D6:  CLRF   x51
1A0D8:  CLRF   x50
1A0DA:  MOVLW  48
1A0DC:  MOVWF  x4F
1A0DE:  MOVLW  84
1A0E0:  MOVWF  x4E
1A0E2:  MOVLB  0
1A0E4:  CALL   1C4E
1A0E8:  MOVFF  03,30E
1A0EC:  MOVFF  02,30D
1A0F0:  MOVFF  01,30C
1A0F4:  MOVFF  00,30B
....................    fprintf(PC,"Current Temp: %1.1f\r\n",temp); 
1A0F8:  MOVLW  B8
1A0FA:  MOVWF  FF6
1A0FC:  MOVLW  0D
1A0FE:  MOVWF  FF7
1A100:  MOVLW  00
1A102:  MOVWF  FF8
1A104:  MOVLW  0E
1A106:  MOVLB  3
1A108:  MOVWF  xA2
1A10A:  MOVLB  0
1A10C:  CALL   06CE
1A110:  MOVLW  89
1A112:  MOVWF  FE9
1A114:  MOVFF  30E,344
1A118:  MOVFF  30D,343
1A11C:  MOVFF  30C,342
1A120:  MOVFF  30B,341
1A124:  MOVLW  01
1A126:  MOVLB  3
1A128:  MOVWF  x45
1A12A:  MOVLB  0
1A12C:  CALL   21A6
1A130:  MOVLW  0D
1A132:  BTFSS  F9E.4
1A134:  BRA    1A132
1A136:  MOVWF  FAD
1A138:  MOVLW  0A
1A13A:  BTFSS  F9E.4
1A13C:  BRA    1A13A
1A13E:  MOVWF  FAD
....................     
....................    if(MAXTEMP < temp) 
1A140:  MOVFF  316,348
1A144:  MOVFF  315,347
1A148:  MOVFF  314,346
1A14C:  MOVFF  313,345
1A150:  MOVFF  30E,34C
1A154:  MOVFF  30D,34B
1A158:  MOVFF  30C,34A
1A15C:  MOVFF  30B,349
1A160:  CALL   2344
1A164:  BNC   1A176
....................    { 
....................       MAXTEMP = temp; 
1A166:  MOVFF  30E,316
1A16A:  MOVFF  30D,315
1A16E:  MOVFF  30C,314
1A172:  MOVFF  30B,313
....................    } 
....................    fprintf(PC,"%f\r\n",temp); 
1A176:  MOVLW  89
1A178:  MOVWF  FE9
1A17A:  MOVFF  30E,344
1A17E:  MOVFF  30D,343
1A182:  MOVFF  30C,342
1A186:  MOVFF  30B,341
1A18A:  MOVLW  02
1A18C:  MOVLB  3
1A18E:  MOVWF  x45
1A190:  MOVLB  0
1A192:  CALL   21A6
1A196:  MOVLW  0D
1A198:  BTFSS  F9E.4
1A19A:  BRA    1A198
1A19C:  MOVWF  FAD
1A19E:  MOVLW  0A
1A1A0:  BTFSS  F9E.4
1A1A2:  BRA    1A1A0
1A1A4:  MOVWF  FAD
....................    return; 
1A1A6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MEASURE_BC_TEMP() 
.................... { 
....................    BC_SETUP();                                                                   //configuracion para lectura analogica 
*
1910C:  RCALL  190A0
....................    ADON = 1; 
1910E:  BSF    FC1.7
....................    SAMP = 1; 
19110:  BSF    FC0.1
....................    delay_ms(1); 
19112:  MOVLW  01
19114:  MOVLB  3
19116:  MOVWF  x98
19118:  MOVLB  0
1911A:  CALL   063E
....................     
....................    SAMP = 0;                                                                     // start converting 
1911E:  BCF    FC0.1
....................    while (!DONE){}; 
19120:  BTFSS  FC0.0
19122:  BRA    19120
....................    delay_ms(1); 
19124:  MOVLW  01
19126:  MOVLB  3
19128:  MOVWF  x98
1912A:  MOVLB  0
1912C:  CALL   063E
....................    BC_temp_data_h = ADCBUF0H;                                                    //read_adc(); 
19130:  MOVLB  3
19132:  CLRF   x06
19134:  MOVFF  FC3,305
....................    BC_temp_data_l = ADCBUF0L; 
19138:  CLRF   x08
1913A:  MOVFF  FC2,307
....................  
....................    return; 
1913E:  MOVLB  0
19140:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_ON_BC() 
.................... { 
....................    output_high(PIN_D5);                                                          //BC switch ON, RD5=1 
*
1A1A8:  BCF    F95.5
1A1AA:  BSF    F8C.5
....................    return; 
1A1AC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_OFF_BC() 
.................... { 
....................    output_low(PIN_D5);                                                           //BC switch OFF, RD5=0 
*
190C2:  BCF    F95.5
190C4:  BCF    F8C.5
....................    return; 
190C6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void BC_OPERATION()                                                              //Turn ON BC and read temperature 
.................... { 
....................    CHECK_BC_TEMP();                                                              //read BC temperature and save It in float MAXTEMP 
*
1A1AE:  RCALL  19FC2
....................    initial_temp = MAXTEMP;                                                       //save temperature in initial_temp before turn_ON BC 
1A1B0:  MOVFF  316,312
1A1B4:  MOVFF  315,311
1A1B8:  MOVFF  314,310
1A1BC:  MOVFF  313,30F
....................    //fprintf(PC,"INITIAL TEMPERATURE is %1.1f\r\n\r\n",initial_temp); 
....................    Turn_ON_BC();                                                                 //BC switch ON, RD5=1 
1A1C0:  RCALL  1A1A8
....................    fprintf(PC,"Turned ON BC\r\n"); 
1A1C2:  MOVLW  CE
1A1C4:  MOVWF  FF6
1A1C6:  MOVLW  0D
1A1C8:  MOVWF  FF7
1A1CA:  MOVLW  00
1A1CC:  MOVWF  FF8
1A1CE:  CALL   06A4
....................    currenttime = 0; 
1A1D2:  MOVLB  2
1A1D4:  CLRF   x4A
1A1D6:  CLRF   x49
....................    int8 counter = 0;    
1A1D8:  MOVLB  3
1A1DA:  CLRF   x3F
....................    while(currenttime < 30)                                                       //turn ON BC for 30 sec 
1A1DC:  MOVLB  2
1A1DE:  MOVF   x4A,F
1A1E0:  BNZ   1A284
1A1E2:  MOVF   x49,W
1A1E4:  SUBLW  1D
1A1E6:  BNC   1A284
....................    { 
....................       for(int i = 0; i < 10; i++) 
1A1E8:  MOVLB  3
1A1EA:  CLRF   x40
1A1EC:  MOVF   x40,W
1A1EE:  SUBLW  09
1A1F0:  BNC   1A25C
....................       { 
....................          COLLECT_RESET_DATA();                                                   //envia comando al reset PIC pidiendo RESET DATA 
1A1F2:  MOVLB  0
1A1F4:  CALL   16860
....................          if(reset_bffr[0] == 0x8e) 
1A1F8:  MOVF   x9E,W
1A1FA:  SUBLW  8E
1A1FC:  BNZ   1A256
....................          { 
....................             for(i = 0; i < 10; i++);                                             //muestra el array recibido 
1A1FE:  MOVLB  3
1A200:  CLRF   x40
1A202:  MOVF   x40,W
1A204:  SUBLW  09
1A206:  BNC   1A20C
1A208:  INCF   x40,F
1A20A:  BRA    1A202
....................             { 
....................                fprintf(PC,"%x,",reset_bffr[i]); 
1A20C:  CLRF   03
1A20E:  MOVF   x40,W
1A210:  ADDLW  9E
1A212:  MOVWF  FE9
1A214:  MOVLW  00
1A216:  ADDWFC 03,W
1A218:  MOVWF  FEA
1A21A:  MOVFF  FEF,3A2
1A21E:  MOVLW  57
1A220:  MOVWF  xA3
1A222:  MOVLB  0
1A224:  CALL   0700
1A228:  MOVLW  2C
1A22A:  BTFSS  F9E.4
1A22C:  BRA    1A22A
1A22E:  MOVWF  FAD
....................             } 
....................             fprintf(PC,"%x\r\n",reset_bffr[10]); 
1A230:  MOVFF  A8,3A2
1A234:  MOVLW  57
1A236:  MOVLB  3
1A238:  MOVWF  xA3
1A23A:  MOVLB  0
1A23C:  CALL   0700
1A240:  MOVLW  0D
1A242:  BTFSS  F9E.4
1A244:  BRA    1A242
1A246:  MOVWF  FAD
1A248:  MOVLW  0A
1A24A:  BTFSS  F9E.4
1A24C:  BRA    1A24A
1A24E:  MOVWF  FAD
....................             break; 
1A250:  MOVLB  3
1A252:  BRA    1A25C
1A254:  MOVLB  0
....................          } 
1A256:  MOVLB  3
1A258:  INCF   x40,F
1A25A:  BRA    1A1EC
....................       } 
....................       CHECK_BC_TEMP();                                                           //read BC temperature and save It in float MAXTEMP 
1A25C:  MOVLB  0
1A25E:  RCALL  19FC2
....................       UNLEG2 = UNLEG2 + RESET_bffr[10];                                          //add the unleg2 current every second 
1A260:  MOVF   xA8,W
1A262:  MOVLB  3
1A264:  ADDWF  x17,F
1A266:  MOVLW  00
1A268:  ADDWFC x18,F
....................       counter++; 
1A26A:  INCF   x3F,F
....................       delay_ms(900); 
1A26C:  MOVLW  04
1A26E:  MOVWF  x41
1A270:  MOVLW  E1
1A272:  MOVWF  x98
1A274:  MOVLB  0
1A276:  CALL   063E
1A27A:  MOVLB  3
1A27C:  DECFSZ x41,F
1A27E:  BRA    1A270
1A280:  BRA    1A1DC
1A282:  MOVLB  2
....................    } 
....................        
....................    Turn_OFF_BC();                                                                //BC switch OFF, RD5=0 
1A284:  MOVLB  0
1A286:  CALL   190C2
....................    fprintf(PC,"Turned OFF BC\r\n"); 
1A28A:  MOVLW  DE
1A28C:  MOVWF  FF6
1A28E:  MOVLW  0D
1A290:  MOVWF  FF7
1A292:  MOVLW  00
1A294:  MOVWF  FF8
1A296:  CALL   06A4
....................    delay_ms(500); 
1A29A:  MOVLW  02
1A29C:  MOVLB  3
1A29E:  MOVWF  x41
1A2A0:  MOVLW  FA
1A2A2:  MOVWF  x98
1A2A4:  MOVLB  0
1A2A6:  CALL   063E
1A2AA:  MOVLB  3
1A2AC:  DECFSZ x41,F
1A2AE:  BRA    1A2A0
....................    CHECK_BC_TEMP();                                                              //lee la temperatura del BC y lo guarda en float MAXTEMP 
1A2B0:  MOVLB  0
1A2B2:  RCALL  19FC2
....................    if(MAXTEMP-initial_temp > 5)                                                  //pone en HIGH bandera si hubo incremento de temperatura 
1A2B4:  BSF    FD8.1
1A2B6:  MOVFF  316,34D
1A2BA:  MOVFF  315,34C
1A2BE:  MOVFF  314,34B
1A2C2:  MOVFF  313,34A
1A2C6:  MOVFF  312,351
1A2CA:  MOVFF  311,350
1A2CE:  MOVFF  310,34F
1A2D2:  MOVFF  30F,34E
1A2D6:  CALL   1C4E
1A2DA:  MOVFF  03,344
1A2DE:  MOVFF  02,343
1A2E2:  MOVFF  01,342
1A2E6:  MOVFF  00,341
1A2EA:  MOVLB  3
1A2EC:  CLRF   x48
1A2EE:  CLRF   x47
1A2F0:  MOVLW  20
1A2F2:  MOVWF  x46
1A2F4:  MOVLW  81
1A2F6:  MOVWF  x45
1A2F8:  MOVFF  03,34C
1A2FC:  MOVFF  02,34B
1A300:  MOVFF  01,34A
1A304:  MOVFF  00,349
1A308:  MOVLB  0
1A30A:  CALL   2344
1A30E:  BNC   1A314
....................    { 
....................       ANT_DEP_STATUS = 1; 
1A310:  MOVLW  01
1A312:  MOVWF  x7B
....................    } 
....................    fprintf(PC,"MAXIMUM TEMPERATURE is %1.1f\r\n\r\n",MAXTEMP); 
1A314:  MOVLW  EE
1A316:  MOVWF  FF6
1A318:  MOVLW  0D
1A31A:  MOVWF  FF7
1A31C:  MOVLW  00
1A31E:  MOVWF  FF8
1A320:  MOVLW  17
1A322:  MOVLB  3
1A324:  MOVWF  xA2
1A326:  MOVLB  0
1A328:  CALL   06CE
1A32C:  MOVLW  89
1A32E:  MOVWF  FE9
1A330:  MOVFF  316,344
1A334:  MOVFF  315,343
1A338:  MOVFF  314,342
1A33C:  MOVFF  313,341
1A340:  MOVLW  01
1A342:  MOVLB  3
1A344:  MOVWF  x45
1A346:  MOVLB  0
1A348:  CALL   21A6
1A34C:  MOVLW  0A
1A34E:  MOVWF  FF6
1A350:  MOVLW  0E
1A352:  MOVWF  FF7
1A354:  MOVLW  00
1A356:  MOVWF  FF8
1A358:  MOVLW  04
1A35A:  MOVLB  3
1A35C:  MOVWF  xA2
1A35E:  MOVLB  0
1A360:  CALL   06CE
....................    MAXTEMP = 0; 
1A364:  MOVLB  3
1A366:  CLRF   x16
1A368:  CLRF   x15
1A36A:  CLRF   x14
1A36C:  CLRF   x13
....................    initial_temp = 0; 
1A36E:  CLRF   x12
1A370:  CLRF   x11
1A372:  CLRF   x10
1A374:  CLRF   x0F
....................    return; 
1A376:  MOVLB  0
1A378:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00019000 
.................... void CLEAR_BC_FLAG() 
.................... { 
....................    BC_ATTEMPT_FLAG = 0; 
*
1B3D8:  CLRF   x68
....................    fprintf(PC,"\r\nBC Attempt Flag clear done\r\n"); 
1B3DA:  MOVLW  10
1B3DC:  MOVWF  FF6
1B3DE:  MOVLW  0E
1B3E0:  MOVWF  FF7
1B3E2:  MOVLW  00
1B3E4:  MOVWF  FF8
1B3E6:  CALL   06A4
....................    return; 
1B3EA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_1() 
.................... { 
....................    BC_ATTEMPT_FLAG = 1; 
1B3EC:  MOVLW  01
1B3EE:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:1\r\n"); 
1B3F0:  MOVLW  30
1B3F2:  MOVWF  FF6
1B3F4:  MOVLW  0E
1B3F6:  MOVWF  FF7
1B3F8:  MOVLW  00
1B3FA:  MOVWF  FF8
1B3FC:  CALL   06A4
....................    return; 
1B400:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_2() 
.................... { 
....................    BC_ATTEMPT_FLAG = 2; 
1B402:  MOVLW  02
1B404:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:2\r\n"); 
1B406:  MOVLW  46
1B408:  MOVWF  FF6
1B40A:  MOVLW  0E
1B40C:  MOVWF  FF7
1B40E:  MOVLW  00
1B410:  MOVWF  FF8
1B412:  CALL   06A4
....................    return; 
1B416:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_3() 
.................... { 
....................    BC_ATTEMPT_FLAG = 3; 
1B418:  MOVLW  03
1B41A:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:3\r\n"); 
1B41C:  MOVLW  5C
1B41E:  MOVWF  FF6
1B420:  MOVLW  0E
1B422:  MOVWF  FF7
1B424:  MOVLW  00
1B426:  MOVWF  FF8
1B428:  CALL   06A4
....................    return; 
1B42C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_4() 
.................... { 
....................    BC_ATTEMPT_FLAG = 4; 
1B42E:  MOVLW  04
1B430:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:4\r\n"); 
1B432:  MOVLW  72
1B434:  MOVWF  FF6
1B436:  MOVLW  0E
1B438:  MOVWF  FF7
1B43A:  MOVLW  00
1B43C:  MOVWF  FF8
1B43E:  CALL   06A4
....................    return; 
1B442:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Antenna_Deploy() 
.................... { 
....................    fprintf(PC,"Ant Dep Attempt No: %x\r\n",BC_ATTEMPT_FLAG); 
*
1A37A:  MOVLW  88
1A37C:  MOVWF  FF6
1A37E:  MOVLW  0E
1A380:  MOVWF  FF7
1A382:  MOVLW  00
1A384:  MOVWF  FF8
1A386:  MOVLW  14
1A388:  MOVLB  3
1A38A:  MOVWF  xA2
1A38C:  MOVLB  0
1A38E:  CALL   06CE
1A392:  MOVFF  68,3A2
1A396:  MOVLW  57
1A398:  MOVLB  3
1A39A:  MOVWF  xA3
1A39C:  MOVLB  0
1A39E:  CALL   0700
1A3A2:  MOVLW  0D
1A3A4:  BTFSS  F9E.4
1A3A6:  BRA    1A3A4
1A3A8:  MOVWF  FAD
1A3AA:  MOVLW  0A
1A3AC:  BTFSS  F9E.4
1A3AE:  BRA    1A3AC
1A3B0:  MOVWF  FAD
....................     
....................    if(BC_ATTEMPT_FLAG < 4 && BC_ATTEMPT_FLAG != 0)                               //SE REPETIRA 3 VECES MAS LUEGO DEL PRIMER DESPLIEGUE, SEA EXITOSO O NO 
1A3B2:  MOVF   x68,W
1A3B4:  SUBLW  03
1A3B6:  BNC   1A460
1A3B8:  MOVF   x68,F
1A3BA:  BZ    1A460
....................    { 
....................       //SAVE_SAT_LOG(0xBC,BC_ATTEMPT_FLAG,BC_ATTEMPT_FLAG); 
....................       fprintf(PC,"BC command sent to RESET PIC\r\n"); 
1A3BC:  MOVLW  A2
1A3BE:  MOVWF  FF6
1A3C0:  MOVLW  0E
1A3C2:  MOVWF  FF7
1A3C4:  MOVLW  00
1A3C6:  MOVWF  FF8
1A3C8:  CALL   06A4
....................       for(int num = 0; num < 50; num++) 
1A3CC:  MOVLB  3
1A3CE:  CLRF   x2C
1A3D0:  MOVF   x2C,W
1A3D2:  SUBLW  31
1A3D4:  BNC   1A3F0
....................       { 
....................          fputc(0xBC,reset); 
1A3D6:  MOVLW  BC
1A3D8:  MOVLB  0
1A3DA:  CALL   157C
....................          delay_ms(10); 
1A3DE:  MOVLW  0A
1A3E0:  MOVLB  3
1A3E2:  MOVWF  x98
1A3E4:  MOVLB  0
1A3E6:  CALL   063E
1A3EA:  MOVLB  3
1A3EC:  INCF   x2C,F
1A3EE:  BRA    1A3D0
....................       } 
....................       delay_ms(1000); 
1A3F0:  MOVLW  04
1A3F2:  MOVWF  x2D
1A3F4:  MOVLW  FA
1A3F6:  MOVWF  x98
1A3F8:  MOVLB  0
1A3FA:  CALL   063E
1A3FE:  MOVLB  3
1A400:  DECFSZ x2D,F
1A402:  BRA    1A3F4
....................       if(reset_bffr[0] == 0xCB)                                                  //check the headear of reset respond 
1A404:  MOVLB  0
1A406:  MOVF   x9E,W
1A408:  SUBLW  CB
1A40A:  BNZ   1A460
....................       { 
....................          RESET_DATA = 0; 
1A40C:  CLRF   x9D
....................          BC_OPERATION();                                                         //Turn ON BC for 30s and read temperature 
1A40E:  RCALL  1A1AE
....................          BC_ATTEMPT_FLAG++;                                                      //increase attempt Flag 
1A410:  INCF   x68,F
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1A412:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //guarda los flags en la EEPROM a partir de la direccion 0x18000 (75%) 
1A416:  CALL   12FE4
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //guarda los datos de direcciones, en un nuevo sector si se cumple el ciclo de R/W 
1A41A:  CALL   142D0
....................          reset_bffr[0] = 0; 
1A41E:  CLRF   x9E
....................          CMD_FROM_PC[1] = 0; 
1A420:  CLRF   x7F
....................          RESET_DATA = 0; 
1A422:  CLRF   x9D
....................          delay_ms(1000); 
1A424:  MOVLW  04
1A426:  MOVLB  3
1A428:  MOVWF  x2D
1A42A:  MOVLW  FA
1A42C:  MOVWF  x98
1A42E:  MOVLB  0
1A430:  CALL   063E
1A434:  MOVLB  3
1A436:  DECFSZ x2D,F
1A438:  BRA    1A42A
....................          delay_ms(20000);                                                        //wait until RESET goes back to nomal loop 
1A43A:  MOVLW  50
1A43C:  MOVWF  x2D
1A43E:  MOVLW  FA
1A440:  MOVWF  x98
1A442:  MOVLB  0
1A444:  CALL   063E
1A448:  MOVLB  3
1A44A:  DECFSZ x2D,F
1A44C:  BRA    1A43E
....................          SAVE_SAT_LOG(0xBC,BC_ATTEMPT_FLAG,BC_ATTEMPT_FLAG); 
1A44E:  MOVLW  BC
1A450:  MOVWF  x53
1A452:  MOVFF  68,354
1A456:  MOVFF  68,355
1A45A:  MOVLB  0
1A45C:  CALL   16EA4
....................       } 
....................    } 
....................    return; 
1A460:  RETURN 0
.................... } 
....................  
.................... //--------FAB HK collection---------------------------------------------------- 
.................... #ORG 0x00019000 
.................... void REFLESH_MSN_ACK_for_COM()                                                   //clear array ACK_for_COM[i] from position 12 to 22 
.................... { 
....................    for(int i = 12; i < 23; i++) 
*
1AD70:  MOVLW  0C
1AD72:  MOVLB  3
1AD74:  MOVWF  x3A
1AD76:  MOVF   x3A,W
1AD78:  SUBLW  16
1AD7A:  BNC   1AD90
....................    { 
....................       ACK_for_COM[i] = 0x00; 
1AD7C:  CLRF   03
1AD7E:  MOVF   x3A,W
1AD80:  ADDLW  E3
1AD82:  MOVWF  FE9
1AD84:  MOVLW  01
1AD86:  ADDWFC 03,W
1AD88:  MOVWF  FEA
1AD8A:  CLRF   FEF
1AD8C:  INCF   x3A,F
1AD8E:  BRA    1AD76
....................    } 
....................    return; 
1AD90:  MOVLB  0
1AD92:  RETURN 0
.................... } 
....................  
.................... //--------ADCS MISSION--------------------------------------------------------- 
.................... ////////////////////////////////////////////////// 
.................... //ADCS MISSION ID: 0x45                         // 
.................... //ADCS MISSION DATA COLLECT: 55                 // 
.................... //ADCS SENSOR SAMPLING: 0x34                    //   
.................... //ADCS ACK: 0x55                                // 
.................... //ADCS Finish Storing: 0x67                     // 
.................... ////////////////////////////////////////////////// 
....................  
.................... #ORG 0x00019000 
.................... void GET_ADCS_SENSOR_DATA()                                                      //after that, method will changed (ADCS make format and just send to MAIN PIC) 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
*
19450:  CALL   1A72
....................    fputc(0x34,adcs);                                                             //send command (just collect sensor) 
19454:  MOVLW  34
19456:  MOVLB  3
19458:  MOVWF  x84
1945A:  MOVLB  0
1945C:  CALL   14A6
....................    //delay_ms(700); 
....................    ADCS_ACK = 0; 
19460:  CLRF   x9B
....................    for(int32 num = 0; num < 1000000; num++) 
19462:  MOVLB  3
19464:  CLRF   x43
19466:  CLRF   x42
19468:  CLRF   x41
1946A:  CLRF   x40
1946C:  MOVF   x43,F
1946E:  BNZ   194AA
19470:  MOVF   x42,W
19472:  SUBLW  0F
19474:  BNC   194AA
19476:  BNZ   19486
19478:  MOVF   x41,W
1947A:  SUBLW  42
1947C:  BNC   194AA
1947E:  BNZ   19486
19480:  MOVF   x40,W
19482:  SUBLW  3F
19484:  BNC   194AA
....................    { 
....................       if(kbhit(ADCS)) 
19486:  BTFSC  F85.6
19488:  BRA    19498
....................       { 
....................          ADCS_ACK = fgetc(ADCS); 
1948A:  MOVLB  0
1948C:  CALL   14EC
19490:  MOVFF  01,9B
....................          break; 
19494:  MOVLB  3
19496:  BRA    194AA
....................       } 
19498:  MOVLW  01
1949A:  ADDWF  x40,F
1949C:  BTFSC  FD8.0
1949E:  INCF   x41,F
194A0:  BTFSC  FD8.2
194A2:  INCF   x42,F
194A4:  BTFSC  FD8.2
194A6:  INCF   x43,F
194A8:  BRA    1946C
....................        
....................    } 
....................    int8 counter = 0; 
194AA:  CLRF   x44
....................    if(ADCS_ACK == 0x55)                                                          //acknowledge 
194AC:  MOVLB  0
194AE:  MOVF   x9B,W
194B0:  SUBLW  55
194B2:  BNZ   19524
....................    { 
....................       for(int32 num = 0; num < 1000000; num++) 
194B4:  MOVLB  3
194B6:  CLRF   x48
194B8:  CLRF   x47
194BA:  CLRF   x46
194BC:  CLRF   x45
194BE:  MOVF   x48,F
194C0:  BNZ   19522
194C2:  MOVF   x47,W
194C4:  SUBLW  0F
194C6:  BNC   19522
194C8:  BNZ   194D8
194CA:  MOVF   x46,W
194CC:  SUBLW  42
194CE:  BNC   19522
194D0:  BNZ   194D8
194D2:  MOVF   x45,W
194D4:  SUBLW  3F
194D6:  BNC   19522
....................       { 
....................          if(kbhit(ADCS)) 
194D8:  BTFSC  F85.6
194DA:  BRA    19510
....................          { 
....................             ADCS_SENSOR_DATA[counter] = fgetc(ADCS); 
194DC:  CLRF   03
194DE:  MOVF   x44,W
194E0:  ADDLW  FB
194E2:  MOVWF  FE9
194E4:  MOVLW  01
194E6:  ADDWFC 03,W
194E8:  MOVWF  FEA
194EA:  MOVFF  FEA,34C
194EE:  MOVFF  FE9,34B
194F2:  MOVLB  0
194F4:  CALL   14EC
194F8:  MOVFF  34C,FEA
194FC:  MOVFF  34B,FE9
19500:  MOVFF  01,FEF
....................             counter++; 
19504:  MOVLB  3
19506:  INCF   x44,F
....................             if(counter == 61) 
19508:  MOVF   x44,W
1950A:  SUBLW  3D
1950C:  BNZ   19510
....................             { 
....................                break; 
1950E:  BRA    19522
....................             } 
....................          } 
19510:  MOVLW  01
19512:  ADDWF  x45,F
19514:  BTFSC  FD8.0
19516:  INCF   x46,F
19518:  BTFSC  FD8.2
1951A:  INCF   x47,F
1951C:  BTFSC  FD8.2
1951E:  INCF   x48,F
19520:  BRA    194BE
19522:  MOVLB  0
....................       } 
....................    } 
....................    CHECK_50_and_CW_RESPOND(); 
19524:  CALL   1A72
....................    if(ADCS_SENSOR_DATA[0] == 0x57) 
19528:  MOVLB  1
1952A:  MOVF   xFB,W
1952C:  SUBLW  57
1952E:  BNZ   19546
....................    { 
....................       fprintf(PC,"\r\nADCS DATA received\r\n");    
19530:  MOVLW  C2
19532:  MOVWF  FF6
19534:  MOVLW  0E
19536:  MOVWF  FF7
19538:  MOVLW  00
1953A:  MOVWF  FF8
1953C:  MOVLB  0
1953E:  CALL   06A4
....................    }else{ 
19542:  BRA    1955C
19544:  MOVLB  1
....................       fprintf(PC,"\r\nADCS DATA not received\r\n"); 
19546:  MOVLW  DA
19548:  MOVWF  FF6
1954A:  MOVLW  0E
1954C:  MOVWF  FF7
1954E:  MOVLW  00
19550:  MOVWF  FF8
19552:  MOVLB  0
19554:  CALL   06A4
....................       ADCS_ACK_COMMING = 0; 
19558:  CLRF   x9C
....................       ADCS_ACK = 0; 
1955A:  CLRF   x9B
....................    } 
....................    return; 
1955C:  RETURN 0
.................... } 
....................  
.................... /////////TLE JOIN PART///////////// 
.................... #ORG 0x00019000 
.................... void ADCS_TLE_JOIN(int8 seq,int8 data1,int8 data2,int8 data3,int8 data4,int8 data5)  //join and save TLE data 
*
1B0DC:  MOVLB  3
1B0DE:  CLRF   x3D
.................... { 
....................    int pos=0;    
....................    switch(seq) 
1B0E0:  MOVLW  01
1B0E2:  SUBWF  x37,W
1B0E4:  ADDLW  F1
1B0E6:  BC    1B16A
1B0E8:  ADDLW  0F
1B0EA:  MOVLB  0
1B0EC:  GOTO   2582
....................    { 
....................       case 0x01: 
....................          pos=1;  
1B0F0:  MOVLW  01
1B0F2:  MOVLB  3
1B0F4:  MOVWF  x3D
....................          break; 
1B0F6:  BRA    1B16A
....................       case 0x02: 
....................          pos=6;  
1B0F8:  MOVLW  06
1B0FA:  MOVLB  3
1B0FC:  MOVWF  x3D
....................          break; 
1B0FE:  BRA    1B16A
....................       case 0x03: 
....................          pos=11;  
1B100:  MOVLW  0B
1B102:  MOVLB  3
1B104:  MOVWF  x3D
....................          break; 
1B106:  BRA    1B16A
....................       case 0x04: 
....................          pos=16;  
1B108:  MOVLW  10
1B10A:  MOVLB  3
1B10C:  MOVWF  x3D
....................          break; 
1B10E:  BRA    1B16A
....................       case 0x05: 
....................          pos=21;  
1B110:  MOVLW  15
1B112:  MOVLB  3
1B114:  MOVWF  x3D
....................          break; 
1B116:  BRA    1B16A
....................       case 0x06: 
....................          pos=26;  
1B118:  MOVLW  1A
1B11A:  MOVLB  3
1B11C:  MOVWF  x3D
....................          break; 
1B11E:  BRA    1B16A
....................       case 0x07: 
....................          pos=31;  
1B120:  MOVLW  1F
1B122:  MOVLB  3
1B124:  MOVWF  x3D
....................          break; 
1B126:  BRA    1B16A
....................       case 0x08: 
....................          pos=36;  
1B128:  MOVLW  24
1B12A:  MOVLB  3
1B12C:  MOVWF  x3D
....................          break; 
1B12E:  BRA    1B16A
....................       case 0x09: 
....................          pos=41;  
1B130:  MOVLW  29
1B132:  MOVLB  3
1B134:  MOVWF  x3D
....................          break; 
1B136:  BRA    1B16A
....................       case 0x0A: 
....................          pos=46;  
1B138:  MOVLW  2E
1B13A:  MOVLB  3
1B13C:  MOVWF  x3D
....................          break; 
1B13E:  BRA    1B16A
....................       case 0x0B: 
....................          pos=51;  
1B140:  MOVLW  33
1B142:  MOVLB  3
1B144:  MOVWF  x3D
....................          break; 
1B146:  BRA    1B16A
....................       case 0x0C: 
....................          pos=56;  
1B148:  MOVLW  38
1B14A:  MOVLB  3
1B14C:  MOVWF  x3D
....................          break; 
1B14E:  BRA    1B16A
....................       case 0x0D: 
....................          pos=61;  
1B150:  MOVLW  3D
1B152:  MOVLB  3
1B154:  MOVWF  x3D
....................          break; 
1B156:  BRA    1B16A
....................       case 0x0E: 
....................          pos=66;  
1B158:  MOVLW  42
1B15A:  MOVLB  3
1B15C:  MOVWF  x3D
....................          break; 
1B15E:  BRA    1B16A
....................       case 0x0F: 
....................          pos=71;  
1B160:  MOVLW  47
1B162:  MOVLB  3
1B164:  MOVWF  x3D
....................          break; 
1B166:  BRA    1B16A
1B168:  MOVLB  3
....................    } 
....................  
....................    output_low(PIN_C4); 
1B16A:  BCF    F94.4
1B16C:  BCF    F8B.4
....................    output_low(PIN_A5); 
1B16E:  BCF    F92.5
1B170:  BCF    F89.5
....................    delay_ms(100); 
1B172:  MOVLW  64
1B174:  MOVWF  x98
1B176:  MOVLB  0
1B178:  CALL   063E
....................    for(int c = 0; c < TLE_size; c++)                                           // Read TLE data from flash and put in TLE[] array 
1B17C:  MOVLB  3
1B17E:  CLRF   x3E
1B180:  MOVF   x3E,W
1B182:  SUBLW  4C
1B184:  BNC   1B1D8
....................       { 
....................          TLE[c]=READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+c); 
1B186:  CLRF   03
1B188:  MOVF   x3E,W
1B18A:  ADDLW  96
1B18C:  MOVWF  01
1B18E:  MOVLW  01
1B190:  ADDWFC 03,F
1B192:  MOVFF  01,341
1B196:  MOVFF  03,342
1B19A:  MOVF   x3E,W
1B19C:  ADDWF  54,W
1B19E:  MOVWF  x43
1B1A0:  MOVLW  00
1B1A2:  ADDWFC 55,W
1B1A4:  MOVWF  x44
1B1A6:  MOVLW  00
1B1A8:  ADDWFC 56,W
1B1AA:  MOVWF  x45
1B1AC:  MOVLW  00
1B1AE:  ADDWFC 57,W
1B1B0:  MOVWF  x46
1B1B2:  MOVWF  xAB
1B1B4:  MOVFF  345,3AA
1B1B8:  MOVFF  344,3A9
1B1BC:  MOVFF  343,3A8
1B1C0:  MOVLB  0
1B1C2:  CALL   11B04
1B1C6:  MOVFF  342,FEA
1B1CA:  MOVFF  341,FE9
1B1CE:  MOVFF  01,FEF
1B1D2:  MOVLB  3
1B1D4:  INCF   x3E,F
1B1D6:  BRA    1B180
....................       } 
....................       REFRESH_SECTOR_OF(0x06,0x65,0x00,0x00);                                    // Clear flash memory TO SAVE NEW DATA 
1B1D8:  MOVLW  06
1B1DA:  MOVWF  x47
1B1DC:  MOVLW  65
1B1DE:  MOVWF  x48
1B1E0:  CLRF   x49
1B1E2:  CLRF   x4A
1B1E4:  MOVLB  0
1B1E6:  CALL   17094
....................       REFRESH_SECTOR_SCF(0x06,0x65,0x00,0x00); 
1B1EA:  MOVLW  06
1B1EC:  MOVLB  3
1B1EE:  MOVWF  x47
1B1F0:  MOVLW  65
1B1F2:  MOVWF  x48
1B1F4:  CLRF   x49
1B1F6:  CLRF   x4A
1B1F8:  MOVLB  0
1B1FA:  CALL   17144
....................       REFRESH_SECTOR_SMF(0x06,0x65,0x00,0x00); 
1B1FE:  MOVLW  06
1B200:  MOVLB  3
1B202:  MOVWF  x47
1B204:  MOVLW  65
1B206:  MOVWF  x48
1B208:  CLRF   x49
1B20A:  CLRF   x4A
1B20C:  MOVLB  0
1B20E:  CALL   16FE0
....................        
....................       TLE[0] = 0xAA; 
1B212:  MOVLW  AA
1B214:  MOVLB  1
1B216:  MOVWF  x96
....................       TLE[pos] = data1;                                                          //update TLE[] array data 
1B218:  CLRF   03
1B21A:  MOVLB  3
1B21C:  MOVF   x3D,W
1B21E:  ADDLW  96
1B220:  MOVWF  FE9
1B222:  MOVLW  01
1B224:  ADDWFC 03,W
1B226:  MOVWF  FEA
1B228:  MOVFF  338,FEF
....................       TLE[pos+1] = data2;                                                       
1B22C:  MOVLW  01
1B22E:  ADDWF  x3D,W
1B230:  CLRF   03
1B232:  ADDLW  96
1B234:  MOVWF  FE9
1B236:  MOVLW  01
1B238:  ADDWFC 03,W
1B23A:  MOVWF  FEA
1B23C:  MOVFF  339,FEF
....................       TLE[pos+2] = data3;                                                       
1B240:  MOVLW  02
1B242:  ADDWF  x3D,W
1B244:  CLRF   03
1B246:  ADDLW  96
1B248:  MOVWF  FE9
1B24A:  MOVLW  01
1B24C:  ADDWFC 03,W
1B24E:  MOVWF  FEA
1B250:  MOVFF  33A,FEF
....................       TLE[pos+3] = data4;                                                       
1B254:  MOVLW  03
1B256:  ADDWF  x3D,W
1B258:  CLRF   03
1B25A:  ADDLW  96
1B25C:  MOVWF  FE9
1B25E:  MOVLW  01
1B260:  ADDWFC 03,W
1B262:  MOVWF  FEA
1B264:  MOVFF  33B,FEF
....................       TLE[pos+4] = data5; 
1B268:  MOVLW  04
1B26A:  ADDWF  x3D,W
1B26C:  CLRF   03
1B26E:  ADDLW  96
1B270:  MOVWF  FE9
1B272:  MOVLW  01
1B274:  ADDWFC 03,W
1B276:  MOVWF  FEA
1B278:  MOVFF  33C,FEF
....................       TLE[TLE_size] = 0xBB; 
1B27C:  MOVLW  BB
1B27E:  MOVLB  1
1B280:  MOVWF  xE3
....................        
....................    for(int i = 0; i < TLE_size; i++)                                             // save everything to flash memory 
1B282:  MOVLB  3
1B284:  CLRF   x3F
1B286:  MOVF   x3F,W
1B288:  SUBLW  4C
1B28A:  BNC   1B356
....................       { 
....................          WRITE_DATA_BYTE_OF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B28C:  MOVF   x3F,W
1B28E:  ADDWF  54,W
1B290:  MOVWF  x41
1B292:  MOVLW  00
1B294:  ADDWFC 55,W
1B296:  MOVWF  x42
1B298:  MOVLW  00
1B29A:  ADDWFC 56,W
1B29C:  MOVWF  x43
1B29E:  MOVLW  00
1B2A0:  ADDWFC 57,W
1B2A2:  MOVWF  x44
1B2A4:  CLRF   03
1B2A6:  MOVF   x3F,W
1B2A8:  ADDLW  96
1B2AA:  MOVWF  FE9
1B2AC:  MOVLW  01
1B2AE:  ADDWFC 03,W
1B2B0:  MOVWF  FEA
1B2B2:  MOVFF  FEF,394
1B2B6:  MOVFF  344,393
1B2BA:  MOVFF  343,392
1B2BE:  MOVFF  342,391
1B2C2:  MOVFF  341,390
1B2C6:  MOVLB  0
1B2C8:  CALL   11B8C
....................          WRITE_DATA_BYTE_SCF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B2CC:  MOVLB  3
1B2CE:  MOVF   x3F,W
1B2D0:  ADDWF  54,W
1B2D2:  MOVWF  x41
1B2D4:  MOVLW  00
1B2D6:  ADDWFC 55,W
1B2D8:  MOVWF  x42
1B2DA:  MOVLW  00
1B2DC:  ADDWFC 56,W
1B2DE:  MOVWF  x43
1B2E0:  MOVLW  00
1B2E2:  ADDWFC 57,W
1B2E4:  MOVWF  x44
1B2E6:  CLRF   03
1B2E8:  MOVF   x3F,W
1B2EA:  ADDLW  96
1B2EC:  MOVWF  FE9
1B2EE:  MOVLW  01
1B2F0:  ADDWFC 03,W
1B2F2:  MOVWF  FEA
1B2F4:  MOVFF  FEF,394
1B2F8:  MOVFF  344,393
1B2FC:  MOVFF  343,392
1B300:  MOVFF  342,391
1B304:  MOVFF  341,390
1B308:  MOVLB  0
1B30A:  CALL   11C0C
....................          WRITE_DATA_BYTE_SMF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B30E:  MOVLB  3
1B310:  MOVF   x3F,W
1B312:  ADDWF  54,W
1B314:  MOVWF  x41
1B316:  MOVLW  00
1B318:  ADDWFC 55,W
1B31A:  MOVWF  x42
1B31C:  MOVLW  00
1B31E:  ADDWFC 56,W
1B320:  MOVWF  x43
1B322:  MOVLW  00
1B324:  ADDWFC 57,W
1B326:  MOVWF  x44
1B328:  CLRF   03
1B32A:  MOVF   x3F,W
1B32C:  ADDLW  96
1B32E:  MOVWF  FE9
1B330:  MOVLW  01
1B332:  ADDWFC 03,W
1B334:  MOVWF  FEA
1B336:  MOVFF  FEF,394
1B33A:  MOVFF  344,393
1B33E:  MOVFF  343,392
1B342:  MOVFF  342,391
1B346:  MOVFF  341,390
1B34A:  MOVLB  0
1B34C:  CALL   11C8C
1B350:  MOVLB  3
1B352:  INCF   x3F,F
1B354:  BRA    1B286
....................       } 
....................  
....................    fprintf(PC,"\r\nTLE:\r\n"); 
1B356:  MOVLW  F6
1B358:  MOVWF  FF6
1B35A:  MOVLW  0E
1B35C:  MOVWF  FF7
1B35E:  MOVLW  00
1B360:  MOVWF  FF8
1B362:  MOVLB  0
1B364:  CALL   06A4
....................    for(int p = 0; p < TLE_size; p++)                                                 // print TLE data 
1B368:  MOVLB  3
1B36A:  CLRF   x40
1B36C:  MOVF   x40,W
1B36E:  SUBLW  4C
1B370:  BNC   1B3C0
....................       { 
....................          fprintf(PC,"%x,",READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+p)); 
1B372:  MOVF   x40,W
1B374:  ADDWF  54,W
1B376:  MOVWF  x41
1B378:  MOVLW  00
1B37A:  ADDWFC 55,W
1B37C:  MOVWF  x42
1B37E:  MOVLW  00
1B380:  ADDWFC 56,W
1B382:  MOVWF  x43
1B384:  MOVLW  00
1B386:  ADDWFC 57,W
1B388:  MOVWF  x44
1B38A:  MOVWF  xAB
1B38C:  MOVFF  343,3AA
1B390:  MOVFF  342,3A9
1B394:  MOVFF  341,3A8
1B398:  MOVLB  0
1B39A:  CALL   11B04
1B39E:  MOVFF  01,341
1B3A2:  MOVFF  01,3A2
1B3A6:  MOVLW  57
1B3A8:  MOVLB  3
1B3AA:  MOVWF  xA3
1B3AC:  MOVLB  0
1B3AE:  CALL   0700
1B3B2:  MOVLW  2C
1B3B4:  BTFSS  F9E.4
1B3B6:  BRA    1B3B4
1B3B8:  MOVWF  FAD
1B3BA:  MOVLB  3
1B3BC:  INCF   x40,F
1B3BE:  BRA    1B36C
....................       } 
....................       fprintf(PC,"\r\n"); 
1B3C0:  MOVLW  0D
1B3C2:  BTFSS  F9E.4
1B3C4:  BRA    1B3C2
1B3C6:  MOVWF  FAD
1B3C8:  MOVLW  0A
1B3CA:  BTFSS  F9E.4
1B3CC:  BRA    1B3CA
1B3CE:  MOVWF  FAD
....................    output_high(PIN_C4); 
1B3D0:  BCF    F94.4
1B3D2:  BSF    F8B.4
....................    return; 
1B3D4:  MOVLB  0
1B3D6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Delete_in_HK()                                                              //Borra el array in_HK[118] 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
*
190C8:  MOVLB  3
190CA:  CLRF   x3E
190CC:  MOVF   x3E,W
190CE:  SUBLW  7B
190D0:  BNC   190E6
....................    { 
....................       in_HK[num] = 0; 
190D2:  CLRF   03
190D4:  MOVF   x3E,W
190D6:  ADDLW  50
190D8:  MOVWF  FE9
190DA:  MOVLW  02
190DC:  ADDWFC 03,W
190DE:  MOVWF  FEA
190E0:  CLRF   FEF
190E2:  INCF   x3E,F
190E4:  BRA    190CC
....................    } 
....................    return; 
190E6:  MOVLB  0
190E8:  RETURN 0
.................... } 
.................... ////////////////////////////////////// 
.................... #ORG 0x00019000 
.................... void Delete_HKDATA()                                                             //funcion que borra el array HKDATA[118] 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
190EA:  MOVLB  3
190EC:  CLRF   x4D
190EE:  MOVF   x4D,W
190F0:  SUBLW  7B
190F2:  BNC   19108
....................    { 
....................       HKDATA[num] = 0; 
190F4:  CLRF   03
190F6:  MOVF   x4D,W
190F8:  ADDLW  7D
190FA:  MOVWF  FE9
190FC:  MOVLW  02
190FE:  ADDWFC 03,W
19100:  MOVWF  FEA
19102:  CLRF   FEF
19104:  INCF   x4D,F
19106:  BRA    190EE
....................    } 
....................    return; 
19108:  MOVLB  0
1910A:  RETURN 0
.................... } 
.................... #ORG 0x00019000 
.................... void Delete_CWFORMAT()                                                           //borra el array CW_FORMAT[5] 
.................... { 
....................    for(int num = 0; num < CW_size; num++) 
*
195DC:  MOVLB  3
195DE:  CLRF   x3E
195E0:  MOVF   x3E,W
195E2:  SUBLW  04
195E4:  BNC   195FA
....................    { 
....................       CW_FORMAT[num] = 0; 
195E6:  CLRF   03
195E8:  MOVF   x3E,W
195EA:  ADDLW  4B
195EC:  MOVWF  FE9
195EE:  MOVLW  02
195F0:  ADDWFC 03,W
195F2:  MOVWF  FEA
195F4:  CLRF   FEF
195F6:  INCF   x3E,F
195F8:  BRA    195E0
....................    } 
....................    return; 
195FA:  MOVLB  0
195FC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CHECK_SUNSHINE(int8 current) 
.................... { 
....................    if(current > EX_PANEL_THRESHHOLD) 
*
19646:  MOVLB  3
19648:  MOVF   x3E,W
1964A:  SUBLW  14
1964C:  BC    19656
....................    { 
....................       return 1; 
1964E:  MOVLW  01
19650:  MOVWF  01
19652:  BRA    1965A
....................    }else{ 
19654:  BRA    1965A
....................       return 0; 
19656:  MOVLW  00
19658:  MOVWF  01
....................    } 
1965A:  MOVLB  0
1965C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_X(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for X 
*
19742:  MOVFF  33E,341
19746:  MOVFF  33F,340
1974A:  MOVFF  341,347
1974E:  MOVFF  340,346
19752:  CALL   1B08
19756:  MOVFF  03,351
1975A:  MOVFF  02,350
1975E:  MOVFF  01,34F
19762:  MOVFF  00,34E
19766:  MOVLW  29
19768:  MOVLB  3
1976A:  MOVWF  x55
1976C:  MOVLW  5C
1976E:  MOVWF  x54
19770:  MOVLW  0F
19772:  MOVWF  x53
19774:  MOVLW  78
19776:  MOVWF  x52
19778:  MOVLB  0
1977A:  CALL   1B58
1977E:  MOVFF  03,349
19782:  MOVFF  02,348
19786:  MOVFF  01,347
1978A:  MOVFF  00,346
1978E:  BSF    FD8.1
19790:  MOVFF  03,34D
19794:  MOVFF  02,34C
19798:  MOVFF  01,34B
1979C:  MOVFF  00,34A
197A0:  MOVLW  DB
197A2:  MOVLB  3
197A4:  MOVWF  x51
197A6:  MOVLW  BF
197A8:  MOVWF  x50
197AA:  MOVLW  72
197AC:  MOVWF  x4F
197AE:  MOVLW  7B
197B0:  MOVWF  x4E
197B2:  MOVLB  0
197B4:  CALL   1C4E
197B8:  MOVFF  03,345
197BC:  MOVFF  02,344
197C0:  MOVFF  01,343
197C4:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.11853; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
197C8:  MOVFF  345,349
197CC:  MOVFF  344,348
197D0:  MOVFF  343,347
197D4:  MOVFF  342,346
197D8:  CALL   1EC6
197DC:  MOVF   01,W
197DE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_Y(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for Y 
197E0:  MOVFF  33E,341
197E4:  MOVFF  33F,340
197E8:  MOVFF  341,347
197EC:  MOVFF  340,346
197F0:  CALL   1B08
197F4:  MOVFF  03,351
197F8:  MOVFF  02,350
197FC:  MOVFF  01,34F
19800:  MOVFF  00,34E
19804:  MOVLW  29
19806:  MOVLB  3
19808:  MOVWF  x55
1980A:  MOVLW  5C
1980C:  MOVWF  x54
1980E:  MOVLW  0F
19810:  MOVWF  x53
19812:  MOVLW  78
19814:  MOVWF  x52
19816:  MOVLB  0
19818:  CALL   1B58
1981C:  MOVFF  03,349
19820:  MOVFF  02,348
19824:  MOVFF  01,347
19828:  MOVFF  00,346
1982C:  BSF    FD8.1
1982E:  MOVFF  03,34D
19832:  MOVFF  02,34C
19836:  MOVFF  01,34B
1983A:  MOVFF  00,34A
1983E:  MOVLW  98
19840:  MOVLB  3
19842:  MOVWF  x51
19844:  MOVLW  69
19846:  MOVWF  x50
19848:  MOVLW  7B
1984A:  MOVWF  x4F
1984C:  MOVLW  7C
1984E:  MOVWF  x4E
19850:  MOVLB  0
19852:  CALL   1C4E
19856:  MOVFF  03,345
1985A:  MOVFF  02,344
1985E:  MOVFF  01,343
19862:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.24552; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
19866:  MOVFF  345,349
1986A:  MOVFF  344,348
1986E:  MOVFF  343,347
19872:  MOVFF  342,346
19876:  CALL   1EC6
1987A:  MOVF   01,W
1987C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_Z(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for Z 
1987E:  MOVFF  33E,341
19882:  MOVFF  33F,340
19886:  MOVFF  341,347
1988A:  MOVFF  340,346
1988E:  CALL   1B08
19892:  MOVFF  03,351
19896:  MOVFF  02,350
1989A:  MOVFF  01,34F
1989E:  MOVFF  00,34E
198A2:  MOVLW  29
198A4:  MOVLB  3
198A6:  MOVWF  x55
198A8:  MOVLW  5C
198AA:  MOVWF  x54
198AC:  MOVLW  0F
198AE:  MOVWF  x53
198B0:  MOVLW  78
198B2:  MOVWF  x52
198B4:  MOVLB  0
198B6:  CALL   1B58
198BA:  MOVFF  03,349
198BE:  MOVFF  02,348
198C2:  MOVFF  01,347
198C6:  MOVFF  00,346
198CA:  BSF    FD8.1
198CC:  MOVFF  03,34D
198D0:  MOVFF  02,34C
198D4:  MOVFF  01,34B
198D8:  MOVFF  00,34A
198DC:  MOVLW  CF
198DE:  MOVLB  3
198E0:  MOVWF  x51
198E2:  MOVLW  49
198E4:  MOVWF  x50
198E6:  MOVLW  4F
198E8:  MOVWF  x4F
198EA:  MOVLW  7D
198EC:  MOVWF  x4E
198EE:  MOVLB  0
198F0:  CALL   1C4E
198F4:  MOVFF  03,345
198F8:  MOVFF  02,344
198FC:  MOVFF  01,343
19900:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.40486; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
19904:  MOVFF  345,349
19908:  MOVFF  344,348
1990C:  MOVFF  343,347
19910:  MOVFF  342,346
19914:  CALL   1EC6
19918:  MOVF   01,W
1991A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 OPERATION_MODE_VALUE(int8 Bat_Vol) 
.................... { 
....................    //0x94HKDATA[116]  
....................    if(Bat_Vol > 0x94){//more than 3.8 
*
195FE:  MOVLB  3
19600:  MOVF   x3E,W
19602:  SUBLW  94
19604:  BC    19616
....................       OPERATION_MODE = 0x11; 
19606:  MOVLW  11
19608:  MOVLB  0
1960A:  MOVWF  x98
....................       return 96; 
1960C:  MOVLW  60
1960E:  MOVWF  01
19610:  BRA    19640
....................    }else if((Bat_Vol > 0x88) && (Bat_Vol <= 0x94)){//3.5 to 3.8 
19612:  BRA    19640
19614:  MOVLB  3
19616:  MOVF   x3E,W
19618:  SUBLW  88
1961A:  BC    19632
1961C:  MOVF   x3E,W
1961E:  SUBLW  94
19620:  BNC   19632
....................       OPERATION_MODE = 0x10; 
19622:  MOVLW  10
19624:  MOVLB  0
19626:  MOVWF  x98
....................       return 64; 
19628:  MOVLW  40
1962A:  MOVWF  01
1962C:  BRA    19640
....................    }else if(Bat_Vol <= 0x88){//less than 3.5 
1962E:  BRA    19640
19630:  MOVLB  3
19632:  MOVF   x3E,W
19634:  SUBLW  88
19636:  BNC   19642
....................       OPERATION_MODE = 0x00; 
19638:  MOVLB  0
1963A:  CLRF   x98
....................       return 16; 
1963C:  MOVLW  10
1963E:  MOVWF  01
19640:  MOVLB  3
....................    } 
19642:  MOVLB  0
19644:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW1_FORMAT()                                                            
.................... { 
....................    Delete_CWFORMAT();                                                            //borra el array CW_FORMAT[5] 
*
1965E:  RCALL  195DC
....................     
....................    CW_FORMAT[0] = HKDATA[44];                                                    //battery voltage 
19660:  MOVFF  2A9,24B
....................    CW_FORMAT[1] = HKDATA[45]<<4|HKDATA[46]>>4;                                   //battery current 
19664:  MOVLB  2
19666:  SWAPF  xAA,W
19668:  MOVLB  3
1966A:  MOVWF  x3E
1966C:  MOVLW  F0
1966E:  ANDWF  x3E,F
19670:  MOVLB  2
19672:  SWAPF  xAB,W
19674:  MOVWF  00
19676:  MOVLW  0F
19678:  ANDWF  00,F
1967A:  MOVF   00,W
1967C:  MOVLB  3
1967E:  IORWF  x3E,W
19680:  MOVLB  2
19682:  MOVWF  x4C
....................    CW_FORMAT[2] = HKDATA[47];                                                    //battery temp 
19684:  MOVFF  2AC,24D
....................     
....................    //   CW_FORMAT[3] = CW_FORMAT[3];//0:CW1 
....................    //   CW_FORMAT[3] = CW_FORMAT[3] + RESERVE_CHECK * 64; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + OPERATION_MODE_VALUE(HKDATA[116]);              //96(=64+32-->0x01100000):nomal, 64(0x01000000):low, 16(0x00100000):safe 
19688:  MOVFF  2F1,33E
1968C:  MOVLB  0
1968E:  RCALL  195FE
19690:  MOVF   01,W
19692:  MOVLB  2
19694:  ADDWF  x4E,F
....................    KILL_FLAG_FAB = (HKDATA[49] & 0x10)>>4; 
19696:  MOVF   xAE,W
19698:  ANDLW  10
1969A:  MOVWF  00
1969C:  SWAPF  00,W
1969E:  MOVLB  0
196A0:  MOVWF  x76
196A2:  MOVLW  0F
196A4:  ANDWF  x76,F
....................    KILL_FLAG_MAIN = HKDATA[49] & 0x01; 
196A6:  MOVLB  2
196A8:  MOVF   xAE,W
196AA:  ANDLW  01
196AC:  MOVLB  0
196AE:  MOVWF  x75
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_MAIN * 16; 
196B0:  MOVF   x75,W
196B2:  MULLW  10
196B4:  MOVF   FF3,W
196B6:  MOVLB  2
196B8:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_FAB * 8; 
196BA:  MOVLB  0
196BC:  MOVF   x76,W
196BE:  MULLW  08
196C0:  MOVF   FF3,W
196C2:  MOVLB  2
196C4:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + ANT_DEP_STATUS * 4; 
196C6:  MOVLB  0
196C8:  MOVF   x7B,W
196CA:  MULLW  04
196CC:  MOVF   FF3,W
196CE:  MOVLB  2
196D0:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + CHECK_SUNSHINE(HKDATA[34]) * 2;                 //+Y Panel (new axis definition) 
196D2:  MOVFF  29F,33E
196D6:  MOVLB  0
196D8:  RCALL  19646
196DA:  BCF    FD8.0
196DC:  RLCF   01,W
196DE:  MOVLB  2
196E0:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + CHECK_SUNSHINE(HKDATA[35]) * 1;                 //+X Panel (new axis definition) 
196E2:  MOVFF  2A0,33E
196E6:  MOVLB  0
196E8:  RCALL  19646
196EA:  MOVF   01,W
196EC:  MOVLB  2
196EE:  ADDWF  x4E,F
....................     
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[36]) * 128;               //-Z Panel (new axis definition) 
196F0:  MOVFF  2A1,33E
196F4:  MOVLB  0
196F6:  RCALL  19646
196F8:  MOVF   01,W
196FA:  MULLW  80
196FC:  MOVF   FF3,W
196FE:  MOVLB  2
19700:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[37]) * 64;                //-X Panel (new axis definition) 
19702:  MOVFF  2A2,33E
19706:  MOVLB  0
19708:  RCALL  19646
1970A:  MOVF   01,W
1970C:  MULLW  40
1970E:  MOVF   FF3,W
19710:  MOVLB  2
19712:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[38]) * 32;                //+Z Panel (new axis definition) 
19714:  MOVFF  2A3,33E
19718:  MOVLB  0
1971A:  RCALL  19646
1971C:  MOVF   01,W
1971E:  MULLW  20
19720:  MOVF   FF3,W
19722:  MOVLB  2
19724:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + (HKDATA[4] & 0b00011111);                       //time data 
19726:  MOVF   x81,W
19728:  ANDLW  1F
1972A:  ADDWF  x4F,F
....................     
....................    CW_IDENTIFIER = 0; 
1972C:  MOVLB  0
1972E:  CLRF   x97
....................    CHECK_50_and_CW_RESPOND(); 
19730:  CALL   1A72
....................    ACK_for_COM[0] = 0xAA;                                                        //for safety (this byte should be always 0) 
19734:  MOVLW  AA
19736:  MOVLB  1
19738:  MOVWF  xE3
....................    ACK_for_COM[23] = 0xBB;                                                       //for safety (this byte should be always 0) 
1973A:  MOVLW  BB
1973C:  MOVWF  xFA
....................    return; 
1973E:  MOVLB  0
19740:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW2_FORMAT() 
.................... { 
....................    Delete_CWFORMAT(); 
*
1991C:  RCALL  195DC
....................    //CHECK_50_and_CW_RESPOND(); 
....................    CW_FORMAT[0] = CONVERT_16bit_GYRO_to_8bit_X(HKDATA[59], HKDATA[60]);          //GYRO X axis 
1991E:  MOVFF  2B8,33E
19922:  MOVFF  2B9,33F
19926:  RCALL  19742
19928:  MOVFF  01,24B
....................    CW_FORMAT[1] = CONVERT_16bit_GYRO_to_8bit_Y(HKDATA[61], HKDATA[62]);          //GYRO Y axis 
1992C:  MOVFF  2BA,33E
19930:  MOVFF  2BB,33F
19934:  RCALL  197E0
19936:  MOVFF  01,24C
....................    CW_FORMAT[2] = CONVERT_16bit_GYRO_to_8bit_Z(HKDATA[63], HKDATA[64]);          //GYRO Z axis 
1993A:  MOVFF  2BC,33E
1993E:  MOVFF  2BD,33F
19942:  RCALL  1987E
19944:  MOVFF  01,24D
....................     
....................    CW_FORMAT[3] = CW_FORMAT[3] + 128;                                            //1:CW2 
19948:  MOVLW  80
1994A:  MOVLB  2
1994C:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + FIRST_HSSC_DONE * 64;                           //High Sampling Sensor Collection Flag 0:not done, 1:done 
1994E:  MOVLB  0
19950:  MOVF   x77,W
19952:  MULLW  40
19954:  MOVF   FF3,W
19956:  MOVLB  2
19958:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_CAM_DONE * 32;                             //AUTO CAM MISSION DONE 0:not done, 1:done 
1995A:  MOVLB  0
1995C:  MOVF   x78,W
1995E:  MULLW  20
19960:  MOVF   FF3,W
19962:  MOVLB  2
19964:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_MBP_DONE * 16;                             //AUTO MBP MISSION DONE 0:not done, 1:done 
19966:  MOVLB  0
19968:  MOVF   x79,W
1996A:  MULLW  10
1996C:  MOVF   FF3,W
1996E:  MOVLB  2
19970:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_ADCS_DONE * 8;                             //AUTO ADCS MISSION DONE 0:not done, 1:done 
19972:  MOVLB  0
19974:  MOVF   x7A,W
19976:  MULLW  08
19978:  MOVF   FF3,W
1997A:  MOVLB  2
1997C:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + HKDATA[48] * 4;                                 //Heater 0:OFF, 1:ON 
1997E:  MOVF   xAD,W
19980:  MULLW  04
19982:  MOVF   FF3,W
19984:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + RESERVE_CHECK * 2;                              //RSV Flag 
19986:  BCF    FD8.0
19988:  MOVLB  0
1998A:  RLCF   x6B,W
1998C:  MOVLB  2
1998E:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + UPLINK_SUCCESS;                                 //UPLINK SUCCESS 
19990:  MOVLB  0
19992:  MOVF   x7C,W
19994:  MOVLB  2
19996:  ADDWF  x4E,F
....................     
....................    CW_FORMAT[4] = HKDATA[20]<<4|HKDATA[21]>>4;                                   //BPB_TEMP 
19998:  SWAPF  x91,W
1999A:  MOVLB  3
1999C:  MOVWF  x3E
1999E:  MOVLW  F0
199A0:  ANDWF  x3E,F
199A2:  MOVLB  2
199A4:  SWAPF  x92,W
199A6:  MOVWF  00
199A8:  MOVLW  0F
199AA:  ANDWF  00,F
199AC:  MOVF   00,W
199AE:  MOVLB  3
199B0:  IORWF  x3E,W
199B2:  MOVLB  2
199B4:  MOVWF  x4F
....................  
....................    CW_IDENTIFIER = 1; 
199B6:  MOVLW  01
199B8:  MOVLB  0
199BA:  MOVWF  x97
....................    CHECK_50_and_CW_RESPOND(); 
199BC:  CALL   1A72
....................    ACK_for_COM[0] = 0xAA;                                                        //for safety (this byte should be always 0) 
199C0:  MOVLW  AA
199C2:  MOVLB  1
199C4:  MOVWF  xE3
....................    ACK_for_COM[23] = 0xBB;                                                       //for safety (this byte should be always 0) 
199C6:  MOVLW  BB
199C8:  MOVWF  xFA
....................     
....................    return; 
199CA:  MOVLB  0
199CC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW_FORMAT() 
.................... { 
....................    if(CW_IDENTIFIER) 
199CE:  MOVF   x97,F
199D0:  BZ    199D6
....................    { 
....................       MAKE_CW1_FORMAT(); 
199D2:  RCALL  1965E
....................    }else{ 
199D4:  BRA    199D8
....................       MAKE_CW2_FORMAT(); 
199D6:  RCALL  1991C
....................    } 
199D8:  RETURN 0
.................... } 
....................  
.................... void Send_COMMAND_TO_FAB(int8 cmd)                                               //funcion que envia comandos al FAB 
.................... { 
....................    fputc(cmd,FAB);                                                               //se indica el dato y el puerto 
*
01A90:  MOVLB  3
01A92:  MOVF   x4F,W
01A94:  MOVLB  0
01A96:  RCALL  1A84
....................    return; 
01A98:  RETURN 0
.................... } 
....................  
.................... void COMMAND_TO_FAB(int32 delaytime)                                             //envia comando al FAB para pedir datos 
.................... { 
....................    FAB_DATA = 0; 
01A9A:  MOVLB  2
01A9C:  CLRF   xF9
....................    enable_interrupts(INT_rda3);                                                  //Habilita interrupcion UART FAB para cargar el vector in_HK[] 
01A9E:  BSF    F61.5
....................    Send_Command_to_FAB(0x61);                                                    //send command to fab 
01AA0:  MOVLW  61
01AA2:  MOVLB  3
01AA4:  MOVWF  x4F
01AA6:  MOVLB  0
01AA8:  RCALL  1A90
....................    /*fprintf(PC,"Command to FAB sent\r\n");*/  
....................    int32 a = 0; 
01AAA:  MOVLB  3
01AAC:  CLRF   x4E
01AAE:  CLRF   x4D
01AB0:  CLRF   x4C
01AB2:  CLRF   x4B
....................    while(FAB_DATA == 0){                                                         //Espera a que la bandera FAB_DATA se ponga en alto 
01AB4:  MOVLB  2
01AB6:  MOVF   xF9,F
01AB8:  BNZ   1AEE
....................       a++;                                                                       //la bandera se pone en alto cuando se recibe un dato en el UART 
01ABA:  MOVLW  01
01ABC:  MOVLB  3
01ABE:  ADDWF  x4B,F
01AC0:  BTFSC  FD8.0
01AC2:  INCF   x4C,F
01AC4:  BTFSC  FD8.2
01AC6:  INCF   x4D,F
01AC8:  BTFSC  FD8.2
01ACA:  INCF   x4E,F
....................       if(a > 50000) 
01ACC:  MOVF   x4E,F
01ACE:  BNZ   1AE4
01AD0:  MOVF   x4D,F
01AD2:  BNZ   1AE4
01AD4:  MOVF   x4C,W
01AD6:  SUBLW  C2
01AD8:  BC    1AEA
01ADA:  XORLW  FF
01ADC:  BNZ   1AE4
01ADE:  MOVF   x4B,W
01AE0:  SUBLW  50
01AE2:  BC    1AEA
....................       { 
....................          break; 
01AE4:  MOVLB  2
01AE6:  BRA    1AEE
01AE8:  MOVLB  3
....................       } 
01AEA:  BRA    1AB4
01AEC:  MOVLB  2
....................    } 
....................    waiting(delaytime);                                                           //funcion de espera 
01AEE:  MOVFF  34A,388
01AF2:  MOVFF  349,387
01AF6:  MOVFF  348,386
01AFA:  MOVFF  347,385
01AFE:  MOVLB  0
01B00:  CALL   16822
....................    disable_interrupts(INT_rda3);                                                 //desabilita interrupcion del UART FAB 
01B04:  BCF    F61.5
....................    return; 
01B06:  RETURN 0
.................... } 
.................... /* 
.................... int8 ACK_FROM_FAB() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM); 
....................    return ack; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
*
19A5C:  BCF    F94.4
19A5E:  BCF    F8B.4
....................    for(int8 num = 0; num < HK_size; num++) 
19A60:  MOVLB  3
19A62:  CLRF   x46
19A64:  MOVF   x46,W
19A66:  SUBLW  7B
19A68:  BNC   19AB0
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress+num, HKDATA[num]); 
19A6A:  MOVF   x46,W
19A6C:  ADDWF  x42,W
19A6E:  MOVWF  x47
19A70:  MOVLW  00
19A72:  ADDWFC x43,W
19A74:  MOVWF  x48
19A76:  MOVLW  00
19A78:  ADDWFC x44,W
19A7A:  MOVWF  x49
19A7C:  MOVLW  00
19A7E:  ADDWFC x45,W
19A80:  MOVWF  x4A
19A82:  CLRF   03
19A84:  MOVF   x46,W
19A86:  ADDLW  7D
19A88:  MOVWF  FE9
19A8A:  MOVLW  02
19A8C:  ADDWFC 03,W
19A8E:  MOVWF  FEA
19A90:  MOVFF  FEF,394
19A94:  MOVFF  34A,393
19A98:  MOVFF  349,392
19A9C:  MOVFF  348,391
19AA0:  MOVFF  347,390
19AA4:  MOVLB  0
19AA6:  CALL   11C0C
19AAA:  MOVLB  3
19AAC:  INCF   x46,F
19AAE:  BRA    19A64
....................    } 
....................    output_high(PIN_C4); 
19AB0:  BCF    F94.4
19AB2:  BSF    F8B.4
....................    return; 
19AB4:  MOVLB  0
19AB6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_SCF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_SCF(adress);  //save HK to COM PIC 
19AB8:  MOVFF  341,345
19ABC:  MOVFF  340,344
19AC0:  MOVFF  33F,343
19AC4:  MOVFF  33E,342
19AC8:  RCALL  19A5C
....................    CHECK_50_and_CW_RESPOND(); 
19ACA:  CALL   1A72
....................    return; 
19ACE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_SMF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_A5); 
19AD0:  BCF    F92.5
19AD2:  BCF    F89.5
....................    for(int8 num = 0; num < HK_size; num++) 
19AD4:  MOVLB  3
19AD6:  CLRF   x46
19AD8:  MOVF   x46,W
19ADA:  SUBLW  7B
19ADC:  BNC   19B24
....................    { 
....................       WRITE_DATA_BYTE_SMF(Memory_Adress+num, HKDATA[num]); 
19ADE:  MOVF   x46,W
19AE0:  ADDWF  x42,W
19AE2:  MOVWF  x47
19AE4:  MOVLW  00
19AE6:  ADDWFC x43,W
19AE8:  MOVWF  x48
19AEA:  MOVLW  00
19AEC:  ADDWFC x44,W
19AEE:  MOVWF  x49
19AF0:  MOVLW  00
19AF2:  ADDWFC x45,W
19AF4:  MOVWF  x4A
19AF6:  CLRF   03
19AF8:  MOVF   x46,W
19AFA:  ADDLW  7D
19AFC:  MOVWF  FE9
19AFE:  MOVLW  02
19B00:  ADDWFC 03,W
19B02:  MOVWF  FEA
19B04:  MOVFF  FEF,394
19B08:  MOVFF  34A,393
19B0C:  MOVFF  349,392
19B10:  MOVFF  348,391
19B14:  MOVFF  347,390
19B18:  MOVLB  0
19B1A:  CALL   11C8C
19B1E:  MOVLB  3
19B20:  INCF   x46,F
19B22:  BRA    19AD8
....................    } 
....................    return; 
19B24:  MOVLB  0
19B26:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_SMF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_SMF(adress);  //save HK to COM PIC 
19B28:  MOVFF  341,345
19B2C:  MOVFF  340,344
19B30:  MOVFF  33F,343
19B34:  MOVFF  33E,342
19B38:  RCALL  19AD0
....................    CHECK_50_and_CW_RESPOND(); 
19B3A:  CALL   1A72
....................    return; 
19B3E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
19B40:  MOVLB  3
19B42:  CLRF   x46
19B44:  MOVF   x46,W
19B46:  SUBLW  7B
19B48:  BNC   19B90
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress+num, HKDATA[num]); 
19B4A:  MOVF   x46,W
19B4C:  ADDWF  x42,W
19B4E:  MOVWF  x47
19B50:  MOVLW  00
19B52:  ADDWFC x43,W
19B54:  MOVWF  x48
19B56:  MOVLW  00
19B58:  ADDWFC x44,W
19B5A:  MOVWF  x49
19B5C:  MOVLW  00
19B5E:  ADDWFC x45,W
19B60:  MOVWF  x4A
19B62:  CLRF   03
19B64:  MOVF   x46,W
19B66:  ADDLW  7D
19B68:  MOVWF  FE9
19B6A:  MOVLW  02
19B6C:  ADDWFC 03,W
19B6E:  MOVWF  FEA
19B70:  MOVFF  FEF,394
19B74:  MOVFF  34A,393
19B78:  MOVFF  349,392
19B7C:  MOVFF  348,391
19B80:  MOVFF  347,390
19B84:  MOVLB  0
19B86:  CALL   11B8C
19B8A:  MOVLB  3
19B8C:  INCF   x46,F
19B8E:  BRA    19B44
....................    } 
....................    return; 
19B90:  MOVLB  0
19B92:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_OF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_OF(adress);  //save HK to COM PIC 
19B94:  MOVFF  341,345
19B98:  MOVFF  340,344
19B9C:  MOVFF  33F,343
19BA0:  MOVFF  33E,342
19BA4:  RCALL  19B40
....................    CHECK_50_and_CW_RESPOND(); 
19BA6:  CALL   1A72
....................    return; 
19BAA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
19BAC:  BCF    F94.4
19BAE:  BCF    F8B.4
....................    for(int8 num = 0; num < CW_size; num++) 
19BB0:  MOVLB  3
19BB2:  CLRF   x46
19BB4:  MOVF   x46,W
19BB6:  SUBLW  04
19BB8:  BNC   19C00
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress+num, CW_FORMAT[num]); 
19BBA:  MOVF   x46,W
19BBC:  ADDWF  x42,W
19BBE:  MOVWF  x47
19BC0:  MOVLW  00
19BC2:  ADDWFC x43,W
19BC4:  MOVWF  x48
19BC6:  MOVLW  00
19BC8:  ADDWFC x44,W
19BCA:  MOVWF  x49
19BCC:  MOVLW  00
19BCE:  ADDWFC x45,W
19BD0:  MOVWF  x4A
19BD2:  CLRF   03
19BD4:  MOVF   x46,W
19BD6:  ADDLW  4B
19BD8:  MOVWF  FE9
19BDA:  MOVLW  02
19BDC:  ADDWFC 03,W
19BDE:  MOVWF  FEA
19BE0:  MOVFF  FEF,394
19BE4:  MOVFF  34A,393
19BE8:  MOVFF  349,392
19BEC:  MOVFF  348,391
19BF0:  MOVFF  347,390
19BF4:  MOVLB  0
19BF6:  CALL   11C0C
19BFA:  MOVLB  3
19BFC:  INCF   x46,F
19BFE:  BRA    19BB4
....................    } 
....................    output_high(PIN_C4); 
19C00:  BCF    F94.4
19C02:  BSF    F8B.4
....................    return; 
19C04:  MOVLB  0
19C06:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_SCF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);                                                 //save HK to COM PIC 
19C08:  MOVFF  341,345
19C0C:  MOVFF  340,344
19C10:  MOVFF  33F,343
19C14:  MOVFF  33E,342
19C18:  RCALL  19BAC
....................    CHECK_50_and_CW_RESPOND(); 
19C1A:  CALL   1A72
....................    return; 
19C1E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_SMF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_A5); 
19C20:  BCF    F92.5
19C22:  BCF    F89.5
....................    for(int8 num = 0; num < CW_size; num++) 
19C24:  MOVLB  3
19C26:  CLRF   x46
19C28:  MOVF   x46,W
19C2A:  SUBLW  04
19C2C:  BNC   19C74
....................    { 
....................       WRITE_DATA_BYTE_SMF(Memory_Adress+num, CW_FORMAT[num]); 
19C2E:  MOVF   x46,W
19C30:  ADDWF  x42,W
19C32:  MOVWF  x47
19C34:  MOVLW  00
19C36:  ADDWFC x43,W
19C38:  MOVWF  x48
19C3A:  MOVLW  00
19C3C:  ADDWFC x44,W
19C3E:  MOVWF  x49
19C40:  MOVLW  00
19C42:  ADDWFC x45,W
19C44:  MOVWF  x4A
19C46:  CLRF   03
19C48:  MOVF   x46,W
19C4A:  ADDLW  4B
19C4C:  MOVWF  FE9
19C4E:  MOVLW  02
19C50:  ADDWFC 03,W
19C52:  MOVWF  FEA
19C54:  MOVFF  FEF,394
19C58:  MOVFF  34A,393
19C5C:  MOVFF  349,392
19C60:  MOVFF  348,391
19C64:  MOVFF  347,390
19C68:  MOVLB  0
19C6A:  CALL   11C8C
19C6E:  MOVLB  3
19C70:  INCF   x46,F
19C72:  BRA    19C28
....................    } 
....................    return; 
19C74:  MOVLB  0
19C76:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_SMF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SMF(adress);  //save HK to COM PIC 
19C78:  MOVFF  341,345
19C7C:  MOVFF  340,344
19C80:  MOVFF  33F,343
19C84:  MOVFF  33E,342
19C88:  RCALL  19C20
....................    CHECK_50_and_CW_RESPOND(); 
19C8A:  CALL   1A72
....................    fprintf(PC,"\r\nCW SAVED\r\n"); 
19C8E:  MOVLW  00
19C90:  MOVWF  FF6
19C92:  MOVLW  0F
19C94:  MOVWF  FF7
19C96:  MOVLW  00
19C98:  MOVWF  FF8
19C9A:  CALL   06A4
....................    return; 
19C9E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    for(int8 num = 0; num < CW_size; num++) 
*
19000:  MOVLB  3
19002:  CLRF   x81
19004:  MOVF   x81,W
19006:  SUBLW  04
19008:  BNC   19050
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress+num, CW_FORMAT[num]); 
1900A:  MOVF   x81,W
1900C:  ADDWF  x7D,W
1900E:  MOVWF  x82
19010:  MOVLW  00
19012:  ADDWFC x7E,W
19014:  MOVWF  x83
19016:  MOVLW  00
19018:  ADDWFC x7F,W
1901A:  MOVWF  x84
1901C:  MOVLW  00
1901E:  ADDWFC x80,W
19020:  MOVWF  x85
19022:  CLRF   03
19024:  MOVF   x81,W
19026:  ADDLW  4B
19028:  MOVWF  FE9
1902A:  MOVLW  02
1902C:  ADDWFC 03,W
1902E:  MOVWF  FEA
19030:  MOVFF  FEF,394
19034:  MOVFF  385,393
19038:  MOVFF  384,392
1903C:  MOVFF  383,391
19040:  MOVFF  382,390
19044:  MOVLB  0
19046:  CALL   11B8C
1904A:  MOVLB  3
1904C:  INCF   x81,F
1904E:  BRA    19004
....................    } 
....................    return; 
19050:  MOVLB  0
19052:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_OF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);                                                 //save HK to COM PIC 
*
19CA0:  MOVFF  341,345
19CA4:  MOVFF  340,344
19CA8:  MOVFF  33F,343
19CAC:  MOVFF  33E,342
19CB0:  RCALL  19BAC
....................    TRANSFER_DATA_NBYTE_TOPC_OF(adress,CW_size);                                  //for checking whether the data saved correctly 
19CB2:  MOVFF  341,345
19CB6:  MOVFF  340,344
19CBA:  MOVFF  33F,343
19CBE:  MOVFF  33E,342
19CC2:  MOVLB  3
19CC4:  CLRF   x49
19CC6:  CLRF   x48
19CC8:  CLRF   x47
19CCA:  MOVLW  05
19CCC:  MOVWF  x46
19CCE:  MOVLB  0
19CD0:  CALL   12F70
....................    CHECK_50_and_CW_RESPOND(); 
19CD4:  CALL   1A72
....................    return; 
19CD8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_HKDATA(int8 in,int32 delaytime)                                       //funcion que carga el array HKDATA[] 
.................... { 
....................    fprintf(PC,"GET SENSOR DATA\r\n"); 
*
19142:  MOVLW  0E
19144:  MOVWF  FF6
19146:  MOVLW  0F
19148:  MOVWF  FF7
1914A:  MOVLW  00
1914C:  MOVWF  FF8
1914E:  CALL   06A4
....................    Delete_HKDATA();                                                              //borra el array HKDATA[] 
19152:  RCALL  190EA
....................    waiting(delaytime);                                                           //espera 
19154:  MOVFF  34B,388
19158:  MOVFF  34A,387
1915C:  MOVFF  349,386
19160:  MOVFF  348,385
19164:  CALL   16822
....................    CHECK_50_and_CW_RESPOND(); 
19168:  CALL   1A72
....................    for(int num = 1; num < 11 - in; num++)                                        //[FAB] +X,-Y,-Z,+Y,-Xtemp_high,low(array[10] to [17]) 
1916C:  MOVLW  01
1916E:  MOVLB  3
19170:  MOVWF  x4C
19172:  MOVLW  0B
19174:  BSF    FD8.0
19176:  SUBFWB x47,W
19178:  SUBWF  x4C,W
1917A:  BC    191E2
....................    { 
....................       HKDATA[num + 5+4] = in_HK[num + 2 - in];                                   //coloca los datos enviados por el FAB en el array HKDATA[] desde la posicion 10 al 17 
1917C:  MOVLW  05
1917E:  ADDWF  x4C,W
19180:  ADDLW  04
19182:  CLRF   03
19184:  ADDLW  7D
19186:  MOVWF  01
19188:  MOVLW  02
1918A:  ADDWFC 03,F
1918C:  MOVFF  03,34E
19190:  MOVLW  02
19192:  ADDWF  x4C,W
19194:  BSF    FD8.0
19196:  SUBFWB x47,W
19198:  CLRF   03
1919A:  ADDLW  50
1919C:  MOVWF  FE9
1919E:  MOVLW  02
191A0:  ADDWFC 03,W
191A2:  MOVWF  FEA
191A4:  MOVFF  FEF,34F
191A8:  MOVFF  34E,FEA
191AC:  MOVFF  01,FE9
191B0:  MOVFF  34F,FEF
....................      /* fputc(HKDATA[num + 5+4],PC); */                                              //imprime los datos desde la posicion 10 hasta 19 
....................       fprintf(PC,"%x,",HKDATA[num + 5+4]); 
191B4:  MOVLW  05
191B6:  ADDWF  x4C,W
191B8:  ADDLW  04
191BA:  CLRF   03
191BC:  ADDLW  7D
191BE:  MOVWF  FE9
191C0:  MOVLW  02
191C2:  ADDWFC 03,W
191C4:  MOVWF  FEA
191C6:  MOVFF  FEF,3A2
191CA:  MOVLW  57
191CC:  MOVWF  xA3
191CE:  MOVLB  0
191D0:  CALL   0700
191D4:  MOVLW  2C
191D6:  BTFSS  F9E.4
191D8:  BRA    191D6
191DA:  MOVWF  FAD
191DC:  MOVLB  3
191DE:  INCF   x4C,F
191E0:  BRA    19172
....................    } 
....................     
....................    MEASURE_BC_TEMP();                                                            //lectura analogica y carga de la variable BC_temp_data_h y BC_temp_data_l 
191E2:  MOVLB  0
191E4:  RCALL  1910C
....................    CHECK_50_and_CW_RESPOND();    
191E6:  CALL   1A72
....................    HKDATA[14+4] = BC_temp_data_h;                                                //+X temp high[18] 
191EA:  MOVFF  305,28F
....................    HKDATA[15+4] = BC_temp_data_l;                                                //+X temp low[19] 
191EE:  MOVFF  307,290
....................     
....................    for(num = 9; num < FAB_SENSOR_size - 2; num++)                                //[FAB] from CPLD temp to Kill status(array[20] to [49]) 
191F2:  MOVLW  09
191F4:  MOVLB  3
191F6:  MOVWF  x4C
191F8:  MOVF   x4C,W
191FA:  SUBLW  2A
191FC:  BNC   19264
....................    { 
....................       HKDATA[num + 7+4] = in_HK[num + 2 - in]; 
191FE:  MOVLW  07
19200:  ADDWF  x4C,W
19202:  ADDLW  04
19204:  CLRF   03
19206:  ADDLW  7D
19208:  MOVWF  01
1920A:  MOVLW  02
1920C:  ADDWFC 03,F
1920E:  MOVFF  03,34E
19212:  MOVLW  02
19214:  ADDWF  x4C,W
19216:  BSF    FD8.0
19218:  SUBFWB x47,W
1921A:  CLRF   03
1921C:  ADDLW  50
1921E:  MOVWF  FE9
19220:  MOVLW  02
19222:  ADDWFC 03,W
19224:  MOVWF  FEA
19226:  MOVFF  FEF,34F
1922A:  MOVFF  34E,FEA
1922E:  MOVFF  01,FE9
19232:  MOVFF  34F,FEF
....................       /*fputc(HKDATA[num + 7+4],PC);*/                                           //imprime los datos desde la posicion 20 hasta 49 
....................       fprintf(PC,"%x,",HKDATA[num + 7+4]); 
19236:  MOVLW  07
19238:  ADDWF  x4C,W
1923A:  ADDLW  04
1923C:  CLRF   03
1923E:  ADDLW  7D
19240:  MOVWF  FE9
19242:  MOVLW  02
19244:  ADDWFC 03,W
19246:  MOVWF  FEA
19248:  MOVFF  FEF,3A2
1924C:  MOVLW  57
1924E:  MOVWF  xA3
19250:  MOVLB  0
19252:  CALL   0700
19256:  MOVLW  2C
19258:  BTFSS  F9E.4
1925A:  BRA    19258
1925C:  MOVWF  FAD
1925E:  MOVLB  3
19260:  INCF   x4C,F
19262:  BRA    191F8
....................    } 
....................    FAB_DATA = 0;                                                                 //pone a cero la bandera 
19264:  MOVLB  2
19266:  CLRF   xF9
....................    return; 
19268:  MOVLB  0
1926A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void VERIFY_FABDATA(int32 delaytime1,int32 delaytime2) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
1926C:  MOVLB  3
1926E:  CLRF   x46
19270:  MOVF   x46,W
19272:  SUBLW  02
19274:  BNC   19324
....................    { 
....................       COMMAND_TO_FAB(delaytime1);                                                //funcion que envia comando al FAB y carga el array in_HK[] 
19276:  MOVFF  341,34A
1927A:  MOVFF  340,349
1927E:  MOVFF  33F,348
19282:  MOVFF  33E,347
19286:  MOVLB  0
19288:  CALL   1A9A
....................       CHECK_50_and_CW_RESPOND(); 
1928C:  CALL   1A72
....................       //FAB_DATA = 0; 
....................       if(in_HK[0] == 0x33)                                                       //gather sensor data by interrupt 
19290:  MOVLB  2
19292:  MOVF   x50,W
19294:  SUBLW  33
19296:  BNZ   192C2
....................       { 
....................          CHECK_HKDATA(2,delaytime2);                                             //funcion que carga el array HKDATA[118]  
19298:  MOVLW  02
1929A:  MOVLB  3
1929C:  MOVWF  x47
1929E:  MOVFF  345,34B
192A2:  MOVFF  344,34A
192A6:  MOVFF  343,349
192AA:  MOVFF  342,348
192AE:  MOVLB  0
192B0:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
192B2:  CALL   1A72
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
192B6:  MOVLW  01
192B8:  MOVLB  3
192BA:  MOVWF  x00
....................          break; 
192BC:  BRA    19324
....................       }else if(in_HK[1] == 0x33){ 
192BE:  BRA    1931C
192C0:  MOVLB  2
192C2:  MOVF   x51,W
192C4:  SUBLW  33
192C6:  BNZ   192F2
....................          //delay_ms(200); 
....................          CHECK_HKDATA(1,delaytime2); 
192C8:  MOVLW  01
192CA:  MOVLB  3
192CC:  MOVWF  x47
192CE:  MOVFF  345,34B
192D2:  MOVFF  344,34A
192D6:  MOVFF  343,349
192DA:  MOVFF  342,348
192DE:  MOVLB  0
192E0:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
192E2:  CALL   1A72
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
192E6:  MOVLW  01
192E8:  MOVLB  3
192EA:  MOVWF  x00
....................          break; 
192EC:  BRA    19324
....................       }else if(in_HK[2] == 0x33){ 
192EE:  BRA    1931C
192F0:  MOVLB  2
192F2:  MOVF   x52,W
192F4:  SUBLW  33
192F6:  BNZ   1931E
....................          //delay_ms(200); 
....................          CHECK_HKDATA(0,delaytime2); 
192F8:  MOVLB  3
192FA:  CLRF   x47
192FC:  MOVFF  345,34B
19300:  MOVFF  344,34A
19304:  MOVFF  343,349
19308:  MOVFF  342,348
1930C:  MOVLB  0
1930E:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
19310:  CALL   1A72
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
19314:  MOVLW  01
19316:  MOVLB  3
19318:  MOVWF  x00
....................          break; 
1931A:  BRA    19324
1931C:  MOVLB  2
....................       } 
1931E:  MOVLB  3
19320:  INCF   x46,F
19322:  BRA    19270
....................    } 
....................    return; 
19324:  MOVLB  0
19326:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void GET_RESET_DATA()                                                            //funcion que carga el array HKDATA con los datos del Reset PIC 
.................... { 
....................    RESET_DATA = 0; 
19328:  CLRF   x9D
....................    for(int i = 0; i < 6; i++) 
1932A:  MOVLB  3
1932C:  CLRF   x3E
1932E:  MOVF   x3E,W
19330:  SUBLW  05
19332:  BNC   1934C
....................    { 
....................       COLLECT_RESET_DATA(); 
19334:  MOVLB  0
19336:  CALL   16860
....................       if(reset_bffr[0] == 0x8e) 
1933A:  MOVF   x9E,W
1933C:  SUBLW  8E
1933E:  BNZ   19346
....................       { 
....................          break; 
19340:  MOVLB  3
19342:  BRA    1934C
19344:  MOVLB  0
....................       } 
19346:  MOVLB  3
19348:  INCF   x3E,F
1934A:  BRA    1932E
....................    }    
....................    CHECK_50_and_CW_RESPOND(); 
1934C:  MOVLB  0
1934E:  CALL   1A72
....................    if(RESET_bffr[0] == 0x8e)                                                     //si el byte de cabecera es el correcto 
19352:  MOVF   x9E,W
19354:  SUBLW  8E
19356:  BNZ   1943A
....................    { 
....................       fprintf(PC,"\r\nRESET DATA OBTAINED\r\n"); 
19358:  MOVLW  20
1935A:  MOVWF  FF6
1935C:  MOVLW  0F
1935E:  MOVWF  FF7
19360:  MOVLW  00
19362:  MOVWF  FF8
19364:  CALL   06A4
....................       for(int num = 0; num < 5; num++)                                           //carga el array HKDATA con timedata en las posiciones 2 al 6 
19368:  MOVLB  3
1936A:  CLRF   x3F
1936C:  MOVF   x3F,W
1936E:  SUBLW  04
19370:  BNC   193D0
....................       { 
....................          HKDATA[num + 2] = reset_bffr[num + 1]; 
19372:  MOVLW  02
19374:  ADDWF  x3F,W
19376:  CLRF   03
19378:  ADDLW  7D
1937A:  MOVWF  01
1937C:  MOVLW  02
1937E:  ADDWFC 03,F
19380:  MOVFF  03,341
19384:  MOVLW  01
19386:  ADDWF  x3F,W
19388:  CLRF   03
1938A:  ADDLW  9E
1938C:  MOVWF  FE9
1938E:  MOVLW  00
19390:  ADDWFC 03,W
19392:  MOVWF  FEA
19394:  MOVFF  FEF,342
19398:  MOVFF  341,FEA
1939C:  MOVFF  01,FE9
193A0:  MOVFF  342,FEF
....................          /* 
....................          fputc(HKDATA[num + 2],PC); 
....................          */ 
....................          fprintf(PC,"%x,",HKDATA[num + 2]);                                      //parte del test con serial monitor 
193A4:  MOVLW  02
193A6:  ADDWF  x3F,W
193A8:  CLRF   03
193AA:  ADDLW  7D
193AC:  MOVWF  FE9
193AE:  MOVLW  02
193B0:  ADDWFC 03,W
193B2:  MOVWF  FEA
193B4:  MOVFF  FEF,3A2
193B8:  MOVLW  57
193BA:  MOVWF  xA3
193BC:  MOVLB  0
193BE:  CALL   0700
193C2:  MOVLW  2C
193C4:  BTFSS  F9E.4
193C6:  BRA    193C4
193C8:  MOVWF  FAD
193CA:  MOVLB  3
193CC:  INCF   x3F,F
193CE:  BRA    1936C
....................       } 
....................     
....................       for(num = 0; num < 5; num++)                                               //carga el array HKDATA con reset sensor data en las posiciones 110 al 114 
193D0:  CLRF   x3F
193D2:  MOVF   x3F,W
193D4:  SUBLW  04
193D6:  BNC   19436
....................       { 
....................          HKDATA[num + 116] = reset_bffr[num + 6];                                //carga el HKDATA[] con los datos del reset[] 
193D8:  MOVLW  74
193DA:  ADDWF  x3F,W
193DC:  CLRF   03
193DE:  ADDLW  7D
193E0:  MOVWF  01
193E2:  MOVLW  02
193E4:  ADDWFC 03,F
193E6:  MOVFF  03,341
193EA:  MOVLW  06
193EC:  ADDWF  x3F,W
193EE:  CLRF   03
193F0:  ADDLW  9E
193F2:  MOVWF  FE9
193F4:  MOVLW  00
193F6:  ADDWFC 03,W
193F8:  MOVWF  FEA
193FA:  MOVFF  FEF,342
193FE:  MOVFF  341,FEA
19402:  MOVFF  01,FE9
19406:  MOVFF  342,FEF
....................          /* 
....................          fputc(HKDATA[num + 116],PC); 
....................          */ 
....................          fprintf(PC,"%x,",HKDATA[num + 116]);                                    //parte del test con serial monitor 
1940A:  MOVLW  74
1940C:  ADDWF  x3F,W
1940E:  CLRF   03
19410:  ADDLW  7D
19412:  MOVWF  FE9
19414:  MOVLW  02
19416:  ADDWFC 03,W
19418:  MOVWF  FEA
1941A:  MOVFF  FEF,3A2
1941E:  MOVLW  57
19420:  MOVWF  xA3
19422:  MOVLB  0
19424:  CALL   0700
19428:  MOVLW  2C
1942A:  BTFSS  F9E.4
1942C:  BRA    1942A
1942E:  MOVWF  FAD
19430:  MOVLB  3
19432:  INCF   x3F,F
19434:  BRA    193D2
....................       } 
....................    }else{ 
19436:  BRA    1944C
19438:  MOVLB  0
....................       fprintf(PC,"\r\nRESET DATA NO OBTAINED\r\n"); 
1943A:  MOVLW  38
1943C:  MOVWF  FF6
1943E:  MOVLW  0F
19440:  MOVWF  FF7
19442:  MOVLW  00
19444:  MOVWF  FF8
19446:  CALL   06A4
1944A:  MOVLB  3
....................    } 
....................    //Delete_Reset(); 
....................    return; 
1944C:  MOVLB  0
1944E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_ADCS_HKDATA()                                                          //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
.................... { 
....................    GET_ADCS_SENSOR_DATA();                                                       //funcion que carga el array ADCS_SENSOR_DATA[] con los datos del ADCS 
*
1955E:  RCALL  19450
....................    CHECK_50_and_CW_RESPOND();    
19560:  CALL   1A72
....................    for(int num = 53; num < 113; num++)                                           //12byte(MAG6,GYRO6)+48byte(GPS) = 60 
19564:  MOVLW  35
19566:  MOVLB  3
19568:  MOVWF  x3E
1956A:  MOVF   x3E,W
1956C:  SUBLW  70
1956E:  BNC   195A4
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 52];                                  //ADCS[1] to ADCS[60] 
19570:  CLRF   03
19572:  MOVF   x3E,W
19574:  ADDLW  7D
19576:  MOVWF  01
19578:  MOVLW  02
1957A:  ADDWFC 03,F
1957C:  MOVFF  03,341
19580:  MOVLW  34
19582:  SUBWF  x3E,W
19584:  CLRF   03
19586:  ADDLW  FB
19588:  MOVWF  FE9
1958A:  MOVLW  01
1958C:  ADDWFC 03,W
1958E:  MOVWF  FEA
19590:  MOVFF  FEF,342
19594:  MOVFF  341,FEA
19598:  MOVFF  01,FE9
1959C:  MOVFF  342,FEF
195A0:  INCF   x3E,F
195A2:  BRA    1956A
....................    } 
....................    for(int n = 1; n < 61; n++)                                             // SHOW IN SERIAL MONITOR 12byte(MAG6,GYRO6)+48byte(GPS) = 60 
195A4:  MOVLW  01
195A6:  MOVWF  x3F
195A8:  MOVF   x3F,W
195AA:  SUBLW  3C
195AC:  BNC   195D8
....................    { 
....................       fprintf(PC,"%x,",ADCS_SENSOR_DATA[n]);                                    //ADCS[1] to ADCS[60] 
195AE:  CLRF   03
195B0:  MOVF   x3F,W
195B2:  ADDLW  FB
195B4:  MOVWF  FE9
195B6:  MOVLW  01
195B8:  ADDWFC 03,W
195BA:  MOVWF  FEA
195BC:  MOVFF  FEF,3A2
195C0:  MOVLW  57
195C2:  MOVWF  xA3
195C4:  MOVLB  0
195C6:  CALL   0700
195CA:  MOVLW  2C
195CC:  BTFSS  F9E.4
195CE:  BRA    195CC
195D0:  MOVWF  FAD
195D2:  MOVLB  3
195D4:  INCF   x3F,F
195D6:  BRA    195A8
....................                                  
....................    } 
....................     
....................    //!   for(num = 65; num < 107; num++)                                            //60byte(GPS) 
....................    //!   { 
....................    //!      HKDATA[num] = ADCS_SENSOR_DATA[num - 34];//HKDATA[54] = ADCS_SENSOR_DATA[21]-->ADCS[21] to ADCS[62] 
....................    //!   } 
....................    return; 
195D8:  MOVLB  0
195DA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void DISPLAY_CW()                                                                //funcion que imprime el array CW_FORMAT[] 
.................... { 
....................    fprintf(PC,"\r\nCW:\r\n"); 
*
19A08:  MOVLW  54
19A0A:  MOVWF  FF6
19A0C:  MOVLW  0F
19A0E:  MOVWF  FF7
19A10:  MOVLW  00
19A12:  MOVWF  FF8
19A14:  CALL   06A4
....................    for(int8 i = 0; i < 5; i++) 
19A18:  MOVLB  3
19A1A:  CLRF   x2E
19A1C:  MOVF   x2E,W
19A1E:  SUBLW  04
19A20:  BNC   19A44
....................    { 
....................       fprintf(PC,"%x",CW_FORMAT[i]); 
19A22:  CLRF   03
19A24:  MOVF   x2E,W
19A26:  ADDLW  4B
19A28:  MOVWF  FE9
19A2A:  MOVLW  02
19A2C:  ADDWFC 03,W
19A2E:  MOVWF  FEA
19A30:  MOVFF  FEF,3A2
19A34:  MOVLW  57
19A36:  MOVWF  xA3
19A38:  MOVLB  0
19A3A:  CALL   0700
19A3E:  MOVLB  3
19A40:  INCF   x2E,F
19A42:  BRA    19A1C
....................    } 
....................    fprintf(PC,"\r\n"); 
19A44:  MOVLW  0D
19A46:  BTFSS  F9E.4
19A48:  BRA    19A46
19A4A:  MOVWF  FAD
19A4C:  MOVLW  0A
19A4E:  BTFSS  F9E.4
19A50:  BRA    19A4E
19A52:  MOVWF  FAD
....................    CHECK_50_and_CW_RESPOND();    
19A54:  MOVLB  0
19A56:  CALL   1A72
....................    return; 
19A5A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SET_IDENTIFIER() 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
*
199DA:  CALL   1A72
....................    HKDATA[0] = 0x33; 
199DE:  MOVLW  33
199E0:  MOVLB  2
199E2:  MOVWF  x7D
....................    HKDATA[1] = 0x33; 
199E4:  MOVWF  x7E
....................    HKDATA[7] = 0xAA; 
199E6:  MOVLW  AA
199E8:  MOVWF  x84
....................    HKDATA[8] = 0xAA; 
199EA:  MOVWF  x85
....................    HKDATA[9] = 0xAA; 
199EC:  MOVWF  x86
....................    HKDATA[50] = 0xBB; 
199EE:  MOVLW  BB
199F0:  MOVWF  xAF
....................    HKDATA[51] = 0xBB; 
199F2:  MOVWF  xB0
....................    HKDATA[52] = 0xBB; 
199F4:  MOVWF  xB1
....................    HKDATA[113] = 0xCC; 
199F6:  MOVLW  CC
199F8:  MOVWF  xEE
....................    HKDATA[114] = 0xCC; 
199FA:  MOVWF  xEF
....................    HKDATA[115] = 0xCC; 
199FC:  MOVWF  xF0
....................    HKDATA[122] = 0x44; 
199FE:  MOVLW  44
19A00:  MOVWF  xF7
....................    HKDATA[123] = 0x44; 
19A02:  MOVWF  xF8
....................    return; 
19A04:  MOVLB  0
19A06:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void FAB_TEST_OPERATION() 
.................... { 
....................    Delete_in_HK();                                                               //Borra el array in_HK[124] 
*
19CDA:  CALL   190C8
....................    LOOP_FAB_HK_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
19CDE:  CALL   1571A
....................    LOOP_FAB_CW_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CE2:  CALL   186A
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CE6:  CALL   1A72
....................    LOOP_FAB_HK_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CEA:  CALL   1571A
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CEE:  CALL   1A72
....................    LOOP_FAB_CW_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CF2:  CALL   186A
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CF6:  CALL   1A72
....................    Turn_ON_ADCS();                                                               //turn ON ADCS, RD6 = HIGH                                                                
19CFA:  CALL   1223A
....................    //fprintf(PC,"FAB communication start\r\n"); 
....................    waiting(200000);                                                              //wait function, about 200.000=1s 
19CFE:  MOVLB  3
19D00:  CLRF   x88
19D02:  MOVLW  03
19D04:  MOVWF  x87
19D06:  MOVLW  0D
19D08:  MOVWF  x86
19D0A:  MOVLW  40
19D0C:  MOVWF  x85
19D0E:  MOVLB  0
19D10:  CALL   16822
....................    FAB_MEASUERING_FLAG++;                                                        //count until 7(it means 10 min) 
19D14:  MOVLB  2
19D16:  INCF   xFA,F
....................    FAB_DATA = 0;                                                                 //for initialize 
19D18:  CLRF   xF9
....................     
....................    //   fprintf(PC,"SENDING COMMAND TO FAB\r\n"); 
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19D1A:  MOVLB  0
19D1C:  CALL   1A72
....................    VERIFY_FABDATA(130000,2000);//delaytime1 and delaytime2                       //envia comando al FAB y Carga el array in_HK[] con los datos del FAB 
19D20:  MOVLB  3
19D22:  CLRF   x41
19D24:  MOVLW  01
19D26:  MOVWF  x40
19D28:  MOVLW  FB
19D2A:  MOVWF  x3F
19D2C:  MOVLW  D0
19D2E:  MOVWF  x3E
19D30:  CLRF   x45
19D32:  CLRF   x44
19D34:  MOVLW  07
19D36:  MOVWF  x43
19D38:  MOVLW  D0
19D3A:  MOVWF  x42
19D3C:  MOVLB  0
19D3E:  CALL   1926C
....................    CHECK_50_and_CW_RESPOND(); 
19D42:  CALL   1A72
....................     
....................    GET_RESET_DATA();                                                             //envia comando al reset PIC y Carga el array HKDATA[] con los datos del Reset PIC 
19D46:  CALL   19328
....................     
....................    MAKE_ADCS_HKDATA();                                                           //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
19D4A:  RCALL  1955E
....................     
....................    // Turn_OFF_ADCS();                                                              //ADCS switch OFF, RD6=0 
....................    CHECK_50_and_CW_RESPOND(); 
19D4C:  CALL   1A72
....................    MAKE_CW_FORMAT();                                                             //make CW format 
19D50:  RCALL  199CE
....................    CHECK_50_and_CW_RESPOND();    
19D52:  CALL   1A72
....................    SET_IDENTIFIER();                                                             //carga el HKDATA[] con los identificadores   
19D56:  RCALL  199DA
....................    if(CHECK_FAB_RESPONSE)                                                        //Si HKDATA[] se cargo con los datos del FAB y realizado el CW format 
19D58:  MOVLB  3
19D5A:  MOVF   x00,F
19D5C:  BTFSC  FD8.2
19D5E:  BRA    19EEC
....................    { 
....................       fprintf(PC,"\r\nCollecting HK and Making CWFormat Done\r\n"); 
19D60:  MOVLW  5C
19D62:  MOVWF  FF6
19D64:  MOVLW  0F
19D66:  MOVWF  FF7
19D68:  MOVLW  00
19D6A:  MOVWF  FF8
19D6C:  MOVLB  0
19D6E:  CALL   06A4
....................  
....................       fprintf(PC,"\r\nHK data:\r\n"); 
19D72:  MOVLW  88
19D74:  MOVWF  FF6
19D76:  MOVLW  0F
19D78:  MOVWF  FF7
19D7A:  MOVLW  00
19D7C:  MOVWF  FF8
19D7E:  CALL   06A4
....................  
....................       CHECK_50_and_CW_RESPOND(); 
19D82:  CALL   1A72
....................        
....................       for(int num = 0; num < 65; num++)                                          //array[0] to [64](until gyro data) 
19D86:  MOVLB  3
19D88:  CLRF   x2C
19D8A:  MOVF   x2C,W
19D8C:  SUBLW  40
19D8E:  BNC   19DBA
....................       { 
....................          fprintf(PC,"%x,",HKDATA[num]); 
19D90:  CLRF   03
19D92:  MOVF   x2C,W
19D94:  ADDLW  7D
19D96:  MOVWF  FE9
19D98:  MOVLW  02
19D9A:  ADDWFC 03,W
19D9C:  MOVWF  FEA
19D9E:  MOVFF  FEF,3A2
19DA2:  MOVLW  57
19DA4:  MOVWF  xA3
19DA6:  MOVLB  0
19DA8:  CALL   0700
19DAC:  MOVLW  2C
19DAE:  BTFSS  F9E.4
19DB0:  BRA    19DAE
19DB2:  MOVWF  FAD
19DB4:  MOVLB  3
19DB6:  INCF   x2C,F
19DB8:  BRA    19D8A
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19DBA:  MOVLB  0
19DBC:  CALL   1A72
....................       for(num = 65; num < 113; num++)                                            //GPS 60 byte should be shown as char type 
19DC0:  MOVLW  41
19DC2:  MOVLB  3
19DC4:  MOVWF  x2C
19DC6:  MOVF   x2C,W
19DC8:  SUBLW  70
19DCA:  BNC   19DF6
....................       { 
....................          //fputc(HKDATA[num],PC); 
....................          fprintf(PC,"%x,",HKDATA[num]);                                          //solo para test 
19DCC:  CLRF   03
19DCE:  MOVF   x2C,W
19DD0:  ADDLW  7D
19DD2:  MOVWF  FE9
19DD4:  MOVLW  02
19DD6:  ADDWFC 03,W
19DD8:  MOVWF  FEA
19DDA:  MOVFF  FEF,3A2
19DDE:  MOVLW  57
19DE0:  MOVWF  xA3
19DE2:  MOVLB  0
19DE4:  CALL   0700
19DE8:  MOVLW  2C
19DEA:  BTFSS  F9E.4
19DEC:  BRA    19DEA
19DEE:  MOVWF  FAD
19DF0:  MOVLB  3
19DF2:  INCF   x2C,F
19DF4:  BRA    19DC6
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19DF6:  MOVLB  0
19DF8:  CALL   1A72
....................       for(num = 113; num < HK_Size; num++)                                       //array[113] to [124] 
19DFC:  MOVLW  71
19DFE:  MOVLB  3
19E00:  MOVWF  x2C
19E02:  MOVF   x2C,W
19E04:  SUBLW  7B
19E06:  BNC   19E36
....................       { 
....................          fprintf(PC,",%x",HKDATA[num]); 
19E08:  CLRF   03
19E0A:  MOVF   x2C,W
19E0C:  ADDLW  7D
19E0E:  MOVWF  FE9
19E10:  MOVLW  02
19E12:  ADDWFC 03,W
19E14:  MOVWF  FEA
19E16:  MOVFF  FEF,32E
19E1A:  MOVLW  2C
19E1C:  BTFSS  F9E.4
19E1E:  BRA    19E1C
19E20:  MOVWF  FAD
19E22:  MOVFF  32E,3A2
19E26:  MOVLW  57
19E28:  MOVWF  xA3
19E2A:  MOVLB  0
19E2C:  CALL   0700
19E30:  MOVLB  3
19E32:  INCF   x2C,F
19E34:  BRA    19E02
....................       }      
....................       CHECK_50_and_CW_RESPOND(); 
19E36:  MOVLB  0
19E38:  CALL   1A72
....................        
....................       DISPLAY_CW();                                                              //funcion que imprime el array CW_FORMAT[] 
19E3C:  RCALL  19A08
....................       CHECK_FAB_RESPONSE = 0;                                                    //bandera FAB a cero      
19E3E:  MOVLB  3
19E40:  CLRF   x00
....................       output_low(PIN_C4);                                                        //COM Flash memory Main side 
19E42:  BCF    F94.4
19E44:  BCF    F8B.4
....................       output_low(PIN_A5); 
19E46:  BCF    F92.5
19E48:  BCF    F89.5
....................       //sector_erase_SCF(65536*50); 
....................       //sector_erase_SCF(65536*51); 
....................       SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                        //guarda en COM flash el array HKDATA[] 
19E4A:  MOVFF  4B,341
19E4E:  MOVFF  4A,340
19E52:  MOVFF  49,33F
19E56:  MOVFF  48,33E
19E5A:  MOVLB  0
19E5C:  RCALL  19AB8
....................       SEND_HKDATA_to_SMF(FAB_HK_ADDRESS); 
19E5E:  MOVFF  4B,341
19E62:  MOVFF  4A,340
19E66:  MOVFF  49,33F
19E6A:  MOVFF  48,33E
19E6E:  RCALL  19B28
....................       SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                         //guarda en Main flash el array HKDATA[] 
19E70:  MOVFF  4B,341
19E74:  MOVFF  4A,340
19E78:  MOVFF  49,33F
19E7C:  MOVFF  48,33E
19E80:  RCALL  19B94
....................       SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS);                                      //guarda en COM flash el array CWFORMAT[] 
19E82:  MOVFF  4F,341
19E86:  MOVFF  4E,340
19E8A:  MOVFF  4D,33F
19E8E:  MOVFF  4C,33E
19E92:  RCALL  19C08
....................       SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
19E94:  MOVFF  4F,341
19E98:  MOVFF  4E,340
19E9C:  MOVFF  4D,33F
19EA0:  MOVFF  4C,33E
19EA4:  RCALL  19C78
....................       SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS);                                       //guarda en Main flash el array CWFORMAT[] 
19EA6:  MOVFF  4F,341
19EAA:  MOVFF  4E,340
19EAE:  MOVFF  4D,33F
19EB2:  MOVFF  4C,33E
19EB6:  RCALL  19CA0
....................       FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                                 //prepare for next storing address 
19EB8:  MOVLW  7C
19EBA:  ADDWF  48,F
19EBC:  MOVLW  00
19EBE:  ADDWFC 49,F
19EC0:  ADDWFC 4A,F
19EC2:  ADDWFC 4B,F
....................       FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                                 //prepare for next storing address 
19EC4:  MOVLW  05
19EC6:  ADDWF  4C,F
19EC8:  MOVLW  00
19ECA:  ADDWFC 4D,F
19ECC:  ADDWFC 4E,F
19ECE:  ADDWFC 4F,F
....................       fprintf(PC,"\r\nSENSORS DATA SAVED ON FLASH\r\n"); 
19ED0:  MOVLW  96
19ED2:  MOVWF  FF6
19ED4:  MOVLW  0F
19ED6:  MOVWF  FF7
19ED8:  MOVLW  00
19EDA:  MOVWF  FF8
19EDC:  CALL   06A4
....................       output_high(PIN_C4);                                                       //COM Flash memory COM side 
19EE0:  BCF    F94.4
19EE2:  BSF    F8B.4
....................       CHECK_50_and_CW_RESPOND(); 
19EE4:  CALL   1A72
....................    }else{ 
19EE8:  BRA    19FC0
19EEA:  MOVLB  3
....................       SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                        //guarda en COM flash el array HKDATA[] 
19EEC:  MOVFF  4B,341
19EF0:  MOVFF  4A,340
19EF4:  MOVFF  49,33F
19EF8:  MOVFF  48,33E
19EFC:  MOVLB  0
19EFE:  RCALL  19AB8
....................       SEND_HKDATA_to_SMF(FAB_HK_ADDRESS); 
19F00:  MOVFF  4B,341
19F04:  MOVFF  4A,340
19F08:  MOVFF  49,33F
19F0C:  MOVFF  48,33E
19F10:  RCALL  19B28
....................       SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                         //guarda en Main flash el array HKDATA[] 
19F12:  MOVFF  4B,341
19F16:  MOVFF  4A,340
19F1A:  MOVFF  49,33F
19F1E:  MOVFF  48,33E
19F22:  RCALL  19B94
....................       SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS);                                      //guarda en COM flash el array CWFORMAT[] 
19F24:  MOVFF  4F,341
19F28:  MOVFF  4E,340
19F2C:  MOVFF  4D,33F
19F30:  MOVFF  4C,33E
19F34:  RCALL  19C08
....................       SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
19F36:  MOVFF  4F,341
19F3A:  MOVFF  4E,340
19F3E:  MOVFF  4D,33F
19F42:  MOVFF  4C,33E
19F46:  RCALL  19C78
....................       SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS);                                       //guarda en Main flash el array CWFORMAT[] 
19F48:  MOVFF  4F,341
19F4C:  MOVFF  4E,340
19F50:  MOVFF  4D,33F
19F54:  MOVFF  4C,33E
19F58:  RCALL  19CA0
....................       FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                                 //prepare for next storing address 
19F5A:  MOVLW  7C
19F5C:  ADDWF  48,F
19F5E:  MOVLW  00
19F60:  ADDWFC 49,F
19F62:  ADDWFC 4A,F
19F64:  ADDWFC 4B,F
....................       FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                                 //prepare for next storing address 
19F66:  MOVLW  05
19F68:  ADDWF  4C,F
19F6A:  MOVLW  00
19F6C:  ADDWFC 4D,F
19F6E:  ADDWFC 4E,F
19F70:  ADDWFC 4F,F
....................       fprintf(PC,"NO RESPONSE FROM FAB\r\n\r\n");   
19F72:  MOVLW  B6
19F74:  MOVWF  FF6
19F76:  MOVLW  0F
19F78:  MOVWF  FF7
19F7A:  MOVLW  00
19F7C:  MOVWF  FF8
19F7E:  CALL   06A4
....................       CHECK_50_and_CW_RESPOND(); 
19F82:  CALL   1A72
....................       for(int num = 0; num < HK_size; num++) 
19F86:  MOVLB  3
19F88:  CLRF   x2D
19F8A:  MOVF   x2D,W
19F8C:  SUBLW  7B
19F8E:  BNC   19FBA
....................       { 
....................          fprintf(PC,"%x,",HKDATA[num]); 
19F90:  CLRF   03
19F92:  MOVF   x2D,W
19F94:  ADDLW  7D
19F96:  MOVWF  FE9
19F98:  MOVLW  02
19F9A:  ADDWFC 03,W
19F9C:  MOVWF  FEA
19F9E:  MOVFF  FEF,3A2
19FA2:  MOVLW  57
19FA4:  MOVWF  xA3
19FA6:  MOVLB  0
19FA8:  CALL   0700
19FAC:  MOVLW  2C
19FAE:  BTFSS  F9E.4
19FB0:  BRA    19FAE
19FB2:  MOVWF  FAD
19FB4:  MOVLB  3
19FB6:  INCF   x2D,F
19FB8:  BRA    19F8A
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19FBA:  MOVLB  0
19FBC:  CALL   1A72
....................     
....................    } 
....................     
....................    return; 
19FC0:  RETURN 0
.................... } 
.................... /* 
.................... void SAVE_ADCS_INITIAL_and_FINAL(int32 ADDRESS) 
.................... { 
....................    output_low(PIN_C4); 
....................    output_low(PIN_A5); 
....................    for(int i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................    for(i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................    for(i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................     
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 90; 
....................     
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 81; 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void GET_INITIAL_TIME() 
.................... { 
....................    COLLECT_RESET_DATA(); 
....................     
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS,0xdd);//header 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(int i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................     
....................    output_low(PIN_C4);//COM_MUX MAINSIDE 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS,0xdd);//header 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................    output_high(PIN_C4); 
....................     
....................    output_low(PIN_A5);//CAM_MUX MAINSIDE 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS,0xdd);//heade 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................     
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 9;//total 9byte for time info 
....................    //5 byte time info and 2 byte header and 2 byte footer 
....................    return; 
.................... } 
.................... */ 
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... /*void GET_ADCS_MSN_DATA() 
.................... { 
....................    int a = 1; 
....................    if(kbhit(ADCS)&&fgetc(ADCS) == 0x57) 
....................    { 
....................       for(int32 n= 0; n < 300000; n++) 
....................       { 
....................          if(kbhit(ADCS)) 
....................          { 
....................             ADCS_SENSOR_DATA[a] = fgetc(ADCS);//[1] to [72] 
....................             a++;//after input everything, a = 73 
....................          } 
....................          if(a == 73) 
....................          { 
....................             break; 
....................          } 
....................       } 
....................       for(int i = 76; i > 70 ; i--)//6 byte [76] to [70] --> Duty XYZ 
....................       { 
....................          ADCS_SENSOR_DATA[i] = ADCS_SENSOR_DATA[i-4];//ADCS_SENSOR_DATA[76] is ADCS_SENSOR_DATA[72] 
....................       } 
....................       for(i = 68; i > 20 ; i--)//48 byte [68] to [21] --> GPS 
....................       { 
....................          ADCS_SENSOR_DATA[i] = ADCS_SENSOR_DATA[i-2];//ADCS_SENSOR_DATA[68] is ADCS_SENSOR_DATA[66] 
....................       } 
....................           
....................       ADCS_SENSOR_DATA[0] = 0x57; 
....................       ADCS_SENSOR_DATA[19] = 0xee; 
....................       ADCS_SENSOR_DATA[20] = 0xee; 
....................       ADCS_SENSOR_DATA[69] = 0x58; 
....................       ADCS_SENSOR_DATA[70] = 0x58; 
....................       ADCS_SENSOR_DATA[77] = 0x59; 
....................              
....................       int8 a = (int8)(currenttime >> 8); 
....................       int8 b = (int8)(currenttime); 
....................       output_low(PIN_C4); 
....................       output_low(PIN_A5); 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................              
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+2,b); 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+2,b); 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+2,b); 
....................       for(i = 0; i < ADCS_SENSOR_SIZE; i++)// save everything to frash memory 
....................       { 
....................          WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................          WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................          WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................       } 
....................       output_high(PIN_C4); 
....................       fprintf(PC,"\r\n%ld,",currenttime); 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+3));//ack 
....................       fprintf(PC,","); 
....................              
....................       for(i = 4; i < 22; i++)// show the data-->Magnetometer XYZ, Gyro XYZ, Cur sensor XYZ 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          i++; 
....................          fprintf(PC,"%x,",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................              
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+22));//0xEE 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+23));//0xEE 
....................       fprintf(PC,","); 
....................              
....................       for(i = 24; i < 72; i++)// show the data(GPS)-->48byte 
....................       { 
....................          //fprintf(PC,"%c",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          fputc(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i),PC); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................              
....................       fprintf(PC,","); 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+84));//0x58 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+85));//0x58 
....................       fprintf(PC,","); 
....................              
....................       for(i = 74; i < ADCS_SENSOR_SIZE+2; i++)// show the duty data-->6byte 
....................       { 
....................          fprintf(PC,"%x,",(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i))); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................          i++; 
....................          fprintf(PC,"%x,",(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i))); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................       ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + ADCS_SENSOR_SIZE + 3; 
....................    } 
....................    return; 
.................... }*/ 
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... //OPERATION_MODE 
.................... /*#define NOMAL_ADCS_MSN 0x22*/ 
.................... #define NOMAL_ADCS_MSN 0x78                                                      //comando esperado por hisatsugu 
.................... #define AUTO_ADCS_MSN 0x27 
....................  
.................... //--------HIGH SAMPLING HK collection------------------------------------------ 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_HIGH_SAMP_FABDATA(int8 in)                                            //FAB sensor data collect 
.................... { 
....................    fprintf(PC,"\r\nFAB DATA OBTAINED\r\n"); 
*
1A83E:  MOVLW  D0
1A840:  MOVWF  FF6
1A842:  MOVLW  0F
1A844:  MOVWF  FF7
1A846:  MOVLW  00
1A848:  MOVWF  FF8
1A84A:  CALL   06A4
....................    Delete_HKDATA(); 
1A84E:  CALL   190EA
....................    for(int num = 1; num < 11; num++)                                             //Collect HK DATA 
1A852:  MOVLW  01
1A854:  MOVLB  3
1A856:  MOVWF  x44
1A858:  MOVF   x44,W
1A85A:  SUBLW  0A
1A85C:  BNC   1A8C0
....................    { 
....................       HKDATA[num + 5+4] = in_HK[num + 2 - in]; 
1A85E:  MOVLW  05
1A860:  ADDWF  x44,W
1A862:  ADDLW  04
1A864:  CLRF   03
1A866:  ADDLW  7D
1A868:  MOVWF  01
1A86A:  MOVLW  02
1A86C:  ADDWFC 03,F
1A86E:  MOVFF  03,346
1A872:  MOVLW  02
1A874:  ADDWF  x44,W
1A876:  BSF    FD8.0
1A878:  SUBFWB x43,W
1A87A:  CLRF   03
1A87C:  ADDLW  50
1A87E:  MOVWF  FE9
1A880:  MOVLW  02
1A882:  ADDWFC 03,W
1A884:  MOVWF  FEA
1A886:  MOVFF  FEF,347
1A88A:  MOVFF  346,FEA
1A88E:  MOVFF  01,FE9
1A892:  MOVFF  347,FEF
....................       fprintf(PC, "%x,", HKDATA[num]); 
1A896:  CLRF   03
1A898:  MOVF   x44,W
1A89A:  ADDLW  7D
1A89C:  MOVWF  FE9
1A89E:  MOVLW  02
1A8A0:  ADDWFC 03,W
1A8A2:  MOVWF  FEA
1A8A4:  MOVFF  FEF,3A2
1A8A8:  MOVLW  57
1A8AA:  MOVWF  xA3
1A8AC:  MOVLB  0
1A8AE:  CALL   0700
1A8B2:  MOVLW  2C
1A8B4:  BTFSS  F9E.4
1A8B6:  BRA    1A8B4
1A8B8:  MOVWF  FAD
1A8BA:  MOVLB  3
1A8BC:  INCF   x44,F
1A8BE:  BRA    1A858
....................    } 
....................    MEASURE_BC_TEMP(); 
1A8C0:  MOVLB  0
1A8C2:  CALL   1910C
....................    HKDATA[18] = BC_temp_data_h;                                                  //-X Panel Temp 
1A8C6:  MOVFF  305,28F
....................    HKDATA[19] = BC_temp_data_l;                                                  //-X Panel Temp 
1A8CA:  MOVFF  307,290
....................    for(num = 9; num < FAB_SENSOR_size - 2; num++)                                //[FAB] from CPLD temp to Kill status(array[20] to [49]) 
1A8CE:  MOVLW  09
1A8D0:  MOVLB  3
1A8D2:  MOVWF  x44
1A8D4:  MOVF   x44,W
1A8D6:  SUBLW  2A
1A8D8:  BNC   1A940
....................    { 
....................       HKDATA[num + 7+4] = in_HK[num + 2 - in]; 
1A8DA:  MOVLW  07
1A8DC:  ADDWF  x44,W
1A8DE:  ADDLW  04
1A8E0:  CLRF   03
1A8E2:  ADDLW  7D
1A8E4:  MOVWF  01
1A8E6:  MOVLW  02
1A8E8:  ADDWFC 03,F
1A8EA:  MOVFF  03,346
1A8EE:  MOVLW  02
1A8F0:  ADDWF  x44,W
1A8F2:  BSF    FD8.0
1A8F4:  SUBFWB x43,W
1A8F6:  CLRF   03
1A8F8:  ADDLW  50
1A8FA:  MOVWF  FE9
1A8FC:  MOVLW  02
1A8FE:  ADDWFC 03,W
1A900:  MOVWF  FEA
1A902:  MOVFF  FEF,347
1A906:  MOVFF  346,FEA
1A90A:  MOVFF  01,FE9
1A90E:  MOVFF  347,FEF
....................       fprintf(PC, "%x,", HKDATA[num + 7+4]); 
1A912:  MOVLW  07
1A914:  ADDWF  x44,W
1A916:  ADDLW  04
1A918:  CLRF   03
1A91A:  ADDLW  7D
1A91C:  MOVWF  FE9
1A91E:  MOVLW  02
1A920:  ADDWFC 03,W
1A922:  MOVWF  FEA
1A924:  MOVFF  FEF,3A2
1A928:  MOVLW  57
1A92A:  MOVWF  xA3
1A92C:  MOVLB  0
1A92E:  CALL   0700
1A932:  MOVLW  2C
1A934:  BTFSS  F9E.4
1A936:  BRA    1A934
1A938:  MOVWF  FAD
1A93A:  MOVLB  3
1A93C:  INCF   x44,F
1A93E:  BRA    1A8D4
....................    } 
....................    FAB_DATA = 0; 
1A940:  MOVLB  2
1A942:  CLRF   xF9
1A944:  MOVLB  0
1A946:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void VERIFY_HIGH_SAMP_FABDATA(int32 delaytime) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
1A948:  MOVLB  3
1A94A:  CLRF   x42
1A94C:  MOVF   x42,W
1A94E:  SUBLW  02
1A950:  BNC   1A9C2
....................    { 
....................       COMMAND_TO_FAB(delaytime); 
1A952:  MOVFF  341,34A
1A956:  MOVFF  340,349
1A95A:  MOVFF  33F,348
1A95E:  MOVFF  33E,347
1A962:  MOVLB  0
1A964:  CALL   1A9A
....................       //FAB_DATA = 0; 
....................       //waiting(1000); 
....................       if(in_HK[0] == 0x33)                                                       //gather sensor data by interrupt 
1A968:  MOVLB  2
1A96A:  MOVF   x50,W
1A96C:  SUBLW  33
1A96E:  BNZ   1A986
....................       { 
....................          CHECK_HIGH_SAMP_FABDATA(2); 
1A970:  MOVLW  02
1A972:  MOVLB  3
1A974:  MOVWF  x43
1A976:  MOVLB  0
1A978:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A97A:  MOVLW  01
1A97C:  MOVLB  3
1A97E:  MOVWF  x00
....................          break; 
1A980:  BRA    1A9C2
....................       }else if(in_HK[1] == 0x33){ 
1A982:  BRA    1A9B8
1A984:  MOVLB  2
1A986:  MOVF   x51,W
1A988:  SUBLW  33
1A98A:  BNZ   1A9A2
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(1); 
1A98C:  MOVLW  01
1A98E:  MOVLB  3
1A990:  MOVWF  x43
1A992:  MOVLB  0
1A994:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A996:  MOVLW  01
1A998:  MOVLB  3
1A99A:  MOVWF  x00
....................          break; 
1A99C:  BRA    1A9C2
....................       }else if(in_HK[2] == 0x33){ 
1A99E:  BRA    1A9B8
1A9A0:  MOVLB  2
1A9A2:  MOVF   x52,W
1A9A4:  SUBLW  33
1A9A6:  BNZ   1A9BA
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(0); 
1A9A8:  MOVLB  3
1A9AA:  CLRF   x43
1A9AC:  MOVLB  0
1A9AE:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A9B0:  MOVLW  01
1A9B2:  MOVLB  3
1A9B4:  MOVWF  x00
....................          break; 
1A9B6:  BRA    1A9C2
1A9B8:  MOVLB  2
....................       } 
....................       FAB_DATA = 0; 
1A9BA:  CLRF   xF9
1A9BC:  MOVLB  3
1A9BE:  INCF   x42,F
1A9C0:  BRA    1A94C
....................    } 
....................    return; 
1A9C2:  MOVLB  0
1A9C4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void GET_HIGH_SAMP_RESET_DATA() 
.................... { 
....................    RESET_DATA = 0; 
1A9C6:  CLRF   x9D
....................    COLLECT_RESET_DATA(); 
1A9C8:  CALL   16860
....................    if(RESET_bffr[0] == 0x8e) 
1A9CC:  MOVF   x9E,W
1A9CE:  SUBLW  8E
1A9D0:  BNZ   1AAA0
....................    { 
....................       fprintf(PC,"GET RESET\r\n"); 
1A9D2:  MOVLW  E6
1A9D4:  MOVWF  FF6
1A9D6:  MOVLW  0F
1A9D8:  MOVWF  FF7
1A9DA:  MOVLW  00
1A9DC:  MOVWF  FF8
1A9DE:  CALL   06A4
....................       for(int num = 0; num < 5; num++)                                           //timedata 
1A9E2:  MOVLB  3
1A9E4:  CLRF   x3E
1A9E6:  MOVF   x3E,W
1A9E8:  SUBLW  04
1A9EA:  BNC   1AA40
....................       { 
....................          HKDATA[num + 2] = reset_bffr[num + 1]; 
1A9EC:  MOVLW  02
1A9EE:  ADDWF  x3E,W
1A9F0:  CLRF   03
1A9F2:  ADDLW  7D
1A9F4:  MOVWF  01
1A9F6:  MOVLW  02
1A9F8:  ADDWFC 03,F
1A9FA:  MOVFF  03,340
1A9FE:  MOVLW  01
1AA00:  ADDWF  x3E,W
1AA02:  CLRF   03
1AA04:  ADDLW  9E
1AA06:  MOVWF  FE9
1AA08:  MOVLW  00
1AA0A:  ADDWFC 03,W
1AA0C:  MOVWF  FEA
1AA0E:  MOVFF  FEF,341
1AA12:  MOVFF  340,FEA
1AA16:  MOVFF  01,FE9
1AA1A:  MOVFF  341,FEF
....................          fputc(HKDATA[num + 2],PC); 
1AA1E:  MOVLW  02
1AA20:  ADDWF  x3E,W
1AA22:  CLRF   03
1AA24:  ADDLW  7D
1AA26:  MOVWF  FE9
1AA28:  MOVLW  02
1AA2A:  ADDWFC 03,W
1AA2C:  MOVWF  FEA
1AA2E:  MOVFF  FEF,33F
1AA32:  MOVF   x3F,W
1AA34:  MOVLB  0
1AA36:  CALL   01D2
1AA3A:  MOVLB  3
1AA3C:  INCF   x3E,F
1AA3E:  BRA    1A9E6
....................       } 
....................     
....................       for(num = 0; num < 5; num++)                                               //reset sensor data 
1AA40:  CLRF   x3E
1AA42:  MOVF   x3E,W
1AA44:  SUBLW  04
1AA46:  BNC   1AA9C
....................       { 
....................          HKDATA[num + 116] = reset_bffr[num + 6];                                //HKDATA[116] = reset[6] 
1AA48:  MOVLW  74
1AA4A:  ADDWF  x3E,W
1AA4C:  CLRF   03
1AA4E:  ADDLW  7D
1AA50:  MOVWF  01
1AA52:  MOVLW  02
1AA54:  ADDWFC 03,F
1AA56:  MOVFF  03,340
1AA5A:  MOVLW  06
1AA5C:  ADDWF  x3E,W
1AA5E:  CLRF   03
1AA60:  ADDLW  9E
1AA62:  MOVWF  FE9
1AA64:  MOVLW  00
1AA66:  ADDWFC 03,W
1AA68:  MOVWF  FEA
1AA6A:  MOVFF  FEF,341
1AA6E:  MOVFF  340,FEA
1AA72:  MOVFF  01,FE9
1AA76:  MOVFF  341,FEF
....................          fputc(HKDATA[num + 116],PC); 
1AA7A:  MOVLW  74
1AA7C:  ADDWF  x3E,W
1AA7E:  CLRF   03
1AA80:  ADDLW  7D
1AA82:  MOVWF  FE9
1AA84:  MOVLW  02
1AA86:  ADDWFC 03,W
1AA88:  MOVWF  FEA
1AA8A:  MOVFF  FEF,33F
1AA8E:  MOVF   x3F,W
1AA90:  MOVLB  0
1AA92:  CALL   01D2
1AA96:  MOVLB  3
1AA98:  INCF   x3E,F
1AA9A:  BRA    1AA42
....................       } 
....................    }else{ 
1AA9C:  BRA    1AAB2
1AA9E:  MOVLB  0
....................       fprintf(PC,"NO RESET\r\n"); 
1AAA0:  MOVLW  F2
1AAA2:  MOVWF  FF6
1AAA4:  MOVLW  0F
1AAA6:  MOVWF  FF7
1AAA8:  MOVLW  00
1AAAA:  MOVWF  FF8
1AAAC:  CALL   06A4
1AAB0:  MOVLB  3
....................    } 
1AAB2:  MOVLB  0
1AAB4:  RETURN 0
....................    //Delete_Reset(); 
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_HIGH_SAMP_ADCS_FORMAT() 
.................... { 
....................    GET_ADCS_SENSOR_DATA(); 
1AAB6:  CALL   19450
....................    for(int num = 53; num < 113; num++)                                           //12byte+48byte = 60 byte 
1AABA:  MOVLW  35
1AABC:  MOVLB  3
1AABE:  MOVWF  x3E
1AAC0:  MOVF   x3E,W
1AAC2:  SUBLW  70
1AAC4:  BNC   1AAFA
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 52];                                  //ADCS[1] to ADCS[60] 
1AAC6:  CLRF   03
1AAC8:  MOVF   x3E,W
1AACA:  ADDLW  7D
1AACC:  MOVWF  01
1AACE:  MOVLW  02
1AAD0:  ADDWFC 03,F
1AAD2:  MOVFF  03,340
1AAD6:  MOVLW  34
1AAD8:  SUBWF  x3E,W
1AADA:  CLRF   03
1AADC:  ADDLW  FB
1AADE:  MOVWF  FE9
1AAE0:  MOVLW  01
1AAE2:  ADDWFC 03,W
1AAE4:  MOVWF  FEA
1AAE6:  MOVFF  FEF,341
1AAEA:  MOVFF  340,FEA
1AAEE:  MOVFF  01,FE9
1AAF2:  MOVFF  341,FEF
1AAF6:  INCF   x3E,F
1AAF8:  BRA    1AAC0
....................    } 
....................    //!   for(num = 65; num < 107; num++) 
....................    //!   { 
....................    //!      HKDATA[num] = ADCS_SENSOR_DATA[num - 34];//HKDATA[54] = ADCS_SENSOR_DATA[21] 
....................    //!   } 
....................    return; 
1AAFA:  MOVLB  0
1AAFC:  RETURN 0
.................... } 
.................... /* 
.................... void MAKE_HIGH_SAMPLING_FORMAT() 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
....................    if(in_HK[0] == 0x33)//gather sensor data by interrupt 
....................    { 
....................       CHECK_HIGH_SAMP_FABDATA(2); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    }else if(in_HK[1] == 0x33){ 
....................       CHECK_HIGH_SAMP_FABDATA(1); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    }else if(in_HK[2] == 0x33){; 
....................       CHECK_HIGH_SAMP_FABDATA(0); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    } 
....................  
....................    CHECK_50_and_CW_RESPOND(); 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       for(int num = 0; num < 5; num++)//timedata 
....................       { 
....................          HKDATA[num] = reset_bffr[num + 1]; 
....................          //fputc(HKDATA[num],PC); 
....................       } 
....................     
....................       for(num = 0; num < 5; num++)//reset sensor data 
....................       { 
....................          HKDATA[num + 91] = reset_bffr[num + 6]; 
....................          //fputc(HKDATA[num + 91],PC); 
....................       } 
....................    } 
....................     
....................    CHECK_50_and_CW_RESPOND(); 
....................    for(int num = 0; num < 12; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 38] = ADCS_SENSOR_DATA[num]; 
....................    } 
....................    for(num = 0; num < 41; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 50] = ADCS_SENSOR_DATA[num + 21]; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY() 
.................... { 
....................    output_low(PIN_C4); 
*
1A71E:  BCF    F94.4
1A720:  BCF    F8B.4
....................    CHECK_50_and_CW_RESPOND(); 
1A722:  CALL   1A72
....................    for(int i = 0; i < HIGH_SAMP_HK_size; i++) 
1A726:  MOVLB  3
1A728:  CLRF   x3E
1A72A:  MOVF   x3E,W
1A72C:  SUBLW  7B
1A72E:  BNC   1A776
....................    { 
....................       WRITE_DATA_BYTE_SCF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A730:  MOVF   x3E,W
1A732:  ADDWF  5C,W
1A734:  MOVWF  x3F
1A736:  MOVLW  00
1A738:  ADDWFC 5D,W
1A73A:  MOVWF  x40
1A73C:  MOVLW  00
1A73E:  ADDWFC 5E,W
1A740:  MOVWF  x41
1A742:  MOVLW  00
1A744:  ADDWFC 5F,W
1A746:  MOVWF  x42
1A748:  CLRF   03
1A74A:  MOVF   x3E,W
1A74C:  ADDLW  7D
1A74E:  MOVWF  FE9
1A750:  MOVLW  02
1A752:  ADDWFC 03,W
1A754:  MOVWF  FEA
1A756:  MOVFF  FEF,394
1A75A:  MOVFF  342,393
1A75E:  MOVFF  341,392
1A762:  MOVFF  340,391
1A766:  MOVFF  33F,390
1A76A:  MOVLB  0
1A76C:  CALL   11C0C
1A770:  MOVLB  3
1A772:  INCF   x3E,F
1A774:  BRA    1A72A
....................    } 
....................    output_high(PIN_C4);  
1A776:  BCF    F94.4
1A778:  BSF    F8B.4
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A77A:  MOVLB  0
1A77C:  CALL   1A72
....................    for(i = 0; i < HIGH_SAMP_HK_size; i++) 
1A780:  MOVLB  3
1A782:  CLRF   x3E
1A784:  MOVF   x3E,W
1A786:  SUBLW  7B
1A788:  BNC   1A7D0
....................    { 
....................       WRITE_DATA_BYTE_OF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A78A:  MOVF   x3E,W
1A78C:  ADDWF  5C,W
1A78E:  MOVWF  x3F
1A790:  MOVLW  00
1A792:  ADDWFC 5D,W
1A794:  MOVWF  x40
1A796:  MOVLW  00
1A798:  ADDWFC 5E,W
1A79A:  MOVWF  x41
1A79C:  MOVLW  00
1A79E:  ADDWFC 5F,W
1A7A0:  MOVWF  x42
1A7A2:  CLRF   03
1A7A4:  MOVF   x3E,W
1A7A6:  ADDLW  7D
1A7A8:  MOVWF  FE9
1A7AA:  MOVLW  02
1A7AC:  ADDWFC 03,W
1A7AE:  MOVWF  FEA
1A7B0:  MOVFF  FEF,394
1A7B4:  MOVFF  342,393
1A7B8:  MOVFF  341,392
1A7BC:  MOVFF  340,391
1A7C0:  MOVFF  33F,390
1A7C4:  MOVLB  0
1A7C6:  CALL   11B8C
1A7CA:  MOVLB  3
1A7CC:  INCF   x3E,F
1A7CE:  BRA    1A784
....................    } 
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A7D0:  MOVLB  0
1A7D2:  CALL   1A72
....................    output_low(PIN_A5); 
1A7D6:  BCF    F92.5
1A7D8:  BCF    F89.5
....................    for(i = 0; i < HIGH_SAMP_HK_size; i++) 
1A7DA:  MOVLB  3
1A7DC:  CLRF   x3E
1A7DE:  MOVF   x3E,W
1A7E0:  SUBLW  7B
1A7E2:  BNC   1A82A
....................    { 
....................       WRITE_DATA_BYTE_SMF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A7E4:  MOVF   x3E,W
1A7E6:  ADDWF  5C,W
1A7E8:  MOVWF  x3F
1A7EA:  MOVLW  00
1A7EC:  ADDWFC 5D,W
1A7EE:  MOVWF  x40
1A7F0:  MOVLW  00
1A7F2:  ADDWFC 5E,W
1A7F4:  MOVWF  x41
1A7F6:  MOVLW  00
1A7F8:  ADDWFC 5F,W
1A7FA:  MOVWF  x42
1A7FC:  CLRF   03
1A7FE:  MOVF   x3E,W
1A800:  ADDLW  7D
1A802:  MOVWF  FE9
1A804:  MOVLW  02
1A806:  ADDWFC 03,W
1A808:  MOVWF  FEA
1A80A:  MOVFF  FEF,394
1A80E:  MOVFF  342,393
1A812:  MOVFF  341,392
1A816:  MOVFF  340,391
1A81A:  MOVFF  33F,390
1A81E:  MOVLB  0
1A820:  CALL   11C8C
1A824:  MOVLB  3
1A826:  INCF   x3E,F
1A828:  BRA    1A7DE
....................    }   
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A82A:  MOVLB  0
1A82C:  CALL   1A72
....................    HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS + HIGH_SAMP_HK_size;              //prepare for next storing address 
1A830:  MOVLW  7C
1A832:  ADDWF  5C,F
1A834:  MOVLW  00
1A836:  ADDWFC 5D,F
1A838:  ADDWFC 5E,F
1A83A:  ADDWFC 5F,F
....................     
....................    return; 
1A83C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void HIGH_SAMP_FAB_OPERATION() 
.................... { 
....................    Turn_ON_ADCS(); 
*
1AAFE:  CALL   1223A
....................    CHECK_50_and_CW_RESPOND(); 
1AB02:  CALL   1A72
....................    HIGH_SAMP_FAB_MEASUERING_FLAG++;                                              //count until 90(it means 10 min) 
1AB06:  MOVLB  2
1AB08:  INCF   xFB,F
....................    //disable_interrupts(INT_rda2); 
....................    if(HIGH_SAMP_FAB_MEASUERING_FLAG > 17)                                        //HIGH_SAMP_FAB_MEASUERING_FLAG=18 --> 18*5 = 90 (sec) 
1AB0A:  MOVF   xFB,W
1AB0C:  SUBLW  11
1AB0E:  BTFSC  FD8.0
1AB10:  BRA    1AC3A
....................       { 
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1AB12:  MOVLB  0
1AB14:  CALL   1A72
....................           
....................          fprintf(PC,"\r\n\90sec\r\n"); 
1AB18:  MOVLW  FE
1AB1A:  MOVWF  FF6
1AB1C:  MOVLW  0F
1AB1E:  MOVWF  FF7
1AB20:  MOVLW  00
1AB22:  MOVWF  FF8
1AB24:  CALL   06A4
....................          Delete_in_HK();                                                         //delet HK array 
1AB28:  CALL   190C8
....................          VERIFY_FABDATA(10000,10);                                               //envia comando al FAB y Carga el array in_HK[] con los datos del FAB 
1AB2C:  MOVLB  3
1AB2E:  CLRF   x41
1AB30:  CLRF   x40
1AB32:  MOVLW  27
1AB34:  MOVWF  x3F
1AB36:  MOVLW  10
1AB38:  MOVWF  x3E
1AB3A:  CLRF   x45
1AB3C:  CLRF   x44
1AB3E:  CLRF   x43
1AB40:  MOVLW  0A
1AB42:  MOVWF  x42
1AB44:  MOVLB  0
1AB46:  CALL   1926C
....................          GET_RESET_DATA();                                                       //funcion que carga el array HKDATA con los datos del Reset PIC 
1AB4A:  CALL   19328
....................          MAKE_ADCS_HKDATA();                                                     //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
1AB4E:  CALL   1955E
....................          SET_IDENTIFIER(); 
1AB52:  CALL   199DA
....................          MAKE_CW_FORMAT(); 
1AB56:  CALL   199CE
....................          output_low(PIN_C4); 
1AB5A:  BCF    F94.4
1AB5C:  BCF    F8B.4
....................          output_low(PIN_A5); 
1AB5E:  BCF    F92.5
1AB60:  BCF    F89.5
....................           
....................          SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                     //save HK in COM flash memory 
1AB62:  MOVFF  4B,341
1AB66:  MOVFF  4A,340
1AB6A:  MOVFF  49,33F
1AB6E:  MOVFF  48,33E
1AB72:  CALL   19AB8
....................          SEND_HKDATA_to_SMF(FAB_HK_ADDRESS);                                     //save HK in Mission flash memory 
1AB76:  MOVFF  4B,341
1AB7A:  MOVFF  4A,340
1AB7E:  MOVFF  49,33F
1AB82:  MOVFF  48,33E
1AB86:  CALL   19B28
....................          SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                      //save HK in OBC flash memory 
1AB8A:  MOVFF  4B,341
1AB8E:  MOVFF  4A,340
1AB92:  MOVFF  49,33F
1AB96:  MOVFF  48,33E
1AB9A:  CALL   19B94
....................          SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS); 
1AB9E:  MOVFF  4F,341
1ABA2:  MOVFF  4E,340
1ABA6:  MOVFF  4D,33F
1ABAA:  MOVFF  4C,33E
1ABAE:  CALL   19C08
....................          SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
1ABB2:  MOVFF  4F,341
1ABB6:  MOVFF  4E,340
1ABBA:  MOVFF  4D,33F
1ABBE:  MOVFF  4C,33E
1ABC2:  CALL   19C78
....................          SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS); 
1ABC6:  MOVFF  4F,341
1ABCA:  MOVFF  4E,340
1ABCE:  MOVFF  4D,33F
1ABD2:  MOVFF  4C,33E
1ABD6:  CALL   19CA0
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1ABDA:  CALL   1A72
....................          FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                              //prepare for next storing address 
1ABDE:  MOVLW  7C
1ABE0:  ADDWF  48,F
1ABE2:  MOVLW  00
1ABE4:  ADDWFC 49,F
1ABE6:  ADDWFC 4A,F
1ABE8:  ADDWFC 4B,F
....................          FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                              //prepare for next storing address 
1ABEA:  MOVLW  05
1ABEC:  ADDWF  4C,F
1ABEE:  MOVLW  00
1ABF0:  ADDWFC 4D,F
1ABF2:  ADDWFC 4E,F
1ABF4:  ADDWFC 4F,F
....................           
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
1ABF6:  RCALL  1A71E
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1ABF8:  CALL   1A72
....................           
....................          fprintf(PC,"\r\nCOUNT:%d\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
1ABFC:  MOVLW  08
1ABFE:  MOVWF  FF6
1AC00:  MOVLW  10
1AC02:  MOVWF  FF7
1AC04:  MOVLW  00
1AC06:  MOVWF  FF8
1AC08:  MOVLW  08
1AC0A:  MOVLB  3
1AC0C:  MOVWF  xA2
1AC0E:  MOVLB  0
1AC10:  CALL   06CE
1AC14:  MOVFF  2FB,33E
1AC18:  MOVLW  18
1AC1A:  MOVLB  3
1AC1C:  MOVWF  x3F
1AC1E:  MOVLB  0
1AC20:  CALL   2404
1AC24:  MOVLW  0D
1AC26:  BTFSS  F9E.4
1AC28:  BRA    1AC26
1AC2A:  MOVWF  FAD
1AC2C:  MOVLW  0A
1AC2E:  BTFSS  F9E.4
1AC30:  BRA    1AC2E
1AC32:  MOVWF  FAD
....................          HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
1AC34:  MOVLB  2
1AC36:  CLRF   xFB
....................           
....................       }else{ 
1AC38:  BRA    1AD66
....................          Delete_in_HK();                                                         //delet HK array 
1AC3A:  MOVLB  0
1AC3C:  CALL   190C8
....................          GET_RESET_DATA();                                                       //funcion que carga el array HKDATA con los datos del Reset PIC 
1AC40:  CALL   19328
....................          VERIFY_HIGH_SAMP_FABDATA(10000);                                        //get FAB data    
1AC44:  MOVLB  3
1AC46:  CLRF   x41
1AC48:  CLRF   x40
1AC4A:  MOVLW  27
1AC4C:  MOVWF  x3F
1AC4E:  MOVLW  10
1AC50:  MOVWF  x3E
1AC52:  MOVLB  0
1AC54:  RCALL  1A948
....................          GET_HIGH_SAMP_RESET_DATA();                                             //get reset data 
1AC56:  RCALL  1A9C6
....................          MAKE_HIGH_SAMP_ADCS_FORMAT();                                           //get ADCS data 
1AC58:  RCALL  1AAB6
....................          SET_IDENTIFIER(); 
1AC5A:  CALL   199DA
....................          //MAKE_CW_FORMAT(); 
....................                
....................          fprintf(PC,"\r\n"); 
1AC5E:  MOVLW  0D
1AC60:  BTFSS  F9E.4
1AC62:  BRA    1AC60
1AC64:  MOVWF  FAD
1AC66:  MOVLW  0A
1AC68:  BTFSS  F9E.4
1AC6A:  BRA    1AC68
1AC6C:  MOVWF  FAD
....................          for(int num = 0; num < 65; num++)                                       //array[0] to [64](until gyro data) 
1AC6E:  MOVLB  3
1AC70:  CLRF   x3D
1AC72:  MOVF   x3D,W
1AC74:  SUBLW  40
1AC76:  BNC   1ACA2
....................          { 
....................             fprintf(PC,"%x,",HKDATA[num]); 
1AC78:  CLRF   03
1AC7A:  MOVF   x3D,W
1AC7C:  ADDLW  7D
1AC7E:  MOVWF  FE9
1AC80:  MOVLW  02
1AC82:  ADDWFC 03,W
1AC84:  MOVWF  FEA
1AC86:  MOVFF  FEF,3A2
1AC8A:  MOVLW  57
1AC8C:  MOVWF  xA3
1AC8E:  MOVLB  0
1AC90:  CALL   0700
1AC94:  MOVLW  2C
1AC96:  BTFSS  F9E.4
1AC98:  BRA    1AC96
1AC9A:  MOVWF  FAD
1AC9C:  MOVLB  3
1AC9E:  INCF   x3D,F
1ACA0:  BRA    1AC72
....................          } 
....................          CHECK_50_and_CW_RESPOND(); 
1ACA2:  MOVLB  0
1ACA4:  CALL   1A72
....................          for(num = 65; num < 113; num++) 
1ACA8:  MOVLW  41
1ACAA:  MOVLB  3
1ACAC:  MOVWF  x3D
1ACAE:  MOVF   x3D,W
1ACB0:  SUBLW  70
1ACB2:  BNC   1ACDE
....................          { 
....................           //fputc(HKDATA[num],PC); 
....................             fprintf(PC,"%x,",HKDATA[num]); 
1ACB4:  CLRF   03
1ACB6:  MOVF   x3D,W
1ACB8:  ADDLW  7D
1ACBA:  MOVWF  FE9
1ACBC:  MOVLW  02
1ACBE:  ADDWFC 03,W
1ACC0:  MOVWF  FEA
1ACC2:  MOVFF  FEF,3A2
1ACC6:  MOVLW  57
1ACC8:  MOVWF  xA3
1ACCA:  MOVLB  0
1ACCC:  CALL   0700
1ACD0:  MOVLW  2C
1ACD2:  BTFSS  F9E.4
1ACD4:  BRA    1ACD2
1ACD6:  MOVWF  FAD
1ACD8:  MOVLB  3
1ACDA:  INCF   x3D,F
1ACDC:  BRA    1ACAE
....................          } 
....................          CHECK_50_and_CW_RESPOND(); 
1ACDE:  MOVLB  0
1ACE0:  CALL   1A72
....................          for(num = 113; num < HK_Size; num++) 
1ACE4:  MOVLW  71
1ACE6:  MOVLB  3
1ACE8:  MOVWF  x3D
1ACEA:  MOVF   x3D,W
1ACEC:  SUBLW  7B
1ACEE:  BNC   1AD1E
....................          { 
....................             fprintf(PC,",%x",HKDATA[num]); 
1ACF0:  CLRF   03
1ACF2:  MOVF   x3D,W
1ACF4:  ADDLW  7D
1ACF6:  MOVWF  FE9
1ACF8:  MOVLW  02
1ACFA:  ADDWFC 03,W
1ACFC:  MOVWF  FEA
1ACFE:  MOVFF  FEF,33E
1AD02:  MOVLW  2C
1AD04:  BTFSS  F9E.4
1AD06:  BRA    1AD04
1AD08:  MOVWF  FAD
1AD0A:  MOVFF  33E,3A2
1AD0E:  MOVLW  57
1AD10:  MOVWF  xA3
1AD12:  MOVLB  0
1AD14:  CALL   0700
1AD18:  MOVLB  3
1AD1A:  INCF   x3D,F
1AD1C:  BRA    1ACEA
....................          }  
....................          CHECK_50_and_CW_RESPOND(); 
1AD1E:  MOVLB  0
1AD20:  CALL   1A72
....................           
....................          fprintf(PC,"\r\nCOUNT:%d\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
1AD24:  MOVLW  16
1AD26:  MOVWF  FF6
1AD28:  MOVLW  10
1AD2A:  MOVWF  FF7
1AD2C:  MOVLW  00
1AD2E:  MOVWF  FF8
1AD30:  MOVLW  08
1AD32:  MOVLB  3
1AD34:  MOVWF  xA2
1AD36:  MOVLB  0
1AD38:  CALL   06CE
1AD3C:  MOVFF  2FB,33E
1AD40:  MOVLW  18
1AD42:  MOVLB  3
1AD44:  MOVWF  x3F
1AD46:  MOVLB  0
1AD48:  CALL   2404
1AD4C:  MOVLW  0D
1AD4E:  BTFSS  F9E.4
1AD50:  BRA    1AD4E
1AD52:  MOVWF  FAD
1AD54:  MOVLW  0A
1AD56:  BTFSS  F9E.4
1AD58:  BRA    1AD56
1AD5A:  MOVWF  FAD
....................          CHECK_FAB_RESPONSE = 0; 
1AD5C:  MOVLB  3
1AD5E:  CLRF   x00
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
1AD60:  MOVLB  0
1AD62:  RCALL  1A71E
1AD64:  MOVLB  2
....................       }     
....................       //Delete_in_HK(); 
....................  
....................    FAB_DATA = 0; 
1AD66:  CLRF   xF9
....................    output_high(PIN_C4); 
1AD68:  BCF    F94.4
1AD6A:  BSF    F8B.4
....................  
....................    return; 
1AD6C:  MOVLB  0
1AD6E:  RETURN 0
.................... } 
....................  
....................  
.................... //--------CAM MISSION---------------------------------------------------------- 
.................... //#define STORE_TO_SING AA 
.................... ////////////////////////////////////////////////// 
.................... //CAM MISSION ID: 0x54                          // 
.................... //CAM ACK: 0x61                                 // 
.................... //CAM Finish Storing: 0x62                      // 
.................... ////////////////////////////////////////////////// 
....................  
.................... int8 CAM_ACK = 0; 
....................  
.................... #ORG 0x00019000 
.................... void Turn_On_CAM() 
.................... { 
....................    output_high(PIN_D7); 
*
1A462:  BCF    F95.7
1A464:  BSF    F8C.7
....................    return; 
1A466:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low(PIN_D7); 
*
190BC:  BCF    F95.7
190BE:  BCF    F8C.7
....................    return; 
190C0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_Command_to_CAM(int8 data)                                              //testing for EM integration 
.................... { 
....................    fputc(data,CAM); 
*
1A4CC:  MOVFF  338,339
1A4D0:  CALL   23BE
....................    fprintf(PC,"Command:%x\r\n",data); 
1A4D4:  MOVLW  24
1A4D6:  MOVWF  FF6
1A4D8:  MOVLW  10
1A4DA:  MOVWF  FF7
1A4DC:  MOVLW  00
1A4DE:  MOVWF  FF8
1A4E0:  MOVLW  08
1A4E2:  MOVLB  3
1A4E4:  MOVWF  xA2
1A4E6:  MOVLB  0
1A4E8:  CALL   06CE
1A4EC:  MOVFF  338,3A2
1A4F0:  MOVLW  57
1A4F2:  MOVLB  3
1A4F4:  MOVWF  xA3
1A4F6:  MOVLB  0
1A4F8:  CALL   0700
1A4FC:  MOVLW  0D
1A4FE:  BTFSS  F9E.4
1A500:  BRA    1A4FE
1A502:  MOVWF  FAD
1A504:  MOVLW  0A
1A506:  BTFSS  F9E.4
1A508:  BRA    1A506
1A50A:  MOVWF  FAD
....................    return; 
1A50C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CAM_SETTINGS() 
.................... { 
....................    //disable_interrupts(INT_rda);                                                // Main to PC 
....................    fprintf(PC,"CAM Start operation\r\n"); 
*
1A468:  MOVLW  32
1A46A:  MOVWF  FF6
1A46C:  MOVLW  10
1A46E:  MOVWF  FF7
1A470:  MOVLW  00
1A472:  MOVWF  FF8
1A474:  CALL   06A4
....................    COM_ONEBYTE_COMMAND = 0; 
1A478:  CLRF   x9A
....................    fprintf(PC,"Deleting 1 sector SMF Address 00080000\r\n"); 
1A47A:  MOVLW  48
1A47C:  MOVWF  FF6
1A47E:  MOVLW  10
1A480:  MOVWF  FF7
1A482:  MOVLW  00
1A484:  MOVWF  FF8
1A486:  CALL   06A4
....................    REFRESH_SECTOR_SMF(0x00,0x08,0x00,0x00);                                      //clear 1 sector MISSION flash CAM PART 
1A48A:  MOVLB  3
1A48C:  CLRF   x47
1A48E:  MOVLW  08
1A490:  MOVWF  x48
1A492:  CLRF   x49
1A494:  CLRF   x4A
1A496:  MOVLB  0
1A498:  CALL   16FE0
....................    output_high(PIN_A5);                                                          //turn on MUX (give access to CAM) 
1A49C:  BCF    F92.5
1A49E:  BSF    F89.5
....................    delay_ms(100); 
1A4A0:  MOVLW  64
1A4A2:  MOVLB  3
1A4A4:  MOVWF  x98
1A4A6:  MOVLB  0
1A4A8:  CALL   063E
....................    Turn_On_CAM();                                                                //Turn on CAM 
1A4AC:  RCALL  1A462
....................    fprintf(PC,"Turned On CAM and MUX CAM side\r\n"); 
1A4AE:  MOVLW  72
1A4B0:  MOVWF  FF6
1A4B2:  MOVLW  10
1A4B4:  MOVWF  FF7
1A4B6:  MOVLW  00
1A4B8:  MOVWF  FF8
1A4BA:  CALL   06A4
....................    delay_ms(10); 
1A4BE:  MOVLW  0A
1A4C0:  MOVLB  3
1A4C2:  MOVWF  x98
1A4C4:  MOVLB  0
1A4C6:  CALL   063E
....................    return; 
1A4CA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_10k()                                                    //check 10000 times (keep listening about 10 sec) 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
1A50E:  MOVLB  3
1A510:  CLRF   x3B
1A512:  CLRF   x3A
1A514:  CLRF   x39
1A516:  CLRF   x38
1A518:  MOVF   x3B,F
1A51A:  BNZ   1A556
1A51C:  MOVF   x3A,W
1A51E:  SUBLW  0F
1A520:  BNC   1A556
1A522:  BNZ   1A532
1A524:  MOVF   x39,W
1A526:  SUBLW  42
1A528:  BNC   1A556
1A52A:  BNZ   1A532
1A52C:  MOVF   x38,W
1A52E:  SUBLW  3F
1A530:  BNC   1A556
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
1A532:  BTFSC  F86.3
1A534:  BRA    1A544
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC    
1A536:  MOVLB  0
1A538:  CALL   1094
1A53C:  MOVFF  01,319
....................          break; 
1A540:  MOVLB  3
1A542:  BRA    1A556
....................       } 
1A544:  MOVLW  01
1A546:  ADDWF  x38,F
1A548:  BTFSC  FD8.0
1A54A:  INCF   x39,F
1A54C:  BTFSC  FD8.2
1A54E:  INCF   x3A,F
1A550:  BTFSC  FD8.2
1A552:  INCF   x3B,F
1A554:  BRA    1A518
....................       //delay_ms(1); 
....................    } 
....................    return; 
1A556:  MOVLB  0
1A558:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_30k()                                                    //check 30000 times (keep listening about 30 sec) 
.................... { 
....................    for(int32 num = 0; num < 3000000; num++)  
*
19054:  MOVLB  3
19056:  CLRF   x80
19058:  CLRF   x7F
1905A:  CLRF   x7E
1905C:  CLRF   x7D
1905E:  MOVF   x80,F
19060:  BNZ   1909C
19062:  MOVF   x7F,W
19064:  SUBLW  2D
19066:  BNC   1909C
19068:  BNZ   19078
1906A:  MOVF   x7E,W
1906C:  SUBLW  C6
1906E:  BNC   1909C
19070:  BNZ   19078
19072:  MOVF   x7D,W
19074:  SUBLW  BF
19076:  BNC   1909C
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
19078:  BTFSC  F86.3
1907A:  BRA    1908A
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC    
1907C:  MOVLB  0
1907E:  CALL   1094
19082:  MOVFF  01,319
....................          break; 
19086:  MOVLB  3
19088:  BRA    1909C
....................       } 
1908A:  MOVLW  01
1908C:  ADDWF  x7D,F
1908E:  BTFSC  FD8.0
19090:  INCF   x7E,F
19092:  BTFSC  FD8.2
19094:  INCF   x7F,F
19096:  BTFSC  FD8.2
19098:  INCF   x80,F
1909A:  BRA    1905E
....................       //delay_ms(1); 
....................    } 
....................    return; 
1909C:  MOVLB  0
1909E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_200k()                                                   //check 200000 times(keep listening about 200 sec) 
.................... { 
....................    for(int32 num = 0; num < 40000000; num++)  
*
1A55A:  MOVLB  3
1A55C:  CLRF   x3B
1A55E:  CLRF   x3A
1A560:  CLRF   x39
1A562:  CLRF   x38
1A564:  MOVF   x3B,W
1A566:  SUBLW  02
1A568:  BNC   1A59E
1A56A:  BNZ   1A57A
1A56C:  MOVF   x3A,W
1A56E:  SUBLW  62
1A570:  BNC   1A59E
1A572:  BNZ   1A57A
1A574:  MOVF   x39,W
1A576:  SUBLW  59
1A578:  BNC   1A59E
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
1A57A:  BTFSC  F86.3
1A57C:  BRA    1A58C
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC 
1A57E:  MOVLB  0
1A580:  CALL   1094
1A584:  MOVFF  01,319
....................          break; 
1A588:  MOVLB  3
1A58A:  BRA    1A59E
....................       } 
1A58C:  MOVLW  01
1A58E:  ADDWF  x38,F
1A590:  BTFSC  FD8.0
1A592:  INCF   x39,F
1A594:  BTFSC  FD8.2
1A596:  INCF   x3A,F
1A598:  BTFSC  FD8.2
1A59A:  INCF   x3B,F
1A59C:  BRA    1A564
....................       //delay_ms(1); 
....................    } 
....................    return; 
1A59E:  MOVLB  0
1A5A0:  RETURN 0
.................... } 
.................... /* 
.................... int8 ACK_from_CAM() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM | PC); 
....................    return ack; 
.................... } 
....................  
.................... void Transfer_Photo() //transfer photo from Shared Mission Flash to Shared COM Flash 
.................... { 
....................    output_low(PIN_A5); 
....................    output_low(PIN_C4); 
....................    TRANSFER_DATA_NBYTE_SMFtoSCF(0,CAM_ADDRESS,65536); //from: sector0, to: sector1, datasize: 64kbyte(this value is for testing) 
....................    CAM_ADDRESS = CAM_ADDRESS + 65536; 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void CAM_TEST_OPERATION(int8 mode)                                               //Integration Testing With CAM 
.................... { 
....................    CAM_SETTINGS();                                                               //Turn ON CAM, delete 1 sector SCF address 00080000, MUX CAM side 
*
1AD94:  CALL   1A468
....................    delay_ms(5000);                                                               //Time is necessary for CAM to be ready 
1AD98:  MOVLW  14
1AD9A:  MOVLB  3
1AD9C:  MOVWF  x38
1AD9E:  MOVLW  FA
1ADA0:  MOVWF  x98
1ADA2:  MOVLB  0
1ADA4:  CALL   063E
1ADA8:  MOVLB  3
1ADAA:  DECFSZ x38,F
1ADAC:  BRA    1AD9E
....................  
....................  
....................    fprintf(PC,"Sending hand shake Command to CAM\r\n"); 
1ADAE:  MOVLW  DE
1ADB0:  MOVWF  FF6
1ADB2:  MOVLW  10
1ADB4:  MOVWF  FF7
1ADB6:  MOVLW  00
1ADB8:  MOVWF  FF8
1ADBA:  MOVLB  0
1ADBC:  CALL   06A4
....................    delay_ms(10); 
1ADC0:  MOVLW  0A
1ADC2:  MOVLB  3
1ADC4:  MOVWF  x98
1ADC6:  MOVLB  0
1ADC8:  CALL   063E
....................    Send_Command_to_CAM(0x54);                                                    //CAM MISSION ID 
1ADCC:  MOVLW  54
1ADCE:  MOVLB  3
1ADD0:  MOVWF  x38
1ADD2:  MOVLB  0
1ADD4:  CALL   1A4CC
....................    //fputc(0x54,PC); 
....................    CHECK_ACK_FROM_CAM_10k();                                                     //keep listening about 10 sec 
1ADD8:  CALL   1A50E
....................     
....................    if(CAM_ACK == 0x61)                                                           //CAM ACK 
1ADDC:  MOVLB  3
1ADDE:  MOVF   x19,W
1ADE0:  SUBLW  61
1ADE2:  BTFSS  FD8.2
1ADE4:  BRA    1B088
....................    { 
....................       CAM_ACK = 0; 
1ADE6:  CLRF   x19
....................       LOOP_CAM_ADDRESS();                                                        //hace un loop en las posiciones de memoria para almacenar CAM data 
1ADE8:  MOVLB  0
1ADEA:  CALL   1587E
....................       fprintf(PC,"ACK received from CAM\r\n\r\n"); 
1ADEE:  MOVLW  02
1ADF0:  MOVWF  FF6
1ADF2:  MOVLW  11
1ADF4:  MOVWF  FF7
1ADF6:  MOVLW  00
1ADF8:  MOVWF  FF8
1ADFA:  CALL   06A4
....................       //delay_ms(1000); 
....................       fprintf(PC,"Sending CAM MODE data\r\n"); 
1ADFE:  MOVLW  1C
1AE00:  MOVWF  FF6
1AE02:  MOVLW  11
1AE04:  MOVWF  FF7
1AE06:  MOVLW  00
1AE08:  MOVWF  FF8
1AE0A:  CALL   06A4
....................       fputc(mode,CAM); 
1AE0E:  MOVFF  337,339
1AE12:  CALL   23BE
....................       CHECK_ACK_FROM_CAM_10k();                                                  //keep listening about 10 sec 
1AE16:  CALL   1A50E
....................       if(CAM_ACK == mode) 
1AE1A:  MOVLB  3
1AE1C:  MOVF   x37,W
1AE1E:  SUBWF  x19,W
1AE20:  BTFSS  FD8.2
1AE22:  BRA    1B086
....................       { 
....................             fprintf(PC,"Capturing and saving in SFM...\r\n\r\n"); 
1AE24:  MOVLW  34
1AE26:  MOVWF  FF6
1AE28:  MOVLW  11
1AE2A:  MOVWF  FF7
1AE2C:  MOVLW  00
1AE2E:  MOVWF  FF8
1AE30:  MOVLB  0
1AE32:  CALL   06A4
....................           
....................          CHECK_ACK_FROM_CAM_200k();                                              //keep listening about 200 sec 
1AE36:  CALL   1A55A
....................           
....................          if(CAM_ACK == 0x62)                                                     //CAM Finish Storing 
1AE3A:  MOVLB  3
1AE3C:  MOVF   x19,W
1AE3E:  SUBLW  62
1AE40:  BTFSS  FD8.2
1AE42:  BRA    1B070
....................          { 
....................             CAM_ACK = 0; 
1AE44:  CLRF   x19
....................             fprintf(PC,"PHOTO SAVING DONE\r\n");    
1AE46:  MOVLW  58
1AE48:  MOVWF  FF6
1AE4A:  MOVLW  11
1AE4C:  MOVWF  FF7
1AE4E:  MOVLW  00
1AE50:  MOVWF  FF8
1AE52:  MOVLB  0
1AE54:  CALL   06A4
....................             output_low(PIN_A5);                                                  //Mission Flash MUX Main side 
1AE58:  BCF    F92.5
1AE5A:  BCF    F89.5
....................             delay_ms(10); 
1AE5C:  MOVLW  0A
1AE5E:  MOVLB  3
1AE60:  MOVWF  x98
1AE62:  MOVLB  0
1AE64:  CALL   063E
....................             //TRANSFER_DATA_NBYTE_TOPC_SMF(0x00000000,256);                      //for checking 
....................             output_low(PIN_C4);                                                  //COM Flash MUX Main side 
1AE68:  BCF    F94.4
1AE6A:  BCF    F8B.4
....................             delay_ms(10); 
1AE6C:  MOVLW  0A
1AE6E:  MOVLB  3
1AE70:  MOVWF  x98
1AE72:  MOVLB  0
1AE74:  CALL   063E
....................             fprintf(PC,"Read and Transfer data from SMF TO SCF and OF Start\r\n"); 
1AE78:  MOVLW  6C
1AE7A:  MOVWF  FF6
1AE7C:  MOVLW  11
1AE7E:  MOVWF  FF7
1AE80:  MOVLW  00
1AE82:  MOVWF  FF8
1AE84:  CALL   06A4
....................             delay_ms(1000); 
1AE88:  MOVLW  04
1AE8A:  MOVLB  3
1AE8C:  MOVWF  x38
1AE8E:  MOVLW  FA
1AE90:  MOVWF  x98
1AE92:  MOVLB  0
1AE94:  CALL   063E
1AE98:  MOVLB  3
1AE9A:  DECFSZ x38,F
1AE9C:  BRA    1AE8E
....................              
....................             if(mode == 0xB0 || mode == 0xB1 || mode == 0xB2)                     //if CAM data size will be 2sectors 
1AE9E:  MOVF   x37,W
1AEA0:  SUBLW  B0
1AEA2:  BZ    1AEB0
1AEA4:  MOVF   x37,W
1AEA6:  SUBLW  B1
1AEA8:  BZ    1AEB0
1AEAA:  MOVF   x37,W
1AEAC:  SUBLW  B2
1AEAE:  BNZ   1AF8C
....................             { 
....................                sector_erase_SCF(CAM_ADDRESS);                                    //delete 1st sector 
1AEB0:  MOVFF  47,38C
1AEB4:  MOVFF  46,38B
1AEB8:  MOVFF  45,38A
1AEBC:  MOVFF  44,389
1AEC0:  MOVLB  0
1AEC2:  CALL   120B0
....................                sector_erase_SCF(CAM_ADDRESS + 65536);                            //delete 2nd sector 
1AEC6:  MOVFF  44,338
1AECA:  MOVLB  3
1AECC:  MOVFF  45,339
1AED0:  MOVLW  01
1AED2:  ADDWF  46,W
1AED4:  MOVWF  x3A
1AED6:  MOVLW  00
1AED8:  ADDWFC 47,W
1AEDA:  MOVWF  x3B
1AEDC:  MOVWF  x8C
1AEDE:  MOVFF  33A,38B
1AEE2:  MOVFF  45,38A
1AEE6:  MOVFF  44,389
1AEEA:  MOVLB  0
1AEEC:  CALL   120B0
....................                TRANSFER_DATA_NBYTE_SMFtoSCF(0x00080000,CAM_ADDRESS,80000);       //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AEF0:  MOVLB  3
1AEF2:  CLRF   x3B
1AEF4:  MOVLW  08
1AEF6:  MOVWF  x3A
1AEF8:  CLRF   x39
1AEFA:  CLRF   x38
1AEFC:  MOVFF  47,33F
1AF00:  MOVFF  46,33E
1AF04:  MOVFF  45,33D
1AF08:  MOVFF  44,33C
1AF0C:  CLRF   x43
1AF0E:  MOVLW  01
1AF10:  MOVWF  x42
1AF12:  MOVLW  38
1AF14:  MOVWF  x41
1AF16:  MOVLW  80
1AF18:  MOVWF  x40
1AF1A:  MOVLB  0
1AF1C:  CALL   13520
....................                TRANSFER_DATA_NBYTE_SMFtoOF(0x00080000,CAM_ADDRESS,80000);        //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AF20:  MOVLB  3
1AF22:  CLRF   x3B
1AF24:  MOVLW  08
1AF26:  MOVWF  x3A
1AF28:  CLRF   x39
1AF2A:  CLRF   x38
1AF2C:  MOVFF  47,33F
1AF30:  MOVFF  46,33E
1AF34:  MOVFF  45,33D
1AF38:  MOVFF  44,33C
1AF3C:  CLRF   x43
1AF3E:  MOVLW  01
1AF40:  MOVWF  x42
1AF42:  MOVLW  38
1AF44:  MOVWF  x41
1AF46:  MOVLW  80
1AF48:  MOVWF  x40
1AF4A:  MOVLB  0
1AF4C:  CALL   135B2
....................                TRANSFER_DATA_NBYTE_TOPC_SCF(CAM_ADDRESS,90000);                  //From(SCF): FROM CAM_ADDRESS To PC 
1AF50:  MOVFF  47,33B
1AF54:  MOVFF  46,33A
1AF58:  MOVFF  45,339
1AF5C:  MOVFF  44,338
1AF60:  MOVLB  3
1AF62:  CLRF   x3F
1AF64:  MOVLW  01
1AF66:  MOVWF  x3E
1AF68:  MOVLW  5F
1AF6A:  MOVWF  x3D
1AF6C:  MOVLW  90
1AF6E:  MOVWF  x3C
1AF70:  MOVLB  0
1AF72:  CALL   13644
....................                CAM_ADDRESS = CAM_ADDRESS + 65536*2;                              //se ubica en la nueva posicion, dos sectores adelante 
1AF76:  MOVLW  02
1AF78:  ADDWF  46,F
1AF7A:  MOVLW  00
1AF7C:  ADDWFC 47,F
....................                delay_ms(10); 
1AF7E:  MOVLW  0A
1AF80:  MOVLB  3
1AF82:  MOVWF  x98
1AF84:  MOVLB  0
1AF86:  CALL   063E
1AF8A:  MOVLB  3
....................             } 
....................             if(mode == 0xA0 || mode == 0xA1 || mode == 0xA2) 
1AF8C:  MOVF   x37,W
1AF8E:  SUBLW  A0
1AF90:  BZ    1AF9E
1AF92:  MOVF   x37,W
1AF94:  SUBLW  A1
1AF96:  BZ    1AF9E
1AF98:  MOVF   x37,W
1AF9A:  SUBLW  A2
1AF9C:  BNZ   1B06E
....................             { 
....................                sector_erase_SCF(CAM_ADDRESS);                                    //delete 1st sector 
1AF9E:  MOVFF  47,38C
1AFA2:  MOVFF  46,38B
1AFA6:  MOVFF  45,38A
1AFAA:  MOVFF  44,389
1AFAE:  MOVLB  0
1AFB0:  CALL   120B0
....................                sector_erase_SCF(CAM_ADDRESS + 65536);                            //delete 2nd sector 
1AFB4:  MOVFF  44,338
1AFB8:  MOVLB  3
1AFBA:  MOVFF  45,339
1AFBE:  MOVLW  01
1AFC0:  ADDWF  46,W
1AFC2:  MOVWF  x3A
1AFC4:  MOVLW  00
1AFC6:  ADDWFC 47,W
1AFC8:  MOVWF  x3B
1AFCA:  MOVWF  x8C
1AFCC:  MOVFF  33A,38B
1AFD0:  MOVFF  45,38A
1AFD4:  MOVFF  44,389
1AFD8:  MOVLB  0
1AFDA:  CALL   120B0
....................                TRANSFER_DATA_NBYTE_SMFtoSCF(0x00080000,CAM_ADDRESS,65536);       //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AFDE:  MOVLB  3
1AFE0:  CLRF   x3B
1AFE2:  MOVLW  08
1AFE4:  MOVWF  x3A
1AFE6:  CLRF   x39
1AFE8:  CLRF   x38
1AFEA:  MOVFF  47,33F
1AFEE:  MOVFF  46,33E
1AFF2:  MOVFF  45,33D
1AFF6:  MOVFF  44,33C
1AFFA:  CLRF   x43
1AFFC:  MOVLW  01
1AFFE:  MOVWF  x42
1B000:  CLRF   x41
1B002:  CLRF   x40
1B004:  MOVLB  0
1B006:  CALL   13520
....................                TRANSFER_DATA_NBYTE_SMFtoOF(0x00080000,CAM_ADDRESS,65536);        //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1B00A:  MOVLB  3
1B00C:  CLRF   x3B
1B00E:  MOVLW  08
1B010:  MOVWF  x3A
1B012:  CLRF   x39
1B014:  CLRF   x38
1B016:  MOVFF  47,33F
1B01A:  MOVFF  46,33E
1B01E:  MOVFF  45,33D
1B022:  MOVFF  44,33C
1B026:  CLRF   x43
1B028:  MOVLW  01
1B02A:  MOVWF  x42
1B02C:  CLRF   x41
1B02E:  CLRF   x40
1B030:  MOVLB  0
1B032:  CALL   135B2
....................                TRANSFER_DATA_NBYTE_TOPC_SCF(CAM_ADDRESS,65536); 
1B036:  MOVFF  47,33B
1B03A:  MOVFF  46,33A
1B03E:  MOVFF  45,339
1B042:  MOVFF  44,338
1B046:  MOVLB  3
1B048:  CLRF   x3F
1B04A:  MOVLW  01
1B04C:  MOVWF  x3E
1B04E:  CLRF   x3D
1B050:  CLRF   x3C
1B052:  MOVLB  0
1B054:  CALL   13644
....................                CAM_ADDRESS = CAM_ADDRESS + 65536; 
1B058:  MOVLW  01
1B05A:  ADDWF  46,F
1B05C:  MOVLW  00
1B05E:  ADDWFC 47,F
....................                delay_ms(10); 
1B060:  MOVLW  0A
1B062:  MOVLB  3
1B064:  MOVWF  x98
1B066:  MOVLB  0
1B068:  CALL   063E
1B06C:  MOVLB  3
....................             } 
....................              
....................          }else{ 
1B06E:  BRA    1B086
....................             CAM_ACK = 0; 
1B070:  CLRF   x19
....................             fprintf(PC,"CAM DATA SAVING FAILURED\r\n"); 
1B072:  MOVLW  A2
1B074:  MOVWF  FF6
1B076:  MOVLW  11
1B078:  MOVWF  FF7
1B07A:  MOVLW  00
1B07C:  MOVWF  FF8
1B07E:  MOVLB  0
1B080:  CALL   06A4
1B084:  MOVLB  3
....................          }    
....................       }    
....................  
....................    }else{ 
1B086:  BRA    1B09E
....................       CAM_ACK = 0; 
1B088:  CLRF   x19
....................       fprintf(PC,"CAM ACK FAILURED\r\n"); 
1B08A:  MOVLW  BE
1B08C:  MOVWF  FF6
1B08E:  MOVLW  11
1B090:  MOVWF  FF7
1B092:  MOVLW  00
1B094:  MOVWF  FF8
1B096:  MOVLB  0
1B098:  CALL   06A4
1B09C:  MOVLB  3
....................    } 
....................    
....................    Turn_Off_CAM(); 
1B09E:  MOVLB  0
1B0A0:  CALL   190BC
....................    fprintf(PC,"Turned OFF CAM\r\n"); 
1B0A4:  MOVLW  D2
1B0A6:  MOVWF  FF6
1B0A8:  MOVLW  11
1B0AA:  MOVWF  FF7
1B0AC:  MOVLW  00
1B0AE:  MOVWF  FF8
1B0B0:  CALL   06A4
....................    output_high(PIN_C4); //Give Access to COM PIC 
1B0B4:  BCF    F94.4
1B0B6:  BSF    F8B.4
....................    //fputc(0x69,COM);  
....................    //enable_interrupts(INT_rda);   // Main to PC 
....................    return; 
1B0B8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CAM_DEPLOYMENT_OPERATION(int8 mode) 
.................... { 
....................    CAM_SETTINGS();                                                               //Turn ON CAM, delete 1 sector SCF address 00080000, MUX CAM side 
*
1A5A2:  RCALL  1A468
....................    delay_ms(5000);                                                               //Time is necessary for CAM to be ready 
1A5A4:  MOVLW  14
1A5A6:  MOVLB  3
1A5A8:  MOVWF  x2E
1A5AA:  MOVLW  FA
1A5AC:  MOVWF  x98
1A5AE:  MOVLB  0
1A5B0:  CALL   063E
1A5B4:  MOVLB  3
1A5B6:  DECFSZ x2E,F
1A5B8:  BRA    1A5AA
....................    fprintf(PC,"Sending hand shake Command to CAM\r\n"); 
1A5BA:  MOVLW  E4
1A5BC:  MOVWF  FF6
1A5BE:  MOVLW  11
1A5C0:  MOVWF  FF7
1A5C2:  MOVLW  00
1A5C4:  MOVWF  FF8
1A5C6:  MOVLB  0
1A5C8:  CALL   06A4
....................    delay_ms(10); 
1A5CC:  MOVLW  0A
1A5CE:  MOVLB  3
1A5D0:  MOVWF  x98
1A5D2:  MOVLB  0
1A5D4:  CALL   063E
....................    Send_Command_to_CAM(0x54);                                                    //CAM MISSION ID 
1A5D8:  MOVLW  54
1A5DA:  MOVLB  3
1A5DC:  MOVWF  x38
1A5DE:  MOVLB  0
1A5E0:  RCALL  1A4CC
....................    CHECK_ACK_FROM_CAM_10k();                                                     //keep listening about 10 sec 
1A5E2:  RCALL  1A50E
....................    if(CAM_ACK == 0x61)                                                           //CAM ACK 
1A5E4:  MOVLB  3
1A5E6:  MOVF   x19,W
1A5E8:  SUBLW  61
1A5EA:  BTFSS  FD8.2
1A5EC:  BRA    1A6E0
....................    { 
....................       fprintf(PC,"ACK received from CAM\r\n\r\n"); 
1A5EE:  MOVLW  08
1A5F0:  MOVWF  FF6
1A5F2:  MOVLW  12
1A5F4:  MOVWF  FF7
1A5F6:  MOVLW  00
1A5F8:  MOVWF  FF8
1A5FA:  MOVLB  0
1A5FC:  CALL   06A4
....................       CAM_ACK = 0;       
1A600:  MOVLB  3
1A602:  CLRF   x19
....................       for(int a = 0; a < 1; a++)                                               //deployment capture repetition 
1A604:  CLRF   x2D
1A606:  MOVF   x2D,F
1A608:  BNZ   1A6DE
....................       { 
....................          LOOP_CAM_ADDRESS();                                                    //hace un loop en las posiciones de memoria para almacenar CAM data 
1A60A:  MOVLB  0
1A60C:  CALL   1587E
....................          fprintf(PC,"Sending CAM MODE data\r\n"); 
1A610:  MOVLW  22
1A612:  MOVWF  FF6
1A614:  MOVLW  12
1A616:  MOVWF  FF7
1A618:  MOVLW  00
1A61A:  MOVWF  FF8
1A61C:  CALL   06A4
....................          delay_ms(2000);                                                         //for CAM to go waiting for OBC cmnd 
1A620:  MOVLW  08
1A622:  MOVLB  3
1A624:  MOVWF  x2E
1A626:  MOVLW  FA
1A628:  MOVWF  x98
1A62A:  MOVLB  0
1A62C:  CALL   063E
1A630:  MOVLB  3
1A632:  DECFSZ x2E,F
1A634:  BRA    1A626
....................          fputc(mode,CAM); 
1A636:  MOVFF  32C,339
1A63A:  MOVLB  0
1A63C:  CALL   23BE
....................          CHECK_ACK_FROM_CAM_10k();                                              //keep listening about 10 sec 
1A640:  RCALL  1A50E
....................             if(CAM_ACK == mode) 
1A642:  MOVLB  3
1A644:  MOVF   x2C,W
1A646:  SUBWF  x19,W
1A648:  BNZ   1A6DA
....................             { 
....................                fprintf(PC,"Capturing and saving in SFM...\r\n\r\n"); 
1A64A:  MOVLW  3A
1A64C:  MOVWF  FF6
1A64E:  MOVLW  12
1A650:  MOVWF  FF7
1A652:  MOVLW  00
1A654:  MOVWF  FF8
1A656:  MOVLB  0
1A658:  CALL   06A4
....................                CHECK_ACK_FROM_CAM_200k();                                       //keep listening about 200 sec 
1A65C:  RCALL  1A55A
....................                //CHECK_ACK_FROM_CAM_30k();                                         //keep listening about 30 sec 
....................                   if(CAM_ACK == 0x62)                                           //CAM Finish Storing 
1A65E:  MOVLB  3
1A660:  MOVF   x19,W
1A662:  SUBLW  62
1A664:  BNZ   1A6C4
....................                   { 
....................                      CAM_ACK = 0; 
1A666:  CLRF   x19
....................                      fprintf(PC,"PHOTO %d SAVING DONE\r\n",a+1);                     
1A668:  MOVLW  01
1A66A:  ADDWF  x2D,W
1A66C:  MOVWF  x2E
1A66E:  MOVLW  5E
1A670:  MOVWF  FF6
1A672:  MOVLW  12
1A674:  MOVWF  FF7
1A676:  MOVLW  00
1A678:  MOVWF  FF8
1A67A:  MOVLW  06
1A67C:  MOVWF  xA2
1A67E:  MOVLB  0
1A680:  CALL   06CE
1A684:  MOVFF  32E,33E
1A688:  MOVLW  18
1A68A:  MOVLB  3
1A68C:  MOVWF  x3F
1A68E:  MOVLB  0
1A690:  CALL   2404
1A694:  MOVLW  66
1A696:  MOVWF  FF6
1A698:  MOVLW  12
1A69A:  MOVWF  FF7
1A69C:  MOVLW  00
1A69E:  MOVWF  FF8
1A6A0:  MOVLW  0E
1A6A2:  MOVLB  3
1A6A4:  MOVWF  xA2
1A6A6:  MOVLB  0
1A6A8:  CALL   06CE
....................                      CAM_ADDRESS = CAM_ADDRESS + 65536;                          //se ubica en la nueva posicion, 10 sectores adelante 
1A6AC:  MOVLW  01
1A6AE:  ADDWF  46,F
1A6B0:  MOVLW  00
1A6B2:  ADDWFC 47,F
....................                      //sector_erase_SCF(CAM_ADDRESS); 
....................                      delay_ms(10); 
1A6B4:  MOVLW  0A
1A6B6:  MOVLB  3
1A6B8:  MOVWF  x98
1A6BA:  MOVLB  0
1A6BC:  CALL   063E
....................        
....................                   }else{ 
1A6C0:  BRA    1A6D8
1A6C2:  MOVLB  3
....................                      CAM_ACK = 0; 
1A6C4:  CLRF   x19
....................                      fprintf(PC,"CAM DATA SAVING FAILURED\r\n"); 
1A6C6:  MOVLW  76
1A6C8:  MOVWF  FF6
1A6CA:  MOVLW  12
1A6CC:  MOVWF  FF7
1A6CE:  MOVLW  00
1A6D0:  MOVWF  FF8
1A6D2:  MOVLB  0
1A6D4:  CALL   06A4
1A6D8:  MOVLB  3
....................                   }    
....................             }    
1A6DA:  INCF   x2D,F
1A6DC:  BRA    1A606
....................          } 
....................    }else{ 
1A6DE:  BRA    1A6F6
....................       CAM_ACK = 0; 
1A6E0:  CLRF   x19
....................       fprintf(PC,"CAM ACK FAILURED\r\n"); 
1A6E2:  MOVLW  92
1A6E4:  MOVWF  FF6
1A6E6:  MOVLW  12
1A6E8:  MOVWF  FF7
1A6EA:  MOVLW  00
1A6EC:  MOVWF  FF8
1A6EE:  MOVLB  0
1A6F0:  CALL   06A4
1A6F4:  MOVLB  3
....................    } 
....................    output_low(PIN_A5);                                                           //Mission Flash MUX Main side 
1A6F6:  BCF    F92.5
1A6F8:  BCF    F89.5
....................    delay_ms(10); 
1A6FA:  MOVLW  0A
1A6FC:  MOVWF  x98
1A6FE:  MOVLB  0
1A700:  CALL   063E
....................    Turn_Off_CAM(); 
1A704:  CALL   190BC
....................    fprintf(PC,"Turned OFF CAM\r\n"); 
1A708:  MOVLW  A6
1A70A:  MOVWF  FF6
1A70C:  MOVLW  12
1A70E:  MOVWF  FF7
1A710:  MOVLW  00
1A712:  MOVWF  FF8
1A714:  CALL   06A4
....................    output_high(PIN_C4);                                                          //Give Access to COM PIC 
1A718:  BCF    F94.4
1A71A:  BSF    F8B.4
....................    return; 
1A71C:  RETURN 0
.................... } 
....................  
.................... //-------Kill Switch----------------------------------------------------------- 
.................... Static int8 KILL_COUNTER = 0; 
.................... #ORG 0x00019000 
.................... void Count_Kill_Flag() 
.................... { 
....................    KILL_COUNTER++; 
*
1B444:  MOVLB  3
1B446:  INCF   x1A,F
....................    if(Kill_COUNTER > 4) 
1B448:  MOVF   x1A,W
1B44A:  SUBLW  04
1B44C:  BC    1B460
....................    { 
....................       Kill_FLAG_MAIN = 1; 
1B44E:  MOVLW  01
1B450:  MOVLB  0
1B452:  MOVWF  x75
....................       output_high(PIN_A4);                                                       //Kill Switch ON 
1B454:  BCF    F92.4
1B456:  BSF    F89.4
....................       fputc(0x17,FAB); 
1B458:  MOVLW  17
1B45A:  CALL   1A84
1B45E:  MOVLB  3
....................    } 
....................    fprintf(PC,"Kill counter: %x\r\n",KILL_COUNTER); 
1B460:  MOVLW  B8
1B462:  MOVWF  FF6
1B464:  MOVLW  12
1B466:  MOVWF  FF7
1B468:  MOVLW  00
1B46A:  MOVWF  FF8
1B46C:  MOVLW  0E
1B46E:  MOVWF  xA2
1B470:  MOVLB  0
1B472:  CALL   06CE
1B476:  MOVFF  31A,3A2
1B47A:  MOVLW  57
1B47C:  MOVLB  3
1B47E:  MOVWF  xA3
1B480:  MOVLB  0
1B482:  CALL   0700
1B486:  MOVLW  0D
1B488:  BTFSS  F9E.4
1B48A:  BRA    1B488
1B48C:  MOVWF  FAD
1B48E:  MOVLW  0A
1B490:  BTFSS  F9E.4
1B492:  BRA    1B490
1B494:  MOVWF  FAD
....................    return; 
1B496:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Disable_Kill() 
.................... { 
....................    KILL_COUNTER = 0; 
1B498:  MOVLB  3
1B49A:  CLRF   x1A
....................     
....................    Kill_FLAG_MAIN = 0; 
1B49C:  MOVLB  0
1B49E:  CLRF   x75
....................    output_low(PIN_A4);                                                           //Kill Switch OFF 
1B4A0:  BCF    F92.4
1B4A2:  BCF    F89.4
....................    fputc(0x18,FAB); 
1B4A4:  MOVLW  18
1B4A6:  CALL   1A84
....................     
....................    fprintf(PC,"Kill counter: %x\r\n",KILL_COUNTER); 
1B4AA:  MOVLW  CC
1B4AC:  MOVWF  FF6
1B4AE:  MOVLW  12
1B4B0:  MOVWF  FF7
1B4B2:  MOVLW  00
1B4B4:  MOVWF  FF8
1B4B6:  MOVLW  0E
1B4B8:  MOVLB  3
1B4BA:  MOVWF  xA2
1B4BC:  MOVLB  0
1B4BE:  CALL   06CE
1B4C2:  MOVFF  31A,3A2
1B4C6:  MOVLW  57
1B4C8:  MOVLB  3
1B4CA:  MOVWF  xA3
1B4CC:  MOVLB  0
1B4CE:  CALL   0700
1B4D2:  MOVLW  0D
1B4D4:  BTFSS  F9E.4
1B4D6:  BRA    1B4D4
1B4D8:  MOVWF  FAD
1B4DA:  MOVLW  0A
1B4DC:  BTFSS  F9E.4
1B4DE:  BRA    1B4DC
1B4E0:  MOVWF  FAD
....................    return; 
1B4E2:  RETURN 0
.................... } 
....................  
.................... //-------Reset Function-------------------------------------------------------- 
.................... #ORG 0x0001B800 
.................... void BC_ON_30min() 
.................... { 
....................    if(currenttime > 1805 && BC_ATTEMPT_FLAG == 0)                                //if first attempt and 30 min(1800sec) passed 
*
1B9DC:  MOVLB  2
1B9DE:  MOVF   x4A,W
1B9E0:  SUBLW  06
1B9E2:  BC    1BAB2
1B9E4:  XORLW  FF
1B9E6:  BNZ   1B9EE
1B9E8:  MOVF   x49,W
1B9EA:  SUBLW  0D
1B9EC:  BC    1BAB2
1B9EE:  MOVLB  0
1B9F0:  MOVF   x68,F
1B9F2:  BTFSC  FD8.2
1B9F4:  BRA    1B9FA
1B9F6:  MOVLB  2
1B9F8:  BRA    1BAB2
....................    { 
....................       fprintf(PC,"sending BC command to RESET PIC\r\n"); 
1B9FA:  MOVLW  E0
1B9FC:  MOVWF  FF6
1B9FE:  MOVLW  12
1BA00:  MOVWF  FF7
1BA02:  MOVLW  00
1BA04:  MOVWF  FF8
1BA06:  CALL   06A4
....................       for(int16 num = 0; num < 200; num++) 
1BA0A:  MOVLB  3
1BA0C:  CLRF   x3E
1BA0E:  CLRF   x3D
1BA10:  MOVF   x3E,F
1BA12:  BNZ   1BA44
1BA14:  MOVF   x3D,W
1BA16:  SUBLW  C7
1BA18:  BNC   1BA44
....................       { 
....................          fputc(0xBC,reset); 
1BA1A:  MOVLW  BC
1BA1C:  MOVLB  0
1BA1E:  CALL   157C
....................          delay_ms(100); 
1BA22:  MOVLW  64
1BA24:  MOVLB  3
1BA26:  MOVWF  x98
1BA28:  MOVLB  0
1BA2A:  CALL   063E
....................          if(reset_bffr[0] == 0xCB)                                               //condicion para que deje de enviar al recibir el ACK 
1BA2E:  MOVF   x9E,W
1BA30:  SUBLW  CB
1BA32:  BNZ   1BA3A
....................          { 
....................          break; 
1BA34:  MOVLB  3
1BA36:  BRA    1BA44
1BA38:  MOVLB  0
....................          } 
1BA3A:  MOVLB  3
1BA3C:  INCF   x3D,F
1BA3E:  BTFSC  FD8.2
1BA40:  INCF   x3E,F
1BA42:  BRA    1BA10
....................       } 
....................       delay_ms(1000);                                                             
1BA44:  MOVLW  04
1BA46:  MOVWF  x3F
1BA48:  MOVLW  FA
1BA4A:  MOVWF  x98
1BA4C:  MOVLB  0
1BA4E:  CALL   063E
1BA52:  MOVLB  3
1BA54:  DECFSZ x3F,F
1BA56:  BRA    1BA48
....................       if(reset_bffr[0] == 0xCB) 
1BA58:  MOVLB  0
1BA5A:  MOVF   x9E,W
1BA5C:  SUBLW  CB
1BA5E:  BNZ   1BAB0
....................       { 
....................          BC_OPERATION(); 
1BA60:  CALL   1A1AE
....................          BC_ATTEMPT_FLAG++; 
1BA64:  INCF   x68,F
....................          WRITE_FLAG_to_EEPROM(); 
1BA66:  CALL   12FE4
....................          STORE_FLAG_INFO(); 
1BA6A:  CALL   146F6
....................          STORE_ADRESS_DATA_TO_FLASH(); 
1BA6E:  CALL   142D0
....................          reset_bffr[0] = 0; 
1BA72:  CLRF   x9E
....................          RESET_DATA = 0; 
1BA74:  CLRF   x9D
....................          delay_ms(1000); 
1BA76:  MOVLW  04
1BA78:  MOVLB  3
1BA7A:  MOVWF  x3F
1BA7C:  MOVLW  FA
1BA7E:  MOVWF  x98
1BA80:  MOVLB  0
1BA82:  CALL   063E
1BA86:  MOVLB  3
1BA88:  DECFSZ x3F,F
1BA8A:  BRA    1BA7C
....................          delay_ms(20000);                                                        //wait until RESET goes back to nomal loop 
1BA8C:  MOVLW  50
1BA8E:  MOVWF  x3F
1BA90:  MOVLW  FA
1BA92:  MOVWF  x98
1BA94:  MOVLB  0
1BA96:  CALL   063E
1BA9A:  MOVLB  3
1BA9C:  DECFSZ x3F,F
1BA9E:  BRA    1BA90
....................          SAVE_SAT_LOG(0xBC,0x30,0x30);                                           //first 30 min antenna deployment 
1BAA0:  MOVLW  BC
1BAA2:  MOVWF  x53
1BAA4:  MOVLW  30
1BAA6:  MOVWF  x54
1BAA8:  MOVWF  x55
1BAAA:  MOVLB  0
1BAAC:  CALL   16EA4
1BAB0:  MOVLB  2
....................       } 
....................    } 
....................    return; 
1BAB2:  MOVLB  0
1BAB4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void HIGHSAMP_SENSOR_COLLECTION(int16 times) 
.................... { 
....................    LOOP_HIGH_SAMP_HK_ADDRESS();                                                  //loop in memory to save data, keep first 3 sectors forever 
1BAB6:  CALL   158DA
....................    int32 num = 0; 
1BABA:  MOVLB  3
1BABC:  CLRF   x3C
1BABE:  CLRF   x3B
1BAC0:  CLRF   x3A
1BAC2:  CLRF   x39
....................  
....................    while(num < times) 
1BAC4:  MOVF   x3C,F
1BAC6:  BTFSS  FD8.2
1BAC8:  BRA    1BB92
1BACA:  MOVF   x3B,F
1BACC:  BTFSS  FD8.2
1BACE:  BRA    1BB92
1BAD0:  MOVF   x3A,W
1BAD2:  SUBWF  x38,W
1BAD4:  BNC   1BB92
1BAD6:  BNZ   1BADE
1BAD8:  MOVF   x37,W
1BADA:  SUBWF  x39,W
1BADC:  BC    1BB92
....................    { 
....................       CHECK_50_and_CW_RESPOND();                                                 //check cw cmd from COM PIC 
1BADE:  MOVLB  0
1BAE0:  CALL   1A72
....................       if(FAB_FLAG > 4) 
1BAE4:  MOVLB  2
1BAE6:  MOVF   xFF,F
1BAE8:  BNZ   1BAF8
1BAEA:  MOVF   xFE,F
1BAEC:  BNZ   1BAF8
1BAEE:  MOVF   xFD,F
1BAF0:  BNZ   1BAF8
1BAF2:  MOVF   xFC,W
1BAF4:  SUBLW  04
1BAF6:  BC    1BB6E
....................       { 
....................          FAB_FLAG = 0; 
1BAF8:  CLRF   xFF
1BAFA:  CLRF   xFE
1BAFC:  CLRF   xFD
1BAFE:  CLRF   xFC
....................          HIGH_SAMP_FAB_OPERATION();                                              //collect FAB, RESET and ADCS data 
1BB00:  MOVLB  0
1BB02:  CALL   1AAFE
....................           
....................          num++; 
1BB06:  MOVLW  01
1BB08:  MOVLB  3
1BB0A:  ADDWF  x39,F
1BB0C:  BTFSC  FD8.0
1BB0E:  INCF   x3A,F
1BB10:  BTFSC  FD8.2
1BB12:  INCF   x3B,F
1BB14:  BTFSC  FD8.2
1BB16:  INCF   x3C,F
....................          if((num % 20) == 0)                                                     //once in the 20 times(every 100sec save the address to the flash) 
1BB18:  BSF    FD8.1
1BB1A:  MOVLW  03
1BB1C:  MOVWF  FEA
1BB1E:  MOVLW  3D
1BB20:  MOVWF  FE9
1BB22:  MOVFF  33C,351
1BB26:  MOVFF  33B,350
1BB2A:  MOVFF  33A,34F
1BB2E:  MOVFF  339,34E
1BB32:  CLRF   x55
1BB34:  CLRF   x54
1BB36:  CLRF   x53
1BB38:  MOVLW  14
1BB3A:  MOVWF  x52
1BB3C:  MOVLB  0
1BB3E:  CALL   2112
1BB42:  MOVFF  340,344
1BB46:  MOVFF  33F,343
1BB4A:  MOVFF  33E,342
1BB4E:  MOVFF  33D,341
1BB52:  MOVLB  3
1BB54:  MOVF   x41,F
1BB56:  BNZ   1BB6C
1BB58:  MOVF   x42,F
1BB5A:  BNZ   1BB6C
1BB5C:  MOVF   x43,F
1BB5E:  BNZ   1BB6C
1BB60:  MOVF   x44,F
1BB62:  BNZ   1BB6C
....................          { 
....................             STORE_ADRESS_DATA_TO_FLASH();                                        //for store the flag 
1BB64:  MOVLB  0
1BB66:  CALL   142D0
1BB6A:  MOVLB  3
1BB6C:  MOVLB  2
....................          }  
....................       } 
....................  
....................       BC_ON_30min();                                                             //check if first attempt and 30 min(1800sec) passed 
1BB6E:  MOVLB  0
1BB70:  RCALL  1B9DC
....................       if((CMD_FROM_PC[0] == 0xAB)||(in_bffr_main[4] == 0xAB))                    //forced termination function 
1BB72:  MOVF   x7E,W
1BB74:  SUBLW  AB
1BB76:  BZ    1BB7E
1BB78:  MOVF   x8A,W
1BB7A:  SUBLW  AB
1BB7C:  BNZ   1BB88
....................       { 
....................          Delete_Buffer(); 
1BB7E:  CALL   121E8
....................          break; 
1BB82:  MOVLB  3
1BB84:  BRA    1BB92
1BB86:  MOVLB  0
....................       } 
....................       PC_DATA = 0; 
1BB88:  CLRF   x99
....................       RESET_SATELLITE();                                                         //check reset command from RESET PIC 
1BB8A:  CALL   16CB0
1BB8E:  MOVLB  3
1BB90:  BRA    1BAC4
....................    } 
....................    fprintf(PC,"HSSC DONE\r\n"); 
1BB92:  MOVLW  02
1BB94:  MOVWF  FF6
1BB96:  MOVLW  13
1BB98:  MOVWF  FF7
1BB9A:  MOVLW  00
1BB9C:  MOVWF  FF8
1BB9E:  MOVLB  0
1BBA0:  CALL   06A4
....................    return; 
1BBA4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void REPLY_TO_COM(int8 data1,int8 data2) 
.................... { 
....................    if(ACK_for_COM[12] == 0x66 && ACK_for_COM[14] == 0x77) 
*
1D84A:  MOVLB  1
1D84C:  MOVF   xEF,W
1D84E:  SUBLW  66
1D850:  BNZ   1D8CA
1D852:  MOVF   xF1,W
1D854:  SUBLW  77
1D856:  BNZ   1D8CA
....................    { 
....................       for(int n = 0; n < 24; n++)                                                //send back the acknowledge 
1D858:  MOVLB  3
1D85A:  CLRF   x39
1D85C:  MOVF   x39,W
1D85E:  SUBLW  17
1D860:  BNC   1D882
....................       { 
....................          fputc(ACK_for_COM[n],COM); 
1D862:  CLRF   03
1D864:  MOVF   x39,W
1D866:  ADDLW  E3
1D868:  MOVWF  FE9
1D86A:  MOVLW  01
1D86C:  ADDWFC 03,W
1D86E:  MOVWF  FEA
1D870:  MOVFF  FEF,33B
1D874:  MOVF   x3B,W
1D876:  MOVLB  0
1D878:  CALL   19D6
1D87C:  MOVLB  3
1D87E:  INCF   x39,F
1D880:  BRA    1D85C
....................       } 
....................       for(n = 0; n < 24; n++)                                                    //send back the acknowledge 
1D882:  CLRF   x39
1D884:  MOVF   x39,W
1D886:  SUBLW  17
1D888:  BNC   1D8B4
....................       { 
....................          fprintf(PC,"%x,",ACK_for_COM[n]); 
1D88A:  CLRF   03
1D88C:  MOVF   x39,W
1D88E:  ADDLW  E3
1D890:  MOVWF  FE9
1D892:  MOVLW  01
1D894:  ADDWFC 03,W
1D896:  MOVWF  FEA
1D898:  MOVFF  FEF,3A2
1D89C:  MOVLW  57
1D89E:  MOVWF  xA3
1D8A0:  MOVLB  0
1D8A2:  CALL   0700
1D8A6:  MOVLW  2C
1D8A8:  BTFSS  F9E.4
1D8AA:  BRA    1D8A8
1D8AC:  MOVWF  FAD
1D8AE:  MOVLB  3
1D8B0:  INCF   x39,F
1D8B2:  BRA    1D884
....................       } 
....................       fprintf(PC,",AUTO\r\n"); 
1D8B4:  MOVLW  0E
1D8B6:  MOVWF  FF6
1D8B8:  MOVLW  13
1D8BA:  MOVWF  FF7
1D8BC:  MOVLW  00
1D8BE:  MOVWF  FF8
1D8C0:  MOVLB  0
1D8C2:  CALL   06A4
....................    } 
1D8C6:  BRA    1D948
1D8C8:  MOVLB  1
....................    else{ 
....................       //REFLESH_MSN_ACK_for_COM(); 
....................       //!      for(int n = 7; n < 24; n++)//send back the acknowledge 
....................       //!      { 
....................       //!         ACK_for_COM[n] = 0xff; 
....................       //!      } 
....................       ACK_for_COM[0] = 0xAA; 
1D8CA:  MOVLW  AA
1D8CC:  MOVWF  xE3
....................       ACK_for_COM[12] = data1; 
1D8CE:  MOVFF  337,1EF
....................       ACK_for_COM[13] = data2; 
1D8D2:  MOVFF  338,1F0
....................       ACK_for_COM[23] = 0xBB; 
1D8D6:  MOVLW  BB
1D8D8:  MOVWF  xFA
....................       for(int n = 0; n < 24; n++)                                                //send back the acknowledge 
1D8DA:  MOVLB  3
1D8DC:  CLRF   x3A
1D8DE:  MOVF   x3A,W
1D8E0:  SUBLW  17
1D8E2:  BNC   1D904
....................       { 
....................          fputc(ACK_for_COM[n],COM); 
1D8E4:  CLRF   03
1D8E6:  MOVF   x3A,W
1D8E8:  ADDLW  E3
1D8EA:  MOVWF  FE9
1D8EC:  MOVLW  01
1D8EE:  ADDWFC 03,W
1D8F0:  MOVWF  FEA
1D8F2:  MOVFF  FEF,33B
1D8F6:  MOVF   x3B,W
1D8F8:  MOVLB  0
1D8FA:  CALL   19D6
1D8FE:  MOVLB  3
1D900:  INCF   x3A,F
1D902:  BRA    1D8DE
....................       } 
....................       for(n = 0; n < 24; n++)                                                    //send back the acknowledge 
1D904:  CLRF   x3A
1D906:  MOVF   x3A,W
1D908:  SUBLW  17
1D90A:  BNC   1D936
....................       { 
....................          fprintf(PC,"%x,",ACK_for_COM[n]); 
1D90C:  CLRF   03
1D90E:  MOVF   x3A,W
1D910:  ADDLW  E3
1D912:  MOVWF  FE9
1D914:  MOVLW  01
1D916:  ADDWFC 03,W
1D918:  MOVWF  FEA
1D91A:  MOVFF  FEF,3A2
1D91E:  MOVLW  57
1D920:  MOVWF  xA3
1D922:  MOVLB  0
1D924:  CALL   0700
1D928:  MOVLW  2C
1D92A:  BTFSS  F9E.4
1D92C:  BRA    1D92A
1D92E:  MOVWF  FAD
1D930:  MOVLB  3
1D932:  INCF   x3A,F
1D934:  BRA    1D906
....................       } 
....................       fprintf(PC,",NORMAL\r\n"); 
1D936:  MOVLW  16
1D938:  MOVWF  FF6
1D93A:  MOVLW  13
1D93C:  MOVWF  FF7
1D93E:  MOVLW  00
1D940:  MOVWF  FF8
1D942:  MOVLB  0
1D944:  CALL   06A4
....................    } 
1D948:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void UPDATE_ACK_for_COM(int8 data1,int8 data2,int32 address, int16 size)         //send data to COM for automatical mission 
.................... { 
....................    REFLESH_MSN_ACK_for_COM();                                                    //clear array ACK_for_COM[i] from position 12 to 22 
*
1BBA6:  CALL   1AD70
....................    ACK_for_COM[15] = address >> 24; 
1BBAA:  MOVFF  336,1F2
....................    ACK_for_COM[16] = address >> 16; 
1BBAE:  MOVFF  335,1F3
....................    ACK_for_COM[17] = address >> 8; 
1BBB2:  MOVFF  334,1F4
....................    ACK_for_COM[18] = address; 
1BBB6:  MOVFF  333,1F5
....................     
....................    ACK_for_COM[19] = size >> 24; 
1BBBA:  MOVLB  1
1BBBC:  CLRF   xF6
....................    ACK_for_COM[20] = size >> 16; 
1BBBE:  CLRF   xF7
....................    ACK_for_COM[21] = size >> 8; 
1BBC0:  MOVFF  338,1F8
....................    ACK_for_COM[22] = size; 
1BBC4:  MOVFF  337,1F9
....................     
....................    ACK_for_COM[0] = 0xAA;                                                        //header 
1BBC8:  MOVLW  AA
1BBCA:  MOVWF  xE3
....................    ACK_for_COM[12] = data1;                                                      //success ack indicator 0x66 
1BBCC:  MOVFF  331,1EF
....................    ACK_for_COM[14] = data2;                                                      //auto indicator 0x77 
1BBD0:  MOVFF  332,1F1
....................    ACK_for_COM[23] = 0xBB;                                                       //footer 
1BBD4:  MOVLW  BB
1BBD6:  MOVWF  xFA
....................    for(int n = 0; n < 24; n++)                                                   //send back the acknowledge 
1BBD8:  MOVLB  3
1BBDA:  CLRF   x39
1BBDC:  MOVF   x39,W
1BBDE:  SUBLW  17
1BBE0:  BNC   1BC02
....................    { 
....................       fputc(ACK_for_COM[n],COM); 
1BBE2:  CLRF   03
1BBE4:  MOVF   x39,W
1BBE6:  ADDLW  E3
1BBE8:  MOVWF  FE9
1BBEA:  MOVLW  01
1BBEC:  ADDWFC 03,W
1BBEE:  MOVWF  FEA
1BBF0:  MOVFF  FEF,33A
1BBF4:  MOVF   x3A,W
1BBF6:  MOVLB  0
1BBF8:  CALL   19D6
1BBFC:  MOVLB  3
1BBFE:  INCF   x39,F
1BC00:  BRA    1BBDC
....................    } 
1BC02:  MOVLB  0
1BC04:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0000F000 
.................... void RSV_DATA_DOWNLOAD(int8 cmnd1,int8 cmnd2,int8 cmnd3,int8 cmnd4,int8 cmnd5,int8 cmnd6,int8 cmnd7) //carga el array ACK_for_COM[] con el dato del array CW_FORMAT[] y envia a COM PIC 
.................... { 
....................    for(int a = 13; a < 23; a++)                                                   //clear ACK_for_COM array  
*
0F000:  MOVLW  0D
0F002:  MOVLB  3
0F004:  MOVWF  x84
0F006:  MOVF   x84,W
0F008:  SUBLW  16
0F00A:  BNC   F020
....................    { 
....................       ACK_for_COM[a] = 0x00; 
0F00C:  CLRF   03
0F00E:  MOVF   x84,W
0F010:  ADDLW  E3
0F012:  MOVWF  FE9
0F014:  MOVLW  01
0F016:  ADDWFC 03,W
0F018:  MOVWF  FEA
0F01A:  CLRF   FEF
0F01C:  INCF   x84,F
0F01E:  BRA    F006
....................    } 
....................    delay_ms(100); 
0F020:  MOVLW  64
0F022:  MOVWF  x98
0F024:  MOVLB  0
0F026:  CALL   063E
....................    ACK_for_COM[14] = cmnd1;                                                      //CMD1 Function 
0F02A:  MOVFF  37D,1F1
....................    ACK_for_COM[15] = cmnd3;                                                      //CMD3 address1 
0F02E:  MOVFF  37F,1F2
....................    ACK_for_COM[16] = cmnd4;                                                      //CMD4 address2 
0F032:  MOVFF  380,1F3
....................    ACK_for_COM[17] = cmnd5;                                                      //CMD5 address3 
0F036:  MOVFF  381,1F4
....................    ACK_for_COM[18] = cmnd6;                                                      //CMD6 address4 
0F03A:  MOVFF  382,1F5
....................    ACK_for_COM[19] = 0x00;                                                       //empty 
0F03E:  MOVLB  1
0F040:  CLRF   xF6
....................    ACK_for_COM[20] = 0x00;                                                       //empty 
0F042:  CLRF   xF7
....................    ACK_for_COM[21] = 0x00;                                                       //empty 
0F044:  CLRF   xF8
....................    ACK_for_COM[22] = cmnd7;                                                      //CMD7 pckt 
0F046:  MOVFF  383,1F9
....................    for(int m = 0; m < 23; m++)                                                   //send the reservation function data to PC 
0F04A:  MOVLB  3
0F04C:  CLRF   x85
0F04E:  MOVF   x85,W
0F050:  SUBLW  16
0F052:  BNC   F07E
....................    { 
....................       fprintf(PC,"%x,",ACK_for_COM[m]); 
0F054:  CLRF   03
0F056:  MOVF   x85,W
0F058:  ADDLW  E3
0F05A:  MOVWF  FE9
0F05C:  MOVLW  01
0F05E:  ADDWFC 03,W
0F060:  MOVWF  FEA
0F062:  MOVFF  FEF,3A2
0F066:  MOVLW  57
0F068:  MOVWF  xA3
0F06A:  MOVLB  0
0F06C:  CALL   0700
0F070:  MOVLW  2C
0F072:  BTFSS  F9E.4
0F074:  BRA    F072
0F076:  MOVWF  FAD
0F078:  MOVLB  3
0F07A:  INCF   x85,F
0F07C:  BRA    F04E
....................    } 
....................    fprintf(PC,"%x\r\n",ACK_for_COM[23]); 
0F07E:  MOVFF  1FA,3A2
0F082:  MOVLW  57
0F084:  MOVWF  xA3
0F086:  MOVLB  0
0F088:  CALL   0700
0F08C:  MOVLW  0D
0F08E:  BTFSS  F9E.4
0F090:  BRA    F08E
0F092:  MOVWF  FAD
0F094:  MOVLW  0A
0F096:  BTFSS  F9E.4
0F098:  BRA    F096
0F09A:  MOVWF  FAD
....................     
....................    return; 
0F09C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void call_ADCS_TEST_OPERATION(unsigned int16 duration, int8 OPERATION_MODE) 
.................... { 
....................    ADCS_TEST_OPERATION(duration, OPERATION_MODE); 
*
1B800:  MOVFF  37E,381
1B804:  MOVFF  37D,380
1B808:  MOVFF  37F,382
1B80C:  CALL   12292
1B810:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<AUTO_MSN.c> 
.................... #ifndef AUTO_MSN_C 
.................... #define AUTO_MSN_C 
....................  
.................... #define loop_day 70 
.................... int16 AD = 0;                                                                    //DATE DATA 
.................... int16 D = 0;                                                                     //everyday change the DL address. nomally, increase 5 packet for each day 
....................                                                                                   
.................... int8 ADH = 0;                                                                    //for satellite log(int16 date high) 
.................... int8 ADL = 0;                                                                    //for satellite log(int16 date low) 
.................... int32 DL_AD = 0;                                                                 //Data size to increase when day changed 
....................  
.................... //@@@@@@@@@@@ HIGH SAMPLING@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY0()                                                                      //2 hour high sampling sensor 
.................... { 
....................    SAVE_SAT_LOG(0xFA,0x11,0x11);                                                 //11,11: automatical mission 
*
1BC06:  MOVLW  FA
1BC08:  MOVLB  3
1BC0A:  MOVWF  x53
1BC0C:  MOVLW  11
1BC0E:  MOVWF  x54
1BC10:  MOVWF  x55
1BC12:  MOVLB  0
1BC14:  CALL   16EA4
....................    FIRST_HSSC_DONE = 1;                                                          //flag in HIGH 
1BC18:  MOVLW  01
1BC1A:  MOVWF  x77
....................    STORE_FLAG_INFO();                                                            //save passed days 
1BC1C:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM(); 
1BC20:  CALL   12FE4
....................    HIGHSAMP_SENSOR_COLLECTION(1440);                                             //execute HSSC mission for 2 hours 
1BC24:  MOVLW  05
1BC26:  MOVLB  3
1BC28:  MOVWF  x38
1BC2A:  MOVLW  A0
1BC2C:  MOVWF  x37
1BC2E:  MOVLB  0
1BC30:  RCALL  1BAB6
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 // save all address data in FLASH memories 
1BC32:  CALL   142D0
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BC36:  MOVFF  6A,385
1BC3A:  MOVFF  69,384
1BC3E:  MOVLB  3
1BC40:  CLRF   x87
1BC42:  MOVLW  46
1BC44:  MOVWF  x86
1BC46:  MOVLB  0
1BC48:  CALL   1536
1BC4C:  MOVFF  00,31B
1BC50:  MOVLB  3
1BC52:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BC56:  CLRF   x1F
....................    ADL = AD; 
1BC58:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1BC5C:  MOVLW  FD
1BC5E:  MOVWF  x53
1BC60:  MOVFF  31F,354
1BC64:  MOVFF  320,355
1BC68:  MOVLB  0
1BC6A:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639,405);                                  //send data1,data2,address,size to COM for automatical mission) 
1BC6E:  MOVLW  66
1BC70:  MOVLB  3
1BC72:  MOVWF  x31
1BC74:  MOVLW  77
1BC76:  MOVWF  x32
1BC78:  MOVLW  06
1BC7A:  MOVWF  x36
1BC7C:  MOVLW  67
1BC7E:  MOVWF  x35
1BC80:  CLRF   x34
1BC82:  CLRF   x33
1BC84:  MOVLW  01
1BC86:  MOVWF  x38
1BC88:  MOVLW  95
1BC8A:  MOVWF  x37
1BC8C:  MOVLB  0
1BC8E:  RCALL  1BBA6
....................                                                                                  //118byte*3600*2/5 (about 2.59sector) 65536*1639 
....................    return;                                                                        
1BC90:  RETURN 0
.................... } 
.................... #ORG 0x0001B800 
.................... void DAY1to4()                                                                   //HIGH SAMPLING Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BC92:  MOVFF  6A,385
1BC96:  MOVFF  69,384
1BC9A:  MOVLB  3
1BC9C:  CLRF   x87
1BC9E:  MOVLW  46
1BCA0:  MOVWF  x86
1BCA2:  MOVLB  0
1BCA4:  CALL   1536
1BCA8:  MOVFF  00,31B
1BCAC:  MOVLB  3
1BCAE:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BCB2:  CLRF   x1F
....................    ADL = AD; 
1BCB4:  MOVFF  31B,320
....................    D = AD; 
1BCB8:  MOVFF  31C,31E
1BCBC:  MOVFF  31B,31D
....................     
....................    DL_AD = 220*D;                                                                //skip 220 packets each day 
1BCC0:  CLRF   x43
1BCC2:  MOVLW  DC
1BCC4:  MOVWF  x42
1BCC6:  MOVFF  31E,345
1BCCA:  MOVFF  31D,344
1BCCE:  MOVLB  0
1BCD0:  CALL   253A
1BCD4:  MOVLB  3
1BCD6:  CLRF   x24
1BCD8:  CLRF   x23
1BCDA:  MOVFF  02,322
1BCDE:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //address from where will be downloaded 
1BCE2:  MOVFF  324,337
1BCE6:  MOVFF  323,336
1BCEA:  MOVFF  322,335
1BCEE:  MOVFF  321,334
1BCF2:  CLRF   x3B
1BCF4:  CLRF   x3A
1BCF6:  CLRF   x39
1BCF8:  MOVLW  51
1BCFA:  MOVWF  x38
1BCFC:  MOVLB  0
1BCFE:  CALL   24DE
1BD02:  MOVFF  03,324
1BD06:  MOVFF  02,323
1BD0A:  MOVFF  01,322
1BD0E:  MOVFF  00,321
....................    /*//////////////PACKET///////////////// 
....................    //220-224, 440-444, 660-664, 880-884 
....................    /////////////////////////////////////*/ 
....................     
....................     
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1BD12:  MOVLW  FD
1BD14:  MOVLB  3
1BD16:  MOVWF  x53
1BD18:  MOVFF  31F,354
1BD1C:  MOVFF  320,355
1BD20:  MOVLB  0
1BD22:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*1639 
1BD26:  MOVLB  3
1BD28:  MOVFF  321,32D
1BD2C:  MOVFF  322,32E
1BD30:  MOVLW  67
1BD32:  ADDWF  x23,W
1BD34:  MOVWF  x2F
1BD36:  MOVLW  06
1BD38:  ADDWFC x24,W
1BD3A:  MOVWF  x30
1BD3C:  MOVLW  66
1BD3E:  MOVWF  x31
1BD40:  MOVLW  77
1BD42:  MOVWF  x32
1BD44:  MOVFF  330,336
1BD48:  MOVFF  32F,335
1BD4C:  MOVFF  322,334
1BD50:  MOVFF  321,333
1BD54:  MOVLW  01
1BD56:  MOVWF  x38
1BD58:  MOVLW  95
1BD5A:  MOVWF  x37
1BD5C:  MOVLB  0
1BD5E:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1BD60:  MOVLB  3
1BD62:  CLRF   x1F
1BD64:  CLRF   x20
1BD66:  CLRF   x24
1BD68:  CLRF   x23
1BD6A:  CLRF   x22
1BD6C:  CLRF   x21
1BD6E:  CLRF   x1E
1BD70:  CLRF   x1D
....................    return; 
1BD72:  MOVLB  0
1BD74:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY1to4_ADDRESS()                                                           //HIGH SAMPLING DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
*
1CB74:  MOVFF  6A,385
1CB78:  MOVFF  69,384
1CB7C:  MOVLB  3
1CB7E:  CLRF   x87
1CB80:  MOVLW  46
1CB82:  MOVWF  x86
1CB84:  MOVLB  0
1CB86:  CALL   1536
1CB8A:  MOVFF  00,31B
1CB8E:  MOVLB  3
1CB90:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CB94:  CLRF   x1F
....................    ADL = AD; 
1CB96:  MOVFF  31B,320
....................    D = AD; 
1CB9A:  MOVFF  31C,31E
1CB9E:  MOVFF  31B,31D
....................     
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1CBA2:  CLRF   x43
1CBA4:  MOVLW  DC
1CBA6:  MOVWF  x42
1CBA8:  MOVFF  31E,345
1CBAC:  MOVFF  31D,344
1CBB0:  MOVLB  0
1CBB2:  CALL   253A
1CBB6:  MOVLB  3
1CBB8:  CLRF   x24
1CBBA:  CLRF   x23
1CBBC:  MOVFF  02,322
1CBC0:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CBC4:  MOVFF  324,337
1CBC8:  MOVFF  323,336
1CBCC:  MOVFF  322,335
1CBD0:  MOVFF  321,334
1CBD4:  CLRF   x3B
1CBD6:  CLRF   x3A
1CBD8:  CLRF   x39
1CBDA:  MOVLW  51
1CBDC:  MOVWF  x38
1CBDE:  MOVLB  0
1CBE0:  CALL   24DE
1CBE4:  MOVFF  03,324
1CBE8:  MOVFF  02,323
1CBEC:  MOVFF  01,322
1CBF0:  MOVFF  00,321
....................    /*//////////////PACKET///////////////// 
....................    //220-224, 440-444, 660-664, 880-884 
....................    /////////////////////////////////////*/ 
....................     
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1CBF4:  MOVLB  3
1CBF6:  MOVFF  321,32D
1CBFA:  MOVFF  322,32E
1CBFE:  MOVLW  67
1CC00:  ADDWF  x23,W
1CC02:  MOVWF  x2F
1CC04:  MOVLW  06
1CC06:  ADDWFC x24,W
1CC08:  MOVWF  x30
1CC0A:  MOVLW  66
1CC0C:  MOVWF  x31
1CC0E:  MOVLW  77
1CC10:  MOVWF  x32
1CC12:  MOVFF  330,336
1CC16:  MOVFF  32F,335
1CC1A:  MOVFF  322,334
1CC1E:  MOVFF  321,333
1CC22:  MOVLW  01
1CC24:  MOVWF  x38
1CC26:  MOVLW  95
1CC28:  MOVWF  x37
1CC2A:  MOVLB  0
1CC2C:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CC30:  MOVLB  3
1CC32:  CLRF   x1F
1CC34:  CLRF   x20
1CC36:  CLRF   x24
1CC38:  CLRF   x23
1CC3A:  CLRF   x22
1CC3C:  CLRF   x21
1CC3E:  CLRF   x1E
1CC40:  CLRF   x1D
....................    return; 
1CC42:  MOVLB  0
1CC44:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY20to25()                                                                 //20-25day 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //20,21,22,23,24,25 
*
1C23C:  MOVFF  6A,385
1C240:  MOVFF  69,384
1C244:  MOVLB  3
1C246:  CLRF   x87
1C248:  MOVLW  46
1C24A:  MOVWF  x86
1C24C:  MOVLB  0
1C24E:  CALL   1536
1C252:  MOVFF  00,31B
1C256:  MOVLB  3
1C258:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C25C:  CLRF   x1F
....................    ADL = AD; 
1C25E:  MOVFF  31B,320
....................     
....................    D = AD - 15;                                                                  //5,6,7,8,9,10 
1C262:  MOVLW  0F
1C264:  SUBWF  x1B,W
1C266:  MOVWF  x1D
1C268:  MOVLW  00
1C26A:  SUBWFB x1C,W
1C26C:  MOVWF  x1E
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1C26E:  CLRF   x43
1C270:  MOVLW  DC
1C272:  MOVWF  x42
1C274:  MOVFF  31E,345
1C278:  MOVFF  31D,344
1C27C:  MOVLB  0
1C27E:  CALL   253A
1C282:  MOVLB  3
1C284:  CLRF   x24
1C286:  CLRF   x23
1C288:  MOVFF  02,322
1C28C:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C290:  MOVFF  324,337
1C294:  MOVFF  323,336
1C298:  MOVFF  322,335
1C29C:  MOVFF  321,334
1C2A0:  CLRF   x3B
1C2A2:  CLRF   x3A
1C2A4:  CLRF   x39
1C2A6:  MOVLW  51
1C2A8:  MOVWF  x38
1C2AA:  MOVLB  0
1C2AC:  CALL   24DE
1C2B0:  MOVFF  03,324
1C2B4:  MOVFF  02,323
1C2B8:  MOVFF  01,322
1C2BC:  MOVFF  00,321
....................    /*/////////////////////////////PACKET//////////////////////////////// 
....................    //1100-1104, 1320-1324, 1540-1544, 1760-1764, 1980,1984, 2200-2204 
....................    ///////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1C2C0:  MOVLW  FD
1C2C2:  MOVLB  3
1C2C4:  MOVWF  x53
1C2C6:  MOVFF  31F,354
1C2CA:  MOVFF  320,355
1C2CE:  MOVLB  0
1C2D0:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C2D4:  MOVLB  3
1C2D6:  MOVFF  321,32D
1C2DA:  MOVFF  322,32E
1C2DE:  MOVLW  67
1C2E0:  ADDWF  x23,W
1C2E2:  MOVWF  x2F
1C2E4:  MOVLW  06
1C2E6:  ADDWFC x24,W
1C2E8:  MOVWF  x30
1C2EA:  MOVLW  66
1C2EC:  MOVWF  x31
1C2EE:  MOVLW  77
1C2F0:  MOVWF  x32
1C2F2:  MOVFF  330,336
1C2F6:  MOVFF  32F,335
1C2FA:  MOVFF  322,334
1C2FE:  MOVFF  321,333
1C302:  MOVLW  01
1C304:  MOVWF  x38
1C306:  MOVLW  95
1C308:  MOVWF  x37
1C30A:  MOVLB  0
1C30C:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C30E:  MOVLB  3
1C310:  CLRF   x1F
1C312:  CLRF   x20
1C314:  CLRF   x24
1C316:  CLRF   x23
1C318:  CLRF   x22
1C31A:  CLRF   x21
1C31C:  CLRF   x1E
1C31E:  CLRF   x1D
....................    return; 
1C320:  MOVLB  0
1C322:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY20to25_ADDRESS()                                                         //20-25day 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //20,21,22,23,24,25 
*
1CE3C:  MOVFF  6A,385
1CE40:  MOVFF  69,384
1CE44:  MOVLB  3
1CE46:  CLRF   x87
1CE48:  MOVLW  46
1CE4A:  MOVWF  x86
1CE4C:  MOVLB  0
1CE4E:  CALL   1536
1CE52:  MOVFF  00,31B
1CE56:  MOVLB  3
1CE58:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CE5C:  CLRF   x1F
....................    ADL = AD; 
1CE5E:  MOVFF  31B,320
....................     
....................    D = AD - 15;                                                                  //5,6,7,8,9,10 
1CE62:  MOVLW  0F
1CE64:  SUBWF  x1B,W
1CE66:  MOVWF  x1D
1CE68:  MOVLW  00
1CE6A:  SUBWFB x1C,W
1CE6C:  MOVWF  x1E
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1CE6E:  CLRF   x43
1CE70:  MOVLW  DC
1CE72:  MOVWF  x42
1CE74:  MOVFF  31E,345
1CE78:  MOVFF  31D,344
1CE7C:  MOVLB  0
1CE7E:  CALL   253A
1CE82:  MOVLB  3
1CE84:  CLRF   x24
1CE86:  CLRF   x23
1CE88:  MOVFF  02,322
1CE8C:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CE90:  MOVFF  324,337
1CE94:  MOVFF  323,336
1CE98:  MOVFF  322,335
1CE9C:  MOVFF  321,334
1CEA0:  CLRF   x3B
1CEA2:  CLRF   x3A
1CEA4:  CLRF   x39
1CEA6:  MOVLW  51
1CEA8:  MOVWF  x38
1CEAA:  MOVLB  0
1CEAC:  CALL   24DE
1CEB0:  MOVFF  03,324
1CEB4:  MOVFF  02,323
1CEB8:  MOVFF  01,322
1CEBC:  MOVFF  00,321
....................    /*/////////////////////////////PACKET//////////////////////////////// 
....................    //1100-1104, 1320-1324, 1540-1544, 1760-1764, 1980,1984, 2200-2204 
....................    ///////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);//65536*8 
1CEC0:  MOVLB  3
1CEC2:  MOVFF  321,32D
1CEC6:  MOVFF  322,32E
1CECA:  MOVLW  67
1CECC:  ADDWF  x23,W
1CECE:  MOVWF  x2F
1CED0:  MOVLW  06
1CED2:  ADDWFC x24,W
1CED4:  MOVWF  x30
1CED6:  MOVLW  66
1CED8:  MOVWF  x31
1CEDA:  MOVLW  77
1CEDC:  MOVWF  x32
1CEDE:  MOVFF  330,336
1CEE2:  MOVFF  32F,335
1CEE6:  MOVFF  322,334
1CEEA:  MOVFF  321,333
1CEEE:  MOVLW  01
1CEF0:  MOVWF  x38
1CEF2:  MOVLW  95
1CEF4:  MOVWF  x37
1CEF6:  MOVLB  0
1CEF8:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CEFC:  MOVLB  3
1CEFE:  CLRF   x1F
1CF00:  CLRF   x20
1CF02:  CLRF   x24
1CF04:  CLRF   x23
1CF06:  CLRF   x22
1CF08:  CLRF   x21
1CF0A:  CLRF   x1E
1CF0C:  CLRF   x1D
....................    return; 
1CF0E:  MOVLB  0
1CF10:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ CAM MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY5()                                                                      //CAM MSN 
.................... { 
....................    SAVE_SAT_LOG(0xC0,0x11,0x11);                                                 //11,11: automatical mission 
*
1BD76:  MOVLW  C0
1BD78:  MOVLB  3
1BD7A:  MOVWF  x53
1BD7C:  MOVLW  11
1BD7E:  MOVWF  x54
1BD80:  MOVWF  x55
1BD82:  MOVLB  0
1BD84:  CALL   16EA4
....................    AUTO_CAM_DONE = 1; 
1BD88:  MOVLW  01
1BD8A:  MOVWF  x78
....................    STORE_FLAG_INFO();                                                            //save flag 
1BD8C:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM(); 
1BD90:  CALL   12FE4
....................    CAM_TEST_OPERATION(0xA0);                                                     //cam mission 320x240 low quality 
1BD94:  MOVLW  A0
1BD96:  MOVLB  3
1BD98:  MOVWF  x37
1BD9A:  MOVLB  0
1BD9C:  CALL   1AD94
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //save passed days 
1BDA0:  CALL   142D0
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BDA4:  MOVFF  6A,385
1BDA8:  MOVFF  69,384
1BDAC:  MOVLB  3
1BDAE:  CLRF   x87
1BDB0:  MOVLW  46
1BDB2:  MOVWF  x86
1BDB4:  MOVLB  0
1BDB6:  CALL   1536
1BDBA:  MOVFF  00,31B
1BDBE:  MOVLB  3
1BDC0:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BDC4:  CLRF   x1F
....................    ADL = AD; 
1BDC6:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1BDCA:  MOVLW  CD
1BDCC:  MOVWF  x53
1BDCE:  MOVFF  31F,354
1BDD2:  MOVFF  320,355
1BDD6:  MOVLB  0
1BDD8:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8,405);                                     //65536*8 
1BDDC:  MOVLW  66
1BDDE:  MOVLB  3
1BDE0:  MOVWF  x31
1BDE2:  MOVLW  77
1BDE4:  MOVWF  x32
1BDE6:  CLRF   x36
1BDE8:  MOVLW  08
1BDEA:  MOVWF  x35
1BDEC:  CLRF   x34
1BDEE:  CLRF   x33
1BDF0:  MOVLW  01
1BDF2:  MOVWF  x38
1BDF4:  MOVLW  95
1BDF6:  MOVWF  x37
1BDF8:  MOVLB  0
1BDFA:  RCALL  1BBA6
....................    return; 
1BDFC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY6to9()                                                                   //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //6,7,8,9 
1BDFE:  MOVFF  6A,385
1BE02:  MOVFF  69,384
1BE06:  MOVLB  3
1BE08:  CLRF   x87
1BE0A:  MOVLW  46
1BE0C:  MOVWF  x86
1BE0E:  MOVLB  0
1BE10:  CALL   1536
1BE14:  MOVFF  00,31B
1BE18:  MOVLB  3
1BE1A:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BE1E:  CLRF   x1F
....................    ADL = AD; 
1BE20:  MOVFF  31B,320
....................     
....................    D = AD - 5;                                                                   //1,2,3,4 
1BE24:  MOVLW  05
1BE26:  SUBWF  x1B,W
1BE28:  MOVWF  x1D
1BE2A:  MOVLW  00
1BE2C:  SUBWFB x1C,W
1BE2E:  MOVWF  x1E
....................    DL_AD = D*5;                                                                   
1BE30:  MOVFF  31E,343
1BE34:  MOVFF  31D,342
1BE38:  CLRF   x45
1BE3A:  MOVLW  05
1BE3C:  MOVWF  x44
1BE3E:  MOVLB  0
1BE40:  CALL   253A
1BE44:  MOVLB  3
1BE46:  CLRF   x24
1BE48:  CLRF   x23
1BE4A:  MOVFF  02,322
1BE4E:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //download address 
1BE52:  MOVFF  324,337
1BE56:  MOVFF  323,336
1BE5A:  MOVFF  322,335
1BE5E:  MOVFF  321,334
1BE62:  CLRF   x3B
1BE64:  CLRF   x3A
1BE66:  CLRF   x39
1BE68:  MOVLW  51
1BE6A:  MOVWF  x38
1BE6C:  MOVLB  0
1BE6E:  CALL   24DE
1BE72:  MOVFF  03,324
1BE76:  MOVFF  02,323
1BE7A:  MOVFF  01,322
1BE7E:  MOVFF  00,321
....................    /*/////////PACKET//////////// 
....................    //5-9, 10-14, 15-19, 20-24 
....................    ///////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1BE82:  MOVLW  CD
1BE84:  MOVLB  3
1BE86:  MOVWF  x53
1BE88:  MOVFF  31F,354
1BE8C:  MOVFF  320,355
1BE90:  MOVLB  0
1BE92:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1BE96:  MOVLB  3
1BE98:  MOVFF  321,32D
1BE9C:  MOVFF  322,32E
1BEA0:  MOVLW  08
1BEA2:  ADDWF  x23,W
1BEA4:  MOVWF  x2F
1BEA6:  MOVLW  00
1BEA8:  ADDWFC x24,W
1BEAA:  MOVWF  x30
1BEAC:  MOVLW  66
1BEAE:  MOVWF  x31
1BEB0:  MOVLW  77
1BEB2:  MOVWF  x32
1BEB4:  MOVFF  330,336
1BEB8:  MOVFF  32F,335
1BEBC:  MOVFF  322,334
1BEC0:  MOVFF  321,333
1BEC4:  MOVLW  01
1BEC6:  MOVWF  x38
1BEC8:  MOVLW  95
1BECA:  MOVWF  x37
1BECC:  MOVLB  0
1BECE:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1BED0:  MOVLB  3
1BED2:  CLRF   x1F
1BED4:  CLRF   x20
1BED6:  CLRF   x24
1BED8:  CLRF   x23
1BEDA:  CLRF   x22
1BEDC:  CLRF   x21
1BEDE:  CLRF   x1E
1BEE0:  CLRF   x1D
....................    return; 
1BEE2:  MOVLB  0
1BEE4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY6to9_ADDRESS()                                                           //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //6,7,8,9 
*
1CC46:  MOVFF  6A,385
1CC4A:  MOVFF  69,384
1CC4E:  MOVLB  3
1CC50:  CLRF   x87
1CC52:  MOVLW  46
1CC54:  MOVWF  x86
1CC56:  MOVLB  0
1CC58:  CALL   1536
1CC5C:  MOVFF  00,31B
1CC60:  MOVLB  3
1CC62:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CC66:  CLRF   x1F
....................    ADL = AD; 
1CC68:  MOVFF  31B,320
....................     
....................    D = AD - 5;                                                                   //1,2,3,4 
1CC6C:  MOVLW  05
1CC6E:  SUBWF  x1B,W
1CC70:  MOVWF  x1D
1CC72:  MOVLW  00
1CC74:  SUBWFB x1C,W
1CC76:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //saltos de 5 paquetes 
1CC78:  MOVFF  31E,343
1CC7C:  MOVFF  31D,342
1CC80:  CLRF   x45
1CC82:  MOVLW  05
1CC84:  MOVWF  x44
1CC86:  MOVLB  0
1CC88:  CALL   253A
1CC8C:  MOVLB  3
1CC8E:  CLRF   x24
1CC90:  CLRF   x23
1CC92:  MOVFF  02,322
1CC96:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CC9A:  MOVFF  324,337
1CC9E:  MOVFF  323,336
1CCA2:  MOVFF  322,335
1CCA6:  MOVFF  321,334
1CCAA:  CLRF   x3B
1CCAC:  CLRF   x3A
1CCAE:  CLRF   x39
1CCB0:  MOVLW  51
1CCB2:  MOVWF  x38
1CCB4:  MOVLB  0
1CCB6:  CALL   24DE
1CCBA:  MOVFF  03,324
1CCBE:  MOVFF  02,323
1CCC2:  MOVFF  01,322
1CCC6:  MOVFF  00,321
....................    /*/////////PACKET//////////// 
....................    //5-9, 10-14, 15-19, 20-24 
....................    ///////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1CCCA:  MOVLB  3
1CCCC:  MOVFF  321,32D
1CCD0:  MOVFF  322,32E
1CCD4:  MOVLW  08
1CCD6:  ADDWF  x23,W
1CCD8:  MOVWF  x2F
1CCDA:  MOVLW  00
1CCDC:  ADDWFC x24,W
1CCDE:  MOVWF  x30
1CCE0:  MOVLW  66
1CCE2:  MOVWF  x31
1CCE4:  MOVLW  77
1CCE6:  MOVWF  x32
1CCE8:  MOVFF  330,336
1CCEC:  MOVFF  32F,335
1CCF0:  MOVFF  322,334
1CCF4:  MOVFF  321,333
1CCF8:  MOVLW  01
1CCFA:  MOVWF  x38
1CCFC:  MOVLW  95
1CCFE:  MOVWF  x37
1CD00:  MOVLB  0
1CD02:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CD06:  MOVLB  3
1CD08:  CLRF   x1F
1CD0A:  CLRF   x20
1CD0C:  CLRF   x24
1CD0E:  CLRF   x23
1CD10:  CLRF   x22
1CD12:  CLRF   x21
1CD14:  CLRF   x1E
1CD16:  CLRF   x1D
....................    return; 
1CD18:  MOVLB  0
1CD1A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY26to46()                                                                 //CAM Download 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46 
*
1C324:  MOVFF  6A,385
1C328:  MOVFF  69,384
1C32C:  MOVLB  3
1C32E:  CLRF   x87
1C330:  MOVLW  46
1C332:  MOVWF  x86
1C334:  MOVLB  0
1C336:  CALL   1536
1C33A:  MOVFF  00,31B
1C33E:  MOVLB  3
1C340:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C344:  CLRF   x1F
....................    ADL = AD; 
1C346:  MOVFF  31B,320
....................     
....................    D = AD - 21;                                                                  //se le descuenta 21 para continuar con la descarga desde el paquete 25  
1C34A:  MOVLW  15
1C34C:  SUBWF  x1B,W
1C34E:  MOVWF  x1D
1C350:  MOVLW  00
1C352:  SUBWFB x1C,W
1C354:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //los primeros 25 se descarga en los primeros 5 dias 
1C356:  MOVFF  31E,343
1C35A:  MOVFF  31D,342
1C35E:  CLRF   x45
1C360:  MOVLW  05
1C362:  MOVWF  x44
1C364:  MOVLB  0
1C366:  CALL   253A
1C36A:  MOVLB  3
1C36C:  CLRF   x24
1C36E:  CLRF   x23
1C370:  MOVFF  02,322
1C374:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C378:  MOVFF  324,337
1C37C:  MOVFF  323,336
1C380:  MOVFF  322,335
1C384:  MOVFF  321,334
1C388:  CLRF   x3B
1C38A:  CLRF   x3A
1C38C:  CLRF   x39
1C38E:  MOVLW  51
1C390:  MOVWF  x38
1C392:  MOVLB  0
1C394:  CALL   24DE
1C398:  MOVFF  03,324
1C39C:  MOVFF  02,323
1C3A0:  MOVFF  01,322
1C3A4:  MOVFF  00,321
....................    /*//////////////////////PACKET///////////////////////// 
....................    //25-29,   30-34,   35-39,   40-44,   45-49 
....................    //50-54,   55-59,   60-64,   65-69,   70-74 
....................    //75-79,   80-84,   85-89,   90-94,   95-99 
....................    //100-104, 105-109, 110-114, 115-119, 120-124 
....................    //125-129 
....................    //---------------------------------------------------- 
....................    //total is 129 packet 
....................    ////////////////////////////////////////////////////// 
....................     
....................    /////////////////////////////BYTE///////////////////////// 
....................    //2025-2429, 2430-2834, 2835-3239, 3240-3644, 3645-4049 
....................    //4050-4454, 4455-4859, 4860-5264, 5265-5669, 5670-6074 
....................    //6075-6479, 6480-6884, 6885-7289, 7290-7694, 7695-8099 
....................    //8100-8504, 8505-8909, 8910-9314, 9315-9719, 9720-10124 
....................    //10125-10530 
....................    //-------------------------------------------------------- 
....................    //total is about 10kB 
....................    /////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1C3A8:  MOVLW  CD
1C3AA:  MOVLB  3
1C3AC:  MOVWF  x53
1C3AE:  MOVFF  31F,354
1C3B2:  MOVFF  320,355
1C3B6:  MOVLB  0
1C3B8:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1C3BC:  MOVLB  3
1C3BE:  MOVFF  321,32D
1C3C2:  MOVFF  322,32E
1C3C6:  MOVLW  08
1C3C8:  ADDWF  x23,W
1C3CA:  MOVWF  x2F
1C3CC:  MOVLW  00
1C3CE:  ADDWFC x24,W
1C3D0:  MOVWF  x30
1C3D2:  MOVLW  66
1C3D4:  MOVWF  x31
1C3D6:  MOVLW  77
1C3D8:  MOVWF  x32
1C3DA:  MOVFF  330,336
1C3DE:  MOVFF  32F,335
1C3E2:  MOVFF  322,334
1C3E6:  MOVFF  321,333
1C3EA:  MOVLW  01
1C3EC:  MOVWF  x38
1C3EE:  MOVLW  95
1C3F0:  MOVWF  x37
1C3F2:  MOVLB  0
1C3F4:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C3F8:  MOVLB  3
1C3FA:  CLRF   x1F
1C3FC:  CLRF   x20
1C3FE:  CLRF   x24
1C400:  CLRF   x23
1C402:  CLRF   x22
1C404:  CLRF   x21
1C406:  CLRF   x1E
1C408:  CLRF   x1D
....................    return; 
1C40A:  MOVLB  0
1C40C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY26to46_ADDRESS()                                                         //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46 
*
1CF12:  MOVFF  6A,385
1CF16:  MOVFF  69,384
1CF1A:  MOVLB  3
1CF1C:  CLRF   x87
1CF1E:  MOVLW  46
1CF20:  MOVWF  x86
1CF22:  MOVLB  0
1CF24:  CALL   1536
1CF28:  MOVFF  00,31B
1CF2C:  MOVLB  3
1CF2E:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CF32:  CLRF   x1F
....................    ADL = AD; 
1CF34:  MOVFF  31B,320
....................     
....................    D = AD - 21; 
1CF38:  MOVLW  15
1CF3A:  SUBWF  x1B,W
1CF3C:  MOVWF  x1D
1CF3E:  MOVLW  00
1CF40:  SUBWFB x1C,W
1CF42:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //saltos de 5 paquetes 
1CF44:  MOVFF  31E,343
1CF48:  MOVFF  31D,342
1CF4C:  CLRF   x45
1CF4E:  MOVLW  05
1CF50:  MOVWF  x44
1CF52:  MOVLB  0
1CF54:  CALL   253A
1CF58:  MOVLB  3
1CF5A:  CLRF   x24
1CF5C:  CLRF   x23
1CF5E:  MOVFF  02,322
1CF62:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CF66:  MOVFF  324,337
1CF6A:  MOVFF  323,336
1CF6E:  MOVFF  322,335
1CF72:  MOVFF  321,334
1CF76:  CLRF   x3B
1CF78:  CLRF   x3A
1CF7A:  CLRF   x39
1CF7C:  MOVLW  51
1CF7E:  MOVWF  x38
1CF80:  MOVLB  0
1CF82:  CALL   24DE
1CF86:  MOVFF  03,324
1CF8A:  MOVFF  02,323
1CF8E:  MOVFF  01,322
1CF92:  MOVFF  00,321
....................    /*//////////////////////PACKET///////////////////////// 
....................    //25-29,   40-34,   35-39,   40-44,   45-49 
....................    //50-54,   55-59,   60-64,   65-69,   70-74 
....................    //75-79,   80-84,   85-89,   90-94,   95-99 
....................    //100-104, 105-109, 110-114, 115-119, 120-124 
....................    //125-129 
....................    //---------------------------------------------------- 
....................    //total is 129 packet 
....................    ////////////////////////////////////////////////////// 
....................     
....................    /////////////////////////////BYTE///////////////////////// 
....................    //2025-2429, 2430-2834, 2835-3239, 3240-3644, 3645-4049 
....................    //4050-4454, 4455-4859, 4860-5264, 5265-5669, 5670-6074 
....................    //6075-6479, 6480-6884, 6885-7289, 7290-7694, 7695-8099 
....................    //8100-8504, 8505-8909, 8910-9314, 9315-9719, 9720-10124 
....................    //10125-10530 
....................    //-------------------------------------------------------- 
....................    //total is about 10kB 
....................    /////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1CF96:  MOVLB  3
1CF98:  MOVFF  321,32D
1CF9C:  MOVFF  322,32E
1CFA0:  MOVLW  08
1CFA2:  ADDWF  x23,W
1CFA4:  MOVWF  x2F
1CFA6:  MOVLW  00
1CFA8:  ADDWFC x24,W
1CFAA:  MOVWF  x30
1CFAC:  MOVLW  66
1CFAE:  MOVWF  x31
1CFB0:  MOVLW  77
1CFB2:  MOVWF  x32
1CFB4:  MOVFF  330,336
1CFB8:  MOVFF  32F,335
1CFBC:  MOVFF  322,334
1CFC0:  MOVFF  321,333
1CFC4:  MOVLW  01
1CFC6:  MOVWF  x38
1CFC8:  MOVLW  95
1CFCA:  MOVWF  x37
1CFCC:  MOVLB  0
1CFCE:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CFD2:  MOVLB  3
1CFD4:  CLRF   x1F
1CFD6:  CLRF   x20
1CFD8:  CLRF   x24
1CFDA:  CLRF   x23
1CFDC:  CLRF   x22
1CFDE:  CLRF   x21
1CFE0:  CLRF   x1E
1CFE2:  CLRF   x1D
....................    return; 
1CFE4:  MOVLB  0
1CFE6:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@ MBP MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY10()                                                                     //MBP mission 
.................... { 
....................    AUTO_MBP_DONE = 1; 
*
1BEE6:  MOVLW  01
1BEE8:  MOVWF  x79
....................    STORE_FLAG_INFO();                                                            //save flag 
1BEEA:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM(); 
1BEEE:  CALL   12FE4
....................     
....................    SAVE_SAT_LOG(0xD0,0x11,0x11);                                                 //11,11: automatical mission 
1BEF2:  MOVLW  D0
1BEF4:  MOVLB  3
1BEF6:  MOVWF  x53
1BEF8:  MOVLW  11
1BEFA:  MOVWF  x54
1BEFC:  MOVWF  x55
1BEFE:  MOVLB  0
1BF00:  CALL   16EA4
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //1 execution of the mission 
....................    delay_ms(3000); 
1BF04:  MOVLW  0C
1BF06:  MOVLB  3
1BF08:  MOVWF  x2D
1BF0A:  MOVLW  FA
1BF0C:  MOVWF  x98
1BF0E:  MOVLB  0
1BF10:  CALL   063E
1BF14:  MOVLB  3
1BF16:  DECFSZ x2D,F
1BF18:  BRA    1BF0A
....................    SAVE_SAT_LOG(0xD0,0x22,0x22);                                                 //01,01: automatical mission 
1BF1A:  MOVLW  D0
1BF1C:  MOVWF  x53
1BF1E:  MOVLW  22
1BF20:  MOVWF  x54
1BF22:  MOVWF  x55
1BF24:  MOVLB  0
1BF26:  CALL   16EA4
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //2 execution of the mission 
....................    delay_ms(3000); 
1BF2A:  MOVLW  0C
1BF2C:  MOVLB  3
1BF2E:  MOVWF  x2D
1BF30:  MOVLW  FA
1BF32:  MOVWF  x98
1BF34:  MOVLB  0
1BF36:  CALL   063E
1BF3A:  MOVLB  3
1BF3C:  DECFSZ x2D,F
1BF3E:  BRA    1BF30
....................    SAVE_SAT_LOG(0xD0,0x33,0x33);                                                 //01,01: automatical mission 
1BF40:  MOVLW  D0
1BF42:  MOVWF  x53
1BF44:  MOVLW  33
1BF46:  MOVWF  x54
1BF48:  MOVWF  x55
1BF4A:  MOVLB  0
1BF4C:  CALL   16EA4
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //3 execution of the mission 
....................    delay_ms(3000); 
1BF50:  MOVLW  0C
1BF52:  MOVLB  3
1BF54:  MOVWF  x2D
1BF56:  MOVLW  FA
1BF58:  MOVWF  x98
1BF5A:  MOVLB  0
1BF5C:  CALL   063E
1BF60:  MOVLB  3
1BF62:  DECFSZ x2D,F
1BF64:  BRA    1BF56
....................    SAVE_SAT_LOG(0xD0,0x44,0x44);                                                 //01,01: automatical mission 
1BF66:  MOVLW  D0
1BF68:  MOVWF  x53
1BF6A:  MOVLW  44
1BF6C:  MOVWF  x54
1BF6E:  MOVWF  x55
1BF70:  MOVLB  0
1BF72:  CALL   16EA4
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //4 execution of the mission 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1BF76:  CALL   142D0
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //10 
1BF7A:  MOVFF  6A,385
1BF7E:  MOVFF  69,384
1BF82:  MOVLB  3
1BF84:  CLRF   x87
1BF86:  MOVLW  46
1BF88:  MOVWF  x86
1BF8A:  MOVLB  0
1BF8C:  CALL   1536
1BF90:  MOVFF  00,31B
1BF94:  MOVLB  3
1BF96:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BF9A:  CLRF   x1F
....................    ADL = AD; 
1BF9C:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xDD,ADH,ADL);                                                   //11,11: automatical mission 
1BFA0:  MOVLW  DD
1BFA2:  MOVWF  x53
1BFA4:  MOVFF  31F,354
1BFA8:  MOVFF  320,355
1BFAC:  MOVLB  0
1BFAE:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);                      //65536*162, 332 corresponde a 4 paquetes de 83 recibidos de la ejecucion de DC 
1BFB2:  MOVLW  4C
1BFB4:  SUBWF  58,W
1BFB6:  MOVLB  3
1BFB8:  MOVWF  x2D
1BFBA:  MOVLW  01
1BFBC:  SUBWFB 59,W
1BFBE:  MOVWF  x2E
1BFC0:  MOVLW  00
1BFC2:  SUBWFB 5A,W
1BFC4:  MOVWF  x2F
1BFC6:  MOVLW  00
1BFC8:  SUBWFB 5B,W
1BFCA:  MOVWF  x30
1BFCC:  MOVLW  66
1BFCE:  MOVWF  x31
1BFD0:  MOVLW  77
1BFD2:  MOVWF  x32
1BFD4:  MOVFF  330,336
1BFD8:  MOVFF  32F,335
1BFDC:  MOVFF  32E,334
1BFE0:  MOVFF  32D,333
1BFE4:  MOVLW  01
1BFE6:  MOVWF  x38
1BFE8:  MOVLW  4C
1BFEA:  MOVWF  x37
1BFEC:  MOVLB  0
1BFEE:  RCALL  1BBA6
....................    return; 
1BFF0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY11to14()                                                                 //MBP Data download 
.................... { 
....................    SAVE_SAT_LOG(0xD0,0x11,0x11);                                                 //01,01: automatical mission 
1BFF2:  MOVLW  D0
1BFF4:  MOVLB  3
1BFF6:  MOVWF  x53
1BFF8:  MOVLW  11
1BFFA:  MOVWF  x54
1BFFC:  MOVWF  x55
1BFFE:  MOVLB  0
1C000:  CALL   16EA4
....................    /* 
....................    DATACOLLECTION_TEST_OPERATION();                                               1 execution of the mission 
....................    */ 
....................    delay_ms(3000); 
1C004:  MOVLW  0C
1C006:  MOVLB  3
1C008:  MOVWF  x2D
1C00A:  MOVLW  FA
1C00C:  MOVWF  x98
1C00E:  MOVLB  0
1C010:  CALL   063E
1C014:  MOVLB  3
1C016:  DECFSZ x2D,F
1C018:  BRA    1C00A
....................    SAVE_SAT_LOG(0xD0,0x22,0x22);                                                 //01,01: automatical mission 
1C01A:  MOVLW  D0
1C01C:  MOVWF  x53
1C01E:  MOVLW  22
1C020:  MOVWF  x54
1C022:  MOVWF  x55
1C024:  MOVLB  0
1C026:  CALL   16EA4
....................  
....................    delay_ms(3000); 
1C02A:  MOVLW  0C
1C02C:  MOVLB  3
1C02E:  MOVWF  x2D
1C030:  MOVLW  FA
1C032:  MOVWF  x98
1C034:  MOVLB  0
1C036:  CALL   063E
1C03A:  MOVLB  3
1C03C:  DECFSZ x2D,F
1C03E:  BRA    1C030
....................    SAVE_SAT_LOG(0xD0,0x33,0x33);                                                 //01,01: automatical mission 
1C040:  MOVLW  D0
1C042:  MOVWF  x53
1C044:  MOVLW  33
1C046:  MOVWF  x54
1C048:  MOVWF  x55
1C04A:  MOVLB  0
1C04C:  CALL   16EA4
....................  
....................    delay_ms(3000); 
1C050:  MOVLW  0C
1C052:  MOVLB  3
1C054:  MOVWF  x2D
1C056:  MOVLW  FA
1C058:  MOVWF  x98
1C05A:  MOVLB  0
1C05C:  CALL   063E
1C060:  MOVLB  3
1C062:  DECFSZ x2D,F
1C064:  BRA    1C056
....................    SAVE_SAT_LOG(0xD4,0x44,0x44);                                                 //01,01: automatical mission 
1C066:  MOVLW  D4
1C068:  MOVWF  x53
1C06A:  MOVLW  44
1C06C:  MOVWF  x54
1C06E:  MOVWF  x55
1C070:  MOVLB  0
1C072:  CALL   16EA4
....................  
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1C076:  CALL   142D0
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //11,12,13,14 
1C07A:  MOVFF  6A,385
1C07E:  MOVFF  69,384
1C082:  MOVLB  3
1C084:  CLRF   x87
1C086:  MOVLW  46
1C088:  MOVWF  x86
1C08A:  MOVLB  0
1C08C:  CALL   1536
1C090:  MOVFF  00,31B
1C094:  MOVLB  3
1C096:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C09A:  CLRF   x1F
....................    ADL = AD; 
1C09C:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xDD,ADH,ADL); 
1C0A0:  MOVLW  DD
1C0A2:  MOVWF  x53
1C0A4:  MOVFF  31F,354
1C0A8:  MOVFF  320,355
1C0AC:  MOVLB  0
1C0AE:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);                      //65536*8 
1C0B2:  MOVLW  4C
1C0B4:  SUBWF  58,W
1C0B6:  MOVLB  3
1C0B8:  MOVWF  x2D
1C0BA:  MOVLW  01
1C0BC:  SUBWFB 59,W
1C0BE:  MOVWF  x2E
1C0C0:  MOVLW  00
1C0C2:  SUBWFB 5A,W
1C0C4:  MOVWF  x2F
1C0C6:  MOVLW  00
1C0C8:  SUBWFB 5B,W
1C0CA:  MOVWF  x30
1C0CC:  MOVLW  66
1C0CE:  MOVWF  x31
1C0D0:  MOVLW  77
1C0D2:  MOVWF  x32
1C0D4:  MOVFF  330,336
1C0D8:  MOVFF  32F,335
1C0DC:  MOVFF  32E,334
1C0E0:  MOVFF  32D,333
1C0E4:  MOVLW  01
1C0E6:  MOVWF  x38
1C0E8:  MOVLW  4C
1C0EA:  MOVWF  x37
1C0EC:  MOVLB  0
1C0EE:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C0F0:  MOVLB  3
1C0F2:  CLRF   x1F
1C0F4:  CLRF   x20
1C0F6:  CLRF   x24
1C0F8:  CLRF   x23
1C0FA:  CLRF   x22
1C0FC:  CLRF   x21
1C0FE:  CLRF   x1E
1C100:  CLRF   x1D
....................    return; 
1C102:  MOVLB  0
1C104:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY11to14_ADDRESS()                                                         //MBP Data download 
.................... {    
....................    AD = PASSED_DAYS % loop_day;                                                  //11,12,13,14 
*
1CD1C:  MOVFF  6A,385
1CD20:  MOVFF  69,384
1CD24:  MOVLB  3
1CD26:  CLRF   x87
1CD28:  MOVLW  46
1CD2A:  MOVWF  x86
1CD2C:  MOVLB  0
1CD2E:  CALL   1536
1CD32:  MOVFF  00,31B
1CD36:  MOVLB  3
1CD38:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CD3C:  CLRF   x1F
....................    ADL = AD; 
1CD3E:  MOVFF  31B,320
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);//65536*8 
1CD42:  MOVLW  4C
1CD44:  SUBWF  58,W
1CD46:  MOVWF  x2D
1CD48:  MOVLW  01
1CD4A:  SUBWFB 59,W
1CD4C:  MOVWF  x2E
1CD4E:  MOVLW  00
1CD50:  SUBWFB 5A,W
1CD52:  MOVWF  x2F
1CD54:  MOVLW  00
1CD56:  SUBWFB 5B,W
1CD58:  MOVWF  x30
1CD5A:  MOVLW  66
1CD5C:  MOVWF  x31
1CD5E:  MOVLW  77
1CD60:  MOVWF  x32
1CD62:  MOVFF  330,336
1CD66:  MOVFF  32F,335
1CD6A:  MOVFF  32E,334
1CD6E:  MOVFF  32D,333
1CD72:  MOVLW  01
1CD74:  MOVWF  x38
1CD76:  MOVLW  4C
1CD78:  MOVWF  x37
1CD7A:  MOVLB  0
1CD7C:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CD80:  MOVLB  3
1CD82:  CLRF   x1F
1CD84:  CLRF   x20
1CD86:  CLRF   x24
1CD88:  CLRF   x23
1CD8A:  CLRF   x22
1CD8C:  CLRF   x21
1CD8E:  CLRF   x1E
1CD90:  CLRF   x1D
....................    return; 
1CD92:  MOVLB  0
1CD94:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ ADCS MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY15()                                                                     //ADCS MSN 
.................... { 
....................    SAVE_SAT_LOG(0xA0,0x11,0x11);                                                 //01,01: automatical mission 
*
1C106:  MOVLW  A0
1C108:  MOVLB  3
1C10A:  MOVWF  x53
1C10C:  MOVLW  11
1C10E:  MOVWF  x54
1C110:  MOVWF  x55
1C112:  MOVLB  0
1C114:  CALL   16EA4
....................    AUTO_ADCS_DONE = 1; 
1C118:  MOVLW  01
1C11A:  MOVWF  x7A
....................    STORE_FLAG_INFO();                                                            //save flag 
1C11C:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM();  
1C120:  CALL   12FE4
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1C124:  CALL   142D0
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //15 
1C128:  MOVFF  6A,385
1C12C:  MOVFF  69,384
1C130:  MOVLB  3
1C132:  CLRF   x87
1C134:  MOVLW  46
1C136:  MOVWF  x86
1C138:  MOVLB  0
1C13A:  CALL   1536
1C13E:  MOVFF  00,31B
1C142:  MOVLB  3
1C144:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C148:  CLRF   x1F
....................    ADL = AD; 
1C14A:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C14E:  MOVLW  AD
1C150:  MOVWF  x53
1C152:  MOVFF  31F,354
1C156:  MOVFF  320,355
1C15A:  MOVLB  0
1C15C:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66, 0x77, SECT*1138, 405);                               //(9byte) + (initial 81byte) + (end 81byte) 
1C160:  MOVLW  66
1C162:  MOVLB  3
1C164:  MOVWF  x31
1C166:  MOVLW  77
1C168:  MOVWF  x32
1C16A:  MOVLW  04
1C16C:  MOVWF  x36
1C16E:  MOVLW  72
1C170:  MOVWF  x35
1C172:  CLRF   x34
1C174:  CLRF   x33
1C176:  MOVLW  01
1C178:  MOVWF  x38
1C17A:  MOVLW  95
1C17C:  MOVWF  x37
1C17E:  MOVLB  0
1C180:  RCALL  1BBA6
....................    return; 
1C182:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY16to19()                                                                 //ADCS Data download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //16,17,18,19 
1C184:  MOVFF  6A,385
1C188:  MOVFF  69,384
1C18C:  MOVLB  3
1C18E:  CLRF   x87
1C190:  MOVLW  46
1C192:  MOVWF  x86
1C194:  MOVLB  0
1C196:  CALL   1536
1C19A:  MOVFF  00,31B
1C19E:  MOVLB  3
1C1A0:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C1A4:  CLRF   x1F
....................    ADL = AD; 
1C1A6:  MOVFF  31B,320
....................    D = AD - 15; 
1C1AA:  MOVLW  0F
1C1AC:  SUBWF  x1B,W
1C1AE:  MOVWF  x1D
1C1B0:  MOVLW  00
1C1B2:  SUBWFB x1C,W
1C1B4:  MOVWF  x1E
....................    DL_AD = 360*D; 
1C1B6:  MOVLW  01
1C1B8:  MOVWF  x43
1C1BA:  MOVLW  68
1C1BC:  MOVWF  x42
1C1BE:  MOVFF  31E,345
1C1C2:  MOVFF  31D,344
1C1C6:  MOVLB  0
1C1C8:  CALL   253A
1C1CC:  MOVLB  3
1C1CE:  CLRF   x24
1C1D0:  CLRF   x23
1C1D2:  MOVFF  02,322
1C1D6:  MOVFF  01,321
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C1DA:  MOVLW  AD
1C1DC:  MOVWF  x53
1C1DE:  MOVFF  31F,354
1C1E2:  MOVFF  320,355
1C1E6:  MOVLB  0
1C1E8:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C1EC:  MOVLB  3
1C1EE:  MOVFF  321,32D
1C1F2:  MOVFF  322,32E
1C1F6:  MOVLW  67
1C1F8:  ADDWF  x23,W
1C1FA:  MOVWF  x2F
1C1FC:  MOVLW  06
1C1FE:  ADDWFC x24,W
1C200:  MOVWF  x30
1C202:  MOVLW  66
1C204:  MOVWF  x31
1C206:  MOVLW  77
1C208:  MOVWF  x32
1C20A:  MOVFF  330,336
1C20E:  MOVFF  32F,335
1C212:  MOVFF  322,334
1C216:  MOVFF  321,333
1C21A:  MOVLW  01
1C21C:  MOVWF  x38
1C21E:  MOVLW  95
1C220:  MOVWF  x37
1C222:  MOVLB  0
1C224:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C226:  MOVLB  3
1C228:  CLRF   x1F
1C22A:  CLRF   x20
1C22C:  CLRF   x24
1C22E:  CLRF   x23
1C230:  CLRF   x22
1C232:  CLRF   x21
1C234:  CLRF   x1E
1C236:  CLRF   x1D
....................    return; 
1C238:  MOVLB  0
1C23A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY16to19_ADDRESS()                                                         //ADCS DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //16,17,18,19 
*
1CD96:  MOVFF  6A,385
1CD9A:  MOVFF  69,384
1CD9E:  MOVLB  3
1CDA0:  CLRF   x87
1CDA2:  MOVLW  46
1CDA4:  MOVWF  x86
1CDA6:  MOVLB  0
1CDA8:  CALL   1536
1CDAC:  MOVFF  00,31B
1CDB0:  MOVLB  3
1CDB2:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CDB6:  CLRF   x1F
....................    ADL = AD; 
1CDB8:  MOVFF  31B,320
....................    D = AD - 15; 
1CDBC:  MOVLW  0F
1CDBE:  SUBWF  x1B,W
1CDC0:  MOVWF  x1D
1CDC2:  MOVLW  00
1CDC4:  SUBWFB x1C,W
1CDC6:  MOVWF  x1E
....................    DL_AD = 360*D;                                                                //saltos de 360 paquetes 
1CDC8:  MOVLW  01
1CDCA:  MOVWF  x43
1CDCC:  MOVLW  68
1CDCE:  MOVWF  x42
1CDD0:  MOVFF  31E,345
1CDD4:  MOVFF  31D,344
1CDD8:  MOVLB  0
1CDDA:  CALL   253A
1CDDE:  MOVLB  3
1CDE0:  CLRF   x24
1CDE2:  CLRF   x23
1CDE4:  MOVFF  02,322
1CDE8:  MOVFF  01,321
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1CDEC:  MOVFF  321,32D
1CDF0:  MOVFF  322,32E
1CDF4:  MOVLW  67
1CDF6:  ADDWF  x23,W
1CDF8:  MOVWF  x2F
1CDFA:  MOVLW  06
1CDFC:  ADDWFC x24,W
1CDFE:  MOVWF  x30
1CE00:  MOVLW  66
1CE02:  MOVWF  x31
1CE04:  MOVLW  77
1CE06:  MOVWF  x32
1CE08:  MOVFF  330,336
1CE0C:  MOVFF  32F,335
1CE10:  MOVFF  322,334
1CE14:  MOVFF  321,333
1CE18:  MOVLW  01
1CE1A:  MOVWF  x38
1CE1C:  MOVLW  95
1CE1E:  MOVWF  x37
1CE20:  MOVLB  0
1CE22:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CE26:  MOVLB  3
1CE28:  CLRF   x1F
1CE2A:  CLRF   x20
1CE2C:  CLRF   x24
1CE2E:  CLRF   x23
1CE30:  CLRF   x22
1CE32:  CLRF   x21
1CE34:  CLRF   x1E
1CE36:  CLRF   x1D
....................    return; 
1CE38:  MOVLB  0
1CE3A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY47to52()                                                                 //ADCS Datadownload 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //47,48,49,50,51,52 
*
1C40E:  MOVFF  6A,385
1C412:  MOVFF  69,384
1C416:  MOVLB  3
1C418:  CLRF   x87
1C41A:  MOVLW  46
1C41C:  MOVWF  x86
1C41E:  MOVLB  0
1C420:  CALL   1536
1C424:  MOVFF  00,31B
1C428:  MOVLB  3
1C42A:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C42E:  CLRF   x1F
....................    ADL = AD; 
1C430:  MOVFF  31B,320
....................    D = AD - 42;                                                                  //5,6,7,8,9,10 
1C434:  MOVLW  2A
1C436:  SUBWF  x1B,W
1C438:  MOVWF  x1D
1C43A:  MOVLW  00
1C43C:  SUBWFB x1C,W
1C43E:  MOVWF  x1E
....................     
....................    DL_AD = 360*D;                                                                //realiza saltos de 360 
1C440:  MOVLW  01
1C442:  MOVWF  x43
1C444:  MOVLW  68
1C446:  MOVWF  x42
1C448:  MOVFF  31E,345
1C44C:  MOVFF  31D,344
1C450:  MOVLB  0
1C452:  CALL   253A
1C456:  MOVLB  3
1C458:  CLRF   x24
1C45A:  CLRF   x23
1C45C:  MOVFF  02,322
1C460:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //download address 
1C464:  MOVFF  324,337
1C468:  MOVFF  323,336
1C46C:  MOVFF  322,335
1C470:  MOVFF  321,334
1C474:  CLRF   x3B
1C476:  CLRF   x3A
1C478:  CLRF   x39
1C47A:  MOVLW  51
1C47C:  MOVWF  x38
1C47E:  MOVLB  0
1C480:  CALL   24DE
1C484:  MOVFF  03,324
1C488:  MOVFF  02,323
1C48C:  MOVFF  01,322
1C490:  MOVFF  00,321
....................    /*////////////////////////////PACKET//////////////////////////////// 
....................    //1800-1804, 2160-2164, 2520-2524, 2880-2884, 3240-3244, 3600-3604 
....................    //////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C494:  MOVLW  AD
1C496:  MOVLB  3
1C498:  MOVWF  x53
1C49A:  MOVFF  31F,354
1C49E:  MOVFF  320,355
1C4A2:  MOVLB  0
1C4A4:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C4A8:  MOVLB  3
1C4AA:  MOVFF  321,32D
1C4AE:  MOVFF  322,32E
1C4B2:  MOVLW  67
1C4B4:  ADDWF  x23,W
1C4B6:  MOVWF  x2F
1C4B8:  MOVLW  06
1C4BA:  ADDWFC x24,W
1C4BC:  MOVWF  x30
1C4BE:  MOVLW  66
1C4C0:  MOVWF  x31
1C4C2:  MOVLW  77
1C4C4:  MOVWF  x32
1C4C6:  MOVFF  330,336
1C4CA:  MOVFF  32F,335
1C4CE:  MOVFF  322,334
1C4D2:  MOVFF  321,333
1C4D6:  MOVLW  01
1C4D8:  MOVWF  x38
1C4DA:  MOVLW  95
1C4DC:  MOVWF  x37
1C4DE:  MOVLB  0
1C4E0:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C4E4:  MOVLB  3
1C4E6:  CLRF   x1F
1C4E8:  CLRF   x20
1C4EA:  CLRF   x24
1C4EC:  CLRF   x23
1C4EE:  CLRF   x22
1C4F0:  CLRF   x21
1C4F2:  CLRF   x1E
1C4F4:  CLRF   x1D
....................    return; 
1C4F6:  MOVLB  0
1C4F8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY47to52_ADDRESS()                                                         //ADCS DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //47,48,49,50,51,52 
*
1CFE8:  MOVFF  6A,385
1CFEC:  MOVFF  69,384
1CFF0:  MOVLB  3
1CFF2:  CLRF   x87
1CFF4:  MOVLW  46
1CFF6:  MOVWF  x86
1CFF8:  MOVLB  0
1CFFA:  CALL   1536
1CFFE:  MOVFF  00,31B
1D002:  MOVLB  3
1D004:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D008:  CLRF   x1F
....................    ADL = AD; 
1D00A:  MOVFF  31B,320
....................    D = AD - 42;                                                                  //5,6,7,8,9,10 
1D00E:  MOVLW  2A
1D010:  SUBWF  x1B,W
1D012:  MOVWF  x1D
1D014:  MOVLW  00
1D016:  SUBWFB x1C,W
1D018:  MOVWF  x1E
....................     
....................    DL_AD = 360*D;                                                                //saltos de 360 paquetes 
1D01A:  MOVLW  01
1D01C:  MOVWF  x43
1D01E:  MOVLW  68
1D020:  MOVWF  x42
1D022:  MOVFF  31E,345
1D026:  MOVFF  31D,344
1D02A:  MOVLB  0
1D02C:  CALL   253A
1D030:  MOVLB  3
1D032:  CLRF   x24
1D034:  CLRF   x23
1D036:  MOVFF  02,322
1D03A:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1D03E:  MOVFF  324,337
1D042:  MOVFF  323,336
1D046:  MOVFF  322,335
1D04A:  MOVFF  321,334
1D04E:  CLRF   x3B
1D050:  CLRF   x3A
1D052:  CLRF   x39
1D054:  MOVLW  51
1D056:  MOVWF  x38
1D058:  MOVLB  0
1D05A:  CALL   24DE
1D05E:  MOVFF  03,324
1D062:  MOVFF  02,323
1D066:  MOVFF  01,322
1D06A:  MOVFF  00,321
....................    /*////////////////////////////PACKET//////////////////////////////// 
....................    //1800-1804, 2160-2164, 2520-2524, 2880-2884, 3240-3244, 3600-3604 
....................    //////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1D06E:  MOVLB  3
1D070:  MOVFF  321,32D
1D074:  MOVFF  322,32E
1D078:  MOVLW  67
1D07A:  ADDWF  x23,W
1D07C:  MOVWF  x2F
1D07E:  MOVLW  06
1D080:  ADDWFC x24,W
1D082:  MOVWF  x30
1D084:  MOVLW  66
1D086:  MOVWF  x31
1D088:  MOVLW  77
1D08A:  MOVWF  x32
1D08C:  MOVFF  330,336
1D090:  MOVFF  32F,335
1D094:  MOVFF  322,334
1D098:  MOVFF  321,333
1D09C:  MOVLW  01
1D09E:  MOVWF  x38
1D0A0:  MOVLW  95
1D0A2:  MOVWF  x37
1D0A4:  MOVLB  0
1D0A6:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D0AA:  MOVLB  3
1D0AC:  CLRF   x1F
1D0AE:  CLRF   x20
1D0B0:  CLRF   x24
1D0B2:  CLRF   x23
1D0B4:  CLRF   x22
1D0B6:  CLRF   x21
1D0B8:  CLRF   x1E
1D0BA:  CLRF   x1D
....................    return; 
1D0BC:  MOVLB  0
1D0BE:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ SAT_LOG @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY53to59()                                                                 //LOG DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //53,54,55,56,57,58,59 
*
1C4FA:  MOVFF  6A,385
1C4FE:  MOVFF  69,384
1C502:  MOVLB  3
1C504:  CLRF   x87
1C506:  MOVLW  46
1C508:  MOVWF  x86
1C50A:  MOVLB  0
1C50C:  CALL   1536
1C510:  MOVFF  00,31B
1C514:  MOVLB  3
1C516:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C51A:  CLRF   x1F
....................    ADL = AD; 
1C51C:  MOVFF  31B,320
....................    D = AD - 53;                                                                  //0,1,2,3,4,5,6 
1C520:  MOVLW  35
1C522:  SUBWF  x1B,W
1C524:  MOVWF  x1D
1C526:  MOVLW  00
1C528:  SUBWFB x1C,W
1C52A:  MOVWF  x1E
....................     
....................    DL_AD = D; 
1C52C:  CLRF   x24
1C52E:  CLRF   x23
1C530:  MOVFF  31E,322
1C534:  MOVFF  31D,321
....................    DL_AD = DL_AD * 81; 
1C538:  MOVFF  324,337
1C53C:  MOVFF  323,336
1C540:  MOVFF  322,335
1C544:  MOVFF  321,334
1C548:  CLRF   x3B
1C54A:  CLRF   x3A
1C54C:  CLRF   x39
1C54E:  MOVLW  51
1C550:  MOVWF  x38
1C552:  MOVLB  0
1C554:  CALL   24DE
1C558:  MOVFF  03,324
1C55C:  MOVFF  02,323
1C560:  MOVFF  01,322
1C564:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //0-4, 5-10, 10-14, 15-19, 20-24, 25-29, 30-34 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C568:  MOVLW  AD
1C56A:  MOVLB  3
1C56C:  MOVWF  x53
1C56E:  MOVFF  31F,354
1C572:  MOVFF  320,355
1C576:  MOVLB  0
1C578:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*6+DL_AD,405);                               //65536*8 
1C57C:  MOVLB  3
1C57E:  MOVFF  321,32D
1C582:  MOVFF  322,32E
1C586:  MOVLW  06
1C588:  ADDWF  x23,W
1C58A:  MOVWF  x2F
1C58C:  MOVLW  00
1C58E:  ADDWFC x24,W
1C590:  MOVWF  x30
1C592:  MOVLW  66
1C594:  MOVWF  x31
1C596:  MOVLW  77
1C598:  MOVWF  x32
1C59A:  MOVFF  330,336
1C59E:  MOVFF  32F,335
1C5A2:  MOVFF  322,334
1C5A6:  MOVFF  321,333
1C5AA:  MOVLW  01
1C5AC:  MOVWF  x38
1C5AE:  MOVLW  95
1C5B0:  MOVWF  x37
1C5B2:  MOVLB  0
1C5B4:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C5B8:  MOVLB  3
1C5BA:  CLRF   x1F
1C5BC:  CLRF   x20
1C5BE:  CLRF   x24
1C5C0:  CLRF   x23
1C5C2:  CLRF   x22
1C5C4:  CLRF   x21
1C5C6:  CLRF   x1E
1C5C8:  CLRF   x1D
....................    return; 
1C5CA:  MOVLB  0
1C5CC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY53to59_ADDRESS()                                                         //LOG DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //53,54,55,56,57,58,59 
*
1D0C0:  MOVFF  6A,385
1D0C4:  MOVFF  69,384
1D0C8:  MOVLB  3
1D0CA:  CLRF   x87
1D0CC:  MOVLW  46
1D0CE:  MOVWF  x86
1D0D0:  MOVLB  0
1D0D2:  CALL   1536
1D0D6:  MOVFF  00,31B
1D0DA:  MOVLB  3
1D0DC:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D0E0:  CLRF   x1F
....................    ADL = AD; 
1D0E2:  MOVFF  31B,320
....................    D = AD - 53;                                                                  //0,1,2,3,4,5,6 
1D0E6:  MOVLW  35
1D0E8:  SUBWF  x1B,W
1D0EA:  MOVWF  x1D
1D0EC:  MOVLW  00
1D0EE:  SUBWFB x1C,W
1D0F0:  MOVWF  x1E
....................     
....................    DL_AD = D; 
1D0F2:  CLRF   x24
1D0F4:  CLRF   x23
1D0F6:  MOVFF  31E,322
1D0FA:  MOVFF  31D,321
....................    DL_AD = DL_AD * 81; 
1D0FE:  MOVFF  324,337
1D102:  MOVFF  323,336
1D106:  MOVFF  322,335
1D10A:  MOVFF  321,334
1D10E:  CLRF   x3B
1D110:  CLRF   x3A
1D112:  CLRF   x39
1D114:  MOVLW  51
1D116:  MOVWF  x38
1D118:  MOVLB  0
1D11A:  CALL   24DE
1D11E:  MOVFF  03,324
1D122:  MOVFF  02,323
1D126:  MOVFF  01,322
1D12A:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //0-4, 5-10, 10-14, 15-19, 20-24, 25-29, 30-34 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*6+DL_AD,405);                               //65536*8 
1D12E:  MOVLB  3
1D130:  MOVFF  321,32D
1D134:  MOVFF  322,32E
1D138:  MOVLW  06
1D13A:  ADDWF  x23,W
1D13C:  MOVWF  x2F
1D13E:  MOVLW  00
1D140:  ADDWFC x24,W
1D142:  MOVWF  x30
1D144:  MOVLW  66
1D146:  MOVWF  x31
1D148:  MOVLW  77
1D14A:  MOVWF  x32
1D14C:  MOVFF  330,336
1D150:  MOVFF  32F,335
1D154:  MOVFF  322,334
1D158:  MOVFF  321,333
1D15C:  MOVLW  01
1D15E:  MOVWF  x38
1D160:  MOVLW  95
1D162:  MOVWF  x37
1D164:  MOVLB  0
1D166:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D16A:  MOVLB  3
1D16C:  CLRF   x1F
1D16E:  CLRF   x20
1D170:  CLRF   x24
1D172:  CLRF   x23
1D174:  CLRF   x22
1D176:  CLRF   x21
1D178:  CLRF   x1E
1D17A:  CLRF   x1D
....................    return; 
1D17C:  MOVLB  0
1D17E:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ NOMAL SAMPLING HK @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY60to69()                                                                 //HK Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //60,61,62,63,64,65,66,67,68,69 
*
1C5CE:  MOVFF  6A,385
1C5D2:  MOVFF  69,384
1C5D6:  MOVLB  3
1C5D8:  CLRF   x87
1C5DA:  MOVLW  46
1C5DC:  MOVWF  x86
1C5DE:  MOVLB  0
1C5E0:  CALL   1536
1C5E4:  MOVFF  00,31B
1C5E8:  MOVLB  3
1C5EA:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C5EE:  CLRF   x1F
....................    ADL = AD; 
1C5F0:  MOVFF  31B,320
....................    //D = AD - 53;                                                                //0,1,2,3,4,5,6,7,8,9 (deberia ser AD-53?) 
....................    D = AD - 60; 
1C5F4:  MOVLW  3C
1C5F6:  SUBWF  x1B,W
1C5F8:  MOVWF  x1D
1C5FA:  MOVLW  00
1C5FC:  SUBWFB x1C,W
1C5FE:  MOVWF  x1E
....................    DL_AD = 9798*D;                                                               //realiza un salto de 9798 paquetes 
1C600:  MOVLW  26
1C602:  MOVWF  x43
1C604:  MOVLW  46
1C606:  MOVWF  x42
1C608:  MOVFF  31E,345
1C60C:  MOVFF  31D,344
1C610:  MOVLB  0
1C612:  CALL   253A
1C616:  MOVLB  3
1C618:  CLRF   x24
1C61A:  CLRF   x23
1C61C:  MOVFF  02,322
1C620:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C624:  MOVFF  324,337
1C628:  MOVFF  323,336
1C62C:  MOVFF  322,335
1C630:  MOVFF  321,334
1C634:  CLRF   x3B
1C636:  CLRF   x3A
1C638:  CLRF   x39
1C63A:  MOVLW  51
1C63C:  MOVWF  x38
1C63E:  MOVLB  0
1C640:  CALL   24DE
1C644:  MOVFF  03,324
1C648:  MOVFF  02,323
1C64C:  MOVFF  01,322
1C650:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //    0-4,      9798-9802,  19596-19600, 29394-29398, 39192-39196 
....................    //48990-48994, 58788-58792, 68586-68590, 78384-78388, 88182-88186 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C654:  MOVLW  AD
1C656:  MOVLB  3
1C658:  MOVWF  x53
1C65A:  MOVFF  31F,354
1C65E:  MOVFF  320,355
1C662:  MOVLB  0
1C664:  CALL   16EA4
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*98+DL_AD,405);                              //65536*8 
1C668:  MOVLB  3
1C66A:  MOVFF  321,32D
1C66E:  MOVFF  322,32E
1C672:  MOVLW  62
1C674:  ADDWF  x23,W
1C676:  MOVWF  x2F
1C678:  MOVLW  00
1C67A:  ADDWFC x24,W
1C67C:  MOVWF  x30
1C67E:  MOVLW  66
1C680:  MOVWF  x31
1C682:  MOVLW  77
1C684:  MOVWF  x32
1C686:  MOVFF  330,336
1C68A:  MOVFF  32F,335
1C68E:  MOVFF  322,334
1C692:  MOVFF  321,333
1C696:  MOVLW  01
1C698:  MOVWF  x38
1C69A:  MOVLW  95
1C69C:  MOVWF  x37
1C69E:  MOVLB  0
1C6A0:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C6A4:  MOVLB  3
1C6A6:  CLRF   x1F
1C6A8:  CLRF   x20
1C6AA:  CLRF   x24
1C6AC:  CLRF   x23
1C6AE:  CLRF   x22
1C6B0:  CLRF   x21
1C6B2:  CLRF   x1E
1C6B4:  CLRF   x1D
....................    return; 
1C6B6:  MOVLB  0
1C6B8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY60to69_ADDRESS()                                                         //HK Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //60,61,62,63,64,65,66,67,68,69 
*
1D180:  MOVFF  6A,385
1D184:  MOVFF  69,384
1D188:  MOVLB  3
1D18A:  CLRF   x87
1D18C:  MOVLW  46
1D18E:  MOVWF  x86
1D190:  MOVLB  0
1D192:  CALL   1536
1D196:  MOVFF  00,31B
1D19A:  MOVLB  3
1D19C:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D1A0:  CLRF   x1F
....................    ADL = AD; 
1D1A2:  MOVFF  31B,320
....................    //D = AD - 53;                                                                  //0,1,2,3,4,5,6,7,8,9 (deberia ser AD-53?) 
....................    D = AD - 60; 
1D1A6:  MOVLW  3C
1D1A8:  SUBWF  x1B,W
1D1AA:  MOVWF  x1D
1D1AC:  MOVLW  00
1D1AE:  SUBWFB x1C,W
1D1B0:  MOVWF  x1E
....................    DL_AD = 9798*D;                                                               //realiza saltos de 9798 paquetes 
1D1B2:  MOVLW  26
1D1B4:  MOVWF  x43
1D1B6:  MOVLW  46
1D1B8:  MOVWF  x42
1D1BA:  MOVFF  31E,345
1D1BE:  MOVFF  31D,344
1D1C2:  MOVLB  0
1D1C4:  CALL   253A
1D1C8:  MOVLB  3
1D1CA:  CLRF   x24
1D1CC:  CLRF   x23
1D1CE:  MOVFF  02,322
1D1D2:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1D1D6:  MOVFF  324,337
1D1DA:  MOVFF  323,336
1D1DE:  MOVFF  322,335
1D1E2:  MOVFF  321,334
1D1E6:  CLRF   x3B
1D1E8:  CLRF   x3A
1D1EA:  CLRF   x39
1D1EC:  MOVLW  51
1D1EE:  MOVWF  x38
1D1F0:  MOVLB  0
1D1F2:  CALL   24DE
1D1F6:  MOVFF  03,324
1D1FA:  MOVFF  02,323
1D1FE:  MOVFF  01,322
1D202:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //    0-4,      9798-9802,  19596-19600, 29394-29398, 39192-39196 
....................    //48990-48994, 58788-58792, 68586-68590, 78384-78388, 88182-88186 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*98+DL_AD,405);                              //65536*8 
1D206:  MOVLB  3
1D208:  MOVFF  321,32D
1D20C:  MOVFF  322,32E
1D210:  MOVLW  62
1D212:  ADDWF  x23,W
1D214:  MOVWF  x2F
1D216:  MOVLW  00
1D218:  ADDWFC x24,W
1D21A:  MOVWF  x30
1D21C:  MOVLW  66
1D21E:  MOVWF  x31
1D220:  MOVLW  77
1D222:  MOVWF  x32
1D224:  MOVFF  330,336
1D228:  MOVFF  32F,335
1D22C:  MOVFF  322,334
1D230:  MOVFF  321,333
1D234:  MOVLW  01
1D236:  MOVWF  x38
1D238:  MOVLW  95
1D23A:  MOVWF  x37
1D23C:  MOVLB  0
1D23E:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D242:  MOVLB  3
1D244:  CLRF   x1F
1D246:  CLRF   x20
1D248:  CLRF   x24
1D24A:  CLRF   x23
1D24C:  CLRF   x22
1D24E:  CLRF   x21
1D250:  CLRF   x1E
1D252:  CLRF   x1D
....................    return; 
1D254:  MOVLB  0
1D256:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ ADDRESS CHANGE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTO_MSN_AD_CHANGE()                                                        //update address for a new cycle 
*
1B812:  MOVFF  6A,385
1B816:  MOVFF  69,384
1B81A:  MOVLB  3
1B81C:  CLRF   x87
1B81E:  MOVLW  46
1B820:  MOVWF  x86
1B822:  MOVLB  0
1B824:  CALL   1536
1B828:  MOVFF  02,32E
1B82C:  MOVFF  01,32D
1B830:  MOVFF  32D,32F
.................... { 
....................    unsigned int16 D = PASSED_DAYS/loop_day; 
....................    int8 UPDATE_TIME = (int8)D; 
....................    SAVE_SAT_LOG(0xF9,UPDATE_TIME,UPDATE_TIME); 
1B834:  MOVLW  F9
1B836:  MOVLB  3
1B838:  MOVWF  x53
1B83A:  MOVFF  32F,354
1B83E:  MOVFF  32F,355
1B842:  MOVLB  0
1B844:  CALL   16EA4
....................    int32 DATA = 8192*D;                                                          //11byte*500 < 5500 (enough), SAT_LOG data sent in one cycle 
1B848:  MOVLB  3
1B84A:  SWAPF  x2D,W
1B84C:  MOVWF  x31
1B84E:  CLRF   x30
1B850:  RLCF   x31,F
1B852:  MOVLW  E0
1B854:  ANDWF  x31,F
....................    SAT_LOG = SECT*6 + DATA;                                                      //2sector 
1B856:  MOVFF  330,40
1B85A:  MOVFF  331,41
1B85E:  MOVLW  06
1B860:  ADDWF  x32,W
1B862:  MOVWF  42
1B864:  MOVLW  00
1B866:  ADDWFC x33,W
1B868:  MOVWF  43
....................     
....................    DATA = SECT*D;                                                                //1sector, CAM data sent in one cycle 
1B86A:  MOVFF  32E,333
1B86E:  MOVFF  32D,332
1B872:  CLRF   x30
1B874:  CLRF   x31
....................    CAM_ADDRESS = SECT*8 + DATA; 
1B876:  MOVFF  330,44
1B87A:  MOVFF  331,45
1B87E:  MOVLW  08
1B880:  ADDWF  x32,W
1B882:  MOVWF  46
1B884:  MOVLW  00
1B886:  ADDWFC x33,W
1B888:  MOVWF  47
....................     
....................    DATA = SECT*130;                                                              //124*3600*24*70/90 < 128sector, HK data sent in one cycle 
1B88A:  CLRF   x33
1B88C:  MOVLW  82
1B88E:  MOVWF  x32
1B890:  CLRF   x31
1B892:  CLRF   x30
....................    DATA = DATA*D; 
1B894:  MOVFF  333,337
1B898:  MOVFF  332,336
1B89C:  MOVFF  331,335
1B8A0:  MOVFF  330,334
1B8A4:  CLRF   x3B
1B8A6:  CLRF   x3A
1B8A8:  MOVFF  32E,339
1B8AC:  MOVFF  32D,338
1B8B0:  MOVLB  0
1B8B2:  CALL   24DE
1B8B6:  MOVFF  03,333
1B8BA:  MOVFF  02,332
1B8BE:  MOVFF  01,331
1B8C2:  MOVFF  00,330
....................    FAB_HK_ADDRESS = SECT*98 + DATA;                                              //1000sector 
1B8C6:  MOVLB  3
1B8C8:  MOVFF  330,48
1B8CC:  MOVFF  331,49
1B8D0:  MOVLW  62
1B8D2:  ADDWF  x32,W
1B8D4:  MOVWF  4A
1B8D6:  MOVLW  00
1B8D8:  ADDWFC x33,W
1B8DA:  MOVWF  4B
....................     
....................    DATA = SECT*5;                                                                //81*5400/1.5 < 5sector, ADCS data sent in one cycle 
1B8DC:  CLRF   x33
1B8DE:  MOVLW  05
1B8E0:  MOVWF  x32
1B8E2:  CLRF   x31
1B8E4:  CLRF   x30
....................    DATA = DATA*D; 
1B8E6:  MOVFF  333,337
1B8EA:  MOVFF  332,336
1B8EE:  MOVFF  331,335
1B8F2:  MOVFF  330,334
1B8F6:  CLRF   x3B
1B8F8:  CLRF   x3A
1B8FA:  MOVFF  32E,339
1B8FE:  MOVFF  32D,338
1B902:  MOVLB  0
1B904:  CALL   24DE
1B908:  MOVFF  03,333
1B90C:  MOVFF  02,332
1B910:  MOVFF  01,331
1B914:  MOVFF  00,330
....................    ADCS_SENSOR_ADDRESS = SECT*1138 + DATA;                                       //500sector 
1B918:  MOVLB  3
1B91A:  MOVFF  330,50
1B91E:  MOVFF  331,51
1B922:  MOVLW  72
1B924:  ADDWF  x32,W
1B926:  MOVWF  52
1B928:  MOVLW  04
1B92A:  ADDWFC x33,W
1B92C:  MOVWF  53
....................     
....................    DATA = 405*5;                                                                 //5packet*5, DC data sent in one cycle 
1B92E:  CLRF   x33
1B930:  CLRF   x32
1B932:  MOVLW  07
1B934:  MOVWF  x31
1B936:  MOVLW  E9
1B938:  MOVWF  x30
....................    DATA = DATA*D; 
1B93A:  MOVFF  333,337
1B93E:  MOVFF  332,336
1B942:  MOVFF  331,335
1B946:  MOVFF  330,334
1B94A:  CLRF   x3B
1B94C:  CLRF   x3A
1B94E:  MOVFF  32E,339
1B952:  MOVFF  32D,338
1B956:  MOVLB  0
1B958:  CALL   24DE
1B95C:  MOVFF  03,333
1B960:  MOVFF  02,332
1B964:  MOVFF  01,331
1B968:  MOVFF  00,330
....................    DC_STATUS_ADDRESS = SECT*1638 + DATA;                                         //1sector 
1B96C:  MOVLB  3
1B96E:  MOVFF  330,58
1B972:  MOVFF  331,59
1B976:  MOVLW  66
1B978:  ADDWF  x32,W
1B97A:  MOVWF  5A
1B97C:  MOVLW  06
1B97E:  ADDWFC x33,W
1B980:  MOVWF  5B
....................     
....................    DATA = SECT*3;                                                                //124*3600*2/5 < 3sector, HSSC data sent in one cycle 
1B982:  CLRF   x33
1B984:  MOVLW  03
1B986:  MOVWF  x32
1B988:  CLRF   x31
1B98A:  CLRF   x30
....................    DATA = DATA*D; 
1B98C:  MOVFF  333,337
1B990:  MOVFF  332,336
1B994:  MOVFF  331,335
1B998:  MOVFF  330,334
1B99C:  CLRF   x3B
1B99E:  CLRF   x3A
1B9A0:  MOVFF  32E,339
1B9A4:  MOVFF  32D,338
1B9A8:  MOVLB  0
1B9AA:  CALL   24DE
1B9AE:  MOVFF  03,333
1B9B2:  MOVFF  02,332
1B9B6:  MOVFF  01,331
1B9BA:  MOVFF  00,330
....................    HIGH_SAMP_HK_ADDRESS = SECT*1639 + DATA;                                      //409sector 
1B9BE:  MOVLB  3
1B9C0:  MOVFF  330,5C
1B9C4:  MOVFF  331,5D
1B9C8:  MOVLW  67
1B9CA:  ADDWF  x32,W
1B9CC:  MOVWF  5E
1B9CE:  MOVLW  06
1B9D0:  ADDWFC x33,W
1B9D2:  MOVWF  5F
....................     
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //update 
1B9D4:  MOVLB  0
1B9D6:  CALL   142D0
....................     
....................    return; 
1B9DA:  RETURN 0
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@ AUTO MISSION EXECUTING FUNCTION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTOMATICAL_MSN_EXE() 
.................... { 
....................     
....................    if(((PASSED_DAYS%loop_day) >= 0 && UPLINK_SUCCESS == 0) && FIRST_HSSC_DONE == 0)                      //automated high samp mission condition 
*
1C6BA:  MOVFF  6A,385
1C6BE:  MOVFF  69,384
1C6C2:  MOVLB  3
1C6C4:  CLRF   x87
1C6C6:  MOVLW  46
1C6C8:  MOVWF  x86
1C6CA:  MOVLB  0
1C6CC:  CALL   1536
1C6D0:  MOVFF  00,32D
1C6D4:  MOVFF  03,32E
1C6D8:  MOVLB  0
1C6DA:  MOVF   x7C,F
1C6DC:  BNZ   1C6E8
1C6DE:  MOVF   x77,F
1C6E0:  BNZ   1C6E8
....................    { 
....................       DAY0(); 
1C6E2:  CALL   1BC06
....................    }else if(PASSED_DAYS < make16(reset_bffr[4],reset_bffr[5]))                                           //if the date changed (next day) 
1C6E6:  BRA    1CB5A
1C6E8:  MOVFF  A2,03
1C6EC:  MOVFF  A3,01
1C6F0:  MOVF   x6A,W
1C6F2:  SUBWF  xA2,W
1C6F4:  BTFSS  FD8.0
1C6F6:  BRA    1CB5A
1C6F8:  BNZ   1C702
1C6FA:  MOVF   01,W
1C6FC:  SUBWF  x69,W
1C6FE:  BTFSC  FD8.0
1C700:  BRA    1CB5A
....................    { 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]);                                                 //update passed days 
1C702:  MOVFF  A2,6A
1C706:  MOVFF  A3,69
....................       STORE_FLAG_INFO();                                                                                 //save passed days 
1C70A:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM(); 
1C70E:  CALL   12FE4
....................        
....................       if(((PASSED_DAYS%loop_day) >= 1 && (PASSED_DAYS%loop_day) <= 4) && UPLINK_SUCCESS == 0){           //1-4th day high samp mission download  
1C712:  MOVFF  6A,385
1C716:  MOVFF  69,384
1C71A:  MOVLB  3
1C71C:  CLRF   x87
1C71E:  MOVLW  46
1C720:  MOVWF  x86
1C722:  MOVLB  0
1C724:  CALL   1536
1C728:  MOVFF  00,32D
1C72C:  MOVLB  3
1C72E:  MOVFF  03,32E
1C732:  MOVF   x2E,F
1C734:  BNZ   1C73C
1C736:  MOVF   x2D,W
1C738:  SUBLW  00
1C73A:  BC    1C778
1C73C:  MOVFF  6A,385
1C740:  MOVFF  69,384
1C744:  CLRF   x87
1C746:  MOVLW  46
1C748:  MOVWF  x86
1C74A:  MOVLB  0
1C74C:  CALL   1536
1C750:  MOVFF  00,32D
1C754:  MOVLB  3
1C756:  MOVFF  03,32E
1C75A:  MOVF   x2E,F
1C75C:  BNZ   1C778
1C75E:  MOVF   x2D,W
1C760:  SUBLW  04
1C762:  BNC   1C778
1C764:  MOVLB  0
1C766:  MOVF   x7C,F
1C768:  BTFSC  FD8.2
1C76A:  BRA    1C770
1C76C:  MOVLB  3
1C76E:  BRA    1C778
....................          DAY1to4(); 
1C770:  CALL   1BC92
....................       }else if(((PASSED_DAYS%loop_day) >= 5 && UPLINK_SUCCESS == 0) && AUTO_CAM_DONE == 0){              //5th day (CAM MSN) 
1C774:  BRA    1CB5A
1C776:  MOVLB  3
1C778:  MOVFF  6A,385
1C77C:  MOVFF  69,384
1C780:  CLRF   x87
1C782:  MOVLW  46
1C784:  MOVWF  x86
1C786:  MOVLB  0
1C788:  CALL   1536
1C78C:  MOVFF  00,32D
1C790:  MOVLB  3
1C792:  MOVFF  03,32E
1C796:  MOVF   x2E,F
1C798:  BNZ   1C7A0
1C79A:  MOVF   x2D,W
1C79C:  SUBLW  04
1C79E:  BC    1C7BE
1C7A0:  MOVLB  0
1C7A2:  MOVF   x7C,F
1C7A4:  BTFSC  FD8.2
1C7A6:  BRA    1C7AC
1C7A8:  MOVLB  3
1C7AA:  BRA    1C7BE
1C7AC:  MOVF   x78,F
1C7AE:  BTFSC  FD8.2
1C7B0:  BRA    1C7B6
1C7B2:  MOVLB  3
1C7B4:  BRA    1C7BE
....................          DAY5(); 
1C7B6:  CALL   1BD76
....................       }else if(((PASSED_DAYS%loop_day) >= 6 && (PASSED_DAYS%loop_day) <= 9) && UPLINK_SUCCESS == 0){     //download cam data 
1C7BA:  BRA    1CB5A
1C7BC:  MOVLB  3
1C7BE:  MOVFF  6A,385
1C7C2:  MOVFF  69,384
1C7C6:  CLRF   x87
1C7C8:  MOVLW  46
1C7CA:  MOVWF  x86
1C7CC:  MOVLB  0
1C7CE:  CALL   1536
1C7D2:  MOVFF  00,32D
1C7D6:  MOVLB  3
1C7D8:  MOVFF  03,32E
1C7DC:  MOVF   x2E,F
1C7DE:  BNZ   1C7E6
1C7E0:  MOVF   x2D,W
1C7E2:  SUBLW  05
1C7E4:  BC    1C822
1C7E6:  MOVFF  6A,385
1C7EA:  MOVFF  69,384
1C7EE:  CLRF   x87
1C7F0:  MOVLW  46
1C7F2:  MOVWF  x86
1C7F4:  MOVLB  0
1C7F6:  CALL   1536
1C7FA:  MOVFF  00,32D
1C7FE:  MOVLB  3
1C800:  MOVFF  03,32E
1C804:  MOVF   x2E,F
1C806:  BNZ   1C822
1C808:  MOVF   x2D,W
1C80A:  SUBLW  09
1C80C:  BNC   1C822
1C80E:  MOVLB  0
1C810:  MOVF   x7C,F
1C812:  BTFSC  FD8.2
1C814:  BRA    1C81A
1C816:  MOVLB  3
1C818:  BRA    1C822
....................          DAY6to9(); 
1C81A:  CALL   1BDFE
....................       }else if(((PASSED_DAYS%loop_day) >= 10 && UPLINK_SUCCESS == 0) && AUTO_MBP_DONE == 0){             //MBP and download 
1C81E:  BRA    1CB5A
1C820:  MOVLB  3
1C822:  MOVFF  6A,385
1C826:  MOVFF  69,384
1C82A:  CLRF   x87
1C82C:  MOVLW  46
1C82E:  MOVWF  x86
1C830:  MOVLB  0
1C832:  CALL   1536
1C836:  MOVFF  00,32D
1C83A:  MOVLB  3
1C83C:  MOVFF  03,32E
1C840:  MOVF   x2E,F
1C842:  BNZ   1C84A
1C844:  MOVF   x2D,W
1C846:  SUBLW  09
1C848:  BC    1C868
1C84A:  MOVLB  0
1C84C:  MOVF   x7C,F
1C84E:  BTFSC  FD8.2
1C850:  BRA    1C856
1C852:  MOVLB  3
1C854:  BRA    1C868
1C856:  MOVF   x79,F
1C858:  BTFSC  FD8.2
1C85A:  BRA    1C860
1C85C:  MOVLB  3
1C85E:  BRA    1C868
....................          DAY10(); 
1C860:  CALL   1BEE6
....................       }else if(((PASSED_DAYS%loop_day) >= 11 && (PASSED_DAYS%loop_day) <= 14) && UPLINK_SUCCESS == 0){   //MBP and download 
1C864:  BRA    1CB5A
1C866:  MOVLB  3
1C868:  MOVFF  6A,385
1C86C:  MOVFF  69,384
1C870:  CLRF   x87
1C872:  MOVLW  46
1C874:  MOVWF  x86
1C876:  MOVLB  0
1C878:  CALL   1536
1C87C:  MOVFF  00,32D
1C880:  MOVLB  3
1C882:  MOVFF  03,32E
1C886:  MOVF   x2E,F
1C888:  BNZ   1C890
1C88A:  MOVF   x2D,W
1C88C:  SUBLW  0A
1C88E:  BC    1C8CC
1C890:  MOVFF  6A,385
1C894:  MOVFF  69,384
1C898:  CLRF   x87
1C89A:  MOVLW  46
1C89C:  MOVWF  x86
1C89E:  MOVLB  0
1C8A0:  CALL   1536
1C8A4:  MOVFF  00,32D
1C8A8:  MOVLB  3
1C8AA:  MOVFF  03,32E
1C8AE:  MOVF   x2E,F
1C8B0:  BNZ   1C8CC
1C8B2:  MOVF   x2D,W
1C8B4:  SUBLW  0E
1C8B6:  BNC   1C8CC
1C8B8:  MOVLB  0
1C8BA:  MOVF   x7C,F
1C8BC:  BTFSC  FD8.2
1C8BE:  BRA    1C8C4
1C8C0:  MOVLB  3
1C8C2:  BRA    1C8CC
....................          DAY11to14(); 
1C8C4:  CALL   1BFF2
....................       }else if(((PASSED_DAYS%loop_day) >= 15 && UPLINK_SUCCESS == 0) && AUTO_ADCS_DONE == 0){            //ADCS Mission and Download 
1C8C8:  BRA    1CB5A
1C8CA:  MOVLB  3
1C8CC:  MOVFF  6A,385
1C8D0:  MOVFF  69,384
1C8D4:  CLRF   x87
1C8D6:  MOVLW  46
1C8D8:  MOVWF  x86
1C8DA:  MOVLB  0
1C8DC:  CALL   1536
1C8E0:  MOVFF  00,32D
1C8E4:  MOVLB  3
1C8E6:  MOVFF  03,32E
1C8EA:  MOVF   x2E,F
1C8EC:  BNZ   1C8F4
1C8EE:  MOVF   x2D,W
1C8F0:  SUBLW  0E
1C8F2:  BC    1C912
1C8F4:  MOVLB  0
1C8F6:  MOVF   x7C,F
1C8F8:  BTFSC  FD8.2
1C8FA:  BRA    1C900
1C8FC:  MOVLB  3
1C8FE:  BRA    1C912
1C900:  MOVF   x7A,F
1C902:  BTFSC  FD8.2
1C904:  BRA    1C90A
1C906:  MOVLB  3
1C908:  BRA    1C912
....................          DAY15(); 
1C90A:  CALL   1C106
....................       }else if(((PASSED_DAYS%loop_day) >= 16 && (PASSED_DAYS%loop_day) <= 19) && UPLINK_SUCCESS == 0){   //ADCS Download 
1C90E:  BRA    1CB5A
1C910:  MOVLB  3
1C912:  MOVFF  6A,385
1C916:  MOVFF  69,384
1C91A:  CLRF   x87
1C91C:  MOVLW  46
1C91E:  MOVWF  x86
1C920:  MOVLB  0
1C922:  CALL   1536
1C926:  MOVFF  00,32D
1C92A:  MOVLB  3
1C92C:  MOVFF  03,32E
1C930:  MOVF   x2E,F
1C932:  BNZ   1C93A
1C934:  MOVF   x2D,W
1C936:  SUBLW  0F
1C938:  BC    1C974
1C93A:  MOVFF  6A,385
1C93E:  MOVFF  69,384
1C942:  CLRF   x87
1C944:  MOVLW  46
1C946:  MOVWF  x86
1C948:  MOVLB  0
1C94A:  CALL   1536
1C94E:  MOVFF  00,32D
1C952:  MOVLB  3
1C954:  MOVFF  03,32E
1C958:  MOVF   x2E,F
1C95A:  BNZ   1C974
1C95C:  MOVF   x2D,W
1C95E:  SUBLW  13
1C960:  BNC   1C974
1C962:  MOVLB  0
1C964:  MOVF   x7C,F
1C966:  BTFSC  FD8.2
1C968:  BRA    1C96E
1C96A:  MOVLB  3
1C96C:  BRA    1C974
....................          DAY16to19(); 
1C96E:  RCALL  1C184
....................       }else if(((PASSED_DAYS%loop_day) >= 20 && (PASSED_DAYS%loop_day) <= 25) && UPLINK_SUCCESS == 0){   //High sampling sensor collecting mission download 
1C970:  BRA    1CB5A
1C972:  MOVLB  3
1C974:  MOVFF  6A,385
1C978:  MOVFF  69,384
1C97C:  CLRF   x87
1C97E:  MOVLW  46
1C980:  MOVWF  x86
1C982:  MOVLB  0
1C984:  CALL   1536
1C988:  MOVFF  00,32D
1C98C:  MOVLB  3
1C98E:  MOVFF  03,32E
1C992:  MOVF   x2E,F
1C994:  BNZ   1C99C
1C996:  MOVF   x2D,W
1C998:  SUBLW  13
1C99A:  BC    1C9D6
1C99C:  MOVFF  6A,385
1C9A0:  MOVFF  69,384
1C9A4:  CLRF   x87
1C9A6:  MOVLW  46
1C9A8:  MOVWF  x86
1C9AA:  MOVLB  0
1C9AC:  CALL   1536
1C9B0:  MOVFF  00,32D
1C9B4:  MOVLB  3
1C9B6:  MOVFF  03,32E
1C9BA:  MOVF   x2E,F
1C9BC:  BNZ   1C9D6
1C9BE:  MOVF   x2D,W
1C9C0:  SUBLW  19
1C9C2:  BNC   1C9D6
1C9C4:  MOVLB  0
1C9C6:  MOVF   x7C,F
1C9C8:  BTFSC  FD8.2
1C9CA:  BRA    1C9D0
1C9CC:  MOVLB  3
1C9CE:  BRA    1C9D6
....................          DAY20to25(); 
1C9D0:  RCALL  1C23C
....................       }else if(((PASSED_DAYS%loop_day) >= 26 && (PASSED_DAYS%loop_day) <= 46) && UPLINK_SUCCESS == 0){   //CAM Mission Download 
1C9D2:  BRA    1CB5A
1C9D4:  MOVLB  3
1C9D6:  MOVFF  6A,385
1C9DA:  MOVFF  69,384
1C9DE:  CLRF   x87
1C9E0:  MOVLW  46
1C9E2:  MOVWF  x86
1C9E4:  MOVLB  0
1C9E6:  CALL   1536
1C9EA:  MOVFF  00,32D
1C9EE:  MOVLB  3
1C9F0:  MOVFF  03,32E
1C9F4:  MOVF   x2E,F
1C9F6:  BNZ   1C9FE
1C9F8:  MOVF   x2D,W
1C9FA:  SUBLW  19
1C9FC:  BC    1CA38
1C9FE:  MOVFF  6A,385
1CA02:  MOVFF  69,384
1CA06:  CLRF   x87
1CA08:  MOVLW  46
1CA0A:  MOVWF  x86
1CA0C:  MOVLB  0
1CA0E:  CALL   1536
1CA12:  MOVFF  00,32D
1CA16:  MOVLB  3
1CA18:  MOVFF  03,32E
1CA1C:  MOVF   x2E,F
1CA1E:  BNZ   1CA38
1CA20:  MOVF   x2D,W
1CA22:  SUBLW  2E
1CA24:  BNC   1CA38
1CA26:  MOVLB  0
1CA28:  MOVF   x7C,F
1CA2A:  BTFSC  FD8.2
1CA2C:  BRA    1CA32
1CA2E:  MOVLB  3
1CA30:  BRA    1CA38
....................          DAY26to46(); 
1CA32:  RCALL  1C324
....................       }else if(((PASSED_DAYS%loop_day) >= 47 && (PASSED_DAYS%loop_day) <= 52) && UPLINK_SUCCESS == 0){   //ADCS Mission Data Download 
1CA34:  BRA    1CB5A
1CA36:  MOVLB  3
1CA38:  MOVFF  6A,385
1CA3C:  MOVFF  69,384
1CA40:  CLRF   x87
1CA42:  MOVLW  46
1CA44:  MOVWF  x86
1CA46:  MOVLB  0
1CA48:  CALL   1536
1CA4C:  MOVFF  00,32D
1CA50:  MOVLB  3
1CA52:  MOVFF  03,32E
1CA56:  MOVF   x2E,F
1CA58:  BNZ   1CA60
1CA5A:  MOVF   x2D,W
1CA5C:  SUBLW  2E
1CA5E:  BC    1CA9A
1CA60:  MOVFF  6A,385
1CA64:  MOVFF  69,384
1CA68:  CLRF   x87
1CA6A:  MOVLW  46
1CA6C:  MOVWF  x86
1CA6E:  MOVLB  0
1CA70:  CALL   1536
1CA74:  MOVFF  00,32D
1CA78:  MOVLB  3
1CA7A:  MOVFF  03,32E
1CA7E:  MOVF   x2E,F
1CA80:  BNZ   1CA9A
1CA82:  MOVF   x2D,W
1CA84:  SUBLW  34
1CA86:  BNC   1CA9A
1CA88:  MOVLB  0
1CA8A:  MOVF   x7C,F
1CA8C:  BTFSC  FD8.2
1CA8E:  BRA    1CA94
1CA90:  MOVLB  3
1CA92:  BRA    1CA9A
....................          DAY47to52(); 
1CA94:  RCALL  1C40E
....................       }else if(((PASSED_DAYS%loop_day) >= 53 && (PASSED_DAYS%loop_day) <= 59) && UPLINK_SUCCESS == 0){   //Satellite LOG Download 
1CA96:  BRA    1CB5A
1CA98:  MOVLB  3
1CA9A:  MOVFF  6A,385
1CA9E:  MOVFF  69,384
1CAA2:  CLRF   x87
1CAA4:  MOVLW  46
1CAA6:  MOVWF  x86
1CAA8:  MOVLB  0
1CAAA:  CALL   1536
1CAAE:  MOVFF  00,32D
1CAB2:  MOVLB  3
1CAB4:  MOVFF  03,32E
1CAB8:  MOVF   x2E,F
1CABA:  BNZ   1CAC2
1CABC:  MOVF   x2D,W
1CABE:  SUBLW  34
1CAC0:  BC    1CAFC
1CAC2:  MOVFF  6A,385
1CAC6:  MOVFF  69,384
1CACA:  CLRF   x87
1CACC:  MOVLW  46
1CACE:  MOVWF  x86
1CAD0:  MOVLB  0
1CAD2:  CALL   1536
1CAD6:  MOVFF  00,32D
1CADA:  MOVLB  3
1CADC:  MOVFF  03,32E
1CAE0:  MOVF   x2E,F
1CAE2:  BNZ   1CAFC
1CAE4:  MOVF   x2D,W
1CAE6:  SUBLW  3B
1CAE8:  BNC   1CAFC
1CAEA:  MOVLB  0
1CAEC:  MOVF   x7C,F
1CAEE:  BTFSC  FD8.2
1CAF0:  BRA    1CAF6
1CAF2:  MOVLB  3
1CAF4:  BRA    1CAFC
....................          DAY53to59(); 
1CAF6:  RCALL  1C4FA
....................       }else if(((PASSED_DAYS%loop_day) >= 60 && (PASSED_DAYS%loop_day) <= 69) && UPLINK_SUCCESS == 0){   //Normal HK Download 
1CAF8:  BRA    1CB5A
1CAFA:  MOVLB  3
1CAFC:  MOVFF  6A,385
1CB00:  MOVFF  69,384
1CB04:  CLRF   x87
1CB06:  MOVLW  46
1CB08:  MOVWF  x86
1CB0A:  MOVLB  0
1CB0C:  CALL   1536
1CB10:  MOVFF  00,32D
1CB14:  MOVLB  3
1CB16:  MOVFF  03,32E
1CB1A:  MOVF   x2E,F
1CB1C:  BNZ   1CB24
1CB1E:  MOVF   x2D,W
1CB20:  SUBLW  3B
1CB22:  BC    1CB5C
1CB24:  MOVFF  6A,385
1CB28:  MOVFF  69,384
1CB2C:  CLRF   x87
1CB2E:  MOVLW  46
1CB30:  MOVWF  x86
1CB32:  MOVLB  0
1CB34:  CALL   1536
1CB38:  MOVFF  00,32D
1CB3C:  MOVLB  3
1CB3E:  MOVFF  03,32E
1CB42:  MOVF   x2E,F
1CB44:  BNZ   1CB5C
1CB46:  MOVF   x2D,W
1CB48:  SUBLW  45
1CB4A:  BNC   1CB5C
1CB4C:  MOVLB  0
1CB4E:  MOVF   x7C,F
1CB50:  BTFSC  FD8.2
1CB52:  BRA    1CB58
1CB54:  MOVLB  3
1CB56:  BRA    1CB5C
....................          DAY60to69(); 
1CB58:  RCALL  1C5CE
1CB5A:  MOVLB  3
....................       } 
....................    } 
....................    if(BC_ATTEMPT_FLAG == 0)                                                      //at this moment, this flag should be over 1 
1CB5C:  MOVLB  0
1CB5E:  MOVF   x68,F
1CB60:  BNZ   1CB66
....................    { 
....................       BC_ON_30min(); 
1CB62:  CALL   1B9DC
....................    } 
....................     
....................    FAB_FLAG = 0; 
1CB66:  MOVLB  2
1CB68:  CLRF   xFF
1CB6A:  CLRF   xFE
1CB6C:  CLRF   xFD
1CB6E:  CLRF   xFC
....................    return; 
1CB70:  MOVLB  0
1CB72:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void PREPARE_AUTOMATICAL_MSN_ADDRESS() 
.................... { 
....................    if((PASSED_DAYS%loop_day) == 0 && UPLINK_SUCCESS == 0){                                               //0th day high samp mission download 
*
1D258:  MOVFF  6A,385
1D25C:  MOVFF  69,384
1D260:  MOVLB  3
1D262:  CLRF   x87
1D264:  MOVLW  46
1D266:  MOVWF  x86
1D268:  MOVLB  0
1D26A:  CALL   1536
1D26E:  MOVFF  00,32D
1D272:  MOVLB  3
1D274:  MOVFF  03,32E
1D278:  MOVF   x2D,F
1D27A:  BNZ   1D2B4
1D27C:  MOVF   x2E,F
1D27E:  BNZ   1D2B4
1D280:  MOVLB  0
1D282:  MOVF   x7C,F
1D284:  BTFSC  FD8.2
1D286:  BRA    1D28C
1D288:  MOVLB  3
1D28A:  BRA    1D2B4
....................       UPDATE_ACK_for_COM(0x66,0x77,SECT*1639,405); 
1D28C:  MOVLW  66
1D28E:  MOVLB  3
1D290:  MOVWF  x31
1D292:  MOVLW  77
1D294:  MOVWF  x32
1D296:  MOVLW  06
1D298:  MOVWF  x36
1D29A:  MOVLW  67
1D29C:  MOVWF  x35
1D29E:  CLRF   x34
1D2A0:  CLRF   x33
1D2A2:  MOVLW  01
1D2A4:  MOVWF  x38
1D2A6:  MOVLW  95
1D2A8:  MOVWF  x37
1D2AA:  MOVLB  0
1D2AC:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 1 && (PASSED_DAYS%loop_day) <= 4) && UPLINK_SUCCESS == 0){        //1-4th day high samp mission download  
1D2B0:  BRA    1D76E
1D2B2:  MOVLB  3
1D2B4:  MOVFF  6A,385
1D2B8:  MOVFF  69,384
1D2BC:  CLRF   x87
1D2BE:  MOVLW  46
1D2C0:  MOVWF  x86
1D2C2:  MOVLB  0
1D2C4:  CALL   1536
1D2C8:  MOVFF  00,32D
1D2CC:  MOVLB  3
1D2CE:  MOVFF  03,32E
1D2D2:  MOVF   x2E,F
1D2D4:  BNZ   1D2DC
1D2D6:  MOVF   x2D,W
1D2D8:  SUBLW  00
1D2DA:  BC    1D316
1D2DC:  MOVFF  6A,385
1D2E0:  MOVFF  69,384
1D2E4:  CLRF   x87
1D2E6:  MOVLW  46
1D2E8:  MOVWF  x86
1D2EA:  MOVLB  0
1D2EC:  CALL   1536
1D2F0:  MOVFF  00,32D
1D2F4:  MOVLB  3
1D2F6:  MOVFF  03,32E
1D2FA:  MOVF   x2E,F
1D2FC:  BNZ   1D316
1D2FE:  MOVF   x2D,W
1D300:  SUBLW  04
1D302:  BNC   1D316
1D304:  MOVLB  0
1D306:  MOVF   x7C,F
1D308:  BTFSC  FD8.2
1D30A:  BRA    1D310
1D30C:  MOVLB  3
1D30E:  BRA    1D316
....................       DAY1to4_ADDRESS(); 
1D310:  RCALL  1CB74
....................    }else if(((PASSED_DAYS%loop_day) >= 5 && UPLINK_SUCCESS == 0) && AUTO_CAM_DONE == 0){                 //5th day (CAM MSN) 
1D312:  BRA    1D76E
1D314:  MOVLB  3
1D316:  MOVFF  6A,385
1D31A:  MOVFF  69,384
1D31E:  CLRF   x87
1D320:  MOVLW  46
1D322:  MOVWF  x86
1D324:  MOVLB  0
1D326:  CALL   1536
1D32A:  MOVFF  00,32D
1D32E:  MOVLB  3
1D330:  MOVFF  03,32E
1D334:  MOVF   x2E,F
1D336:  BNZ   1D33E
1D338:  MOVF   x2D,W
1D33A:  SUBLW  04
1D33C:  BC    1D37A
1D33E:  MOVLB  0
1D340:  MOVF   x7C,F
1D342:  BTFSC  FD8.2
1D344:  BRA    1D34A
1D346:  MOVLB  3
1D348:  BRA    1D37A
1D34A:  MOVF   x78,F
1D34C:  BTFSC  FD8.2
1D34E:  BRA    1D354
1D350:  MOVLB  3
1D352:  BRA    1D37A
....................       UPDATE_ACK_for_COM(0x66,0x77,SECT*8,405);//65536*8; 
1D354:  MOVLW  66
1D356:  MOVLB  3
1D358:  MOVWF  x31
1D35A:  MOVLW  77
1D35C:  MOVWF  x32
1D35E:  CLRF   x36
1D360:  MOVLW  08
1D362:  MOVWF  x35
1D364:  CLRF   x34
1D366:  CLRF   x33
1D368:  MOVLW  01
1D36A:  MOVWF  x38
1D36C:  MOVLW  95
1D36E:  MOVWF  x37
1D370:  MOVLB  0
1D372:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 6 && (PASSED_DAYS%loop_day) <= 9) && UPLINK_SUCCESS == 0){        //download cam data 
1D376:  BRA    1D76E
1D378:  MOVLB  3
1D37A:  MOVFF  6A,385
1D37E:  MOVFF  69,384
1D382:  CLRF   x87
1D384:  MOVLW  46
1D386:  MOVWF  x86
1D388:  MOVLB  0
1D38A:  CALL   1536
1D38E:  MOVFF  00,32D
1D392:  MOVLB  3
1D394:  MOVFF  03,32E
1D398:  MOVF   x2E,F
1D39A:  BNZ   1D3A2
1D39C:  MOVF   x2D,W
1D39E:  SUBLW  05
1D3A0:  BC    1D3DC
1D3A2:  MOVFF  6A,385
1D3A6:  MOVFF  69,384
1D3AA:  CLRF   x87
1D3AC:  MOVLW  46
1D3AE:  MOVWF  x86
1D3B0:  MOVLB  0
1D3B2:  CALL   1536
1D3B6:  MOVFF  00,32D
1D3BA:  MOVLB  3
1D3BC:  MOVFF  03,32E
1D3C0:  MOVF   x2E,F
1D3C2:  BNZ   1D3DC
1D3C4:  MOVF   x2D,W
1D3C6:  SUBLW  09
1D3C8:  BNC   1D3DC
1D3CA:  MOVLB  0
1D3CC:  MOVF   x7C,F
1D3CE:  BTFSC  FD8.2
1D3D0:  BRA    1D3D6
1D3D2:  MOVLB  3
1D3D4:  BRA    1D3DC
....................       DAY6to9_ADDRESS(); 
1D3D6:  RCALL  1CC46
....................    }else if(((PASSED_DAYS%loop_day) >= 10 && UPLINK_SUCCESS == 0) && AUTO_MBP_DONE == 0){                //MBP and download 
1D3D8:  BRA    1D76E
1D3DA:  MOVLB  3
1D3DC:  MOVFF  6A,385
1D3E0:  MOVFF  69,384
1D3E4:  CLRF   x87
1D3E6:  MOVLW  46
1D3E8:  MOVWF  x86
1D3EA:  MOVLB  0
1D3EC:  CALL   1536
1D3F0:  MOVFF  00,32D
1D3F4:  MOVLB  3
1D3F6:  MOVFF  03,32E
1D3FA:  MOVF   x2E,F
1D3FC:  BNZ   1D404
1D3FE:  MOVF   x2D,W
1D400:  SUBLW  09
1D402:  BC    1D45E
1D404:  MOVLB  0
1D406:  MOVF   x7C,F
1D408:  BTFSC  FD8.2
1D40A:  BRA    1D410
1D40C:  MOVLB  3
1D40E:  BRA    1D45E
1D410:  MOVF   x79,F
1D412:  BTFSC  FD8.2
1D414:  BRA    1D41A
1D416:  MOVLB  3
1D418:  BRA    1D45E
....................       UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);//65536*162; 
1D41A:  MOVLW  4C
1D41C:  SUBWF  58,W
1D41E:  MOVLB  3
1D420:  MOVWF  x2D
1D422:  MOVLW  01
1D424:  SUBWFB 59,W
1D426:  MOVWF  x2E
1D428:  MOVLW  00
1D42A:  SUBWFB 5A,W
1D42C:  MOVWF  x2F
1D42E:  MOVLW  00
1D430:  SUBWFB 5B,W
1D432:  MOVWF  x30
1D434:  MOVLW  66
1D436:  MOVWF  x31
1D438:  MOVLW  77
1D43A:  MOVWF  x32
1D43C:  MOVFF  330,336
1D440:  MOVFF  32F,335
1D444:  MOVFF  32E,334
1D448:  MOVFF  32D,333
1D44C:  MOVLW  01
1D44E:  MOVWF  x38
1D450:  MOVLW  4C
1D452:  MOVWF  x37
1D454:  MOVLB  0
1D456:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 11 && (PASSED_DAYS%loop_day) <= 14) && UPLINK_SUCCESS == 0){      //MBP and download 
1D45A:  BRA    1D76E
1D45C:  MOVLB  3
1D45E:  MOVFF  6A,385
1D462:  MOVFF  69,384
1D466:  CLRF   x87
1D468:  MOVLW  46
1D46A:  MOVWF  x86
1D46C:  MOVLB  0
1D46E:  CALL   1536
1D472:  MOVFF  00,32D
1D476:  MOVLB  3
1D478:  MOVFF  03,32E
1D47C:  MOVF   x2E,F
1D47E:  BNZ   1D486
1D480:  MOVF   x2D,W
1D482:  SUBLW  0A
1D484:  BC    1D4C0
1D486:  MOVFF  6A,385
1D48A:  MOVFF  69,384
1D48E:  CLRF   x87
1D490:  MOVLW  46
1D492:  MOVWF  x86
1D494:  MOVLB  0
1D496:  CALL   1536
1D49A:  MOVFF  00,32D
1D49E:  MOVLB  3
1D4A0:  MOVFF  03,32E
1D4A4:  MOVF   x2E,F
1D4A6:  BNZ   1D4C0
1D4A8:  MOVF   x2D,W
1D4AA:  SUBLW  0E
1D4AC:  BNC   1D4C0
1D4AE:  MOVLB  0
1D4B0:  MOVF   x7C,F
1D4B2:  BTFSC  FD8.2
1D4B4:  BRA    1D4BA
1D4B6:  MOVLB  3
1D4B8:  BRA    1D4C0
....................       DAY11to14_ADDRESS(); 
1D4BA:  RCALL  1CD1C
....................    }else if(((PASSED_DAYS%loop_day) >= 15 && UPLINK_SUCCESS == 0) && AUTO_ADCS_DONE == 0){               //ADCS Mission and Download 
1D4BC:  BRA    1D76E
1D4BE:  MOVLB  3
1D4C0:  MOVFF  6A,385
1D4C4:  MOVFF  69,384
1D4C8:  CLRF   x87
1D4CA:  MOVLW  46
1D4CC:  MOVWF  x86
1D4CE:  MOVLB  0
1D4D0:  CALL   1536
1D4D4:  MOVFF  00,32D
1D4D8:  MOVLB  3
1D4DA:  MOVFF  03,32E
1D4DE:  MOVF   x2E,F
1D4E0:  BNZ   1D4E8
1D4E2:  MOVF   x2D,W
1D4E4:  SUBLW  0E
1D4E6:  BC    1D526
1D4E8:  MOVLB  0
1D4EA:  MOVF   x7C,F
1D4EC:  BTFSC  FD8.2
1D4EE:  BRA    1D4F4
1D4F0:  MOVLB  3
1D4F2:  BRA    1D526
1D4F4:  MOVF   x7A,F
1D4F6:  BTFSC  FD8.2
1D4F8:  BRA    1D4FE
1D4FA:  MOVLB  3
1D4FC:  BRA    1D526
....................       UPDATE_ACK_for_COM(0x66, 0x77, SECT*1138, 405);                                                    //ADCS 
1D4FE:  MOVLW  66
1D500:  MOVLB  3
1D502:  MOVWF  x31
1D504:  MOVLW  77
1D506:  MOVWF  x32
1D508:  MOVLW  04
1D50A:  MOVWF  x36
1D50C:  MOVLW  72
1D50E:  MOVWF  x35
1D510:  CLRF   x34
1D512:  CLRF   x33
1D514:  MOVLW  01
1D516:  MOVWF  x38
1D518:  MOVLW  95
1D51A:  MOVWF  x37
1D51C:  MOVLB  0
1D51E:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 16 && (PASSED_DAYS%loop_day) <= 19) && UPLINK_SUCCESS == 0){      //ADCS Download 
1D522:  BRA    1D76E
1D524:  MOVLB  3
1D526:  MOVFF  6A,385
1D52A:  MOVFF  69,384
1D52E:  CLRF   x87
1D530:  MOVLW  46
1D532:  MOVWF  x86
1D534:  MOVLB  0
1D536:  CALL   1536
1D53A:  MOVFF  00,32D
1D53E:  MOVLB  3
1D540:  MOVFF  03,32E
1D544:  MOVF   x2E,F
1D546:  BNZ   1D54E
1D548:  MOVF   x2D,W
1D54A:  SUBLW  0F
1D54C:  BC    1D588
1D54E:  MOVFF  6A,385
1D552:  MOVFF  69,384
1D556:  CLRF   x87
1D558:  MOVLW  46
1D55A:  MOVWF  x86
1D55C:  MOVLB  0
1D55E:  CALL   1536
1D562:  MOVFF  00,32D
1D566:  MOVLB  3
1D568:  MOVFF  03,32E
1D56C:  MOVF   x2E,F
1D56E:  BNZ   1D588
1D570:  MOVF   x2D,W
1D572:  SUBLW  13
1D574:  BNC   1D588
1D576:  MOVLB  0
1D578:  MOVF   x7C,F
1D57A:  BTFSC  FD8.2
1D57C:  BRA    1D582
1D57E:  MOVLB  3
1D580:  BRA    1D588
....................       DAY16to19_ADDRESS();                                                                               //ADCS DL 
1D582:  RCALL  1CD96
....................    }else if(((PASSED_DAYS%loop_day) >= 20 && (PASSED_DAYS%loop_day) <= 25) && UPLINK_SUCCESS == 0){      //High sampling sensor collecting mission download 
1D584:  BRA    1D76E
1D586:  MOVLB  3
1D588:  MOVFF  6A,385
1D58C:  MOVFF  69,384
1D590:  CLRF   x87
1D592:  MOVLW  46
1D594:  MOVWF  x86
1D596:  MOVLB  0
1D598:  CALL   1536
1D59C:  MOVFF  00,32D
1D5A0:  MOVLB  3
1D5A2:  MOVFF  03,32E
1D5A6:  MOVF   x2E,F
1D5A8:  BNZ   1D5B0
1D5AA:  MOVF   x2D,W
1D5AC:  SUBLW  13
1D5AE:  BC    1D5EA
1D5B0:  MOVFF  6A,385
1D5B4:  MOVFF  69,384
1D5B8:  CLRF   x87
1D5BA:  MOVLW  46
1D5BC:  MOVWF  x86
1D5BE:  MOVLB  0
1D5C0:  CALL   1536
1D5C4:  MOVFF  00,32D
1D5C8:  MOVLB  3
1D5CA:  MOVFF  03,32E
1D5CE:  MOVF   x2E,F
1D5D0:  BNZ   1D5EA
1D5D2:  MOVF   x2D,W
1D5D4:  SUBLW  19
1D5D6:  BNC   1D5EA
1D5D8:  MOVLB  0
1D5DA:  MOVF   x7C,F
1D5DC:  BTFSC  FD8.2
1D5DE:  BRA    1D5E4
1D5E0:  MOVLB  3
1D5E2:  BRA    1D5EA
....................       DAY20to25_ADDRESS(); 
1D5E4:  RCALL  1CE3C
....................    }else if(((PASSED_DAYS%loop_day) >= 26 && (PASSED_DAYS%loop_day) <= 46) && UPLINK_SUCCESS == 0){      //CAM Mission Download 
1D5E6:  BRA    1D76E
1D5E8:  MOVLB  3
1D5EA:  MOVFF  6A,385
1D5EE:  MOVFF  69,384
1D5F2:  CLRF   x87
1D5F4:  MOVLW  46
1D5F6:  MOVWF  x86
1D5F8:  MOVLB  0
1D5FA:  CALL   1536
1D5FE:  MOVFF  00,32D
1D602:  MOVLB  3
1D604:  MOVFF  03,32E
1D608:  MOVF   x2E,F
1D60A:  BNZ   1D612
1D60C:  MOVF   x2D,W
1D60E:  SUBLW  19
1D610:  BC    1D64C
1D612:  MOVFF  6A,385
1D616:  MOVFF  69,384
1D61A:  CLRF   x87
1D61C:  MOVLW  46
1D61E:  MOVWF  x86
1D620:  MOVLB  0
1D622:  CALL   1536
1D626:  MOVFF  00,32D
1D62A:  MOVLB  3
1D62C:  MOVFF  03,32E
1D630:  MOVF   x2E,F
1D632:  BNZ   1D64C
1D634:  MOVF   x2D,W
1D636:  SUBLW  2E
1D638:  BNC   1D64C
1D63A:  MOVLB  0
1D63C:  MOVF   x7C,F
1D63E:  BTFSC  FD8.2
1D640:  BRA    1D646
1D642:  MOVLB  3
1D644:  BRA    1D64C
....................       DAY26to46_ADDRESS(); 
1D646:  RCALL  1CF12
....................    }else if(((PASSED_DAYS%loop_day) >= 47 && (PASSED_DAYS%loop_day) <= 52) && UPLINK_SUCCESS == 0){      //ADCS Mission Data Download 
1D648:  BRA    1D76E
1D64A:  MOVLB  3
1D64C:  MOVFF  6A,385
1D650:  MOVFF  69,384
1D654:  CLRF   x87
1D656:  MOVLW  46
1D658:  MOVWF  x86
1D65A:  MOVLB  0
1D65C:  CALL   1536
1D660:  MOVFF  00,32D
1D664:  MOVLB  3
1D666:  MOVFF  03,32E
1D66A:  MOVF   x2E,F
1D66C:  BNZ   1D674
1D66E:  MOVF   x2D,W
1D670:  SUBLW  2E
1D672:  BC    1D6AE
1D674:  MOVFF  6A,385
1D678:  MOVFF  69,384
1D67C:  CLRF   x87
1D67E:  MOVLW  46
1D680:  MOVWF  x86
1D682:  MOVLB  0
1D684:  CALL   1536
1D688:  MOVFF  00,32D
1D68C:  MOVLB  3
1D68E:  MOVFF  03,32E
1D692:  MOVF   x2E,F
1D694:  BNZ   1D6AE
1D696:  MOVF   x2D,W
1D698:  SUBLW  34
1D69A:  BNC   1D6AE
1D69C:  MOVLB  0
1D69E:  MOVF   x7C,F
1D6A0:  BTFSC  FD8.2
1D6A2:  BRA    1D6A8
1D6A4:  MOVLB  3
1D6A6:  BRA    1D6AE
....................       DAY47to52_ADDRESS(); 
1D6A8:  RCALL  1CFE8
....................    }else if(((PASSED_DAYS%loop_day) >= 53 && (PASSED_DAYS%loop_day) <= 59) && UPLINK_SUCCESS == 0){      //Satellite LOG Download 
1D6AA:  BRA    1D76E
1D6AC:  MOVLB  3
1D6AE:  MOVFF  6A,385
1D6B2:  MOVFF  69,384
1D6B6:  CLRF   x87
1D6B8:  MOVLW  46
1D6BA:  MOVWF  x86
1D6BC:  MOVLB  0
1D6BE:  CALL   1536
1D6C2:  MOVFF  00,32D
1D6C6:  MOVLB  3
1D6C8:  MOVFF  03,32E
1D6CC:  MOVF   x2E,F
1D6CE:  BNZ   1D6D6
1D6D0:  MOVF   x2D,W
1D6D2:  SUBLW  34
1D6D4:  BC    1D710
1D6D6:  MOVFF  6A,385
1D6DA:  MOVFF  69,384
1D6DE:  CLRF   x87
1D6E0:  MOVLW  46
1D6E2:  MOVWF  x86
1D6E4:  MOVLB  0
1D6E6:  CALL   1536
1D6EA:  MOVFF  00,32D
1D6EE:  MOVLB  3
1D6F0:  MOVFF  03,32E
1D6F4:  MOVF   x2E,F
1D6F6:  BNZ   1D710
1D6F8:  MOVF   x2D,W
1D6FA:  SUBLW  3B
1D6FC:  BNC   1D710
1D6FE:  MOVLB  0
1D700:  MOVF   x7C,F
1D702:  BTFSC  FD8.2
1D704:  BRA    1D70A
1D706:  MOVLB  3
1D708:  BRA    1D710
....................       DAY53to59_ADDRESS(); 
1D70A:  RCALL  1D0C0
....................    }else if(((PASSED_DAYS%loop_day) >= 60 && (PASSED_DAYS%loop_day) <= 69) && UPLINK_SUCCESS == 0){      //Normal HK Download 
1D70C:  BRA    1D76E
1D70E:  MOVLB  3
1D710:  MOVFF  6A,385
1D714:  MOVFF  69,384
1D718:  CLRF   x87
1D71A:  MOVLW  46
1D71C:  MOVWF  x86
1D71E:  MOVLB  0
1D720:  CALL   1536
1D724:  MOVFF  00,32D
1D728:  MOVLB  3
1D72A:  MOVFF  03,32E
1D72E:  MOVF   x2E,F
1D730:  BNZ   1D738
1D732:  MOVF   x2D,W
1D734:  SUBLW  3B
1D736:  BC    1D770
1D738:  MOVFF  6A,385
1D73C:  MOVFF  69,384
1D740:  CLRF   x87
1D742:  MOVLW  46
1D744:  MOVWF  x86
1D746:  MOVLB  0
1D748:  CALL   1536
1D74C:  MOVFF  00,32D
1D750:  MOVLB  3
1D752:  MOVFF  03,32E
1D756:  MOVF   x2E,F
1D758:  BNZ   1D770
1D75A:  MOVF   x2D,W
1D75C:  SUBLW  45
1D75E:  BNC   1D770
1D760:  MOVLB  0
1D762:  MOVF   x7C,F
1D764:  BTFSC  FD8.2
1D766:  BRA    1D76C
1D768:  MOVLB  3
1D76A:  BRA    1D770
....................       DAY60to69_ADDRESS(); 
1D76C:  RCALL  1D180
1D76E:  MOVLB  3
....................    } 
....................    return; 
1D770:  MOVLB  0
1D772:  RETURN 0
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@ AUTO MISSION OPERATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTOMATICAL_MISSION_CHECK() 
.................... { 
....................    int c; 
....................    for(c = 0; c < 6; c++) 
1D774:  MOVLB  3
1D776:  CLRF   x2C
1D778:  MOVF   x2C,W
1D77A:  SUBLW  05
1D77C:  BNC   1D796
....................    { 
....................       COLLECT_RESET_DATA();                                                      //send cmd to get reset data 
1D77E:  MOVLB  0
1D780:  CALL   16860
....................       if(reset_bffr[0] == 0x8e) 
1D784:  MOVF   x9E,W
1D786:  SUBLW  8E
1D788:  BNZ   1D790
....................       { 
....................          break; 
1D78A:  MOVLB  3
1D78C:  BRA    1D796
1D78E:  MOVLB  0
....................       } 
1D790:  MOVLB  3
1D792:  INCF   x2C,F
1D794:  BRA    1D778
....................    } 
....................     
....................    for(c = 0; c < 10; c++)                                                       //print reset data 
1D796:  CLRF   x2C
1D798:  MOVF   x2C,W
1D79A:  SUBLW  09
1D79C:  BNC   1D7C8
....................    { 
....................       fprintf(PC,"%x,",reset_bffr[c]); 
1D79E:  CLRF   03
1D7A0:  MOVF   x2C,W
1D7A2:  ADDLW  9E
1D7A4:  MOVWF  FE9
1D7A6:  MOVLW  00
1D7A8:  ADDWFC 03,W
1D7AA:  MOVWF  FEA
1D7AC:  MOVFF  FEF,3A2
1D7B0:  MOVLW  57
1D7B2:  MOVWF  xA3
1D7B4:  MOVLB  0
1D7B6:  CALL   0700
1D7BA:  MOVLW  2C
1D7BC:  BTFSS  F9E.4
1D7BE:  BRA    1D7BC
1D7C0:  MOVWF  FAD
1D7C2:  MOVLB  3
1D7C4:  INCF   x2C,F
1D7C6:  BRA    1D798
....................    } 
....................    fprintf(PC,"%x\r\n",reset_bffr[10]); 
1D7C8:  MOVFF  A8,3A2
1D7CC:  MOVLW  57
1D7CE:  MOVWF  xA3
1D7D0:  MOVLB  0
1D7D2:  CALL   0700
1D7D6:  MOVLW  0D
1D7D8:  BTFSS  F9E.4
1D7DA:  BRA    1D7D8
1D7DC:  MOVWF  FAD
1D7DE:  MOVLW  0A
1D7E0:  BTFSS  F9E.4
1D7E2:  BRA    1D7E0
1D7E4:  MOVWF  FAD
....................     
....................    if(((PASSED_DAYS%loop_day==0)&&(PASSED_DAYS>69))&&UPLINK_SUCCESS == 0)        //after 70 day (one cycle), auto mission again 
1D7E6:  MOVFF  6A,385
1D7EA:  MOVFF  69,384
1D7EE:  MOVLB  3
1D7F0:  CLRF   x87
1D7F2:  MOVLW  46
1D7F4:  MOVWF  x86
1D7F6:  MOVLB  0
1D7F8:  CALL   1536
1D7FC:  MOVFF  00,32D
1D800:  MOVLB  3
1D802:  MOVFF  03,32E
1D806:  MOVF   x2D,F
1D808:  BNZ   1D840
1D80A:  MOVF   x2E,F
1D80C:  BNZ   1D840
1D80E:  MOVLB  0
1D810:  MOVF   x6A,F
1D812:  BNZ   1D820
1D814:  MOVF   x69,W
1D816:  SUBLW  45
1D818:  BTFSS  FD8.0
1D81A:  BRA    1D820
1D81C:  MOVLB  3
1D81E:  BRA    1D840
1D820:  MOVF   x7C,F
1D822:  BTFSC  FD8.2
1D824:  BRA    1D82A
1D826:  MOVLB  3
1D828:  BRA    1D840
....................    { 
....................       FIRST_HSSC_DONE = 0; 
1D82A:  CLRF   x77
....................       AUTO_CAM_DONE = 0; 
1D82C:  CLRF   x78
....................       AUTO_MBP_DONE = 0; 
1D82E:  CLRF   x79
....................       AUTO_ADCS_DONE = 0; 
1D830:  CLRF   x7A
....................       AUTO_MSN_AD_CHANGE();                                                      //update address for a new cycle 
1D832:  CALL   1B812
....................       STORE_FLAG_INFO();                                                         //save flag data to flash memory 
1D836:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //saves the flags in the EEPROM from the address 0x18000 (75%) 
1D83A:  CALL   12FE4
1D83E:  MOVLB  3
....................    } 
....................    AUTOMATICAL_MSN_EXE(); 
1D840:  MOVLB  0
1D842:  CALL   1C6BA
....................    PREPARE_AUTOMATICAL_MSN_ADDRESS(); 
1D846:  RCALL  1D258
....................    return; 
1D848:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<analyze_command.c> 
.................... #ifndef ANALYZE_COMMAND_C 
.................... #define ANALYZE_COMMAND_C 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_CHECK() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E188:  MOVF   x7C,F
1E18A:  BNZ   1E198
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E18C:  MOVLW  01
1E18E:  MOVWF  x7C
....................       STORE_FLAG_INFO();                                                         //save flag data to flash memory 
1E190:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //save flags on EEPROM from address 0x18000 (75%) 
1E194:  CALL   12FE4
....................    } 
....................    return; 
1E198:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_ADCS() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E13C:  MOVF   x7C,F
1E13E:  BNZ   1E150
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E140:  MOVLW  01
1E142:  MOVWF  x7C
....................       AUTO_ADCS_DONE = 1; 
1E144:  MOVWF  x7A
....................       STORE_FLAG_INFO(); 
1E146:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM(); 
1E14A:  CALL   12FE4
....................    }else if(AUTO_ADCS_DONE == 0){ 
1E14E:  BRA    1E160
1E150:  MOVF   x7A,F
1E152:  BNZ   1E160
....................       AUTO_ADCS_DONE = 1; 
1E154:  MOVLW  01
1E156:  MOVWF  x7A
....................       STORE_FLAG_INFO(); 
1E158:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM(); 
1E15C:  CALL   12FE4
....................    } 
....................    return; 
1E160:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_HSSC() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E19A:  MOVF   x7C,F
1E19C:  BNZ   1E1AE
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E19E:  MOVLW  01
1E1A0:  MOVWF  x7C
....................       FIRST_HSSC_DONE = 1; 
1E1A2:  MOVWF  x77
....................       STORE_FLAG_INFO(); 
1E1A4:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM(); 
1E1A8:  CALL   12FE4
....................    }else if(FIRST_HSSC_DONE == 0){ 
1E1AC:  BRA    1E1BE
1E1AE:  MOVF   x77,F
1E1B0:  BNZ   1E1BE
....................       FIRST_HSSC_DONE = 1; 
1E1B2:  MOVLW  01
1E1B4:  MOVWF  x77
....................       STORE_FLAG_INFO(); 
1E1B6:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM(); 
1E1BA:  CALL   12FE4
....................    } 
....................    return; 
1E1BE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... //I actually don't know what this function does.  
.................... //*PURPOSE Something i don't know.  
.................... void UPLINK_SUCCESS_MBP() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E162:  MOVF   x7C,F
1E164:  BNZ   1E176
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E166:  MOVLW  01
1E168:  MOVWF  x7C
....................       AUTO_MBP_DONE = 1; 
1E16A:  MOVWF  x79
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
1E16C:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
1E170:  CALL   12FE4
....................    }else if(AUTO_MBP_DONE == 0){ 
1E174:  BRA    1E186
1E176:  MOVF   x79,F
1E178:  BNZ   1E186
....................       AUTO_MBP_DONE = 1; 
1E17A:  MOVLW  01
1E17C:  MOVWF  x79
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
1E17E:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
1E182:  CALL   12FE4
....................    } 
....................    return; 
1E186:  RETURN 0
....................    //I actually don't know what this function does.  
....................    //*PURPOSE Something i don't know.  
....................    //*AUTHOR Maisun Ibn Monowar 
.................... } 
....................  
.................... void UPLINK_SUCCESS_CAM() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
0255C:  MOVF   x7C,F
0255E:  BNZ   2570
....................    { 
....................       AUTO_CAM_DONE = 1; 
02560:  MOVLW  01
02562:  MOVWF  x78
....................       UPLINK_SUCCESS = 1; 
02564:  MOVWF  x7C
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
02566:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
0256A:  CALL   12FE4
....................    }else if(AUTO_CAM_DONE == 0){ 
0256E:  BRA    2580
02570:  MOVF   x78,F
02572:  BNZ   2580
....................       AUTO_CAM_DONE = 1; 
02574:  MOVLW  01
02576:  MOVWF  x78
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
02578:  CALL   146F6
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
0257C:  CALL   12FE4
....................    } 
....................    return; 
02580:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x0001E000 
.................... int8 CHECK_MEMORY_FUNCTION(int8 data)                                            //evita operacion de memoria como comandos reservados 
.................... { 
....................    if((data == 0xe0)||(data == 0xe1)||(data == 0xe2)) 
*
1E10A:  MOVLB  3
1E10C:  MOVF   x2C,W
1E10E:  SUBLW  E0
1E110:  BZ    1E11E
1E112:  MOVF   x2C,W
1E114:  SUBLW  E1
1E116:  BZ    1E11E
1E118:  MOVF   x2C,W
1E11A:  SUBLW  E2
1E11C:  BNZ   1E120
....................    { 
....................       data = 0; 
1E11E:  CLRF   x2C
....................    } 
....................    if((data == 0x12)||(data == 0x32)||(data == 0x21)) 
1E120:  MOVF   x2C,W
1E122:  SUBLW  12
1E124:  BZ    1E132
1E126:  MOVF   x2C,W
1E128:  SUBLW  32
1E12A:  BZ    1E132
1E12C:  MOVF   x2C,W
1E12E:  SUBLW  21
1E130:  BNZ   1E134
....................    { 
....................       data = 0; 
1E132:  CLRF   x2C
....................    } 
....................    return data; 
1E134:  MOVFF  32C,01
1E138:  MOVLB  0
1E13A:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... //#include "elseIfChain.c" 
.................... #include "switchCase.c" 
.................... #ifndef SWITCHCASE_C 
.................... #define SWITCHCASE_C 
....................  
.................... void EXECUTE_MISSION_from_COM(int8 CMD1,int8 CMD2,int8 CMD3,int8 CMD4,int8 CMD5,int8 CMD6,int8 CMD7) 
.................... { 
....................    switch(CMD1) 
*
026AE:  MOVLB  3
026B0:  MOVF   x2C,W
026B2:  XORLW  C0
026B4:  MOVLB  0
026B6:  BTFSC  FD8.2
026B8:  BRA    27B4
026BA:  XORLW  60
026BC:  BTFSC  FD8.2
026BE:  BRA    27EC
026C0:  XORLW  01
026C2:  BTFSC  FD8.2
026C4:  BRA    284E
026C6:  XORLW  03
026C8:  BTFSC  FD8.2
026CA:  BRA    2898
026CC:  XORLW  72
026CE:  BTFSC  FD8.2
026D0:  BRA    28CA
026D2:  XORLW  01
026D4:  BTFSC  FD8.2
026D6:  BRA    2926
026D8:  XORLW  03
026DA:  BTFSC  FD8.2
026DC:  BRA    2980
026DE:  XORLW  01
026E0:  BTFSC  FD8.2
026E2:  BRA    29DA
026E4:  XORLW  07
026E6:  BTFSC  FD8.2
026E8:  BRA    2A34
026EA:  XORLW  01
026EC:  BTFSC  FD8.2
026EE:  BRA    2A8E
026F0:  XORLW  03
026F2:  BTFSC  FD8.2
026F4:  BRA    2AE8
026F6:  XORLW  01
026F8:  BTFSC  FD8.2
026FA:  BRA    2B42
026FC:  XORLW  08
026FE:  BTFSC  FD8.2
02700:  BRA    2B9C
02702:  XORLW  75
02704:  BTFSC  FD8.2
02706:  BRA    2BF6
02708:  XORLW  88
0270A:  BTFSC  FD8.2
0270C:  BRA    2C2E
0270E:  XORLW  92
02710:  BTFSC  FD8.2
02712:  BRA    2C5C
02714:  XORLW  01
02716:  BTFSC  FD8.2
02718:  BRA    2C86
0271A:  XORLW  03
0271C:  BTFSC  FD8.2
0271E:  BRA    2CB0
02720:  XORLW  01
02722:  BTFSC  FD8.2
02724:  BRA    2CDA
02726:  XORLW  07
02728:  BTFSC  FD8.2
0272A:  BRA    2D04
0272C:  XORLW  FF
0272E:  BTFSC  FD8.2
02730:  BRA    2D2E
02732:  XORLW  F0
02734:  BTFSC  FD8.2
02736:  BRA    2D5C
02738:  XORLW  41
0273A:  BTFSC  FD8.2
0273C:  BRA    2D8A
0273E:  XORLW  A3
02740:  BTFSC  FD8.2
02742:  BRA    2E04
02744:  XORLW  B7
02746:  BTFSC  FD8.2
02748:  BRA    2E1C
0274A:  XORLW  66
0274C:  BTFSC  FD8.2
0274E:  BRA    2E2A
02750:  XORLW  17
02752:  BTFSC  FD8.2
02754:  BRA    2E30
02756:  XORLW  CF
02758:  BTFSC  FD8.2
0275A:  BRA    2E36
0275C:  XORLW  B0
0275E:  BTFSC  FD8.2
02760:  BRA    2E48
02762:  XORLW  01
02764:  BTFSC  FD8.2
02766:  BRA    2E76
02768:  XORLW  03
0276A:  BTFSC  FD8.2
0276C:  BRA    2EA4
0276E:  XORLW  F0
02770:  BTFSC  FD8.2
02772:  BRA    2ED2
02774:  XORLW  01
02776:  BTFSC  FD8.2
02778:  BRA    2F00
0277A:  XORLW  32
0277C:  BTFSC  FD8.2
0277E:  BRA    2F2E
02780:  XORLW  02
02782:  BTFSC  FD8.2
02784:  GOTO   2F5C
02788:  XORLW  12
0278A:  BTFSC  FD8.2
0278C:  GOTO   2F8A
02790:  XORLW  03
02792:  BTFSC  FD8.2
02794:  GOTO   2FB8
02798:  XORLW  33
0279A:  BTFSC  FD8.2
0279C:  GOTO   2FE6
027A0:  XORLW  03
027A2:  BTFSC  FD8.2
027A4:  GOTO   301A
027A8:  XORLW  01
027AA:  BTFSC  FD8.2
027AC:  GOTO   304E
027B0:  GOTO   3082
....................    { 
....................       case 0xC0: 
....................          REPLY_TO_COM(0x66,0); 
027B4:  MOVLW  66
027B6:  MOVLB  3
027B8:  MOVWF  x37
027BA:  CLRF   x38
027BC:  MOVLB  0
027BE:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data          
027C2:  MOVFF  32C,353
027C6:  MOVLB  3
027C8:  CLRF   x54
027CA:  MOVFF  32D,355
027CE:  MOVLB  0
027D0:  CALL   16EA4
....................          UPLINK_SUCCESS_CAM();                                                   //put uplink succes flag in high and store flags 
027D4:  RCALL  255C
....................          ACK_for_COM[14] = 0x00;         
027D6:  MOVLB  1
027D8:  CLRF   xF1
....................          CAM_TEST_OPERATION(CMD2);                                               //send command to CAM, execute mission and transfer data 
027DA:  MOVFF  32D,337
027DE:  MOVLB  0
027E0:  CALL   1AD94
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated CAM address 
027E4:  CALL   142D0
....................          break; 
027E8:  GOTO   3082
....................       case 0xA0: 
....................          REPLY_TO_COM(0x66,0); 
027EC:  MOVLW  66
027EE:  MOVLB  3
027F0:  MOVWF  x37
027F2:  CLRF   x38
027F4:  MOVLB  0
027F6:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1,CMD2,CMD4); 
027FA:  MOVFF  32C,353
027FE:  MOVFF  32D,354
02802:  MOVFF  32F,355
02806:  CALL   16EA4
....................          unsigned int16 op_duration = (unsigned int16)CMD4*60;          
0280A:  MOVLB  3
0280C:  CLRF   x38
0280E:  MOVFF  32F,337
02812:  MOVFF  338,343
02816:  MOVFF  32F,342
0281A:  CLRF   x45
0281C:  MOVLW  3C
0281E:  MOVWF  x44
02820:  MOVLB  0
02822:  RCALL  253A
02824:  MOVFF  02,334
02828:  MOVFF  01,333
....................          UPLINK_SUCCESS_ADCS(); 
0282C:  CALL   1E13C
....................          ACK_for_COM[14] = 0x00;         
02830:  MOVLB  1
02832:  CLRF   xF1
....................          //ADCS_TEST_OPERATION(op_duration,NOMAL_ADCS_MSN); 
....................          ADCS_TEST_OPERATION(op_duration,CMD2); 
02834:  MOVFF  334,381
02838:  MOVFF  333,380
0283C:  MOVFF  32D,382
02840:  MOVLB  0
02842:  CALL   12292
....................          STORE_ADRESS_DATA_TO_FLASH(); 
02846:  CALL   142D0
....................          break; 
0284A:  GOTO   3082
....................       case 0xA1:                                                                 //TLE data reception  
....................          REPLY_TO_COM(0x66,0); 
0284E:  MOVLW  66
02850:  MOVLB  3
02852:  MOVWF  x37
02854:  CLRF   x38
02856:  MOVLB  0
02858:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
0285C:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
02860:  MOVFF  32C,353
02864:  MOVLB  3
02866:  CLRF   x54
02868:  MOVFF  32D,355
0286C:  MOVLB  0
0286E:  CALL   16EA4
....................          ACK_for_COM[14] = 0x00; 
02872:  MOVLB  1
02874:  CLRF   xF1
....................          ADCS_TLE_JOIN(CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                           //Receive, assemble and save TLE data in flash 
02876:  MOVFF  32D,337
0287A:  MOVFF  32E,338
0287E:  MOVFF  32F,339
02882:  MOVFF  330,33A
02886:  MOVFF  331,33B
0288A:  MOVFF  332,33C
0288E:  MOVLB  0
02890:  CALL   1B0DC
....................          break; 
02894:  GOTO   3082
....................       case 0xA2:                                                                 //TLE data reception  
....................          REPLY_TO_COM(0x66,0); 
02898:  MOVLW  66
0289A:  MOVLB  3
0289C:  MOVWF  x37
0289E:  CLRF   x38
028A0:  MOVLB  0
028A2:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
028A6:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
028AA:  MOVFF  32C,353
028AE:  MOVLB  3
028B0:  CLRF   x54
028B2:  MOVFF  32D,355
028B6:  MOVLB  0
028B8:  CALL   16EA4
....................          ACK_for_COM[14] = 0x00; 
028BC:  MOVLB  1
028BE:  CLRF   xF1
....................          ADCS_TLE_TRANSFER();                                                    //TRANSFER TLE data to ADCS 
028C0:  MOVLB  0
028C2:  CALL   136BE
....................          break;     
028C6:  GOTO   3082
....................       case 0xD0:                                                                 //transfer data from Mission BOSS 
....................          REPLY_TO_COM(0x66,0); 
028CA:  MOVLW  66
028CC:  MOVLB  3
028CE:  MOVWF  x37
028D0:  CLRF   x38
028D2:  MOVLB  0
028D4:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
028D8:  MOVFF  32C,353
028DC:  MOVLB  3
028DE:  CLRF   x54
028E0:  MOVFF  32D,355
028E4:  MOVLB  0
028E6:  CALL   16EA4
....................          UPLINK_SUCCESS_MBP();                                                   //put uplink succes flag in high and store flags 
028EA:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;          
028EE:  MOVLB  1
028F0:  CLRF   xF1
....................          DATACOLLECTION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);      //Turn ON MBP, get data, store in flash 
028F2:  MOVFF  32C,337
028F6:  MOVFF  32D,338
028FA:  MOVFF  32E,339
028FE:  MOVFF  32F,33A
02902:  MOVFF  330,33B
02906:  MOVFF  331,33C
0290A:  MOVFF  332,33D
0290E:  MOVLB  0
02910:  CALL   138DA
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02914:  CALL   142D0
....................          delay_ms(10); 
02918:  MOVLW  0A
0291A:  MOVLB  3
0291C:  MOVWF  x98
0291E:  MOVLB  0
02920:  CALL   063E
....................          break;  
02924:  BRA    3082
....................       case 0xD1:                                                                 //PSC Mission 
....................          REPLY_TO_COM(0x66,0); 
02926:  MOVLW  66
02928:  MOVLB  3
0292A:  MOVWF  x37
0292C:  CLRF   x38
0292E:  MOVLB  0
02930:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02934:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
02938:  MOVLB  1
0293A:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0293C:  MOVFF  32C,353
02940:  MOVLB  3
02942:  CLRF   x54
02944:  MOVFF  32D,355
02948:  MOVLB  0
0294A:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0294E:  MOVFF  32C,337
02952:  MOVFF  32D,338
02956:  MOVFF  32E,339
0295A:  MOVFF  32F,33A
0295E:  MOVFF  330,33B
02962:  MOVFF  331,33C
02966:  MOVFF  332,33D
0296A:  CALL   13A86
....................          delay_ms(10); 
0296E:  MOVLW  0A
02970:  MOVLB  3
02972:  MOVWF  x98
02974:  MOVLB  0
02976:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0297A:  CALL   142D0
....................          break; 
0297E:  BRA    3082
....................       case 0xD2:                                                                 //TMCR Mission 
....................          REPLY_TO_COM(0x66,0); 
02980:  MOVLW  66
02982:  MOVLB  3
02984:  MOVWF  x37
02986:  CLRF   x38
02988:  MOVLB  0
0298A:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0298E:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
02992:  MOVLB  1
02994:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02996:  MOVFF  32C,353
0299A:  MOVLB  3
0299C:  CLRF   x54
0299E:  MOVFF  32D,355
029A2:  MOVLB  0
029A4:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
029A8:  MOVFF  32C,337
029AC:  MOVFF  32D,338
029B0:  MOVFF  32E,339
029B4:  MOVFF  32F,33A
029B8:  MOVFF  330,33B
029BC:  MOVFF  331,33C
029C0:  MOVFF  332,33D
029C4:  CALL   13A86
....................          delay_ms(10); 
029C8:  MOVLW  0A
029CA:  MOVLB  3
029CC:  MOVWF  x98
029CE:  MOVLB  0
029D0:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
029D4:  CALL   142D0
....................          break; 
029D8:  BRA    3082
....................       case 0xD3:                                                                 //NTU Mission 
....................          REPLY_TO_COM(0x66,0); 
029DA:  MOVLW  66
029DC:  MOVLB  3
029DE:  MOVWF  x37
029E0:  CLRF   x38
029E2:  MOVLB  0
029E4:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
029E8:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
029EC:  MOVLB  1
029EE:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
029F0:  MOVFF  32C,353
029F4:  MOVLB  3
029F6:  CLRF   x54
029F8:  MOVFF  32D,355
029FC:  MOVLB  0
029FE:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02A02:  MOVFF  32C,337
02A06:  MOVFF  32D,338
02A0A:  MOVFF  32E,339
02A0E:  MOVFF  32F,33A
02A12:  MOVFF  330,33B
02A16:  MOVFF  331,33C
02A1A:  MOVFF  332,33D
02A1E:  CALL   13A86
....................          delay_ms(10); 
02A22:  MOVLW  0A
02A24:  MOVLB  3
02A26:  MOVWF  x98
02A28:  MOVLB  0
02A2A:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02A2E:  CALL   142D0
....................          break; 
02A32:  BRA    3082
....................       case 0xD4:                                                                 //SF_WARD Mission 
....................          REPLY_TO_COM(0x66,0); 
02A34:  MOVLW  66
02A36:  MOVLB  3
02A38:  MOVWF  x37
02A3A:  CLRF   x38
02A3C:  MOVLB  0
02A3E:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02A42:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
02A46:  MOVLB  1
02A48:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02A4A:  MOVFF  32C,353
02A4E:  MOVLB  3
02A50:  CLRF   x54
02A52:  MOVFF  32D,355
02A56:  MOVLB  0
02A58:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02A5C:  MOVFF  32C,337
02A60:  MOVFF  32D,338
02A64:  MOVFF  32E,339
02A68:  MOVFF  32F,33A
02A6C:  MOVFF  330,33B
02A70:  MOVFF  331,33C
02A74:  MOVFF  332,33D
02A78:  CALL   13A86
....................          delay_ms(10); 
02A7C:  MOVLW  0A
02A7E:  MOVLB  3
02A80:  MOVWF  x98
02A82:  MOVLB  0
02A84:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02A88:  CALL   142D0
....................          break; 
02A8C:  BRA    3082
....................       case 0xD5:                                                                 //HNT Mission 
....................          REPLY_TO_COM(0x66,0); 
02A8E:  MOVLW  66
02A90:  MOVLB  3
02A92:  MOVWF  x37
02A94:  CLRF   x38
02A96:  MOVLB  0
02A98:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02A9C:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
02AA0:  MOVLB  1
02AA2:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02AA4:  MOVFF  32C,353
02AA8:  MOVLB  3
02AAA:  CLRF   x54
02AAC:  MOVFF  32D,355
02AB0:  MOVLB  0
02AB2:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02AB6:  MOVFF  32C,337
02ABA:  MOVFF  32D,338
02ABE:  MOVFF  32E,339
02AC2:  MOVFF  32F,33A
02AC6:  MOVFF  330,33B
02ACA:  MOVFF  331,33C
02ACE:  MOVFF  332,33D
02AD2:  CALL   13A86
....................          delay_ms(10); 
02AD6:  MOVLW  0A
02AD8:  MOVLB  3
02ADA:  MOVWF  x98
02ADC:  MOVLB  0
02ADE:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02AE2:  CALL   142D0
....................          break; 
02AE6:  BRA    3082
....................       case 0xD6:                                                                 //APRS_DP Mission 
....................          REPLY_TO_COM(0x66,0); 
02AE8:  MOVLW  66
02AEA:  MOVLB  3
02AEC:  MOVWF  x37
02AEE:  CLRF   x38
02AF0:  MOVLB  0
02AF2:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02AF6:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
02AFA:  MOVLB  1
02AFC:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02AFE:  MOVFF  32C,353
02B02:  MOVLB  3
02B04:  CLRF   x54
02B06:  MOVFF  32D,355
02B0A:  MOVLB  0
02B0C:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02B10:  MOVFF  32C,337
02B14:  MOVFF  32D,338
02B18:  MOVFF  32E,339
02B1C:  MOVFF  32F,33A
02B20:  MOVFF  330,33B
02B24:  MOVFF  331,33C
02B28:  MOVFF  332,33D
02B2C:  CALL   13A86
....................          delay_ms(10); 
02B30:  MOVLW  0A
02B32:  MOVLB  3
02B34:  MOVWF  x98
02B36:  MOVLB  0
02B38:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02B3C:  CALL   142D0
....................          break; 
02B40:  BRA    3082
....................       case 0xD7:                                                                 //dummy data for MBP 
....................          REPLY_TO_COM(0x66,0); 
02B42:  MOVLW  66
02B44:  MOVLB  3
02B46:  MOVWF  x37
02B48:  CLRF   x38
02B4A:  MOVLB  0
02B4C:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02B50:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
02B54:  MOVLB  1
02B56:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02B58:  MOVFF  32C,353
02B5C:  MOVLB  3
02B5E:  CLRF   x54
02B60:  MOVFF  32D,355
02B64:  MOVLB  0
02B66:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02B6A:  MOVFF  32C,337
02B6E:  MOVFF  32D,338
02B72:  MOVFF  32E,339
02B76:  MOVFF  32F,33A
02B7A:  MOVFF  330,33B
02B7E:  MOVFF  331,33C
02B82:  MOVFF  332,33D
02B86:  CALL   13A86
....................          delay_ms(10); 
02B8A:  MOVLW  0A
02B8C:  MOVLB  3
02B8E:  MOVWF  x98
02B90:  MOVLB  0
02B92:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02B96:  CALL   142D0
....................          break; 
02B9A:  BRA    3082
....................       case 0xDF:                                                                 //dummy data for MBP 
....................          REPLY_TO_COM(0x66,0); 
02B9C:  MOVLW  66
02B9E:  MOVLB  3
02BA0:  MOVWF  x37
02BA2:  CLRF   x38
02BA4:  MOVLB  0
02BA6:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
02BAA:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
02BAE:  MOVLB  1
02BB0:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
02BB2:  MOVFF  32C,353
02BB6:  MOVLB  3
02BB8:  CLRF   x54
02BBA:  MOVFF  32D,355
02BBE:  MOVLB  0
02BC0:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
02BC4:  MOVFF  32C,337
02BC8:  MOVFF  32D,338
02BCC:  MOVFF  32E,339
02BD0:  MOVFF  32F,33A
02BD4:  MOVFF  330,33B
02BD8:  MOVFF  331,33C
02BDC:  MOVFF  332,33D
02BE0:  CALL   13A86
....................          delay_ms(10); 
02BE4:  MOVLW  0A
02BE6:  MOVLB  3
02BE8:  MOVWF  x98
02BEA:  MOVLB  0
02BEC:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
02BF0:  CALL   142D0
....................          break; 
02BF4:  BRA    3082
....................       case 0xaa: 
....................          REPLY_TO_COM(0x66,0); 
02BF6:  MOVLW  66
02BF8:  MOVLB  3
02BFA:  MOVWF  x37
02BFC:  CLRF   x38
02BFE:  MOVLB  0
02C00:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
02C04:  MOVFF  32C,353
02C08:  MOVLB  3
02C0A:  CLRF   x54
02C0C:  MOVFF  32D,355
02C10:  MOVLB  0
02C12:  CALL   16EA4
....................          STORE_ADRESS_DATA_TO_FLASH();          
02C16:  CALL   142D0
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02C1A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02C1E:  MOVLB  1
02C20:  CLRF   xF1
....................          STORE_FLAG_INFO();                                                      //store flag info on flash 
02C22:  MOVLB  0
02C24:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //store flag info on EEPROM 
02C28:  CALL   12FE4
....................          break; 
02C2C:  BRA    3082
....................       case 0x22: 
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02C2E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
02C32:  MOVLB  1
02C34:  CLRF   xF1
....................          REPLY_TO_COM(0x66,0);                                                   //ACK_for_COM[12] = 0x66 ACK_for_COM[13] = 0          
02C36:  MOVLW  66
02C38:  MOVLB  3
02C3A:  MOVWF  x37
02C3C:  CLRF   x38
02C3E:  MOVLB  0
02C40:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data, cmd1 and cmd2 as sat log         
02C44:  MOVFF  32C,353
02C48:  MOVLB  3
02C4A:  CLRF   x54
02C4C:  MOVFF  32D,355
02C50:  MOVLB  0
02C52:  CALL   16EA4
....................          SEND_CMD_FOR_RESET_SATELLITE();                                         //save flag data, address data and RSV table in flash, send cmd for sat reset 
02C56:  CALL   16AE2
....................          break; 
02C5A:  BRA    3082
....................       case 0xb0: 
....................          REPLY_TO_COM(0x66,0); 
02C5C:  MOVLW  66
02C5E:  MOVLB  3
02C60:  MOVWF  x37
02C62:  CLRF   x38
02C64:  MOVLB  0
02C66:  CALL   1D84A
....................          CLEAR_BC_FLAG();                                                        //BC_ATTEMPT_FLAG = 0        
02C6A:  CALL   1B3D8
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02C6E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
02C72:  MOVLB  1
02C74:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
02C76:  MOVLB  0
02C78:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
02C7C:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
02C80:  CALL   12FE4
....................          break; 
02C84:  BRA    3082
....................       case 0xb1: 
....................          REPLY_TO_COM(0x66,0); 
02C86:  MOVLW  66
02C88:  MOVLB  3
02C8A:  MOVWF  x37
02C8C:  CLRF   x38
02C8E:  MOVLB  0
02C90:  CALL   1D84A
....................          MAKE_BC_FLAG_1();                                                       //BC_ATTEMPT_FLAG = 1          
02C94:  CALL   1B3EC
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02C98:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
02C9C:  MOVLB  1
02C9E:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
02CA0:  MOVLB  0
02CA2:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
02CA6:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
02CAA:  CALL   12FE4
....................          break; 
02CAE:  BRA    3082
....................       case 0xb2: 
....................          REPLY_TO_COM(0x66,0); 
02CB0:  MOVLW  66
02CB2:  MOVLB  3
02CB4:  MOVWF  x37
02CB6:  CLRF   x38
02CB8:  MOVLB  0
02CBA:  CALL   1D84A
....................          MAKE_BC_FLAG_2();                                                       //BC_ATTEMPT_FLAG = 2          
02CBE:  CALL   1B402
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02CC2:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02CC6:  MOVLB  1
02CC8:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
02CCA:  MOVLB  0
02CCC:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
02CD0:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
02CD4:  CALL   12FE4
....................          break; 
02CD8:  BRA    3082
....................       case 0xb3: 
....................          REPLY_TO_COM(0x66,0); 
02CDA:  MOVLW  66
02CDC:  MOVLB  3
02CDE:  MOVWF  x37
02CE0:  CLRF   x38
02CE2:  MOVLB  0
02CE4:  CALL   1D84A
....................          MAKE_BC_FLAG_3();                                                       //BC_ATTEMPT_FLAG = 3         
02CE8:  CALL   1B418
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02CEC:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02CF0:  MOVLB  1
02CF2:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
02CF4:  MOVLB  0
02CF6:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
02CFA:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
02CFE:  CALL   12FE4
....................          break; 
02D02:  BRA    3082
....................       case 0xb4: 
....................          REPLY_TO_COM(0x66,0); 
02D04:  MOVLW  66
02D06:  MOVLB  3
02D08:  MOVWF  x37
02D0A:  CLRF   x38
02D0C:  MOVLB  0
02D0E:  CALL   1D84A
....................          MAKE_BC_FLAG_4();                                                       //BC_ATTEMPT_FLAG = 4          
02D12:  CALL   1B42E
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02D16:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
02D1A:  MOVLB  1
02D1C:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
02D1E:  MOVLB  0
02D20:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
02D24:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
02D28:  CALL   12FE4
....................          break; 
02D2C:  BRA    3082
....................       case 0x4b: 
....................          REPLY_TO_COM(0x66,0); 
02D2E:  MOVLW  66
02D30:  MOVLB  3
02D32:  MOVWF  x37
02D34:  CLRF   x38
02D36:  MOVLB  0
02D38:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02D3C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02D40:  MOVLB  1
02D42:  CLRF   xF1
....................          Count_Kill_Flag();                                                      //Enable if Kill_COUNTER > 4 
02D44:  MOVLB  0
02D46:  CALL   1B444
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
02D4A:  MOVFF  32C,353
02D4E:  MOVFF  31A,354
02D52:  MOVFF  32D,355
02D56:  CALL   16EA4
....................          break; 
02D5A:  BRA    3082
....................       case 0xbb: 
....................          REPLY_TO_COM(0x66,0); 
02D5C:  MOVLW  66
02D5E:  MOVLB  3
02D60:  MOVWF  x37
02D62:  CLRF   x38
02D64:  MOVLB  0
02D66:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
02D6A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02D6E:  MOVLB  1
02D70:  CLRF   xF1
....................          Disable_Kill();                                                         //Kill Switch OFF 
02D72:  MOVLB  0
02D74:  CALL   1B498
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
02D78:  MOVFF  32C,353
02D7C:  MOVFF  31A,354
02D80:  MOVFF  32D,355
02D84:  CALL   16EA4
....................          break; 
02D88:  BRA    3082
....................       case 0xfa: 
....................          REPLY_TO_COM(0x66,0); 
02D8A:  MOVLW  66
02D8C:  MOVLB  3
02D8E:  MOVWF  x37
02D90:  CLRF   x38
02D92:  MOVLB  0
02D94:  CALL   1D84A
....................          UPLINK_SUCCESS_HSSC();                                                  //High Sampling Sensor Collect mission 
02D98:  CALL   1E19A
....................          ACK_for_COM[14] = 0x00;       
02D9C:  MOVLB  1
02D9E:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);          
02DA0:  MOVFF  32C,353
02DA4:  MOVLB  3
02DA6:  CLRF   x54
02DA8:  MOVFF  32D,355
02DAC:  MOVLB  0
02DAE:  CALL   16EA4
....................          unsigned int16 duration = (unsigned int16)CMD2*12;                      //CMD2 is operation time(min), maxima cantidad de lecturas en 2 horas = 1440 
02DB2:  MOVLB  3
02DB4:  CLRF   x38
02DB6:  MOVFF  32D,337
02DBA:  MOVFF  338,343
02DBE:  MOVFF  32D,342
02DC2:  CLRF   x45
02DC4:  MOVLW  0C
02DC6:  MOVWF  x44
02DC8:  MOVLB  0
02DCA:  CALL   253A
02DCE:  MOVFF  02,336
02DD2:  MOVFF  01,335
....................          if(duration > 1440){duration = 1440;}                                   // 12 readings in 1 min, every 5 seconds 
02DD6:  MOVLB  3
02DD8:  MOVF   x36,W
02DDA:  SUBLW  04
02DDC:  BC    2DF0
02DDE:  XORLW  FF
02DE0:  BNZ   2DE8
02DE2:  MOVF   x35,W
02DE4:  SUBLW  A0
02DE6:  BC    2DF0
02DE8:  MOVLW  05
02DEA:  MOVWF  x36
02DEC:  MOVLW  A0
02DEE:  MOVWF  x35
....................          HIGHSAMP_SENSOR_COLLECTION(duration);                                   //duration is how many times will be executed 
02DF0:  MOVFF  336,338
02DF4:  MOVFF  335,337
02DF8:  MOVLB  0
02DFA:  CALL   1BAB6
....................          STORE_ADRESS_DATA_TO_FLASH(); 
02DFE:  CALL   142D0
....................          break; 
02E02:  BRA    3082
....................       case 0x59:       
....................          //UPLINK_SUCCESS_CHECK(); 
....................          //ACK_for_COM[14] = 0x00;       
....................          REPLY_TO_COM(0x66,0);                                                   //send ACK to COM 
02E04:  MOVLW  66
02E06:  MOVLB  3
02E08:  MOVWF  x37
02E0A:  CLRF   x38
02E0C:  MOVLB  0
02E0E:  CALL   1D84A
....................          GIVE_ACCESS_SCF_Nsec(CMD2); 
02E12:  MOVFF  32D,337
02E16:  CALL   1B4E4
....................          break; 
02E1A:  BRA    3082
....................       case 0xee:       
....................          UPLINK_SUCCESS_CHECK(); 
02E1C:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00;       
....................          ERASE_EEPROM_INFO();                                                    //erase 512byte(from 0x18000 to 0x181ff) 
02E20:  CALL   13C2A
....................          MEMORY_ERASE();                                                         //erase OF, SCF, SMF flash memories 
02E24:  CALL   15AEC
....................          break; 
02E28:  BRA    3082
....................       case 0x88: 
....................        
....................          //UPLINK_SUCCESS_CHECK(); 
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          CURRENT_FLAG_STATUS();                                                  //Print on PC port current flag status 
02E2A:  CALL   124D0
....................          break; 
02E2E:  BRA    3082
....................       case 0x9f: 
....................        
....................          //UPLINK_SUCCESS_CHECK(); 
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          Disp_RSV();                                                             //show the reserve status (reserve command and reserve table) 
02E30:  CALL   171FC
....................          break; 
02E34:  BRA    3082
....................       case 0x50: 
....................          if(UPLINK_SUCCESS == 0){ACK_for_COM[14]=0x77;} 
02E36:  MOVF   x7C,F
02E38:  BNZ   2E42
02E3A:  MOVLW  77
02E3C:  MOVLB  1
02E3E:  MOVWF  xF1
02E40:  MOVLB  0
....................          CW_RESPOND();                                                           //carga el array ACK_for_COM[] con los datos del CW 
02E42:  CALL   1E024
....................          break; 
02E46:  BRA    3082
....................       case 0xe0: 
....................          REPLY_TO_COM(0x66,0); 
02E48:  MOVLW  66
02E4A:  MOVLB  3
02E4C:  MOVWF  x37
02E4E:  CLRF   x38
02E50:  MOVLB  0
02E52:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02E56:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02E5A:  MOVLB  1
02E5C:  CLRF   xF1
....................          REFRESH_SECTOR_OF(CMD2,CMD3,CMD4,CMD5);                                 //Erase 1 sector of OBC flash, also this function contains saving log 
02E5E:  MOVFF  32D,347
02E62:  MOVFF  32E,348
02E66:  MOVFF  32F,349
02E6A:  MOVFF  330,34A
02E6E:  MOVLB  0
02E70:  CALL   17094
....................          break; 
02E74:  BRA    3082
....................       case 0xe1: 
....................          REPLY_TO_COM(0x66,0); 
02E76:  MOVLW  66
02E78:  MOVLB  3
02E7A:  MOVWF  x37
02E7C:  CLRF   x38
02E7E:  MOVLB  0
02E80:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02E84:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02E88:  MOVLB  1
02E8A:  CLRF   xF1
....................          REFRESH_SECTOR_SCF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of COM flash, also this function contains saving log 
02E8C:  MOVFF  32D,347
02E90:  MOVFF  32E,348
02E94:  MOVFF  32F,349
02E98:  MOVFF  330,34A
02E9C:  MOVLB  0
02E9E:  CALL   17144
....................          break; 
02EA2:  BRA    3082
....................       case 0xe2: 
....................          REPLY_TO_COM(0x66,0); 
02EA4:  MOVLW  66
02EA6:  MOVLB  3
02EA8:  MOVWF  x37
02EAA:  CLRF   x38
02EAC:  MOVLB  0
02EAE:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02EB2:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
02EB6:  MOVLB  1
02EB8:  CLRF   xF1
....................          REFRESH_SECTOR_SMF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of MISION flash, also this function contains saving log 
02EBA:  MOVFF  32D,347
02EBE:  MOVFF  32E,348
02EC2:  MOVFF  32F,349
02EC6:  MOVFF  330,34A
02ECA:  MOVLB  0
02ECC:  CALL   16FE0
....................          break; 
02ED0:  BRA    3082
....................       case 0x12: 
....................          REPLY_TO_COM(0x66,0); 
02ED2:  MOVLW  66
02ED4:  MOVLB  3
02ED6:  MOVWF  x37
02ED8:  CLRF   x38
02EDA:  MOVLB  0
02EDC:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02EE0:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02EE4:  MOVLB  1
02EE6:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SCF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
02EE8:  MOVFF  32D,337
02EEC:  MOVFF  32E,338
02EF0:  MOVFF  32F,339
02EF4:  MOVFF  330,33A
02EF8:  MOVLB  0
02EFA:  CALL   1742A
....................          break; 
02EFE:  BRA    3082
....................       case 0x13: 
....................          REPLY_TO_COM(0x66,0); 
02F00:  MOVLW  66
02F02:  MOVLB  3
02F04:  MOVWF  x37
02F06:  CLRF   x38
02F08:  MOVLB  0
02F0A:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02F0E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02F12:  MOVLB  1
02F14:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SMF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
02F16:  MOVFF  32D,337
02F1A:  MOVFF  32E,338
02F1E:  MOVFF  32F,339
02F22:  MOVFF  330,33A
02F26:  MOVLB  0
02F28:  CALL   175A2
....................          break; 
02F2C:  BRA    3082
....................       case 0x21: 
....................          REPLY_TO_COM(0x66,0); 
02F2E:  MOVLW  66
02F30:  MOVLB  3
02F32:  MOVWF  x37
02F34:  CLRF   x38
02F36:  MOVLB  0
02F38:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02F3C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02F40:  MOVLB  1
02F42:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
02F44:  MOVFF  32D,337
02F48:  MOVFF  32E,338
02F4C:  MOVFF  32F,339
02F50:  MOVFF  330,33A
02F54:  MOVLB  0
02F56:  CALL   17718
....................          break; 
02F5A:  BRA    3082
....................       case 0x23: 
....................          REPLY_TO_COM(0x66,0); 
02F5C:  MOVLW  66
02F5E:  MOVLB  3
02F60:  MOVWF  x37
02F62:  CLRF   x38
02F64:  MOVLB  0
02F66:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02F6A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02F6E:  MOVLB  1
02F70:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2SMF(CMD2,CMD3,CMD4,CMD5);                           //transfer 1 sector, this function contains saving log 
02F72:  MOVFF  32D,337
02F76:  MOVFF  32E,338
02F7A:  MOVFF  32F,339
02F7E:  MOVFF  330,33A
02F82:  MOVLB  0
02F84:  CALL   17892
....................          break; 
02F88:  BRA    3082
....................       case 0x31: 
....................          REPLY_TO_COM(0x66,0); 
02F8A:  MOVLW  66
02F8C:  MOVLB  3
02F8E:  MOVWF  x37
02F90:  CLRF   x38
02F92:  MOVLB  0
02F94:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02F98:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
02F9C:  MOVLB  1
02F9E:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
02FA0:  MOVFF  32D,337
02FA4:  MOVFF  32E,338
02FA8:  MOVFF  32F,339
02FAC:  MOVFF  330,33A
02FB0:  MOVLB  0
02FB2:  CALL   17A12
....................          break; 
02FB6:  BRA    3082
....................     case 0x32: 
....................          REPLY_TO_COM(0x66,0); 
02FB8:  MOVLW  66
02FBA:  MOVLB  3
02FBC:  MOVWF  x37
02FBE:  CLRF   x38
02FC0:  MOVLB  0
02FC2:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02FC6:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02FCA:  MOVLB  1
02FCC:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2SCF(CMD2,CMD3,CMD4,CMD5);                          //transfer 1 sector, also this function contains saving log 
02FCE:  MOVFF  32D,337
02FD2:  MOVFF  32E,338
02FD6:  MOVFF  32F,339
02FDA:  MOVFF  330,33A
02FDE:  MOVLB  0
02FE0:  CALL   17B8A
....................          break; 
02FE4:  BRA    3082
....................     case 0x01: 
....................          REPLY_TO_COM(0x66,0); 
02FE6:  MOVLW  66
02FE8:  MOVLB  3
02FEA:  MOVWF  x37
02FEC:  CLRF   x38
02FEE:  MOVLB  0
02FF0:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
02FF4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
02FF8:  MOVLB  1
02FFA:  CLRF   xF1
....................          Send_Command_to_FAB(0x01);                                              //send cmd to FAB to turn ON battery heater 
02FFC:  MOVLW  01
02FFE:  MOVLB  3
03000:  MOVWF  x4F
03002:  MOVLB  0
03004:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater ON\r\n"); 
03008:  MOVLW  88
0300A:  MOVWF  FF6
0300C:  MOVLW  15
0300E:  MOVWF  FF7
03010:  MOVLW  00
03012:  MOVWF  FF8
03014:  CALL   06A4
....................          break; 
03018:  BRA    3082
....................     case 0x02: 
....................          REPLY_TO_COM(0x66,0); 
0301A:  MOVLW  66
0301C:  MOVLB  3
0301E:  MOVWF  x37
03020:  CLRF   x38
03022:  MOVLB  0
03024:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03028:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0302C:  MOVLB  1
0302E:  CLRF   xF1
....................          Send_Command_to_FAB(0x02);                                              //send cmd to FAB to turn OFF battery heater 
03030:  MOVLW  02
03032:  MOVLB  3
03034:  MOVWF  x4F
03036:  MOVLB  0
03038:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater OFF\r\n"); 
0303C:  MOVLW  9E
0303E:  MOVWF  FF6
03040:  MOVLW  15
03042:  MOVWF  FF7
03044:  MOVLW  00
03046:  MOVWF  FF8
03048:  CALL   06A4
....................          break; 
0304C:  BRA    3082
....................     case 0x03: 
....................          REPLY_TO_COM(0x66,0); 
0304E:  MOVLW  66
03050:  MOVLB  3
03052:  MOVWF  x37
03054:  CLRF   x38
03056:  MOVLB  0
03058:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0305C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
03060:  MOVLB  1
03062:  CLRF   xF1
....................          Send_Command_to_FAB(0x03);                                              //send cmd to FAB to operate Heater in AUTO mode 
03064:  MOVLW  03
03066:  MOVLB  3
03068:  MOVWF  x4F
0306A:  MOVLB  0
0306C:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater AUTO\r\n"); 
03070:  MOVLW  B4
03072:  MOVWF  FF6
03074:  MOVLW  15
03076:  MOVWF  FF7
03078:  MOVLW  00
0307A:  MOVWF  FF8
0307C:  CALL   06A4
....................          break;          
03080:  BRA    3082
.................... //!     case 0x35: 
.................... //!         REPLY_TO_COM(0x66,0); 
.................... //!         RSV_DATA_DOWNLOAD(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                  //send array of commnands to COM 
.................... //!         fprintf(PC,"Sent CMD to COM for data download\r\n"); 
.................... //!         break; 
....................       default: 
....................          //bad command. Do nothing. 
....................          break;      
....................    } 
....................    return; 
03082:  RETURN 0
.................... } 
....................  
.................... void EXECUTE_MISSION_from_PC(int8 CMD1,int8 CMD2,int8 CMD3,int8 CMD4,int8 CMD5,int8 CMD6,int8 CMD7) 
.................... { 
....................    switch(CMD1) 
03084:  MOVLB  3
03086:  MOVF   x2C,W
03088:  XORLW  C0
0308A:  MOVLB  0
0308C:  BTFSC  FD8.2
0308E:  BRA    3176
03090:  XORLW  60
03092:  BTFSC  FD8.2
03094:  BRA    31A2
03096:  XORLW  01
03098:  BTFSC  FD8.2
0309A:  BRA    31F6
0309C:  XORLW  03
0309E:  BTFSC  FD8.2
030A0:  BRA    3230
030A2:  XORLW  72
030A4:  BTFSC  FD8.2
030A6:  BRA    3252
030A8:  XORLW  01
030AA:  BTFSC  FD8.2
030AC:  BRA    32AE
030AE:  XORLW  03
030B0:  BTFSC  FD8.2
030B2:  BRA    32FA
030B4:  XORLW  01
030B6:  BTFSC  FD8.2
030B8:  BRA    3346
030BA:  XORLW  07
030BC:  BTFSC  FD8.2
030BE:  BRA    3392
030C0:  XORLW  01
030C2:  BTFSC  FD8.2
030C4:  BRA    33DE
030C6:  XORLW  03
030C8:  BTFSC  FD8.2
030CA:  BRA    342A
030CC:  XORLW  01
030CE:  BTFSC  FD8.2
030D0:  BRA    3476
030D2:  XORLW  08
030D4:  BTFSC  FD8.2
030D6:  BRA    34C2
030D8:  XORLW  46
030DA:  BTFSC  FD8.2
030DC:  BRA    351C
030DE:  XORLW  33
030E0:  BTFSC  FD8.2
030E2:  BRA    353C
030E4:  XORLW  88
030E6:  BTFSC  FD8.2
030E8:  BRA    3564
030EA:  XORLW  92
030EC:  BTFSC  FD8.2
030EE:  BRA    3580
030F0:  XORLW  01
030F2:  BTFSC  FD8.2
030F4:  BRA    359C
030F6:  XORLW  03
030F8:  BTFSC  FD8.2
030FA:  BRA    35B8
030FC:  XORLW  01
030FE:  BTFSC  FD8.2
03100:  BRA    35D4
03102:  XORLW  07
03104:  BTFSC  FD8.2
03106:  BRA    35F0
03108:  XORLW  FF
0310A:  BTFSC  FD8.2
0310C:  BRA    360C
0310E:  XORLW  F0
03110:  BTFSC  FD8.2
03112:  BRA    362C
03114:  XORLW  41
03116:  BTFSC  FD8.2
03118:  BRA    3648
0311A:  XORLW  A3
0311C:  BTFSC  FD8.2
0311E:  BRA    36B4
03120:  XORLW  B7
03122:  BTFSC  FD8.2
03124:  BRA    36C8
03126:  XORLW  66
03128:  BTFSC  FD8.2
0312A:  BRA    36D6
0312C:  XORLW  17
0312E:  BTFSC  FD8.2
03130:  BRA    36E0
03132:  XORLW  50
03134:  BTFSC  FD8.2
03136:  BRA    36EA
03138:  XORLW  A5
0313A:  BTFSC  FD8.2
0313C:  BRA    36F4
0313E:  XORLW  8A
03140:  BTFSC  FD8.2
03142:  BRA    3704
03144:  XORLW  01
03146:  BTFSC  FD8.2
03148:  BRA    3724
0314A:  XORLW  03
0314C:  BTFSC  FD8.2
0314E:  BRA    3744
03150:  XORLW  F0
03152:  BTFSC  FD8.2
03154:  BRA    3764
03156:  XORLW  20
03158:  BTFSC  FD8.2
0315A:  BRA    3784
0315C:  XORLW  13
0315E:  BTFSC  FD8.2
03160:  BRA    37A4
03162:  XORLW  20
03164:  BTFSC  FD8.2
03166:  BRA    37C4
03168:  XORLW  03
0316A:  BTFSC  FD8.2
0316C:  BRA    37EA
0316E:  XORLW  01
03170:  BTFSC  FD8.2
03172:  BRA    3810
03174:  BRA    3834
....................    { 
....................       case 0xC0: 
....................        
....................          UPLINK_SUCCESS_CAM();                                                   //put uplink succes flag in high and store flags 
03176:  CALL   255C
....................          ACK_for_COM[14] = 0x00; 
0317A:  MOVLB  1
0317C:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data 
0317E:  MOVFF  32C,353
03182:  MOVLB  3
03184:  CLRF   x54
03186:  MOVFF  32D,355
0318A:  MOVLB  0
0318C:  CALL   16EA4
....................          CAM_TEST_OPERATION(CMD2);                                               //send command to CAM, execute mission and transfer data 
03190:  MOVFF  32D,337
03194:  CALL   1AD94
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated CAM address 
03198:  CALL   142D0
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0319C:  CALL   1E188
....................          break; 
031A0:  BRA    3834
....................       case 0xA0: 
....................  
....................          SAVE_SAT_LOG(CMD1,CMD2,CMD4); 
031A2:  MOVFF  32C,353
031A6:  MOVFF  32D,354
031AA:  MOVFF  32F,355
031AE:  CALL   16EA4
....................          unsigned int16 op_duration = (unsigned int16)CMD4*60; 
031B2:  MOVLB  3
031B4:  CLRF   x38
031B6:  MOVFF  32F,337
031BA:  MOVFF  338,343
031BE:  MOVFF  32F,342
031C2:  CLRF   x45
031C4:  MOVLW  3C
031C6:  MOVWF  x44
031C8:  MOVLB  0
031CA:  CALL   253A
031CE:  MOVFF  02,334
031D2:  MOVFF  01,333
....................           
....................          UPLINK_SUCCESS_ADCS(); 
031D6:  CALL   1E13C
....................          ACK_for_COM[14] = 0x00; 
031DA:  MOVLB  1
031DC:  CLRF   xF1
....................           
....................          //ADCS_TEST_OPERATION(op_duration,NOMAL_ADCS_MSN); 
....................          ADCS_TEST_OPERATION(op_duration,CMD2); 
031DE:  MOVFF  334,381
031E2:  MOVFF  333,380
031E6:  MOVFF  32D,382
031EA:  MOVLB  0
031EC:  CALL   12292
....................          STORE_ADRESS_DATA_TO_FLASH(); 
031F0:  CALL   142D0
....................          break; 
031F4:  BRA    3834
....................       case 0xA1:                                                                 //TLE data reception  
....................          UPLINK_SUCCESS_ADCS(); 
031F6:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
031FA:  MOVFF  32C,353
031FE:  MOVLB  3
03200:  CLRF   x54
03202:  MOVFF  32D,355
03206:  MOVLB  0
03208:  CALL   16EA4
....................          ACK_for_COM[14] = 0x00; 
0320C:  MOVLB  1
0320E:  CLRF   xF1
....................          ADCS_TLE_JOIN(CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                           //Receive, assemble and save TLE data in flash 
03210:  MOVFF  32D,337
03214:  MOVFF  32E,338
03218:  MOVFF  32F,339
0321C:  MOVFF  330,33A
03220:  MOVFF  331,33B
03224:  MOVFF  332,33C
03228:  MOVLB  0
0322A:  CALL   1B0DC
....................          break; 
0322E:  BRA    3834
....................       case 0xA2:                                                                 //TLE data reception  
....................  
....................          UPLINK_SUCCESS_ADCS(); 
03230:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
03234:  MOVFF  32C,353
03238:  MOVLB  3
0323A:  CLRF   x54
0323C:  MOVFF  32D,355
03240:  MOVLB  0
03242:  CALL   16EA4
....................          ACK_for_COM[14] = 0x00; 
03246:  MOVLB  1
03248:  CLRF   xF1
....................          ADCS_TLE_TRANSFER();                                                    //TRANSFER TLE data to ADCS 
0324A:  MOVLB  0
0324C:  CALL   136BE
....................          break; 
03250:  BRA    3834
....................       case 0xD0:                                                                 //transfer data from Mission BOSS 
....................          REPLY_TO_COM(0x66,0); 
03252:  MOVLW  66
03254:  MOVLB  3
03256:  MOVWF  x37
03258:  CLRF   x38
0325A:  MOVLB  0
0325C:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
03260:  MOVFF  32C,353
03264:  MOVLB  3
03266:  CLRF   x54
03268:  MOVFF  32D,355
0326C:  MOVLB  0
0326E:  CALL   16EA4
....................           
....................          UPLINK_SUCCESS_MBP();                                                   //put uplink succes flag in high and store flags 
03272:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
03276:  MOVLB  1
03278:  CLRF   xF1
....................           
....................          DATACOLLECTION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);      //Turn ON MBP, get data, store in flash 
0327A:  MOVFF  32C,337
0327E:  MOVFF  32D,338
03282:  MOVFF  32E,339
03286:  MOVFF  32F,33A
0328A:  MOVFF  330,33B
0328E:  MOVFF  331,33C
03292:  MOVFF  332,33D
03296:  MOVLB  0
03298:  CALL   138DA
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0329C:  CALL   142D0
....................          delay_ms(10); 
032A0:  MOVLW  0A
032A2:  MOVLB  3
032A4:  MOVWF  x98
032A6:  MOVLB  0
032A8:  CALL   063E
....................          break;  
032AC:  BRA    3834
....................       case 0xD1:                                                                 //PSC Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
032AE:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
032B2:  MOVLB  1
032B4:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
032B6:  MOVFF  32C,353
032BA:  MOVLB  3
032BC:  CLRF   x54
032BE:  MOVFF  32D,355
032C2:  MOVLB  0
032C4:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
032C8:  MOVFF  32C,337
032CC:  MOVFF  32D,338
032D0:  MOVFF  32E,339
032D4:  MOVFF  32F,33A
032D8:  MOVFF  330,33B
032DC:  MOVFF  331,33C
032E0:  MOVFF  332,33D
032E4:  CALL   13A86
....................          delay_ms(10); 
032E8:  MOVLW  0A
032EA:  MOVLB  3
032EC:  MOVWF  x98
032EE:  MOVLB  0
032F0:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
032F4:  CALL   142D0
....................          break; 
032F8:  BRA    3834
....................       case 0xD2:                                                                 //TMCR Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
032FA:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
032FE:  MOVLB  1
03300:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
03302:  MOVFF  32C,353
03306:  MOVLB  3
03308:  CLRF   x54
0330A:  MOVFF  32D,355
0330E:  MOVLB  0
03310:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
03314:  MOVFF  32C,337
03318:  MOVFF  32D,338
0331C:  MOVFF  32E,339
03320:  MOVFF  32F,33A
03324:  MOVFF  330,33B
03328:  MOVFF  331,33C
0332C:  MOVFF  332,33D
03330:  CALL   13A86
....................          delay_ms(10); 
03334:  MOVLW  0A
03336:  MOVLB  3
03338:  MOVWF  x98
0333A:  MOVLB  0
0333C:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
03340:  CALL   142D0
....................          break; 
03344:  BRA    3834
....................       case 0xD3:                                                                 //NTU Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
03346:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
0334A:  MOVLB  1
0334C:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0334E:  MOVFF  32C,353
03352:  MOVLB  3
03354:  CLRF   x54
03356:  MOVFF  32D,355
0335A:  MOVLB  0
0335C:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
03360:  MOVFF  32C,337
03364:  MOVFF  32D,338
03368:  MOVFF  32E,339
0336C:  MOVFF  32F,33A
03370:  MOVFF  330,33B
03374:  MOVFF  331,33C
03378:  MOVFF  332,33D
0337C:  CALL   13A86
....................          delay_ms(10); 
03380:  MOVLW  0A
03382:  MOVLB  3
03384:  MOVWF  x98
03386:  MOVLB  0
03388:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0338C:  CALL   142D0
....................          break; 
03390:  BRA    3834
....................       case 0xD4:                                                                 //SF_WARD Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
03392:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
03396:  MOVLB  1
03398:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0339A:  MOVFF  32C,353
0339E:  MOVLB  3
033A0:  CLRF   x54
033A2:  MOVFF  32D,355
033A6:  MOVLB  0
033A8:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
033AC:  MOVFF  32C,337
033B0:  MOVFF  32D,338
033B4:  MOVFF  32E,339
033B8:  MOVFF  32F,33A
033BC:  MOVFF  330,33B
033C0:  MOVFF  331,33C
033C4:  MOVFF  332,33D
033C8:  CALL   13A86
....................          delay_ms(10); 
033CC:  MOVLW  0A
033CE:  MOVLB  3
033D0:  MOVWF  x98
033D2:  MOVLB  0
033D4:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
033D8:  CALL   142D0
....................          break; 
033DC:  BRA    3834
....................       case 0xD5:                                                                 //HNT Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
033DE:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
033E2:  MOVLB  1
033E4:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
033E6:  MOVFF  32C,353
033EA:  MOVLB  3
033EC:  CLRF   x54
033EE:  MOVFF  32D,355
033F2:  MOVLB  0
033F4:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
033F8:  MOVFF  32C,337
033FC:  MOVFF  32D,338
03400:  MOVFF  32E,339
03404:  MOVFF  32F,33A
03408:  MOVFF  330,33B
0340C:  MOVFF  331,33C
03410:  MOVFF  332,33D
03414:  CALL   13A86
....................          delay_ms(10); 
03418:  MOVLW  0A
0341A:  MOVLB  3
0341C:  MOVWF  x98
0341E:  MOVLB  0
03420:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
03424:  CALL   142D0
....................          break; 
03428:  BRA    3834
....................       case 0xD6:                                                                 //APRS_DP Mission 
....................        
....................          UPLINK_SUCCESS_MBP(); 
0342A:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
0342E:  MOVLB  1
03430:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
03432:  MOVFF  32C,353
03436:  MOVLB  3
03438:  CLRF   x54
0343A:  MOVFF  32D,355
0343E:  MOVLB  0
03440:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
03444:  MOVFF  32C,337
03448:  MOVFF  32D,338
0344C:  MOVFF  32E,339
03450:  MOVFF  32F,33A
03454:  MOVFF  330,33B
03458:  MOVFF  331,33C
0345C:  MOVFF  332,33D
03460:  CALL   13A86
....................          delay_ms(10); 
03464:  MOVLW  0A
03466:  MOVLB  3
03468:  MOVWF  x98
0346A:  MOVLB  0
0346C:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
03470:  CALL   142D0
....................          break; 
03474:  BRA    3834
....................       case 0xD7:                                                                 //dummy data for MBP 
....................        
....................          UPLINK_SUCCESS_MBP(); 
03476:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
0347A:  MOVLB  1
0347C:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0347E:  MOVFF  32C,353
03482:  MOVLB  3
03484:  CLRF   x54
03486:  MOVFF  32D,355
0348A:  MOVLB  0
0348C:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
03490:  MOVFF  32C,337
03494:  MOVFF  32D,338
03498:  MOVFF  32E,339
0349C:  MOVFF  32F,33A
034A0:  MOVFF  330,33B
034A4:  MOVFF  331,33C
034A8:  MOVFF  332,33D
034AC:  CALL   13A86
....................          delay_ms(10); 
034B0:  MOVLW  0A
034B2:  MOVLB  3
034B4:  MOVWF  x98
034B6:  MOVLB  0
034B8:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
034BC:  CALL   142D0
....................          break; 
034C0:  BRA    3834
....................       case 0xDF:                                                                 //dummy data for MBP 
....................          REPLY_TO_COM(0x66,0); 
034C2:  MOVLW  66
034C4:  MOVLB  3
034C6:  MOVWF  x37
034C8:  CLRF   x38
034CA:  MOVLB  0
034CC:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
034D0:  CALL   1E162
....................          ACK_for_COM[14] = 0x00; 
034D4:  MOVLB  1
034D6:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
034D8:  MOVFF  32C,353
034DC:  MOVLB  3
034DE:  CLRF   x54
034E0:  MOVFF  32D,355
034E4:  MOVLB  0
034E6:  CALL   16EA4
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
034EA:  MOVFF  32C,337
034EE:  MOVFF  32D,338
034F2:  MOVFF  32E,339
034F6:  MOVFF  32F,33A
034FA:  MOVFF  330,33B
034FE:  MOVFF  331,33C
03502:  MOVFF  332,33D
03506:  CALL   13A86
....................          delay_ms(10); 
0350A:  MOVLW  0A
0350C:  MOVLB  3
0350E:  MOVWF  x98
03510:  MOVLB  0
03512:  CALL   063E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
03516:  CALL   142D0
....................          break; 
0351A:  BRA    3834
....................       case 0x99: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
0351C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03520:  MOVLB  1
03522:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2); 
03524:  MOVFF  32C,353
03528:  MOVLB  3
0352A:  CLRF   x54
0352C:  MOVFF  32D,355
03530:  MOVLB  0
03532:  CALL   16EA4
....................          CURRENT_ADDRESS_OF_FLASH();                                             //show address info address on PC 
03536:  CALL   12742
....................          break; 
0353A:  BRA    3834
....................       case 0xaa: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
0353C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03540:  MOVLB  1
03542:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data 
03544:  MOVFF  32C,353
03548:  MOVLB  3
0354A:  CLRF   x54
0354C:  MOVFF  32D,355
03550:  MOVLB  0
03552:  CALL   16EA4
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
03556:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //store flag info on flash 
0355A:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //store flag info on EEPROM 
0355E:  CALL   12FE4
....................          break; 
03562:  BRA    3834
....................       case 0x22: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
03564:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data, cmd1 and cmd2 as sat log 
03568:  MOVFF  32C,353
0356C:  MOVLB  3
0356E:  CLRF   x54
03570:  MOVFF  32D,355
03574:  MOVLB  0
03576:  CALL   16EA4
....................          SEND_CMD_FOR_RESET_SATELLITE();                                         //save flag data, address data and RSV table in flash, send cmd for sat reset 
0357A:  CALL   16AE2
....................          break;  
0357E:  BRA    3834
....................       case 0xb0: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
03580:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03584:  MOVLB  1
03586:  CLRF   xF1
....................        
....................          CLEAR_BC_FLAG();                                                        //BC_ATTEMPT_FLAG = 0 
03588:  MOVLB  0
0358A:  CALL   1B3D8
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0358E:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
03592:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
03596:  CALL   12FE4
....................          break; 
0359A:  BRA    3834
....................       case 0xb1: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0359C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
035A0:  MOVLB  1
035A2:  CLRF   xF1
....................        
....................          MAKE_BC_FLAG_1();                                                       //BC_ATTEMPT_FLAG = 1 
035A4:  MOVLB  0
035A6:  CALL   1B3EC
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
035AA:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
035AE:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
035B2:  CALL   12FE4
....................          break; 
035B6:  BRA    3834
....................       case 0xb2: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
035B8:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
035BC:  MOVLB  1
035BE:  CLRF   xF1
....................        
....................          MAKE_BC_FLAG_2();                                                       //BC_ATTEMPT_FLAG = 2 
035C0:  MOVLB  0
035C2:  CALL   1B402
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
035C6:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
035CA:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
035CE:  CALL   12FE4
....................          break;                
035D2:  BRA    3834
....................       case 0xb3: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
035D4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
035D8:  MOVLB  1
035DA:  CLRF   xF1
....................           
....................          MAKE_BC_FLAG_3();                                                       //BC_ATTEMPT_FLAG = 3 
035DC:  MOVLB  0
035DE:  CALL   1B418
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
035E2:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
035E6:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
035EA:  CALL   12FE4
....................          break; 
035EE:  BRA    3834
....................       case 0xb4: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
035F0:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
035F4:  MOVLB  1
035F6:  CLRF   xF1
....................        
....................          MAKE_BC_FLAG_4();                                                       //BC_ATTEMPT_FLAG = 4 
035F8:  MOVLB  0
035FA:  CALL   1B42E
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
035FE:  CALL   142D0
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
03602:  CALL   146F6
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
03606:  CALL   12FE4
....................          break;  
0360A:  BRA    3834
....................       case 0x4b: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0360C:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03610:  MOVLB  1
03612:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              // save reset data and commands 
03614:  MOVFF  32C,353
03618:  MOVLB  3
0361A:  CLRF   x54
0361C:  MOVFF  32D,355
03620:  MOVLB  0
03622:  CALL   16EA4
....................          Count_Kill_Flag();                                                      //Enable if Kill_COUNTER > 4 
03626:  CALL   1B444
....................          break; 
0362A:  BRA    3834
....................       case 0xbb: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0362C:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            // save reset data and commands 
03630:  MOVFF  32C,353
03634:  MOVLB  3
03636:  CLRF   x54
03638:  MOVFF  32D,355
0363C:  MOVLB  0
0363E:  CALL   16EA4
....................          Disable_Kill();                                                         //kill switch OFF 
03642:  CALL   1B498
....................          break; 
03646:  BRA    3834
....................       case 0xfa: 
....................        
....................          UPLINK_SUCCESS_HSSC();                                                  //High Sampling Sensor Collect mission 
03648:  CALL   1E19A
....................          ACK_for_COM[14] = 0x00; 
0364C:  MOVLB  1
0364E:  CLRF   xF1
....................        
....................          SAVE_SAT_LOG(CMD1,0,CMD2); 
03650:  MOVFF  32C,353
03654:  MOVLB  3
03656:  CLRF   x54
03658:  MOVFF  32D,355
0365C:  MOVLB  0
0365E:  CALL   16EA4
....................           
....................          unsigned int16 duration = (unsigned int16)CMD2*12;                      //CMD2 is operation time(min), maximum duration = 1440 
03662:  MOVLB  3
03664:  CLRF   x38
03666:  MOVFF  32D,337
0366A:  MOVFF  338,343
0366E:  MOVFF  32D,342
03672:  CLRF   x45
03674:  MOVLW  0C
03676:  MOVWF  x44
03678:  MOVLB  0
0367A:  CALL   253A
0367E:  MOVFF  02,336
03682:  MOVFF  01,335
....................          if(duration > 1440){duration = 1440;} 
03686:  MOVLB  3
03688:  MOVF   x36,W
0368A:  SUBLW  04
0368C:  BC    36A0
0368E:  XORLW  FF
03690:  BNZ   3698
03692:  MOVF   x35,W
03694:  SUBLW  A0
03696:  BC    36A0
03698:  MOVLW  05
0369A:  MOVWF  x36
0369C:  MOVLW  A0
0369E:  MOVWF  x35
....................          HIGHSAMP_SENSOR_COLLECTION(duration); 
036A0:  MOVFF  336,338
036A4:  MOVFF  335,337
036A8:  MOVLB  0
036AA:  CALL   1BAB6
....................          //Turn_OFF_ADCS(); 
....................          STORE_ADRESS_DATA_TO_FLASH(); 
036AE:  CALL   142D0
....................          break; 
036B2:  BRA    3834
....................       case 0x59: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
036B4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;                                                 //send ACK to COM 
036B8:  MOVLB  1
036BA:  CLRF   xF1
....................        
....................          GIVE_ACCESS_SCF_Nsec(CMD2); 
036BC:  MOVFF  32D,337
036C0:  MOVLB  0
036C2:  CALL   1B4E4
....................          break;  
036C6:  BRA    3834
....................       case 0xee: 
....................          UPLINK_SUCCESS_CHECK(); 
036C8:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00;    
....................          ERASE_EEPROM_INFO();                                                    //erase 512byte(from 0x18000 to 0x181ff) 
036CC:  CALL   13C2A
....................          MEMORY_ERASE();                                                         //erase OF, SCF, SMF flash memories 
036D0:  CALL   15AEC
....................          break;  
036D4:  BRA    3834
....................       case 0x88: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
036D6:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          CURRENT_FLAG_STATUS();                                                  //Print on PC port current flag status 
036DA:  CALL   124D0
....................          break;    
036DE:  BRA    3834
....................       case 0x9f: 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
036E0:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          Disp_RSV();                                                             //show the reserve status (reserve command and reserve table) 
036E4:  CALL   171FC
....................          break;  
036E8:  BRA    3834
....................       case 0xcf:                                                                 //only for execution from PC 
....................        
....................          UPLINK_SUCCESS_CHECK(); 
036EA:  CALL   1E188
....................          //ACK_for_COM[14] = 0x00; 
....................        
....................          table_refresh();                                                        //table and flags are come back to default 
036EE:  CALL   18356
....................          break; 
036F2:  BRA    3834
....................       case 0x6a: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
036F4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
036F8:  MOVLB  1
036FA:  CLRF   xF1
....................        
....................          RESET_FLAG_DATA();                                                      //clear all flags and save 
036FC:  MOVLB  0
036FE:  CALL   162AA
....................          break; 
03702:  BRA    3834
....................       case 0xe0: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03704:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03708:  MOVLB  1
0370A:  CLRF   xF1
....................        
....................          REFRESH_SECTOR_OF(CMD2,CMD3,CMD4,CMD5);                                 //Erase 1 sector of OBC flash, also this function contains saving log 
0370C:  MOVFF  32D,347
03710:  MOVFF  32E,348
03714:  MOVFF  32F,349
03718:  MOVFF  330,34A
0371C:  MOVLB  0
0371E:  CALL   17094
....................          break; 
03722:  BRA    3834
....................       case 0xe1: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03724:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03728:  MOVLB  1
0372A:  CLRF   xF1
....................        
....................          REFRESH_SECTOR_SCF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of COM flash, also this function contains saving log 
0372C:  MOVFF  32D,347
03730:  MOVFF  32E,348
03734:  MOVFF  32F,349
03738:  MOVFF  330,34A
0373C:  MOVLB  0
0373E:  CALL   17144
....................          break; 
03742:  BRA    3834
....................       case 0xe2: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03744:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03748:  MOVLB  1
0374A:  CLRF   xF1
....................        
....................          REFRESH_SECTOR_SMF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of MISION flash, also this function contains saving log 
0374C:  MOVFF  32D,347
03750:  MOVFF  32E,348
03754:  MOVFF  32F,349
03758:  MOVFF  330,34A
0375C:  MOVLB  0
0375E:  CALL   16FE0
....................          break; 
03762:  BRA    3834
....................       case 0x12: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03764:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03768:  MOVLB  1
0376A:  CLRF   xF1
....................        
....................          TRANSFER_SECTOR_OF2SCF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
0376C:  MOVFF  32D,337
03770:  MOVFF  32E,338
03774:  MOVFF  32F,339
03778:  MOVFF  330,33A
0377C:  MOVLB  0
0377E:  CALL   1742A
....................          break; 
03782:  BRA    3834
....................       case 0x32: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03784:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03788:  MOVLB  1
0378A:  CLRF   xF1
....................        
....................          TRANSFER_SECTOR_SMF2SCF(CMD2,CMD3,CMD4,CMD5);                           //transfer 1 sector, also this function contains saving log 
0378C:  MOVFF  32D,337
03790:  MOVFF  32E,338
03794:  MOVFF  32F,339
03798:  MOVFF  330,33A
0379C:  MOVLB  0
0379E:  CALL   17B8A
....................          break; 
037A2:  BRA    3834
....................       case 0x21: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
037A4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
037A8:  MOVLB  1
037AA:  CLRF   xF1
....................        
....................          TRANSFER_SECTOR_SCF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
037AC:  MOVFF  32D,337
037B0:  MOVFF  32E,338
037B4:  MOVFF  32F,339
037B8:  MOVFF  330,33A
037BC:  MOVLB  0
037BE:  CALL   17718
....................          break; 
037C2:  BRA    3834
....................       case 0x01: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
037C4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
037C8:  MOVLB  1
037CA:  CLRF   xF1
....................        
....................          Send_Command_to_FAB(0x01);                                              //send cmd to FAB to turn ON battery heater 
037CC:  MOVLW  01
037CE:  MOVLB  3
037D0:  MOVWF  x4F
037D2:  MOVLB  0
037D4:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater ON\r\n"); 
037D8:  MOVLW  CC
037DA:  MOVWF  FF6
037DC:  MOVLW  15
037DE:  MOVWF  FF7
037E0:  MOVLW  00
037E2:  MOVWF  FF8
037E4:  CALL   06A4
....................          break; 
037E8:  BRA    3834
....................       case 0x02: 
....................        
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
037EA:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
037EE:  MOVLB  1
037F0:  CLRF   xF1
....................        
....................          Send_Command_to_FAB(0x02);                                              //send cmd to FAB to turn OFF battery heater 
037F2:  MOVLW  02
037F4:  MOVLB  3
037F6:  MOVWF  x4F
037F8:  MOVLB  0
037FA:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater OFF\r\n"); 
037FE:  MOVLW  E2
03800:  MOVWF  FF6
03802:  MOVLW  15
03804:  MOVWF  FF7
03806:  MOVLW  00
03808:  MOVWF  FF8
0380A:  CALL   06A4
....................          break; 
0380E:  BRA    3834
....................       case 0x03: 
....................  
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
03810:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
03814:  MOVLB  1
03816:  CLRF   xF1
....................        
....................          Send_Command_to_FAB(0x03);                                              //send cmd to FAB to operate Heater in AUTO mode 
03818:  MOVLW  03
0381A:  MOVLB  3
0381C:  MOVWF  x4F
0381E:  MOVLB  0
03820:  CALL   1A90
....................          fprintf(PC,"Sent CMD Heater AUTO\r\n"); 
03824:  MOVLW  F8
03826:  MOVWF  FF6
03828:  MOVLW  15
0382A:  MOVWF  FF7
0382C:  MOVLW  00
0382E:  MOVWF  FF8
03830:  CALL   06A4
....................          break;          
....................       /*case 0x35: 
....................          fprintf(PC,"Sent CMD to COM for data download\r\n"); 
....................          RSV_DATA_DOWNLOAD(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                  //send array of commnands to COM 
....................           
....................          break;*/ 
....................    } 
....................    return; 
03834:  GOTO   3DB4 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #int_timer0                                                                      //Interrupcion del TMR0 
....................  
.................... void intval() 
.................... {    
....................    //*PURPOSE This program is to test in-orbit update feasibility 
....................    //*AUTHOR Maisun Ibn Monowar 
....................    /**:CHANGES 
....................             Rewrote command analyzer 
....................             Allocated memory segement to each segment. 
.................... */ 
....................    static int32 counter = 0;                                                     //la variable se activa como global, mantiene su valor al entrar y salir de la funcion 
....................    counter++;                                                                    //se incrementa cada 16.384ms 
*
01610:  MOVLW  01
01612:  MOVLB  3
01614:  ADDWF  x25,F
01616:  BTFSC  FD8.0
01618:  INCF   x26,F
0161A:  BTFSC  FD8.2
0161C:  INCF   x27,F
0161E:  BTFSC  FD8.2
01620:  INCF   x28,F
....................    if (counter > 60)                                                             //los contadores dentro del if se incrementan aprox cada 1s 
01622:  MOVF   x28,F
01624:  BNZ   1634
01626:  MOVF   x27,F
01628:  BNZ   1634
0162A:  MOVF   x26,F
0162C:  BNZ   1634
0162E:  MOVF   x25,W
01630:  SUBLW  3C
01632:  BC    1668
....................    { 
....................       counter = 0; 
01634:  CLRF   x28
01636:  CLRF   x27
01638:  CLRF   x26
0163A:  CLRF   x25
....................  
....................       FAB_FLAG++;                                                                //contador de tiempo en segundos, a los 90 segundos pide datos al FAB 
0163C:  MOVLW  01
0163E:  MOVLB  2
01640:  ADDWF  xFC,F
01642:  BTFSC  FD8.0
01644:  INCF   xFD,F
01646:  BTFSC  FD8.2
01648:  INCF   xFE,F
0164A:  BTFSC  FD8.2
0164C:  INCF   xFF,F
....................       RESERVE_SEC_FLAG++;                                                        //contador de tiempo en segundos (used in Table) 
0164E:  MOVLB  0
01650:  INCF   x7D,F
....................       currenttime++;                                                             //contador de tiempo en segundos (Reset Function) 
01652:  MOVLB  2
01654:  INCF   x49,F
01656:  BTFSC  FD8.2
01658:  INCF   x4A,F
....................  
....................       if(RESERVE_SEC_FLAG > 59)                                                  //los contadores dentro del if se incrementan cada 60s 
0165A:  MOVLB  0
0165C:  MOVF   x7D,W
0165E:  SUBLW  3B
01660:  BC    1666
....................       { 
....................          RESERVE_SEC_FLAG = 0; 
01662:  CLRF   x7D
....................          RESERVE_MIN_FLAG++;                                                     //contador de tiempo en minutos (used in Table) 
01664:  INCF   x6C,F
01666:  MOVLB  3
....................       } 
....................    } 
.................... } 
....................  
01668:  BCF    FF2.2
0166A:  MOVLB  0
0166C:  GOTO   009E
.................... #INT_rda                                                                         //PC Interrupt, RS232 receive data available in buffer 1 
.................... void UART1_RXD(void) 
.................... { 
....................    CMD_FROM_PC[PC_DATA] = fgetc(PC);                                             //carga el array CMD_FROM_PC[] con los datos enviados por PC 
01670:  CLRF   03
01672:  MOVF   x99,W
01674:  ADDLW  7E
01676:  MOVWF  FE9
01678:  MOVLW  00
0167A:  ADDWFC 03,W
0167C:  MOVWF  FEA
0167E:  BTFSS  F9E.5
01680:  BRA    167E
01682:  MOVFF  FAE,FEF
....................    PC_DATA = ((PC_DATA + 1) % 8);                                                //cuando se obtenga el dato en la posicion 6, PC_DATA=0    
01686:  MOVLW  01
01688:  ADDWF  x99,W
0168A:  ANDLW  07
0168C:  MOVWF  x99
.................... } 
....................  
....................  
0168E:  BCF    F9E.5
01690:  GOTO   009E
.................... #INT_rda2 HIGH                                                                   //COM Interrupt, RS232 receive data available in buffer 2 
.................... void UART2_RXD(void) 
.................... {    
....................    in_bffr_main[COM_DATA] = fgetc(COM);                                          //carga el array in_bffr_main[] con los datos enviados por COM PIC 
01694:  CLRF   03
01696:  MOVF   x96,W
01698:  ADDLW  86
0169A:  MOVWF  FE9
0169C:  MOVLW  00
0169E:  ADDWFC 03,W
016A0:  MOVWF  FEA
016A2:  BTFSS  FA4.5
016A4:  BRA    16A2
016A6:  MOVLB  F
016A8:  MOVFF  F1E,FEF
....................    COM_DATA = ((COM_DATA + 1) % 16);                                             //cuando se obtenga el dato en la posicion 16, COM_DATA=0 
016AC:  MOVLW  01
016AE:  MOVLB  0
016B0:  ADDWF  x96,W
016B2:  ANDLW  0F
016B4:  MOVWF  x96
.................... }  
....................  
....................  
016B6:  BCF    FA4.5
016B8:  GOTO   014A
.................... #INT_rda3                                                                        //FAB Interrupt, RS232 receive data available in buffer 3 
.................... void UART3_RXD(void) 
.................... { 
....................    //collect_HK_from_FAB(); 
....................    in_HK[FAB_DATA] = fgetc(FAB);                                                 //carga el array in_HK[] con los datos enviados por el FAB PIC 
*
016E8:  CLRF   03
016EA:  MOVLB  2
016EC:  MOVF   xF9,W
016EE:  ADDLW  50
016F0:  MOVWF  FE9
016F2:  MOVLW  02
016F4:  ADDWFC 03,W
016F6:  MOVWF  FEA
016F8:  BTFSS  FA6.5
016FA:  BRA    16F8
016FC:  MOVLB  F
016FE:  MOVFF  F2A,FEF
....................    FAB_DATA = ((FAB_DATA + 1) % FAB_SENSOR_size);                                //cuando se obtenga el dato en la posicion 45 FAB_DATA=0 
01702:  MOVLW  01
01704:  MOVLB  2
01706:  ADDWF  xF9,W
01708:  MOVLB  3
0170A:  MOVWF  x77
0170C:  MOVWF  x78
0170E:  MOVLW  2D
01710:  MOVWF  x79
01712:  MOVLB  0
01714:  RCALL  16BC
01716:  MOVFF  00,2F9
.................... }  
....................  
....................  
0171A:  BCF    FA6.5
0171C:  GOTO   009E
.................... #INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4 
.................... void UART4_RXD(void) 
.................... { 
....................    reset_bffr[RESET_DATA] = fgetc(reset);                                        //carga el array reset_bffr con los datos enviados por el Reset PIC 
01720:  CLRF   03
01722:  MOVF   x9D,W
01724:  ADDLW  9E
01726:  MOVWF  FE9
01728:  MOVLW  00
0172A:  ADDWFC 03,W
0172C:  MOVWF  FEA
0172E:  BTFSS  FA6.7
01730:  BRA    172E
01732:  MOVLB  E
01734:  MOVFF  EFA,FEF
....................    RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //cuando se obtenga el dato en la posicion 11 RESET_DATA=0 
01738:  MOVLW  01
0173A:  MOVLB  0
0173C:  ADDWF  x9D,W
0173E:  MOVLB  3
01740:  MOVWF  x77
01742:  MOVWF  x78
01744:  MOVLW  0B
01746:  MOVWF  x79
01748:  MOVLB  0
0174A:  RCALL  16BC
0174C:  MOVFF  00,9D
....................    //fputc(fgetc(reset),PC); 
....................    if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite 
01750:  MOVF   x9E,W
01752:  SUBLW  AA
01754:  BNZ   175C
....................    { 
....................       reset_flag = 1;                                                            //pone a alto bandera para reseteo 
01756:  MOVLW  01
01758:  MOVWF  xA9
....................       RESET_DATA = 0;                                                            //indicador de posicion dentro del vector reset_data 
0175A:  CLRF   x9D
....................    } 
....................     
0175C:  BCF    FA6.7
0175E:  GOTO   009E
.................... }  
....................  
.................... void settings() 
.................... { 
....................    set_tris_b(0b11010000);                                                       // Configuracion del puerto b 
*
017DE:  MOVLW  D0
017E0:  MOVWF  F93
....................    enable_interrupts(global);                                                    // Habilitacion de interrupciones globales       
017E2:  MOVLW  C0
017E4:  IORWF  FF2,F
....................    enable_interrupts(INT_rda);                                                   // Main to PC 
017E6:  BSF    F9D.5
....................    enable_interrupts(INT_rda2);                                                  // Main to COM PIC 
017E8:  BSF    FA3.5
....................    enable_interrupts(INT_rda3);                                                  // Main to FAB PIC    
017EA:  BSF    F61.5
....................    enable_interrupts(INT_rda4);                                                  // Main to RESET PIC 
017EC:  BSF    F61.7
....................  
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_BIT);                     //Config TMR0, internal clock, prescaler 256, clock/counter 8bit 
017EE:  MOVLW  D7
017F0:  MOVWF  FD5
....................    set_timer0(0);                                                                //this sets timer0 register to 0 
017F2:  CLRF   FD7
017F4:  CLRF   FD6
....................     
....................    READ_WRTITING_ADDRESS_LOCATION();                                             //save in ADD_INFO_ADDRESS with address info location 
017F6:  CALL   14992
....................    RESERVE_CHECK = 0;                                                            //bandera que indica si una tabla esta utilizada 
017FA:  CLRF   x6B
....................    RESET_DATA = 0;                                                               //indicador de posicion dentro del vector reset_data 
017FC:  CLRF   x9D
....................   
....................    CHECK_FLAG_INFO();                                                            //imprime el estado de los flags y los separa en cada variable correspondiente 
017FE:  CALL   16D10
....................    CHECK_ADDRESS_DATA();                                                         //imprime los datos de direcciones y los separa en cada variable correspondiente 
01802:  CALL   15542
....................     
....................    BC_SETUP();                                                                   //configuracion del conversor analogico digital para lectura de sensor de temperatura 
01806:  CALL   190A0
....................    
....................    output_low(PIN_A4);                                                           //kill switch off 
0180A:  BCF    F92.4
0180C:  BCF    F89.4
....................    Turn_OFF_CAM();                                                               //Camera switch OFF, RD7=0 
0180E:  CALL   190BC
....................    //Turn_OFF_ADCS();                                                              //ADCS switch OFF, RD6=0   
....................    Turn_ON_ADCS();                                                               //ADCS switch ON, RD6=1 
01812:  CALL   1223A
....................    Turn_ON_MBP();                                                                //Mission Boss switch ON, RF5=1 
01816:  CALL   124CA
....................    Turn_OFF_BC();                                                                //Burner Circuit switch OFF, RD5=0 
0181A:  CALL   190C2
....................  
....................    fprintf(PC,"\r\n"); 
0181E:  MOVLW  0D
01820:  BTFSS  F9E.4
01822:  BRA    1820
01824:  MOVWF  FAD
01826:  MOVLW  0A
01828:  BTFSS  F9E.4
0182A:  BRA    1828
0182C:  MOVWF  FAD
....................    CURRENT_FLAG_STATUS();                                                        //Imprime en pantalla el estado de todos los flags 
0182E:  CALL   124D0
....................    fprintf(PC,"\r\n"); 
01832:  MOVLW  0D
01834:  BTFSS  F9E.4
01836:  BRA    1834
01838:  MOVWF  FAD
0183A:  MOVLW  0A
0183C:  BTFSS  F9E.4
0183E:  BRA    183C
01840:  MOVWF  FAD
....................    CURRENT_ADDRESS_OF_FLASH();                                                   //Print current address allocation 
01842:  CALL   12742
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion de escritura cuando se superan los 95.000 ciclos 
01846:  CALL   14000
....................  
....................    output_high(PIN_C4);                                                          //MUX: COM side (MAIN-COM) 
0184A:  BCF    F94.4
0184C:  BSF    F8B.4
....................    output_low(PIN_A5);                                                           //MUX: Main side (MAIN-MISSION) 
0184E:  BCF    F92.5
01850:  BCF    F89.5
....................    
....................    Get_RSV();                                                                    //read the reservation table info from flash memory   
01852:  CALL   16DE6
....................    SAVE_SAT_LOG(0x25,0x25,0x25);                                                 //carga el RESET_bffr[] con los datos del reset PIC, verifica nro de escrituras flash  
01856:  MOVLW  25
01858:  MOVLB  3
0185A:  MOVWF  x53
0185C:  MOVWF  x54
0185E:  MOVWF  x55
01860:  MOVLB  0
01862:  CALL   16EA4
....................    return;                                                                       //y guarda en las flash los datos en la direccion indicada por SAT_LOG   
01866:  GOTO   3AD8 (RETURN)
.................... }                                   
....................  
.................... void main() 
*
03838:  CLRF   FF8
0383A:  BCF    FF1.2
0383C:  BCF    F9F.5
0383E:  BSF    FA5.5
03840:  BCF    FA9.5
03842:  BCF    FA9.7
03844:  BSF    FD0.7
03846:  BSF    07.7
03848:  MOVLB  E
0384A:  MOVLW  55
0384C:  MOVWF  F7E
0384E:  MOVLW  AA
03850:  MOVWF  F7E
03852:  BCF    F66.6
03854:  MOVLW  F4
03856:  MOVWF  x2A
03858:  MOVLW  F5
0385A:  MOVWF  x2B
0385C:  MOVLW  F8
0385E:  MOVWF  x2C
03860:  MOVLW  F9
03862:  MOVWF  x2D
03864:  MOVLW  01
03866:  MOVWF  x1B
03868:  MOVLW  20
0386A:  MOVWF  x1D
0386C:  MOVLW  30
0386E:  MOVWF  x22
03870:  MOVLW  20
03872:  MOVWF  x24
03874:  MOVLW  55
03876:  MOVWF  F7E
03878:  MOVLW  AA
0387A:  MOVWF  F7E
0387C:  BSF    F66.6
0387E:  CLRF   F9B
03880:  CLRF   F64
03882:  CLRF   F65
03884:  CLRF   F66
03886:  MOVLW  02
03888:  MOVWF  FD3
0388A:  BSF    F67.3
0388C:  MOVLW  22
0388E:  MOVWF  FAF
03890:  MOVLW  00
03892:  MOVLB  F
03894:  MOVWF  x30
03896:  MOVLW  A6
03898:  MOVWF  FAC
0389A:  MOVLW  90
0389C:  MOVWF  FAB
0389E:  BSF    x31.3
038A0:  MOVLW  A0
038A2:  MOVWF  x1F
038A4:  MOVLW  01
038A6:  MOVWF  x20
038A8:  MOVLW  A6
038AA:  MOVWF  x32
038AC:  MOVLW  90
038AE:  MOVWF  x33
038B0:  BSF    x2D.3
038B2:  MOVLW  A0
038B4:  MOVWF  x2B
038B6:  MOVLW  01
038B8:  MOVWF  x2C
038BA:  MOVLW  A6
038BC:  MOVWF  x2E
038BE:  MOVLW  90
038C0:  MOVWF  x2F
038C2:  MOVLB  E
038C4:  BSF    xFD.3
038C6:  MOVLW  A0
038C8:  MOVWF  xFB
038CA:  MOVLW  01
038CC:  MOVWF  xFC
038CE:  MOVLW  A6
038D0:  MOVWF  xFE
038D2:  MOVLW  90
038D4:  MOVWF  xFF
038D6:  BCF    F97.7
038D8:  BSF    F8E.7
038DA:  BCF    F98.2
038DC:  BSF    F8F.2
038DE:  BCF    F98.0
038E0:  BSF    F8F.0
038E2:  BSF    F96.0
038E4:  BCF    F96.6
038E6:  BCF    F96.1
038E8:  BCF    F8D.1
038EA:  BSF    F93.5
038EC:  BCF    F93.4
038EE:  BCF    F93.2
038F0:  BCF    F8A.2
038F2:  BSF    F92.0
038F4:  BCF    F92.1
038F6:  BCF    F92.3
038F8:  BCF    F89.3
038FA:  CLRF   33
038FC:  CLRF   32
038FE:  MOVLW  10
03900:  MOVWF  31
03902:  CLRF   30
03904:  CLRF   37
03906:  CLRF   36
03908:  CLRF   35
0390A:  CLRF   34
0390C:  CLRF   3B
0390E:  MOVLW  04
03910:  MOVWF  3A
03912:  CLRF   39
03914:  CLRF   38
03916:  CLRF   3F
03918:  MOVLW  05
0391A:  MOVWF  3E
0391C:  CLRF   3D
0391E:  CLRF   3C
03920:  CLRF   43
03922:  MOVLW  06
03924:  MOVWF  42
03926:  CLRF   41
03928:  CLRF   40
0392A:  CLRF   47
0392C:  MOVLW  08
0392E:  MOVWF  46
03930:  CLRF   45
03932:  CLRF   44
03934:  CLRF   4B
03936:  MOVLW  62
03938:  MOVWF  4A
0393A:  CLRF   49
0393C:  CLRF   48
0393E:  MOVLW  04
03940:  MOVWF  4F
03942:  MOVLW  4A
03944:  MOVWF  4E
03946:  CLRF   4D
03948:  CLRF   4C
0394A:  MOVLW  04
0394C:  MOVWF  53
0394E:  MOVLW  72
03950:  MOVWF  52
03952:  CLRF   51
03954:  CLRF   50
03956:  MOVLW  06
03958:  MOVWF  57
0395A:  MOVLW  65
0395C:  MOVWF  56
0395E:  CLRF   55
03960:  CLRF   54
03962:  MOVLW  06
03964:  MOVWF  5B
03966:  MOVLW  66
03968:  MOVWF  5A
0396A:  CLRF   59
0396C:  CLRF   58
0396E:  MOVLW  06
03970:  MOVWF  5F
03972:  MOVLW  67
03974:  MOVWF  5E
03976:  CLRF   5D
03978:  CLRF   5C
0397A:  MOVLB  0
0397C:  CLRF   x63
0397E:  MOVLW  01
03980:  MOVWF  x62
03982:  MOVLW  80
03984:  MOVWF  x61
03986:  CLRF   x60
03988:  CLRF   x67
0398A:  MOVLW  01
0398C:  MOVWF  x66
0398E:  MOVLW  80
03990:  MOVWF  x65
03992:  MOVLW  1C
03994:  MOVWF  x64
03996:  CLRF   x68
03998:  CLRF   x6A
0399A:  CLRF   x69
0399C:  CLRF   x6B
0399E:  CLRF   x6C
039A0:  CLRF   x6D
039A2:  CLRF   x6E
039A4:  CLRF   x6F
039A6:  CLRF   x70
039A8:  CLRF   x71
039AA:  CLRF   x72
039AC:  CLRF   x73
039AE:  CLRF   x74
039B0:  CLRF   x75
039B2:  CLRF   x76
039B4:  CLRF   x77
039B6:  CLRF   x78
039B8:  CLRF   x79
039BA:  CLRF   x7A
039BC:  CLRF   x7B
039BE:  CLRF   x7C
039C0:  CLRF   x7D
039C2:  CLRF   x96
039C4:  CLRF   x97
039C6:  CLRF   x98
039C8:  CLRF   x99
039CA:  CLRF   x9A
039CC:  CLRF   x9B
039CE:  CLRF   x9C
039D0:  CLRF   x9D
039D2:  CLRF   xA9
039D4:  CLRF   xE4
039D6:  CLRF   xE3
039D8:  MOVLB  1
039DA:  CLRF   x36
039DC:  CLRF   x95
039DE:  MOVLB  2
039E0:  CLRF   x4A
039E2:  CLRF   x49
039E4:  CLRF   xF9
039E6:  CLRF   xFA
039E8:  CLRF   xFB
039EA:  CLRF   xFF
039EC:  CLRF   xFE
039EE:  CLRF   xFD
039F0:  CLRF   xFC
039F2:  MOVLB  3
039F4:  CLRF   x00
039F6:  CLRF   x04
039F8:  CLRF   x03
039FA:  CLRF   x02
039FC:  CLRF   x01
039FE:  CLRF   x06
03A00:  CLRF   x05
03A02:  CLRF   x08
03A04:  CLRF   x07
03A06:  CLRF   x0A
03A08:  CLRF   x09
03A0A:  CLRF   x0E
03A0C:  CLRF   x0D
03A0E:  CLRF   x0C
03A10:  CLRF   x0B
03A12:  CLRF   x12
03A14:  CLRF   x11
03A16:  CLRF   x10
03A18:  CLRF   x0F
03A1A:  CLRF   x16
03A1C:  CLRF   x15
03A1E:  CLRF   x14
03A20:  CLRF   x13
03A22:  CLRF   x18
03A24:  CLRF   x17
03A26:  CLRF   x19
03A28:  CLRF   x1A
03A2A:  CLRF   x1C
03A2C:  CLRF   x1B
03A2E:  CLRF   x1E
03A30:  CLRF   x1D
03A32:  CLRF   x1F
03A34:  CLRF   x20
03A36:  CLRF   x24
03A38:  CLRF   x23
03A3A:  CLRF   x22
03A3C:  CLRF   x21
03A3E:  CLRF   x28
03A40:  CLRF   x27
03A42:  CLRF   x26
03A44:  CLRF   x25
03A46:  MOVLB  E
03A48:  CLRF   xD9
03A4A:  CLRF   xDA
03A4C:  CLRF   x45
03A4E:  CLRF   x46
03A50:  CLRF   x47
03A52:  BCF    x8D.7
03A54:  BCF    x8D.6
03A56:  BCF    x8D.5
03A58:  MOVLB  1
03A5A:  CLRF   x88
03A5C:  MOVLB  F
03A5E:  CLRF   x53
03A60:  CLRF   x38
03A62:  CLRF   x37
03A64:  BRA    3A94
03A66:  DATA 18,40
03A68:  DATA 7E,00
03A6A:  DATA 0B,40
03A6C:  DATA 9E,00
03A6E:  DATA 39,40
03A70:  DATA AA,00
03A72:  DATA 51,40
03A74:  DATA E5,00
03A76:  DATA 5E,41
03A78:  DATA 37,00
03A7A:  DATA 01,01
03A7C:  DATA 96,AA
03A7E:  DATA 4B,C0
03A80:  DATA 00,02
03A82:  DATA 80,BB
03A84:  DATA AA,16
03A86:  DATA C0,00
03A88:  DATA 01,80
03A8A:  DATA BB,4E
03A8C:  DATA C0,00
03A8E:  DATA AE,42
03A90:  DATA 4B,00
03A92:  DATA 00,00
03A94:  MOVLW  00
03A96:  MOVWF  FF8
03A98:  MOVLW  3A
03A9A:  MOVWF  FF7
03A9C:  MOVLW  66
03A9E:  MOVWF  FF6
03AA0:  TBLRD*+
03AA2:  MOVF   FF5,W
03AA4:  MOVWF  00
03AA6:  XORLW  00
03AA8:  BZ    3AD0
03AAA:  TBLRD*+
03AAC:  MOVF   FF5,W
03AAE:  MOVWF  01
03AB0:  BTFSC  FE8.7
03AB2:  BRA    3ABE
03AB4:  ANDLW  0F
03AB6:  MOVWF  FEA
03AB8:  TBLRD*+
03ABA:  MOVFF  FF5,FE9
03ABE:  BTFSC  01.6
03AC0:  TBLRD*+
03AC2:  BTFSS  01.6
03AC4:  TBLRD*+
03AC6:  MOVFF  FF5,FEE
03ACA:  DCFSNZ 00,F
03ACC:  BRA    3AA0
03ACE:  BRA    3AC2
03AD0:  CLRF   FF8
.................... { 
....................    settings(); 
03AD2:  MOVLB  0
03AD4:  GOTO   17DE
....................    enable_interrupts(INT_TIMER0); 
03AD8:  BSF    FF2.5
....................    fprintf(PC,"Start Operating\r\n");    
03ADA:  MOVLW  62
03ADC:  MOVWF  FF6
03ADE:  MOVLW  17
03AE0:  MOVWF  FF7
03AE2:  MOVLW  00
03AE4:  MOVWF  FF8
03AE6:  CALL   06A4
....................    FAB_TEST_OPERATION();                                                         //carga el array FABDATA[], crea el CW format y los guarda en la Flash    
03AEA:  CALL   19CDA
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //guarda los datos de direcciones en flash, y en un nuevo sector si se cumple el ciclo 95000 
03AEE:  CALL   142D0
....................    CURRENT_ADDRESS_OF_FLASH();                                                   //imprime la asignacion de direcciones de la Flash memory 
03AF2:  CALL   12742
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory (in OF, SCF and SMF) 
03AF6:  CALL   146F6
....................    WRITE_FLAG_to_EEPROM();                                                       //guarda los flags en la EEPROM a partir de la direccion 0x18000 (75%)   
03AFA:  CALL   12FE4
....................    fprintf(PC,"\r\nCW:"); 
03AFE:  MOVLW  74
03B00:  MOVWF  FF6
03B02:  MOVLW  17
03B04:  MOVWF  FF7
03B06:  MOVLW  00
03B08:  MOVWF  FF8
03B0A:  CALL   06A4
....................    for(int i = 0; i < 4; i++)                                                    //imprime el contenido del array CW_FORMAT[] 
03B0E:  MOVLB  3
03B10:  CLRF   x29
03B12:  MOVF   x29,W
03B14:  SUBLW  03
03B16:  BNC   3B42
....................    { 
....................       fprintf(PC,"%x,",CW_FORMAT[i]); 
03B18:  CLRF   03
03B1A:  MOVF   x29,W
03B1C:  ADDLW  4B
03B1E:  MOVWF  FE9
03B20:  MOVLW  02
03B22:  ADDWFC 03,W
03B24:  MOVWF  FEA
03B26:  MOVFF  FEF,3A2
03B2A:  MOVLW  57
03B2C:  MOVWF  xA3
03B2E:  MOVLB  0
03B30:  CALL   0700
03B34:  MOVLW  2C
03B36:  BTFSS  F9E.4
03B38:  BRA    3B36
03B3A:  MOVWF  FAD
03B3C:  MOVLB  3
03B3E:  INCF   x29,F
03B40:  BRA    3B12
....................    } 
....................    fprintf(PC,"%x\r\n",CW_FORMAT[4]); 
03B42:  MOVFF  24F,3A2
03B46:  MOVLW  57
03B48:  MOVWF  xA3
03B4A:  MOVLB  0
03B4C:  CALL   0700
03B50:  MOVLW  0D
03B52:  BTFSS  F9E.4
03B54:  BRA    3B52
03B56:  MOVWF  FAD
03B58:  MOVLW  0A
03B5A:  BTFSS  F9E.4
03B5C:  BRA    3B5A
03B5E:  MOVWF  FAD
....................    Antenna_Deploy();                                                             //after each restart check BC_ATTEMPT_FLAG to deploy antenna 
03B60:  CALL   1A37A
....................    //CAM deployment 
....................    if(PASSED_DAYS == 0 && UPLINK_SUCCESS == 0)                                  //automated CAM DEPLOYMENT mission condition 
03B64:  MOVF   x69,F
03B66:  BNZ   3B7C
03B68:  MOVF   x6A,F
03B6A:  BNZ   3B7C
03B6C:  MOVF   x7C,F
03B6E:  BNZ   3B7C
....................    {   
....................       CAM_DEPLOYMENT_OPERATION(0xAD);                                           //CMD for CAM deployment mode 
03B70:  MOVLW  AD
03B72:  MOVLB  3
03B74:  MOVWF  x2C
03B76:  MOVLB  0
03B78:  CALL   1A5A2
....................    } 
....................    //try 5 times for reliability 
....................    AUTOMATICAL_MISSION_CHECK(); 
03B7C:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
03B80:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
03B84:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
03B88:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
03B8C:  CALL   1D774
....................    RESET_DATA = 0;                                                               //bandera a cero 
03B90:  CLRF   x9D
....................    while(true) 
....................    { 
....................       BC_ON_30min();                                                             //if satellite shut down during automatical MSN, this function will be used after start again       
03B92:  CALL   1B9DC
....................       RESET_SATELLITE();                                                         //check reset command from RESET PIC       
03B96:  CALL   16CB0
....................       if(FAB_FLAG > 89)                                                          //every 90 sec, OBC gather sensor data and update CW format  
03B9A:  MOVLB  2
03B9C:  MOVF   xFF,F
03B9E:  BNZ   3BAE
03BA0:  MOVF   xFE,F
03BA2:  BNZ   3BAE
03BA4:  MOVF   xFD,F
03BA6:  BNZ   3BAE
03BA8:  MOVF   xFC,W
03BAA:  SUBLW  59
03BAC:  BC    3C40
....................       { 
....................          FAB_FLAG = 0; 
03BAE:  CLRF   xFF
03BB0:  CLRF   xFE
03BB2:  CLRF   xFD
03BB4:  CLRF   xFC
....................          fprintf(PC,"\r\n***90sec passed***\r\n"); 
03BB6:  MOVLW  7A
03BB8:  MOVWF  FF6
03BBA:  MOVLW  17
03BBC:  MOVWF  FF7
03BBE:  MOVLW  00
03BC0:  MOVWF  FF8
03BC2:  MOVLB  0
03BC4:  CALL   06A4
....................          FAB_TEST_OPERATION();                                                   //carga el array FABDATA[], crea el CW format y los guarda en la Flash 
03BC8:  CALL   19CDA
....................          COM_DATA = 0; 
03BCC:  CLRF   x96
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //for store the address info 
03BCE:  CALL   142D0
....................          fprintf(PC,"CW:"); 
03BD2:  MOVLW  92
03BD4:  MOVWF  FF6
03BD6:  MOVLW  17
03BD8:  MOVWF  FF7
03BDA:  MOVLW  00
03BDC:  MOVWF  FF8
03BDE:  CALL   06A4
....................          for(int i = 0; i < 4; i++)                                              //show CW format 
03BE2:  MOVLB  3
03BE4:  CLRF   x2A
03BE6:  MOVF   x2A,W
03BE8:  SUBLW  03
03BEA:  BNC   3C16
....................          { 
....................             fprintf(PC,"%x,",CW_FORMAT[i]); 
03BEC:  CLRF   03
03BEE:  MOVF   x2A,W
03BF0:  ADDLW  4B
03BF2:  MOVWF  FE9
03BF4:  MOVLW  02
03BF6:  ADDWFC 03,W
03BF8:  MOVWF  FEA
03BFA:  MOVFF  FEF,3A2
03BFE:  MOVLW  57
03C00:  MOVWF  xA3
03C02:  MOVLB  0
03C04:  CALL   0700
03C08:  MOVLW  2C
03C0A:  BTFSS  F9E.4
03C0C:  BRA    3C0A
03C0E:  MOVWF  FAD
03C10:  MOVLB  3
03C12:  INCF   x2A,F
03C14:  BRA    3BE6
....................          } 
....................          fprintf(PC,"%x\r\n",CW_FORMAT[4]); 
03C16:  MOVFF  24F,3A2
03C1A:  MOVLW  57
03C1C:  MOVWF  xA3
03C1E:  MOVLB  0
03C20:  CALL   0700
03C24:  MOVLW  0D
03C26:  BTFSS  F9E.4
03C28:  BRA    3C26
03C2A:  MOVWF  FAD
03C2C:  MOVLW  0A
03C2E:  BTFSS  F9E.4
03C30:  BRA    3C2E
03C32:  MOVWF  FAD
....................          DELETE_CMD_FROM_PC();                                                   //delete PC command 
03C34:  CALL   1B0BA
....................          PC_DATA = 0;                                                            //reset interrupt data for safety 
03C38:  CLRF   x99
....................          COM_DATA = 0;                                                           //reset interrupt data for safety 
03C3A:  CLRF   x96
....................          RESET_DATA = 0;                                                         //reset interrupt data for safety 
03C3C:  CLRF   x9D
03C3E:  MOVLB  2
....................       }          
....................       if((RESERVE_MIN_FLAG >= RESERVE_TARGET_FLAG) && RESERVE_CHECK == 1)        //check the reservation command, if time came, execute 
03C40:  MOVLB  0
03C42:  MOVF   x6D,W
03C44:  SUBWF  x6C,W
03C46:  BNC   3CA6
03C48:  DECFSZ x6B,W
03C4A:  BRA    3CA6
....................       { 
....................          fprintf(PC,"Execute reserved command\r\n"); 
03C4C:  MOVLW  96
03C4E:  MOVWF  FF6
03C50:  MOVLW  17
03C52:  MOVWF  FF7
03C54:  MOVLW  00
03C56:  MOVWF  FF8
03C58:  CALL   06A4
....................          MISSION_CONTENTS = CHECK_MEMORY_FUNCTION(MISSION_CONTENTS);             //avoid erase or transfer sectors from memory as reserved commands 
03C5C:  MOVFF  6E,32C
03C60:  CALL   1E10A
03C64:  MOVFF  01,6E
....................          EXECUTE_MISSION_from_COM(MISSION_CONTENTS,MISSION_DETAIL,RESERVE_ADDRESS_1,RESERVE_ADDRESS_2,RESERVE_ADDRESS_3,RESERVE_ADDRESS_4,RESERVE_PACKET_NUM);    //execute command 
03C68:  MOVFF  6E,32C
03C6C:  MOVFF  6F,32D
03C70:  MOVFF  70,32E
03C74:  MOVFF  71,32F
03C78:  MOVFF  72,330
03C7C:  MOVFF  73,331
03C80:  MOVFF  74,332
03C84:  CALL   26AE
....................          Remove_1_Reservation();                                                 //remove the finished command and sort again and save updated command table 
03C88:  CALL   1802A
....................          if(reserve_table[80] != 0x00)                                           //if next reservation is registered, wait until time will be come 
03C8C:  MOVLB  1
03C8E:  MOVF   x35,F
03C90:  BZ    3C9C
....................          { 
....................             Reserve_next();                                                      //take the next CMD from the table 
03C92:  MOVLB  0
03C94:  CALL   180C4
....................          }else{                                                                  //if all reservation finished, reset flag about reservation 
03C98:  BRA    3CA6
03C9A:  MOVLB  1
....................             RESERVE_TARGET_FLAG = 0;                                             //reset flag 
03C9C:  MOVLB  0
03C9E:  CLRF   x6D
....................             RESERVE_CHECK = 0; 
03CA0:  CLRF   x6B
....................             MISSION_CONTENTS = 0; 
03CA2:  CLRF   x6E
....................             MISSION_DETAIL = 0; 
03CA4:  CLRF   x6F
....................          } 
....................       }       
....................       if(buffer_from_com)                                                        //If TRU -> (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
03CA6:  MOVF   x86,W
03CA8:  SUBLW  AA
03CAA:  BNZ   3D3E
03CAC:  MOVF   x95,W
03CAE:  SUBLW  BB
03CB0:  BNZ   3D3E
....................       { 
....................          fprintf(PC,"COM COMMAND:\r\n"); 
03CB2:  MOVLW  B2
03CB4:  MOVWF  FF6
03CB6:  MOVLW  17
03CB8:  MOVWF  FF7
03CBA:  MOVLW  00
03CBC:  MOVWF  FF8
03CBE:  CALL   06A4
....................          for(COM_DATA = 0; COM_DATA < 16; COM_DATA++)                            //display command in PC 
03CC2:  CLRF   x96
03CC4:  MOVF   x96,W
03CC6:  SUBLW  0F
03CC8:  BNC   3CF4
....................          { 
....................             //fputc(in_bffr_main[COM_DATA],PC); 
....................             fprintf(PC,"%x,",in_bffr_main[COM_DATA]);                            //para visualizar en la PC 
03CCA:  CLRF   03
03CCC:  MOVF   x96,W
03CCE:  ADDLW  86
03CD0:  MOVWF  FE9
03CD2:  MOVLW  00
03CD4:  ADDWFC 03,W
03CD6:  MOVWF  FEA
03CD8:  MOVFF  FEF,3A2
03CDC:  MOVLW  57
03CDE:  MOVLB  3
03CE0:  MOVWF  xA3
03CE2:  MOVLB  0
03CE4:  CALL   0700
03CE8:  MOVLW  2C
03CEA:  BTFSS  F9E.4
03CEC:  BRA    3CEA
03CEE:  MOVWF  FAD
03CF0:  INCF   x96,F
03CF2:  BRA    3CC4
....................          } 
....................          COM_DATA = 0;                                                           //position indicator for the vector in_bffr_main[] 
03CF4:  CLRF   x96
....................          //fprintf(PC,"COM COMMAND\r\n"); 
....................          if(in_bffr_main[5] == 0)                                                //if time data is not placed 
03CF6:  MOVF   x8B,F
03CF8:  BNZ   3D1C
....................          { 
....................             EXECUTE_MISSION_from_COM(in_bffr_main[4],in_bffr_main[6],in_bffr_main[7],in_bffr_main[8],in_bffr_main[9],in_bffr_main[10],in_bffr_main[11]); 
03CFA:  MOVFF  8A,32C
03CFE:  MOVFF  8C,32D
03D02:  MOVFF  8D,32E
03D06:  MOVFF  8E,32F
03D0A:  MOVFF  8F,330
03D0E:  MOVFF  90,331
03D12:  MOVFF  91,332
03D16:  CALL   26AE
....................          }else{                                                                  //if time data is placed (that means reservation command) 
03D1A:  BRA    3D30
....................             SAVE_SAT_LOG(in_bffr_main[4],in_bffr_main[5],in_bffr_main[6]);       //reservation command log 
03D1C:  MOVFF  8A,353
03D20:  MOVFF  8B,354
03D24:  MOVFF  8C,355
03D28:  CALL   16EA4
....................             Reserve_command_COM();                                               //used when in_bffr_main[5] has a Time value 
03D2C:  CALL   18308
....................          } 
....................          DELETE_CMD_FROM_PC();                                                   //set to zero the array CMD_FROM_PC[] 
03D30:  CALL   1B0BA
....................          Delete_Buffer();                                                        //set to zero the array in_bffr_main[] 
03D34:  CALL   121E8
....................          CMD_FROM_PC[1] = 0; 
03D38:  CLRF   x7F
....................          COM_DATA = 0;                                                           //position indicator for the vector in_bffr_main[] 
03D3A:  CLRF   x96
....................          PC_DATA = 0;                                                            //position indicator for the vector CMD_FROM_PC[] 
03D3C:  CLRF   x99
....................       }       
....................       //COMMANDS EXECUTION FROM PC//              
....................       if(CMD_FROM_PC[0]) 
03D3E:  MOVF   x7E,F
03D40:  BZ    3DD8
....................       { 
....................          fprintf(PC,"COMMAND RECEIVED FROM PC: "); 
03D42:  MOVLW  C2
03D44:  MOVWF  FF6
03D46:  MOVLW  17
03D48:  MOVWF  FF7
03D4A:  MOVLW  00
03D4C:  MOVWF  FF8
03D4E:  CALL   06A4
....................          for(int m = 0; m < 8; m++) 
03D52:  MOVLB  3
03D54:  CLRF   x2B
03D56:  MOVF   x2B,W
03D58:  SUBLW  07
03D5A:  BNC   3D7E
....................          { 
....................             fprintf(PC,"%x",CMD_FROM_PC[m]); 
03D5C:  CLRF   03
03D5E:  MOVF   x2B,W
03D60:  ADDLW  7E
03D62:  MOVWF  FE9
03D64:  MOVLW  00
03D66:  ADDWFC 03,W
03D68:  MOVWF  FEA
03D6A:  MOVFF  FEF,3A2
03D6E:  MOVLW  57
03D70:  MOVWF  xA3
03D72:  MOVLB  0
03D74:  CALL   0700
03D78:  MOVLB  3
03D7A:  INCF   x2B,F
03D7C:  BRA    3D56
....................          } 
....................          fprintf(PC,"\r\n"); 
03D7E:  MOVLW  0D
03D80:  BTFSS  F9E.4
03D82:  BRA    3D80
03D84:  MOVWF  FAD
03D86:  MOVLW  0A
03D88:  BTFSS  F9E.4
03D8A:  BRA    3D88
03D8C:  MOVWF  FAD
....................           
....................          if(CMD_FROM_PC[1] == 0)                                                 //if time data is not placed 
03D8E:  MOVLB  0
03D90:  MOVF   x7F,F
03D92:  BNZ   3DB6
....................          { 
....................             EXECUTE_MISSION_from_PC(CMD_FROM_PC[0],CMD_FROM_PC[2],CMD_FROM_PC[3],CMD_FROM_PC[4],CMD_FROM_PC[5],CMD_FROM_PC[6],CMD_FROM_PC[7]);//execute mission 
03D94:  MOVFF  7E,32C
03D98:  MOVFF  80,32D
03D9C:  MOVFF  81,32E
03DA0:  MOVFF  82,32F
03DA4:  MOVFF  83,330
03DA8:  MOVFF  84,331
03DAC:  MOVFF  85,332
03DB0:  GOTO   3084
....................          }else{                                                                  //if time data is placed (that means reservation command) 
03DB4:  BRA    3DCA
....................             SAVE_SAT_LOG(CMD_FROM_PC[0],CMD_FROM_PC[1],CMD_FROM_PC[2]);          //reservation command log 
03DB6:  MOVFF  7E,353
03DBA:  MOVFF  7F,354
03DBE:  MOVFF  80,355
03DC2:  CALL   16EA4
....................             Reserve_command_PC();                                                //mission command reservation from PC comand 
03DC6:  CALL   185E0
....................          } 
....................          DELETE_CMD_FROM_PC();                                                   //clear CMD_FROM_PC[] array 
03DCA:  CALL   1B0BA
....................          Delete_Buffer();                                                        //clear in_bffr_main[] array 
03DCE:  CALL   121E8
....................          CMD_FROM_PC[1] = 0; 
03DD2:  CLRF   x7F
....................          COM_DATA = 0;                                                           //clear COM correct receiving data flag 
03DD4:  CLRF   x96
....................          PC_DATA = 0;                                                            //clear PC correct receiving data flag 
03DD6:  CLRF   x99
....................       } 
....................              
....................       if(COM_DATA != 0 || PC_DATA != 0)                                          //COM_DATA Y PC_DATA SERAN CERO SI SE RECIBEN LA CANTIDAD CORRECTA DE CARACTERES 
03DD8:  MOVF   x96,F
03DDA:  BNZ   3DE0
03DDC:  MOVF   x99,F
03DDE:  BZ    3E10
....................       { 
....................          delay_ms(500); 
03DE0:  MOVLW  02
03DE2:  MOVLB  3
03DE4:  MOVWF  x2C
03DE6:  MOVLW  FA
03DE8:  MOVWF  x98
03DEA:  MOVLB  0
03DEC:  CALL   063E
03DF0:  MOVLB  3
03DF2:  DECFSZ x2C,F
03DF4:  BRA    3DE6
....................          if(PC_DATA != 0)                                                        //Si no se recibio la cantidad correcta de caracteres pone a cero el array CMD_FROM_PC 
03DF6:  MOVLB  0
03DF8:  MOVF   x99,F
03DFA:  BZ    3E10
....................          { 
....................             CMD_FROM_PC[0] = 0; 
03DFC:  CLRF   x7E
....................             CMD_FROM_PC[1] = 0; 
03DFE:  CLRF   x7F
....................             CMD_FROM_PC[2] = 0; 
03E00:  CLRF   x80
....................             CMD_FROM_PC[3] = 0; 
03E02:  CLRF   x81
....................             CMD_FROM_PC[4] = 0; 
03E04:  CLRF   x82
....................             CMD_FROM_PC[5] = 0; 
03E06:  CLRF   x83
....................             CMD_FROM_PC[6] = 0; 
03E08:  CLRF   x84
....................             CMD_FROM_PC[7] = 0; 
03E0A:  CLRF   x85
....................             COM_DATA = 0; 
03E0C:  CLRF   x96
....................             PC_DATA = 0; 
03E0E:  CLRF   x99
....................          } 
....................       } 
....................       delay_ms(400);     
03E10:  MOVLW  02
03E12:  MOVLB  3
03E14:  MOVWF  x2C
03E16:  MOVLW  C8
03E18:  MOVWF  x98
03E1A:  MOVLB  0
03E1C:  CALL   063E
03E20:  MOVLB  3
03E22:  DECFSZ x2C,F
03E24:  BRA    3E16
03E26:  MOVLB  0
03E28:  BRA    3B92
....................    } 
.................... //*PURPOSE This program is to test in-orbit update feasibility 
.................... //*AUTHOR Maisun Ibn Monowar 
.................... /**:CHANGES 
....................             Rewrote command analyzer 
....................             Allocated memory segement to each segment. 
.................... */ 
.................... } 
03E2A:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
