CCS PCH C Compiler, Version 5.056, 29513               06-Feb-20 20:46

               Filename:   C:\Users\maisun\Documents\PhD\offline\code\ccs\orgFuncWithoutRes\MAIN_PIC_FM.lst

               ROM used:   60928 bytes (46%)
                           Largest free fragment is 39774
               RAM used:   813 (23%) at main() level
                           950 (27%) worst case
               Stack used: 22 locations (13 in main + 9 for interrupts)
               Stack size: 31

*
00002:  NOP   
00004:  GOTO   26AE
*
0000A:  GOTO   00F4
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  NOP   
0001A:  MOVWF  04
0001C:  MOVFF  FD8,05
00020:  MOVFF  FE0,06
00024:  MOVLB  0
00026:  MOVFF  FE9,0C
0002A:  MOVFF  FEA,07
0002E:  MOVFF  FE1,08
00032:  MOVFF  FE2,09
00036:  MOVFF  FD9,0A
0003A:  MOVFF  FDA,0B
0003E:  MOVFF  FF3,12
00042:  MOVFF  FF4,13
00046:  MOVFF  FFA,14
0004A:  MOVFF  FF5,15
0004E:  MOVFF  FF6,16
00052:  MOVFF  FF7,17
00056:  MOVFF  FF8,18
0005A:  MOVFF  FFB,19
0005E:  MOVFF  00,0E
00062:  MOVFF  01,0F
00066:  MOVFF  02,10
0006A:  MOVFF  03,11
0006E:  BTFSS  FF2.5
00070:  GOTO   007A
00074:  BTFSC  FF2.2
00076:  GOTO   1644
0007A:  BTFSS  F9D.5
0007C:  GOTO   0086
00080:  BTFSC  F9E.5
00082:  GOTO   16A4
00086:  BTFSS  F61.5
00088:  GOTO   0092
0008C:  BTFSC  FA6.5
0008E:  GOTO   171C
00092:  BTFSS  F61.7
00094:  GOTO   009E
00098:  BTFSC  FA6.7
0009A:  GOTO   1754
0009E:  MOVFF  0E,00
000A2:  MOVFF  0F,01
000A6:  MOVFF  10,02
000AA:  MOVFF  11,03
000AE:  MOVFF  0C,FE9
000B2:  MOVFF  07,FEA
000B6:  BSF    07.7
000B8:  MOVFF  08,FE1
000BC:  MOVFF  09,FE2
000C0:  MOVFF  0A,FD9
000C4:  MOVFF  0B,FDA
000C8:  MOVFF  12,FF3
000CC:  MOVFF  13,FF4
000D0:  MOVFF  14,FFA
000D4:  MOVFF  15,FF5
000D8:  MOVFF  16,FF6
000DC:  MOVFF  17,FF7
000E0:  MOVFF  18,FF8
000E4:  MOVFF  19,FFB
000E8:  MOVF   04,W
000EA:  MOVFF  06,FE0
000EE:  MOVFF  05,FD8
000F2:  RETFIE 0
000F4:  MOVLB  0
000F6:  MOVFF  FE9,21
000FA:  MOVFF  FEA,1C
000FE:  MOVFF  FE1,1D
00102:  MOVFF  FE2,1E
00106:  MOVFF  FD9,1F
0010A:  MOVFF  FDA,20
0010E:  MOVFF  FF3,27
00112:  MOVFF  FF4,28
00116:  MOVFF  FFA,29
0011A:  MOVFF  FF5,2A
0011E:  MOVFF  FF6,2B
00122:  MOVFF  FF7,2C
00126:  MOVFF  FF8,2D
0012A:  MOVFF  FFB,2E
0012E:  MOVFF  00,23
00132:  MOVFF  01,24
00136:  MOVFF  02,25
0013A:  MOVFF  03,26
0013E:  BTFSS  FA3.5
00140:  GOTO   014A
00144:  BTFSC  FA4.5
00146:  GOTO   16C8
0014A:  MOVFF  23,00
0014E:  MOVFF  24,01
00152:  MOVFF  25,02
00156:  MOVFF  26,03
0015A:  MOVFF  21,FE9
0015E:  MOVFF  1C,FEA
00162:  BSF    1C.7
00164:  MOVFF  1D,FE1
00168:  MOVFF  1E,FE2
0016C:  MOVFF  1F,FD9
00170:  MOVFF  20,FDA
00174:  MOVFF  27,FF3
00178:  MOVFF  28,FF4
0017C:  MOVFF  29,FFA
00180:  MOVFF  2A,FF5
00184:  MOVFF  2B,FF6
00188:  MOVFF  2C,FF7
0018C:  MOVFF  2D,FF8
00190:  MOVFF  2E,FFB
00194:  RETFIE 1
.................... #include <MAIN_PIC_FM.h> 
.................... #ifndef MAIN_PIC_FM_H 
.................... #define MAIN_PIC_FM_H 
....................  
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
*
001DA:  DATA 0D,0A
001DC:  DATA 50,41
001DE:  DATA 53,53
001E0:  DATA 45,44
001E2:  DATA 20,44
001E4:  DATA 41,59
001E6:  DATA 53,3A
001E8:  DATA 25,78
001EA:  DATA 0D,0A
001EC:  DATA 00,00
001EE:  DATA 52,45
001F0:  DATA 53,45
001F2:  DATA 52,56
001F4:  DATA 45,20
001F6:  DATA 43,48
001F8:  DATA 45,43
001FA:  DATA 4B,3A
001FC:  DATA 25,78
001FE:  DATA 0D,0A
00200:  DATA 00,00
00202:  DATA 4B,69
00204:  DATA 6C,6C
00206:  DATA 20,46
00208:  DATA 4C,41
0020A:  DATA 47,20
0020C:  DATA 4D,41
0020E:  DATA 49,4E
00210:  DATA 3A,25
00212:  DATA 78,0D
00214:  DATA 0A,00
00216:  DATA 4B,69
00218:  DATA 6C,6C
0021A:  DATA 20,46
0021C:  DATA 4C,41
0021E:  DATA 47,20
00220:  DATA 46,41
00222:  DATA 42,3A
00224:  DATA 25,78
00226:  DATA 0D,0A
00228:  DATA 00,00
0022A:  DATA 41,55
0022C:  DATA 54,4F
0022E:  DATA 20,48
00230:  DATA 49,47
00232:  DATA 48,20
00234:  DATA 53,41
00236:  DATA 4D,50
00238:  DATA 4C,49
0023A:  DATA 4E,47
0023C:  DATA 3A,25
0023E:  DATA 78,0D
00240:  DATA 0A,00
00242:  DATA 41,55
00244:  DATA 54,4F
00246:  DATA 20,43
00248:  DATA 41,4D
0024A:  DATA 3A,25
0024C:  DATA 78,0D
0024E:  DATA 0A,00
00250:  DATA 41,55
00252:  DATA 54,4F
00254:  DATA 20,4D
00256:  DATA 42,50
00258:  DATA 3A,25
0025A:  DATA 78,0D
0025C:  DATA 0A,00
0025E:  DATA 41,55
00260:  DATA 54,4F
00262:  DATA 20,41
00264:  DATA 44,43
00266:  DATA 53,3A
00268:  DATA 25,78
0026A:  DATA 0D,0A
0026C:  DATA 00,00
0026E:  DATA 41,4E
00270:  DATA 54,45
00272:  DATA 4E,4E
00274:  DATA 41,20
00276:  DATA 44,45
00278:  DATA 50,4C
0027A:  DATA 4F,59
0027C:  DATA 3A,25
0027E:  DATA 78,0D
00280:  DATA 0A,00
00282:  DATA 41,4E
00284:  DATA 54,45
00286:  DATA 4E,4E
00288:  DATA 41,20
0028A:  DATA 44,45
0028C:  DATA 50,4C
0028E:  DATA 4F,59
00290:  DATA 20,41
00292:  DATA 54,54
00294:  DATA 45,4D
00296:  DATA 50,54
00298:  DATA 3A,25
0029A:  DATA 78,0D
0029C:  DATA 0A,00
0029E:  DATA 55,50
002A0:  DATA 4C,49
002A2:  DATA 4E,4B
002A4:  DATA 20,53
002A6:  DATA 55,43
002A8:  DATA 43,45
002AA:  DATA 53,53
002AC:  DATA 3A,25
002AE:  DATA 78,0D
002B0:  DATA 0A,0D
002B2:  DATA 0A,00
002B4:  DATA 0D,0A
002B6:  DATA 41,44
002B8:  DATA 44,20
002BA:  DATA 49,4E
002BC:  DATA 46,4F
002BE:  DATA 20,41
002C0:  DATA 44,44
002C2:  DATA 52,45
002C4:  DATA 53,53
002C6:  DATA 3A,25
002C8:  DATA 6C,78
002CA:  DATA 0D,0A
002CC:  DATA 0D,0A
002CE:  DATA 00,00
002D0:  DATA 46,4C
002D2:  DATA 41,47
002D4:  DATA 20,44
002D6:  DATA 41,54
002D8:  DATA 41,20
002DA:  DATA 41,44
002DC:  DATA 44,52
002DE:  DATA 45,53
002E0:  DATA 53,3A
002E2:  DATA 25,78
002E4:  DATA 25,78
002E6:  DATA 25,78
002E8:  DATA 25,78
002EA:  DATA 0D,0A
002EC:  DATA 00,00
002EE:  DATA 52,45
002F0:  DATA 53,45
002F2:  DATA 52,56
002F4:  DATA 41,54
002F6:  DATA 49,4F
002F8:  DATA 4E,20
002FA:  DATA 54,41
002FC:  DATA 42,4C
002FE:  DATA 45,20
00300:  DATA 41,44
00302:  DATA 44,52
00304:  DATA 45,53
00306:  DATA 53,3A
00308:  DATA 25,78
0030A:  DATA 25,78
0030C:  DATA 25,78
0030E:  DATA 25,78
00310:  DATA 0D,0A
00312:  DATA 00,00
00314:  DATA 53,41
00316:  DATA 54,45
00318:  DATA 4C,4C
0031A:  DATA 49,54
0031C:  DATA 45,20
0031E:  DATA 4C,4F
00320:  DATA 47,20
00322:  DATA 41,44
00324:  DATA 44,52
00326:  DATA 45,53
00328:  DATA 53,3A
0032A:  DATA 25,78
0032C:  DATA 25,78
0032E:  DATA 25,78
00330:  DATA 25,78
00332:  DATA 0D,0A
00334:  DATA 00,00
00336:  DATA 43,41
00338:  DATA 4D,20
0033A:  DATA 41,44
0033C:  DATA 44,52
0033E:  DATA 45,53
00340:  DATA 53,3A
00342:  DATA 25,78
00344:  DATA 25,78
00346:  DATA 25,78
00348:  DATA 25,78
0034A:  DATA 0D,0A
0034C:  DATA 00,00
0034E:  DATA 46,41
00350:  DATA 42,20
00352:  DATA 48,4B
00354:  DATA 20,41
00356:  DATA 44,44
00358:  DATA 52,45
0035A:  DATA 53,53
0035C:  DATA 3A,25
0035E:  DATA 78,25
00360:  DATA 78,25
00362:  DATA 78,25
00364:  DATA 78,0D
00366:  DATA 0A,00
00368:  DATA 46,41
0036A:  DATA 42,20
0036C:  DATA 43,57
0036E:  DATA 20,41
00370:  DATA 44,44
00372:  DATA 52,45
00374:  DATA 53,53
00376:  DATA 3A,25
00378:  DATA 78,25
0037A:  DATA 78,25
0037C:  DATA 78,25
0037E:  DATA 78,0D
00380:  DATA 0A,00
00382:  DATA 41,44
00384:  DATA 43,53
00386:  DATA 20,53
00388:  DATA 45,4E
0038A:  DATA 53,4F
0038C:  DATA 52,20
0038E:  DATA 41,44
00390:  DATA 44,52
00392:  DATA 45,53
00394:  DATA 53,3A
00396:  DATA 25,78
00398:  DATA 25,78
0039A:  DATA 25,78
0039C:  DATA 25,78
0039E:  DATA 0D,0A
003A0:  DATA 00,00
003A2:  DATA 41,44
003A4:  DATA 43,53
003A6:  DATA 20,54
003A8:  DATA 4C,45
003AA:  DATA 20,41
003AC:  DATA 44,44
003AE:  DATA 52,45
003B0:  DATA 53,53
003B2:  DATA 3A,25
003B4:  DATA 78,25
003B6:  DATA 78,25
003B8:  DATA 78,25
003BA:  DATA 78,0D
003BC:  DATA 0A,00
003BE:  DATA 4D,49
003C0:  DATA 53,53
003C2:  DATA 49,4F
003C4:  DATA 4E,20
003C6:  DATA 42,4F
003C8:  DATA 53,53
003CA:  DATA 20,41
003CC:  DATA 44,44
003CE:  DATA 52,45
003D0:  DATA 53,53
003D2:  DATA 3A,25
003D4:  DATA 78,25
003D6:  DATA 78,25
003D8:  DATA 78,25
003DA:  DATA 78,0D
003DC:  DATA 0A,00
003DE:  DATA 48,49
003E0:  DATA 47,48
003E2:  DATA 20,53
003E4:  DATA 41,4D
003E6:  DATA 50,20
003E8:  DATA 48,4B
003EA:  DATA 20,41
003EC:  DATA 44,44
003EE:  DATA 45,52
003F0:  DATA 53,53
003F2:  DATA 3A,25
003F4:  DATA 78,25
003F6:  DATA 78,25
003F8:  DATA 78,25
003FA:  DATA 78,0D
003FC:  DATA 0A,00
003FE:  DATA 57,52
00400:  DATA 49,54
00402:  DATA 45,20
00404:  DATA 25,6C
00406:  DATA 78,20
00408:  DATA 54,49
0040A:  DATA 4D,45
0040C:  DATA 53,0D
0040E:  DATA 0A,00
00410:  DATA 0D,0A
00412:  DATA 50,41
00414:  DATA 53,53
00416:  DATA 45,44
00418:  DATA 20,44
0041A:  DATA 41,59
0041C:  DATA 53,3A
0041E:  DATA 25,6C
00420:  DATA 78,0D
00422:  DATA 0A,00
00424:  DATA 52,45
00426:  DATA 53,45
00428:  DATA 52,56
0042A:  DATA 45,20
0042C:  DATA 43,48
0042E:  DATA 45,43
00430:  DATA 4B,3A
00432:  DATA 25,78
00434:  DATA 0D,0A
00436:  DATA 00,00
00438:  DATA 4B,69
0043A:  DATA 6C,6C
0043C:  DATA 20,46
0043E:  DATA 4C,41
00440:  DATA 47,20
00442:  DATA 4D,41
00444:  DATA 49,4E
00446:  DATA 3A,25
00448:  DATA 78,0D
0044A:  DATA 0A,00
0044C:  DATA 4B,69
0044E:  DATA 6C,6C
00450:  DATA 20,46
00452:  DATA 4C,41
00454:  DATA 47,20
00456:  DATA 46,41
00458:  DATA 42,3A
0045A:  DATA 25,78
0045C:  DATA 0D,0A
0045E:  DATA 00,00
00460:  DATA 41,55
00462:  DATA 54,4F
00464:  DATA 20,48
00466:  DATA 49,47
00468:  DATA 48,20
0046A:  DATA 53,41
0046C:  DATA 4D,50
0046E:  DATA 4C,49
00470:  DATA 4E,47
00472:  DATA 3A,25
00474:  DATA 78,0D
00476:  DATA 0A,00
00478:  DATA 41,55
0047A:  DATA 54,4F
0047C:  DATA 20,43
0047E:  DATA 41,4D
00480:  DATA 3A,25
00482:  DATA 78,0D
00484:  DATA 0A,00
00486:  DATA 41,55
00488:  DATA 54,4F
0048A:  DATA 20,4D
0048C:  DATA 42,50
0048E:  DATA 3A,25
00490:  DATA 78,0D
00492:  DATA 0A,00
00494:  DATA 41,55
00496:  DATA 54,4F
00498:  DATA 20,41
0049A:  DATA 44,43
0049C:  DATA 53,3A
0049E:  DATA 25,78
004A0:  DATA 0D,0A
004A2:  DATA 00,00
004A4:  DATA 41,4E
004A6:  DATA 54,45
004A8:  DATA 4E,4E
004AA:  DATA 41,20
004AC:  DATA 44,45
004AE:  DATA 50,4C
004B0:  DATA 4F,59
004B2:  DATA 3A,25
004B4:  DATA 78,0D
004B6:  DATA 0A,00
004B8:  DATA 55,50
004BA:  DATA 4C,49
004BC:  DATA 4E,4B
004BE:  DATA 20,53
004C0:  DATA 55,43
004C2:  DATA 43,45
004C4:  DATA 53,53
004C6:  DATA 3A,25
004C8:  DATA 78,0D
004CA:  DATA 0A,0D
004CC:  DATA 0A,00
004CE:  DATA 46,4C
004D0:  DATA 41,47
004D2:  DATA 20,49
004D4:  DATA 4E,46
004D6:  DATA 4F,20
004D8:  DATA 53,54
004DA:  DATA 4F,52
004DC:  DATA 45,44
004DE:  DATA 20,49
004E0:  DATA 4E,20
004E2:  DATA 46,4C
004E4:  DATA 41,53
004E6:  DATA 48,0D
004E8:  DATA 0A,00
*
0058C:  TBLRD*+
0058E:  MOVF   FF5,F
00590:  BZ    05B4
00592:  MOVFF  FF6,38F
00596:  MOVFF  FF7,390
0059A:  MOVFF  FF8,391
0059E:  MOVF   FF5,W
005A0:  BTFSS  F9E.4
005A2:  BRA    05A0
005A4:  MOVWF  FAD
005A6:  MOVFF  38F,FF6
005AA:  MOVFF  390,FF7
005AE:  MOVFF  391,FF8
005B2:  BRA    058C
005B4:  RETURN 0
005B6:  MOVLW  C0
005B8:  ANDWF  FF6,F
005BA:  MOVLW  3F
005BC:  MOVWF  00
005BE:  TBLRD*
005C0:  TBLWT*+
005C2:  DECFSZ 00,F
005C4:  BRA    05BE
005C6:  TBLRD*
005C8:  TBLWT*
005CA:  RETURN 0
005CC:  MOVF   FF2,W
005CE:  MOVWF  03
005D0:  BCF    FF2.7
005D2:  BSF    F7F.2
005D4:  MOVLB  F
005D6:  MOVLW  55
005D8:  MOVWF  F7E
005DA:  MOVLW  AA
005DC:  MOVWF  F7E
005DE:  BSF    F7F.1
005E0:  NOP   
005E2:  MOVF   03,W
005E4:  IORWF  FF2,F
005E6:  MOVLB  0
005E8:  RETURN 0
005EA:  DATA 0D,0A
005EC:  DATA 61,64
005EE:  DATA 64,72
005F0:  DATA 65,73
005F2:  DATA 73,20
005F4:  DATA 69,6E
005F6:  DATA 66,6F
005F8:  DATA 20,6C
005FA:  DATA 6F,63
005FC:  DATA 61,74
005FE:  DATA 69,6F
00600:  DATA 6E,3A
00602:  DATA 25,6C
00604:  DATA 78,0D
00606:  DATA 0A,00
00608:  DATA 41,44
0060A:  DATA 20,43
0060C:  DATA 4F,55
0060E:  DATA 4E,54
00610:  DATA 45,52
00612:  DATA 3A,25
00614:  DATA 6C,78
00616:  DATA 0D,0A
00618:  DATA 00,00
0061A:  DATA 43,48
0061C:  DATA 41,4E
0061E:  DATA 47,45
00620:  DATA 44,20
00622:  DATA 4D,45
00624:  DATA 4D,4F
00626:  DATA 52,59
00628:  DATA 20,41
0062A:  DATA 44,44
0062C:  DATA 52,45
0062E:  DATA 53,53
00630:  DATA 3A,00
00632:  DATA 0D,0A
00634:  DATA 53,74
00636:  DATA 6F,72
00638:  DATA 65,69
0063A:  DATA 6E,67
0063C:  DATA 20,41
0063E:  DATA 64,64
00640:  DATA 72,65
00642:  DATA 73,73
00644:  DATA 20,44
00646:  DATA 61,74
00648:  DATA 61,20
0064A:  DATA 69,6E
0064C:  DATA 20,46
0064E:  DATA 6C,61
00650:  DATA 73,68
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 41,44
00658:  DATA 44,52
0065A:  DATA 45,53
0065C:  DATA 53,20
0065E:  DATA 44,41
00660:  DATA 54,41
00662:  DATA 20,53
00664:  DATA 54,4F
00666:  DATA 52,45
00668:  DATA 20,44
0066A:  DATA 4F,4E
0066C:  DATA 45,3A
0066E:  DATA 25,6C
00670:  DATA 78,0D
00672:  DATA 0A,00
00674:  DATA 46,4C
00676:  DATA 41,53
00678:  DATA 48,20
0067A:  DATA 4D,45
0067C:  DATA 4D,4F
0067E:  DATA 52,59
00680:  DATA 20,45
00682:  DATA 52,41
00684:  DATA 53,45
00686:  DATA 20,53
00688:  DATA 54,41
0068A:  DATA 52,54
0068C:  DATA 0D,0A
0068E:  DATA 00,00
00690:  DATA 46,4C
00692:  DATA 41,53
00694:  DATA 48,20
00696:  DATA 4D,45
00698:  DATA 4D,4F
0069A:  DATA 52,59
0069C:  DATA 20,45
0069E:  DATA 52,41
006A0:  DATA 53,45
006A2:  DATA 20,44
006A4:  DATA 4F,4E
006A6:  DATA 45,0D
006A8:  DATA 0A,00
006AA:  DATA 52,65
006AC:  DATA 6D,61
006AE:  DATA 69,6E
006B0:  DATA 69,6E
006B2:  DATA 67,20
006B4:  DATA 74,69
006B6:  DATA 6D,65
006B8:  DATA 3A,20
006BA:  DATA 25,64
006BC:  DATA 20,20
006BE:  DATA 0D,00
006C0:  DATA 65,72
006C2:  DATA 61,73
006C4:  DATA 69,6E
006C6:  DATA 67,20
006C8:  DATA 6E,65
006CA:  DATA 78,74
006CC:  DATA 20,73
006CE:  DATA 65,63
006D0:  DATA 74,6F
006D2:  DATA 72,0D
006D4:  DATA 0A,00
006D6:  DATA 65,72
006D8:  DATA 61,73
006DA:  DATA 69,6E
006DC:  DATA 67,20
006DE:  DATA 6E,65
006E0:  DATA 78,74
006E2:  DATA 20,73
006E4:  DATA 65,63
006E6:  DATA 74,6F
006E8:  DATA 72,0D
006EA:  DATA 0A,00
006EC:  DATA 65,72
006EE:  DATA 61,73
006F0:  DATA 69,6E
006F2:  DATA 67,20
006F4:  DATA 6E,65
006F6:  DATA 78,74
006F8:  DATA 20,73
006FA:  DATA 65,63
006FC:  DATA 74,6F
006FE:  DATA 72,0D
00700:  DATA 0A,00
00702:  TBLRD*+
00704:  MOVFF  FF6,3A3
00708:  MOVFF  FF7,3A4
0070C:  MOVFF  FF8,3A5
00710:  MOVF   FF5,W
00712:  BTFSS  F9E.4
00714:  BRA    0712
00716:  MOVWF  FAD
00718:  MOVFF  3A3,FF6
0071C:  MOVFF  3A4,FF7
00720:  MOVFF  3A5,FF8
00724:  MOVLB  3
00726:  DECFSZ xA2,F
00728:  BRA    072C
0072A:  BRA    0730
0072C:  MOVLB  0
0072E:  BRA    0702
00730:  MOVLB  0
00732:  RETURN 0
00734:  MOVLB  3
00736:  BTFSC  xA3.7
00738:  BRA    075A
0073A:  MOVLW  0F
0073C:  MOVWF  00
0073E:  SWAPF  xA2,W
00740:  ANDWF  00,F
00742:  MOVLW  0A
00744:  SUBWF  00,W
00746:  BC    074E
00748:  MOVLW  30
0074A:  ADDWF  00,F
0074C:  BRA    0752
0074E:  MOVF   xA3,W
00750:  ADDWF  00,F
00752:  MOVF   00,W
00754:  BTFSS  F9E.4
00756:  BRA    0754
00758:  MOVWF  FAD
0075A:  MOVLW  0F
0075C:  ANDWF  xA2,F
0075E:  MOVLW  0A
00760:  SUBWF  xA2,W
00762:  BC    0768
00764:  MOVLW  30
00766:  BRA    076C
00768:  BCF    xA3.7
0076A:  MOVF   xA3,W
0076C:  ADDWF  xA2,F
0076E:  MOVF   xA2,W
00770:  BTFSS  F9E.4
00772:  BRA    0770
00774:  MOVWF  FAD
00776:  MOVLB  0
00778:  RETURN 0
0077A:  DATA 65,72
0077C:  DATA 61,73
0077E:  DATA 69,6E
00780:  DATA 67,20
00782:  DATA 6E,65
00784:  DATA 78,74
00786:  DATA 20,73
00788:  DATA 65,63
0078A:  DATA 74,6F
0078C:  DATA 72,0D
0078E:  DATA 0A,00
00790:  DATA 65,72
00792:  DATA 61,73
00794:  DATA 69,6E
00796:  DATA 67,20
00798:  DATA 6E,65
0079A:  DATA 78,74
0079C:  DATA 20,73
0079E:  DATA 65,63
007A0:  DATA 74,6F
007A2:  DATA 72,0D
007A4:  DATA 0A,00
007A6:  DATA 52,45
007A8:  DATA 53,45
007AA:  DATA 52,56
007AC:  DATA 45,5F
007AE:  DATA 43,48
007B0:  DATA 45,43
007B2:  DATA 4B,20
007B4:  DATA 3D,20
007B6:  DATA 25,78
007B8:  DATA 0D,0A
007BA:  DATA 00,00
007BC:  DATA 4E,45
007BE:  DATA 58,54
007C0:  DATA 20,46
007C2:  DATA 55,4E
007C4:  DATA 43,54
007C6:  DATA 49,4F
007C8:  DATA 4E,5F
007CA:  DATA 43,4F
007CC:  DATA 4E,54
007CE:  DATA 45,4E
007D0:  DATA 54,53
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 78,0D
007D8:  DATA 0A,00
007DA:  DATA 52,45
007DC:  DATA 53,45
007DE:  DATA 52,56
007E0:  DATA 45,5F
007E2:  DATA 54,41
007E4:  DATA 52,47
007E6:  DATA 45,54
007E8:  DATA 5F,46
007EA:  DATA 4C,41
007EC:  DATA 47,20
007EE:  DATA 3D,20
007F0:  DATA 25,78
007F2:  DATA 0D,0A
007F4:  DATA 00,00
007F6:  DATA 4E,45
007F8:  DATA 58,54
007FA:  DATA 20,46
007FC:  DATA 55,4E
007FE:  DATA 43,54
00800:  DATA 49,4F
00802:  DATA 4E,20
00804:  DATA 44,45
00806:  DATA 54,41
00808:  DATA 49,4C
0080A:  DATA 20,3D
0080C:  DATA 20,25
0080E:  DATA 78,0D
00810:  DATA 0A,00
00812:  DATA 4E,45
00814:  DATA 58,54
00816:  DATA 20,46
00818:  DATA 55,4E
0081A:  DATA 43,54
0081C:  DATA 49,4F
0081E:  DATA 4E,20
00820:  DATA 41,44
00822:  DATA 44,52
00824:  DATA 45,53
00826:  DATA 53,20
00828:  DATA 3D,20
0082A:  DATA 25,78
0082C:  DATA 25,78
0082E:  DATA 25,78
00830:  DATA 25,78
00832:  DATA 0D,0A
00834:  DATA 00,00
00836:  DATA 4E,45
00838:  DATA 58,54
0083A:  DATA 20,46
0083C:  DATA 55,4E
0083E:  DATA 43,54
00840:  DATA 49,4F
00842:  DATA 4E,20
00844:  DATA 50,43
00846:  DATA 4B,54
00848:  DATA 20,4E
0084A:  DATA 55,4D
0084C:  DATA 42,45
0084E:  DATA 52,20
00850:  DATA 3D,20
00852:  DATA 25,78
00854:  DATA 0D,0A
00856:  DATA 00,00
00858:  DATA 52,45
0085A:  DATA 53,45
0085C:  DATA 52,56
0085E:  DATA 45,5F
00860:  DATA 4D,49
00862:  DATA 4E,5F
00864:  DATA 46,4C
00866:  DATA 41,47
00868:  DATA 20,3D
0086A:  DATA 20,25
0086C:  DATA 78,0D
0086E:  DATA 0A,00
00870:  DATA 54,41
00872:  DATA 42,4C
00874:  DATA 45,20
00876:  DATA 4E,55
00878:  DATA 4D,20
0087A:  DATA 3D,20
0087C:  DATA 25,78
0087E:  DATA 0D,0A
00880:  DATA 00,00
00882:  DATA 52,65
00884:  DATA 73,65
00886:  DATA 72,76
00888:  DATA 61,74
0088A:  DATA 69,6F
0088C:  DATA 6E,20
0088E:  DATA 74,61
00890:  DATA 62,6C
00892:  DATA 65,20
00894:  DATA 69,73
00896:  DATA 20,46
00898:  DATA 75,6C
0089A:  DATA 6C,21
0089C:  DATA 0D,0A
0089E:  DATA 0D,0A
008A0:  DATA 00,00
008A2:  DATA 54,61
008A4:  DATA 62,6C
008A6:  DATA 65,20
008A8:  DATA 6E,75
008AA:  DATA 6D,3A
008AC:  DATA 20,25
008AE:  DATA 78,0D
008B0:  DATA 0A,00
008B2:  DATA 52,65
008B4:  DATA 73,65
008B6:  DATA 72,76
008B8:  DATA 61,74
008BA:  DATA 69,6F
008BC:  DATA 6E,20
008BE:  DATA 74,61
008C0:  DATA 62,6C
008C2:  DATA 65,20
008C4:  DATA 69,73
008C6:  DATA 20,46
008C8:  DATA 75,6C
008CA:  DATA 6C,21
008CC:  DATA 0D,0A
008CE:  DATA 0D,0A
008D0:  DATA 00,00
008D2:  DATA 52,65
008D4:  DATA 6D,6F
008D6:  DATA 76,65
008D8:  DATA 64,20
008DA:  DATA 66,69
008DC:  DATA 6E,69
008DE:  DATA 73,68
008E0:  DATA 65,64
008E2:  DATA 20,6D
008E4:  DATA 69,73
008E6:  DATA 73,69
008E8:  DATA 6F,6E
008EA:  DATA 20,63
008EC:  DATA 6F,6D
008EE:  DATA 6D,61
008F0:  DATA 6E,64
008F2:  DATA 3A,00
008F4:  DATA 52,65
008F6:  DATA 73,65
008F8:  DATA 72,76
008FA:  DATA 65,20
008FC:  DATA 43,4D
008FE:  DATA 44,20
00900:  DATA 66,72
00902:  DATA 6F,6D
00904:  DATA 20,43
00906:  DATA 4F,4D
00908:  DATA 0D,0A
0090A:  DATA 00,00
0090C:  DATA 52,65
0090E:  DATA 73,65
00910:  DATA 72,76
00912:  DATA 65,20
00914:  DATA 43,4D
00916:  DATA 44,20
00918:  DATA 66,72
0091A:  DATA 6F,6D
0091C:  DATA 20,50
0091E:  DATA 43,0D
00920:  DATA 0A,00
00922:  DATA 52,65
00924:  DATA 73,65
00926:  DATA 72,76
00928:  DATA 65,20
0092A:  DATA 6E,65
0092C:  DATA 78,74
0092E:  DATA 0D,0A
00930:  DATA 00,00
00932:  DATA 52,65
00934:  DATA 61,64
00936:  DATA 79,20
00938:  DATA 66,6F
0093A:  DATA 72,20
0093C:  DATA 72,65
0093E:  DATA 73,65
00940:  DATA 74,00
00942:  DATA 4C,4F
00944:  DATA 47,20
00946:  DATA 73,61
00948:  DATA 76,69
0094A:  DATA 6E,67
0094C:  DATA 20,64
0094E:  DATA 6F,6E
00950:  DATA 65,0D
00952:  DATA 0A,00
00954:  DATA 45,52
00956:  DATA 41,53
00958:  DATA 45,20
0095A:  DATA 4F,46
0095C:  DATA 3A,25
0095E:  DATA 78,25
00960:  DATA 78,25
00962:  DATA 78,25
00964:  DATA 78,0D
00966:  DATA 0A,00
00968:  DATA 45,52
0096A:  DATA 41,53
0096C:  DATA 45,20
0096E:  DATA 53,43
00970:  DATA 46,3A
00972:  DATA 25,78
00974:  DATA 25,78
00976:  DATA 25,78
00978:  DATA 25,78
0097A:  DATA 0D,0A
0097C:  DATA 00,00
0097E:  DATA 45,52
00980:  DATA 41,53
00982:  DATA 45,20
00984:  DATA 53,4D
00986:  DATA 46,3A
00988:  DATA 25,78
0098A:  DATA 25,78
0098C:  DATA 25,78
0098E:  DATA 25,78
00990:  DATA 0D,0A
00992:  DATA 00,00
00994:  DATA 74,72
00996:  DATA 61,6E
00998:  DATA 73,66
0099A:  DATA 65,72
0099C:  DATA 20,4F
0099E:  DATA 46,32
009A0:  DATA 53,43
009A2:  DATA 46,3A
009A4:  DATA 25,78
009A6:  DATA 25,78
009A8:  DATA 25,78
009AA:  DATA 25,78
009AC:  DATA 0D,0A
009AE:  DATA 00,00
009B0:  DATA 74,72
009B2:  DATA 61,6E
009B4:  DATA 73,66
009B6:  DATA 65,72
009B8:  DATA 20,4F
009BA:  DATA 46,32
009BC:  DATA 53,4D
009BE:  DATA 46,3A
009C0:  DATA 25,78
009C2:  DATA 25,78
009C4:  DATA 25,78
009C6:  DATA 25,78
009C8:  DATA 0D,0A
009CA:  DATA 00,00
009CC:  DATA 74,72
009CE:  DATA 61,6E
009D0:  DATA 73,66
009D2:  DATA 65,72
009D4:  DATA 20,53
009D6:  DATA 43,46
009D8:  DATA 32,4F
009DA:  DATA 46,3A
009DC:  DATA 25,78
009DE:  DATA 25,78
009E0:  DATA 25,78
009E2:  DATA 25,78
009E4:  DATA 0D,0A
009E6:  DATA 00,00
009E8:  DATA 74,72
009EA:  DATA 61,6E
009EC:  DATA 73,66
009EE:  DATA 65,72
009F0:  DATA 20,53
009F2:  DATA 43,46
009F4:  DATA 32,53
009F6:  DATA 4D,46
009F8:  DATA 3A,25
009FA:  DATA 78,25
009FC:  DATA 78,25
009FE:  DATA 78,25
00A00:  DATA 78,0D
00A02:  DATA 0A,00
00A04:  DATA 74,72
00A06:  DATA 61,6E
00A08:  DATA 73,66
00A0A:  DATA 65,72
00A0C:  DATA 20,53
00A0E:  DATA 4D,46
00A10:  DATA 32,4F
00A12:  DATA 46,3A
00A14:  DATA 25,78
00A16:  DATA 25,78
00A18:  DATA 25,78
00A1A:  DATA 25,78
00A1C:  DATA 0D,0A
00A1E:  DATA 00,00
00A20:  DATA 74,72
00A22:  DATA 61,6E
00A24:  DATA 73,66
00A26:  DATA 65,72
00A28:  DATA 20,53
00A2A:  DATA 4D,46
00A2C:  DATA 32,53
00A2E:  DATA 43,46
00A30:  DATA 3A,25
00A32:  DATA 78,25
00A34:  DATA 78,25
00A36:  DATA 78,25
00A38:  DATA 78,0D
00A3A:  DATA 0A,00
00A3C:  DATA 54,72
00A3E:  DATA 61,6E
00A40:  DATA 73,66
00A42:  DATA 65,72
00A44:  DATA 72,65
00A46:  DATA 64,20
00A48:  DATA 25,6C
00A4A:  DATA 64,20
00A4C:  DATA 42,79
00A4E:  DATA 74,65
00A50:  DATA 73,00
00A52:  DATA 73,65
00A54:  DATA 6E,64
00A56:  DATA 69,6E
00A58:  DATA 67,20
00A5A:  DATA 63,6F
00A5C:  DATA 6D,6D
00A5E:  DATA 61,6E
00A60:  DATA 64,73
00A62:  DATA 20,74
00A64:  DATA 6F,20
00A66:  DATA 4D,42
00A68:  DATA 50,0D
00A6A:  DATA 0A,00
00A6C:  DATA 52,65
00A6E:  DATA 63,65
00A70:  DATA 69,76
00A72:  DATA 65,64
00A74:  DATA 20,41
00A76:  DATA 43,4B
00A78:  DATA 20,46
00A7A:  DATA 72,6F
00A7C:  DATA 6D,20
00A7E:  DATA 4D,42
00A80:  DATA 50,0D
00A82:  DATA 0A,00
00A84:  DATA 54,52
00A86:  DATA 41,4E
00A88:  DATA 53,46
00A8A:  DATA 45,52
00A8C:  DATA 52,49
00A8E:  DATA 4E,47
00A90:  DATA 20,25
00A92:  DATA 6C,78
00A94:  DATA 20,50
00A96:  DATA 41,43
00A98:  DATA 4B,45
00A9A:  DATA 54,53
00A9C:  DATA 0D,0A
00A9E:  DATA 00,00
00AA0:  DATA 46,41
00AA2:  DATA 49,4C
00AA4:  DATA 55,52
00AA6:  DATA 45,44
00AA8:  DATA 20,47
00AAA:  DATA 45,54
00AAC:  DATA 54,49
00AAE:  DATA 4E,47
00AB0:  DATA 20,41
00AB2:  DATA 43,4B
00AB4:  DATA 20,46
00AB6:  DATA 72,6F
00AB8:  DATA 6D,20
00ABA:  DATA 4D,42
00ABC:  DATA 50,0D
00ABE:  DATA 0A,00
00AC0:  DATA 73,65
00AC2:  DATA 6E,64
00AC4:  DATA 69,6E
00AC6:  DATA 67,20
00AC8:  DATA 63,6F
00ACA:  DATA 6D,6D
00ACC:  DATA 61,6E
00ACE:  DATA 64,73
00AD0:  DATA 20,74
00AD2:  DATA 6F,20
00AD4:  DATA 4D,42
00AD6:  DATA 50,0D
00AD8:  DATA 0A,00
00ADA:  DATA 52,65
00ADC:  DATA 63,65
00ADE:  DATA 69,76
00AE0:  DATA 65,64
00AE2:  DATA 20,41
00AE4:  DATA 43,4B
00AE6:  DATA 20,46
00AE8:  DATA 72,6F
00AEA:  DATA 6D,20
00AEC:  DATA 4D,42
00AEE:  DATA 50,0D
00AF0:  DATA 0A,00
00AF2:  DATA 46,41
00AF4:  DATA 49,4C
00AF6:  DATA 55,52
00AF8:  DATA 45,44
00AFA:  DATA 20,47
00AFC:  DATA 45,54
00AFE:  DATA 54,49
00B00:  DATA 4E,47
00B02:  DATA 20,41
00B04:  DATA 43,4B
00B06:  DATA 20,46
00B08:  DATA 72,6F
00B0A:  DATA 6D,20
00B0C:  DATA 4D,42
00B0E:  DATA 50,0D
00B10:  DATA 0A,00
00B12:  DATA 50,57
00B14:  DATA 52,20
00B16:  DATA 63,79
00B18:  DATA 63,6C
00B1A:  DATA 65,20
00B1C:  DATA 61,6E
00B1E:  DATA 64,20
00B20:  DATA 73,65
00B22:  DATA 6E,64
00B24:  DATA 69,6E
00B26:  DATA 67,20
00B28:  DATA 63,6F
00B2A:  DATA 6D,6D
00B2C:  DATA 61,6E
00B2E:  DATA 64,73
00B30:  DATA 20,61
00B32:  DATA 67,61
00B34:  DATA 69,6E
00B36:  DATA 0D,0A
00B38:  DATA 00,00
00B3A:  DATA 0D,0A
00B3C:  DATA 73,65
00B3E:  DATA 6E,64
00B40:  DATA 69,6E
00B42:  DATA 67,20
00B44:  DATA 53,59
00B46:  DATA 4E,43
00B48:  DATA 20,74
00B4A:  DATA 69,6D
00B4C:  DATA 65,20
00B4E:  DATA 74,6F
00B50:  DATA 20,4D
00B52:  DATA 42,50
00B54:  DATA 0D,0A
00B56:  DATA 00,00
00B58:  DATA 54,69
00B5A:  DATA 6D,65
00B5C:  DATA 20,72
00B5E:  DATA 65,63
00B60:  DATA 65,69
00B62:  DATA 76,65
00B64:  DATA 64,20
00B66:  DATA 66,72
00B68:  DATA 6F,6D
00B6A:  DATA 20,52
00B6C:  DATA 45,53
00B6E:  DATA 45,54
00B70:  DATA 0D,0A
00B72:  DATA 00,00
00B74:  DATA 4E,4F
00B76:  DATA 20,52
00B78:  DATA 45,53
00B7A:  DATA 45,54
00B7C:  DATA 20,74
00B7E:  DATA 69,6D
00B80:  DATA 65,0D
00B82:  DATA 0A,00
00B84:  DATA 54,69
00B86:  DATA 6D,65
00B88:  DATA 20,52
00B8A:  DATA 65,63
00B8C:  DATA 65,69
00B8E:  DATA 76,65
00B90:  DATA 64,20
00B92:  DATA 66,6F
00B94:  DATA 72,20
00B96:  DATA 4D,42
00B98:  DATA 50,0D
00B9A:  DATA 0A,00
00B9C:  DATA 46,41
00B9E:  DATA 49,4C
00BA0:  DATA 55,52
00BA2:  DATA 45,44
00BA4:  DATA 20,47
00BA6:  DATA 45,54
00BA8:  DATA 54,49
00BAA:  DATA 4E,47
00BAC:  DATA 20,41
00BAE:  DATA 43,4B
00BB0:  DATA 20,46
00BB2:  DATA 72,6F
00BB4:  DATA 6D,20
00BB6:  DATA 4D,42
00BB8:  DATA 50,0D
00BBA:  DATA 0A,00
00BBC:  DATA 0D,0A
00BBE:  DATA 43,57
00BC0:  DATA 20,41
00BC2:  DATA 4E,53
00BC4:  DATA 3A,00
00BC6:  DATA 54,75
00BC8:  DATA 72,6E
00BCA:  DATA 20,4F
00BCC:  DATA 6E,20
00BCE:  DATA 41,44
00BD0:  DATA 43,53
00BD2:  DATA 20,0D
00BD4:  DATA 0A,00
00BD6:  DATA 52,65
00BD8:  DATA 63,65
00BDA:  DATA 69,76
00BDC:  DATA 65,64
00BDE:  DATA 20,41
00BE0:  DATA 43,4B
00BE2:  DATA 20,46
00BE4:  DATA 72,6F
00BE6:  DATA 6D,20
00BE8:  DATA 41,44
00BEA:  DATA 43,53
00BEC:  DATA 0D,0A
00BEE:  DATA 00,00
00BF0:  DATA 53,65
00BF2:  DATA 6E,74
00BF4:  DATA 20,54
00BF6:  DATA 4C,45
00BF8:  DATA 20,64
00BFA:  DATA 61,74
00BFC:  DATA 61,20
00BFE:  DATA 74,6F
00C00:  DATA 20,41
00C02:  DATA 44,43
00C04:  DATA 53,0D
00C06:  DATA 0A,00
00C08:  DATA 46,41
00C0A:  DATA 49,4C
00C0C:  DATA 55,52
00C0E:  DATA 45,44
00C10:  DATA 20,47
00C12:  DATA 45,54
00C14:  DATA 54,49
00C16:  DATA 4E,47
00C18:  DATA 20,41
00C1A:  DATA 43,4B
00C1C:  DATA 20,46
00C1E:  DATA 72,6F
00C20:  DATA 6D,20
00C22:  DATA 41,44
00C24:  DATA 43,53
00C26:  DATA 0D,0A
00C28:  DATA 00,00
00C2A:  DATA 54,75
00C2C:  DATA 72,6E
00C2E:  DATA 20,4F
00C30:  DATA 6E,20
00C32:  DATA 41,44
00C34:  DATA 43,53
00C36:  DATA 20,0D
00C38:  DATA 0A,00
00C3A:  DATA 52,65
00C3C:  DATA 63,65
00C3E:  DATA 69,76
00C40:  DATA 65,64
00C42:  DATA 20,41
00C44:  DATA 43,4B
00C46:  DATA 20,46
00C48:  DATA 72,6F
00C4A:  DATA 6D,20
00C4C:  DATA 41,44
00C4E:  DATA 43,53
00C50:  DATA 0D,0A
00C52:  DATA 00,00
00C54:  DATA 53,65
00C56:  DATA 6E,74
00C58:  DATA 20,4F
00C5A:  DATA 50,45
00C5C:  DATA 52,41
00C5E:  DATA 54,49
00C60:  DATA 4F,4E
00C62:  DATA 20,4D
00C64:  DATA 4F,44
00C66:  DATA 45,20
00C68:  DATA 74,6F
00C6A:  DATA 20,41
00C6C:  DATA 44,43
00C6E:  DATA 53,0D
00C70:  DATA 0A,00
00C72:  DATA 46,41
00C74:  DATA 49,4C
00C76:  DATA 55,52
00C78:  DATA 45,44
00C7A:  DATA 20,47
00C7C:  DATA 45,54
00C7E:  DATA 54,49
00C80:  DATA 4E,47
00C82:  DATA 20,41
00C84:  DATA 43,4B
00C86:  DATA 20,46
00C88:  DATA 72,6F
00C8A:  DATA 6D,20
00C8C:  DATA 41,44
00C8E:  DATA 43,53
00C90:  DATA 0D,0A
00C92:  DATA 00,00
00C94:  DATA 64,6F
00C96:  DATA 6E,65
00C98:  DATA 0D,0A
00C9A:  DATA 00,00
00C9C:  DATA 53,74
00C9E:  DATA 6F,70
00CA0:  DATA 20,41
00CA2:  DATA 44,43
00CA4:  DATA 53,20
00CA6:  DATA 4D,69
00CA8:  DATA 73,73
00CAA:  DATA 69,6F
00CAC:  DATA 6E,0D
00CAE:  DATA 0A,00
00CB0:  DATA 0D,0A
00CB2:  DATA 0D,0A
00CB4:  DATA 54,75
00CB6:  DATA 72,6E
00CB8:  DATA 65,64
00CBA:  DATA 5F,4F
00CBC:  DATA 46,46
00CBE:  DATA 5F,41
00CC0:  DATA 44,43
00CC2:  DATA 53,0D
00CC4:  DATA 0A,0D
00CC6:  DATA 0A,0D
00CC8:  DATA 0A,00
00CCA:  DATA 0D,0A
00CCC:  DATA 0D,0A
00CCE:  DATA 54,75
00CD0:  DATA 72,6E
00CD2:  DATA 65,64
00CD4:  DATA 5F,4F
00CD6:  DATA 4E,5F
00CD8:  DATA 41,44
00CDA:  DATA 43,53
00CDC:  DATA 0D,0A
00CDE:  DATA 0D,0A
00CE0:  DATA 0D,0A
00CE2:  DATA 00,00
00CE4:  DATA 4E,4F
00CE6:  DATA 20,44
00CE8:  DATA 41,54
00CEA:  DATA 41,0D
00CEC:  DATA 0A,00
00CEE:  MOVFF  FEA,3AA
00CF2:  MOVFF  FE9,3A9
00CF6:  MOVLB  3
00CF8:  SWAPF  xA3,W
00CFA:  IORLW  F0
00CFC:  MOVWF  xA5
00CFE:  ADDWF  xA5,F
00D00:  ADDLW  E2
00D02:  MOVWF  xA6
00D04:  ADDLW  32
00D06:  MOVWF  xA8
00D08:  MOVF   xA3,W
00D0A:  ANDLW  0F
00D0C:  ADDWF  xA6,F
00D0E:  ADDWF  xA6,F
00D10:  ADDWF  xA8,F
00D12:  ADDLW  E9
00D14:  MOVWF  xA7
00D16:  ADDWF  xA7,F
00D18:  ADDWF  xA7,F
00D1A:  SWAPF  xA2,W
00D1C:  ANDLW  0F
00D1E:  ADDWF  xA7,F
00D20:  ADDWF  xA8,F
00D22:  RLCF   xA7,F
00D24:  RLCF   xA8,F
00D26:  COMF   xA8,F
00D28:  RLCF   xA8,F
00D2A:  MOVF   xA2,W
00D2C:  ANDLW  0F
00D2E:  ADDWF  xA8,F
00D30:  RLCF   xA5,F
00D32:  MOVLW  07
00D34:  MOVWF  xA4
00D36:  MOVLW  0A
00D38:  DECF   xA7,F
00D3A:  ADDWF  xA8,F
00D3C:  BNC   0D38
00D3E:  DECF   xA6,F
00D40:  ADDWF  xA7,F
00D42:  BNC   0D3E
00D44:  DECF   xA5,F
00D46:  ADDWF  xA6,F
00D48:  BNC   0D44
00D4A:  DECF   xA4,F
00D4C:  ADDWF  xA5,F
00D4E:  BNC   0D4A
00D50:  MOVLW  03
00D52:  MOVWF  FEA
00D54:  MOVLW  A4
00D56:  MOVWF  FE9
00D58:  MOVLW  07
00D5A:  ANDWF  xA9,W
00D5C:  BCF    xA9.6
00D5E:  ADDWF  FE9,F
00D60:  MOVLW  00
00D62:  ADDWFC FEA,F
00D64:  MOVF   FE9,W
00D66:  SUBLW  A8
00D68:  BNZ   0D72
00D6A:  MOVF   FEA,W
00D6C:  SUBLW  03
00D6E:  BNZ   0D72
00D70:  BSF    xA9.6
00D72:  MOVF   FEF,W
00D74:  MOVWF  00
00D76:  BNZ   0D88
00D78:  BTFSC  xA9.6
00D7A:  BRA    0D88
00D7C:  BTFSC  xA9.4
00D7E:  BRA    0D98
00D80:  BTFSC  xA9.3
00D82:  BRA    0D88
00D84:  MOVLW  20
00D86:  BRA    0D8E
00D88:  BSF    xA9.3
00D8A:  BCF    xA9.4
00D8C:  MOVLW  30
00D8E:  ADDWF  00,F
00D90:  MOVF   00,W
00D92:  BTFSS  F9E.4
00D94:  BRA    0D92
00D96:  MOVWF  FAD
00D98:  MOVF   FEE,W
00D9A:  BTFSS  xA9.6
00D9C:  BRA    0D64
00D9E:  MOVLB  0
00DA0:  RETURN 0
00DA2:  DATA 25,6C
00DA4:  DATA 75,64
00DA6:  DATA 2C,25
00DA8:  DATA 6C,75
00DAA:  DATA 64,0D
00DAC:  DATA 0A,00
00DAE:  DATA 67,69
00DB0:  DATA 76,69
00DB2:  DATA 6E,67
00DB4:  DATA 20,61
00DB6:  DATA 63,63
00DB8:  DATA 65,73
00DBA:  DATA 73,20
00DBC:  DATA 74,6F
00DBE:  DATA 20,43
00DC0:  DATA 4F,4D
00DC2:  DATA 20,66
00DC4:  DATA 6F,72
00DC6:  DATA 20,25
00DC8:  DATA 64,20
00DCA:  DATA 6D,69
00DCC:  DATA 6E,0D
00DCE:  DATA 0A,00
00DD0:  DATA 0D,0A
00DD2:  DATA 42,61
00DD4:  DATA 63,6B
00DD6:  DATA 20,74
00DD8:  DATA 6F,20
00DDA:  DATA 4E,6F
00DDC:  DATA 6D,61
00DDE:  DATA 6C,20
00DE0:  DATA 4F,70
00DE2:  DATA 65,72
00DE4:  DATA 61,74
00DE6:  DATA 69,6F
00DE8:  DATA 6E,0D
00DEA:  DATA 0A,00
00DEC:  DATA 43,75
00DEE:  DATA 72,72
00DF0:  DATA 65,6E
00DF2:  DATA 74,20
00DF4:  DATA 54,65
00DF6:  DATA 6D,70
00DF8:  DATA 3A,20
00DFA:  DATA 25,31
00DFC:  DATA 2E,31
00DFE:  DATA 66,0D
00E00:  DATA 0A,00
00E02:  DATA 54,75
00E04:  DATA 72,6E
00E06:  DATA 65,64
00E08:  DATA 20,4F
00E0A:  DATA 4E,20
00E0C:  DATA 42,43
00E0E:  DATA 0D,0A
00E10:  DATA 00,00
00E12:  DATA 54,75
00E14:  DATA 72,6E
00E16:  DATA 65,64
00E18:  DATA 20,4F
00E1A:  DATA 46,46
00E1C:  DATA 20,42
00E1E:  DATA 43,0D
00E20:  DATA 0A,00
00E22:  DATA 4D,41
00E24:  DATA 58,49
00E26:  DATA 4D,55
00E28:  DATA 4D,20
00E2A:  DATA 54,45
00E2C:  DATA 4D,50
00E2E:  DATA 45,52
00E30:  DATA 41,54
00E32:  DATA 55,52
00E34:  DATA 45,20
00E36:  DATA 69,73
00E38:  DATA 20,25
00E3A:  DATA 31,2E
00E3C:  DATA 31,66
00E3E:  DATA 0D,0A
00E40:  DATA 0D,0A
00E42:  DATA 00,00
00E44:  DATA 0D,0A
00E46:  DATA 42,43
00E48:  DATA 20,41
00E4A:  DATA 74,74
00E4C:  DATA 65,6D
00E4E:  DATA 70,74
00E50:  DATA 20,46
00E52:  DATA 6C,61
00E54:  DATA 67,20
00E56:  DATA 63,6C
00E58:  DATA 65,61
00E5A:  DATA 72,20
00E5C:  DATA 64,6F
00E5E:  DATA 6E,65
00E60:  DATA 0D,0A
00E62:  DATA 00,00
00E64:  DATA 0D,0A
00E66:  DATA 42,43
00E68:  DATA 20,41
00E6A:  DATA 74,74
00E6C:  DATA 65,6D
00E6E:  DATA 70,74
00E70:  DATA 20,46
00E72:  DATA 6C,61
00E74:  DATA 67,3A
00E76:  DATA 31,0D
00E78:  DATA 0A,00
00E7A:  DATA 0D,0A
00E7C:  DATA 42,43
00E7E:  DATA 20,41
00E80:  DATA 74,74
00E82:  DATA 65,6D
00E84:  DATA 70,74
00E86:  DATA 20,46
00E88:  DATA 6C,61
00E8A:  DATA 67,3A
00E8C:  DATA 32,0D
00E8E:  DATA 0A,00
00E90:  DATA 0D,0A
00E92:  DATA 42,43
00E94:  DATA 20,41
00E96:  DATA 74,74
00E98:  DATA 65,6D
00E9A:  DATA 70,74
00E9C:  DATA 20,46
00E9E:  DATA 6C,61
00EA0:  DATA 67,3A
00EA2:  DATA 33,0D
00EA4:  DATA 0A,00
00EA6:  DATA 0D,0A
00EA8:  DATA 42,43
00EAA:  DATA 20,41
00EAC:  DATA 74,74
00EAE:  DATA 65,6D
00EB0:  DATA 70,74
00EB2:  DATA 20,46
00EB4:  DATA 6C,61
00EB6:  DATA 67,3A
00EB8:  DATA 34,0D
00EBA:  DATA 0A,00
00EBC:  DATA 41,6E
00EBE:  DATA 74,20
00EC0:  DATA 44,65
00EC2:  DATA 70,20
00EC4:  DATA 41,74
00EC6:  DATA 74,65
00EC8:  DATA 6D,70
00ECA:  DATA 74,20
00ECC:  DATA 4E,6F
00ECE:  DATA 3A,20
00ED0:  DATA 25,78
00ED2:  DATA 0D,0A
00ED4:  DATA 00,00
00ED6:  DATA 42,43
00ED8:  DATA 20,63
00EDA:  DATA 6F,6D
00EDC:  DATA 6D,61
00EDE:  DATA 6E,64
00EE0:  DATA 20,73
00EE2:  DATA 65,6E
00EE4:  DATA 74,20
00EE6:  DATA 74,6F
00EE8:  DATA 20,52
00EEA:  DATA 45,53
00EEC:  DATA 45,54
00EEE:  DATA 20,50
00EF0:  DATA 49,43
00EF2:  DATA 0D,0A
00EF4:  DATA 00,00
00EF6:  DATA 0D,0A
00EF8:  DATA 41,44
00EFA:  DATA 43,53
00EFC:  DATA 20,44
00EFE:  DATA 41,54
00F00:  DATA 41,20
00F02:  DATA 72,65
00F04:  DATA 63,65
00F06:  DATA 69,76
00F08:  DATA 65,64
00F0A:  DATA 0D,0A
00F0C:  DATA 00,00
00F0E:  DATA 0D,0A
00F10:  DATA 41,44
00F12:  DATA 43,53
00F14:  DATA 20,44
00F16:  DATA 41,54
00F18:  DATA 41,20
00F1A:  DATA 6E,6F
00F1C:  DATA 74,20
00F1E:  DATA 72,65
00F20:  DATA 63,65
00F22:  DATA 69,76
00F24:  DATA 65,64
00F26:  DATA 0D,0A
00F28:  DATA 00,00
00F2A:  DATA 0D,0A
00F2C:  DATA 54,4C
00F2E:  DATA 45,3A
00F30:  DATA 0D,0A
00F32:  DATA 00,00
00F34:  DATA 0D,0A
00F36:  DATA 43,57
00F38:  DATA 20,53
00F3A:  DATA 41,56
00F3C:  DATA 45,44
00F3E:  DATA 0D,0A
00F40:  DATA 00,00
00F42:  DATA 47,45
00F44:  DATA 54,20
00F46:  DATA 53,45
00F48:  DATA 4E,53
00F4A:  DATA 4F,52
00F4C:  DATA 20,44
00F4E:  DATA 41,54
00F50:  DATA 41,0D
00F52:  DATA 0A,00
00F54:  DATA 0D,0A
00F56:  DATA 52,45
00F58:  DATA 53,45
00F5A:  DATA 54,20
00F5C:  DATA 44,41
00F5E:  DATA 54,41
00F60:  DATA 20,4F
00F62:  DATA 42,54
00F64:  DATA 41,49
00F66:  DATA 4E,45
00F68:  DATA 44,0D
00F6A:  DATA 0A,00
00F6C:  DATA 0D,0A
00F6E:  DATA 52,45
00F70:  DATA 53,45
00F72:  DATA 54,20
00F74:  DATA 44,41
00F76:  DATA 54,41
00F78:  DATA 20,4E
00F7A:  DATA 4F,20
00F7C:  DATA 4F,42
00F7E:  DATA 54,41
00F80:  DATA 49,4E
00F82:  DATA 45,44
00F84:  DATA 0D,0A
00F86:  DATA 00,00
00F88:  DATA 0D,0A
00F8A:  DATA 43,57
00F8C:  DATA 3A,0D
00F8E:  DATA 0A,00
00F90:  DATA 0D,0A
00F92:  DATA 43,6F
00F94:  DATA 6C,6C
00F96:  DATA 65,63
00F98:  DATA 74,69
00F9A:  DATA 6E,67
00F9C:  DATA 20,48
00F9E:  DATA 4B,20
00FA0:  DATA 61,6E
00FA2:  DATA 64,20
00FA4:  DATA 4D,61
00FA6:  DATA 6B,69
00FA8:  DATA 6E,67
00FAA:  DATA 20,43
00FAC:  DATA 57,46
00FAE:  DATA 6F,72
00FB0:  DATA 6D,61
00FB2:  DATA 74,20
00FB4:  DATA 44,6F
00FB6:  DATA 6E,65
00FB8:  DATA 0D,0A
00FBA:  DATA 00,00
00FBC:  DATA 0D,0A
00FBE:  DATA 48,4B
00FC0:  DATA 20,64
00FC2:  DATA 61,74
00FC4:  DATA 61,3A
00FC6:  DATA 0D,0A
00FC8:  DATA 00,00
00FCA:  DATA 0D,0A
00FCC:  DATA 53,45
00FCE:  DATA 4E,53
00FD0:  DATA 4F,52
00FD2:  DATA 53,20
00FD4:  DATA 44,41
00FD6:  DATA 54,41
00FD8:  DATA 20,53
00FDA:  DATA 41,56
00FDC:  DATA 45,44
00FDE:  DATA 20,4F
00FE0:  DATA 4E,20
00FE2:  DATA 46,4C
00FE4:  DATA 41,53
00FE6:  DATA 48,0D
00FE8:  DATA 0A,00
00FEA:  DATA 4E,4F
00FEC:  DATA 20,52
00FEE:  DATA 45,53
00FF0:  DATA 50,4F
00FF2:  DATA 4E,53
00FF4:  DATA 45,20
00FF6:  DATA 46,52
00FF8:  DATA 4F,4D
00FFA:  DATA 20,46
00FFC:  DATA 41,42
00FFE:  DATA 0D,0A
01000:  DATA 0D,0A
01002:  DATA 00,00
01004:  DATA 0D,0A
01006:  DATA 46,41
01008:  DATA 42,20
0100A:  DATA 44,41
0100C:  DATA 54,41
0100E:  DATA 20,4F
01010:  DATA 42,54
01012:  DATA 41,49
01014:  DATA 4E,45
01016:  DATA 44,0D
01018:  DATA 0A,00
0101A:  DATA 47,45
0101C:  DATA 54,20
0101E:  DATA 52,45
01020:  DATA 53,45
01022:  DATA 54,0D
01024:  DATA 0A,00
01026:  DATA 4E,4F
01028:  DATA 20,52
0102A:  DATA 45,53
0102C:  DATA 45,54
0102E:  DATA 0D,0A
01030:  DATA 00,00
01032:  DATA 0D,0A
01034:  DATA 39,30
01036:  DATA 73,65
01038:  DATA 63,0D
0103A:  DATA 0A,00
0103C:  DATA 0D,0A
0103E:  DATA 43,4F
01040:  DATA 55,4E
01042:  DATA 54,3A
01044:  DATA 25,64
01046:  DATA 0D,0A
01048:  DATA 00,00
0104A:  DATA 0D,0A
0104C:  DATA 43,4F
0104E:  DATA 55,4E
01050:  DATA 54,3A
01052:  DATA 25,64
01054:  DATA 0D,0A
01056:  DATA 00,00
01058:  DATA 43,6F
0105A:  DATA 6D,6D
0105C:  DATA 61,6E
0105E:  DATA 64,3A
01060:  DATA 25,78
01062:  DATA 0D,0A
01064:  DATA 00,00
01066:  DATA 43,41
01068:  DATA 4D,20
0106A:  DATA 53,74
0106C:  DATA 61,72
0106E:  DATA 74,20
01070:  DATA 6F,70
01072:  DATA 65,72
01074:  DATA 61,74
01076:  DATA 69,6F
01078:  DATA 6E,0D
0107A:  DATA 0A,00
0107C:  DATA 44,65
0107E:  DATA 6C,65
01080:  DATA 74,69
01082:  DATA 6E,67
01084:  DATA 20,31
01086:  DATA 20,73
01088:  DATA 65,63
0108A:  DATA 74,6F
0108C:  DATA 72,20
0108E:  DATA 53,4D
01090:  DATA 46,20
01092:  DATA 41,64
01094:  DATA 64,72
01096:  DATA 65,73
01098:  DATA 73,20
0109A:  DATA 30,30
0109C:  DATA 30,38
0109E:  DATA 30,30
010A0:  DATA 30,30
010A2:  DATA 0D,0A
010A4:  DATA 00,00
010A6:  DATA 54,75
010A8:  DATA 72,6E
010AA:  DATA 65,64
010AC:  DATA 20,4F
010AE:  DATA 6E,20
010B0:  DATA 43,41
010B2:  DATA 4D,20
010B4:  DATA 61,6E
010B6:  DATA 64,20
010B8:  DATA 4D,55
010BA:  DATA 58,20
010BC:  DATA 43,41
010BE:  DATA 4D,20
010C0:  DATA 73,69
010C2:  DATA 64,65
010C4:  DATA 0D,0A
010C6:  DATA 00,00
*
01112:  DATA 53,65
01114:  DATA 6E,64
01116:  DATA 69,6E
01118:  DATA 67,20
0111A:  DATA 68,61
0111C:  DATA 6E,64
0111E:  DATA 20,73
01120:  DATA 68,61
01122:  DATA 6B,65
01124:  DATA 20,43
01126:  DATA 6F,6D
01128:  DATA 6D,61
0112A:  DATA 6E,64
0112C:  DATA 20,74
0112E:  DATA 6F,20
01130:  DATA 43,41
01132:  DATA 4D,0D
01134:  DATA 0A,00
01136:  DATA 41,43
01138:  DATA 4B,20
0113A:  DATA 72,65
0113C:  DATA 63,65
0113E:  DATA 69,76
01140:  DATA 65,64
01142:  DATA 20,66
01144:  DATA 72,6F
01146:  DATA 6D,20
01148:  DATA 43,41
0114A:  DATA 4D,0D
0114C:  DATA 0A,0D
0114E:  DATA 0A,00
01150:  DATA 53,65
01152:  DATA 6E,64
01154:  DATA 69,6E
01156:  DATA 67,20
01158:  DATA 43,41
0115A:  DATA 4D,20
0115C:  DATA 4D,4F
0115E:  DATA 44,45
01160:  DATA 20,64
01162:  DATA 61,74
01164:  DATA 61,0D
01166:  DATA 0A,00
01168:  DATA 43,61
0116A:  DATA 70,74
0116C:  DATA 75,72
0116E:  DATA 69,6E
01170:  DATA 67,20
01172:  DATA 61,6E
01174:  DATA 64,20
01176:  DATA 73,61
01178:  DATA 76,69
0117A:  DATA 6E,67
0117C:  DATA 20,69
0117E:  DATA 6E,20
01180:  DATA 53,46
01182:  DATA 4D,2E
01184:  DATA 2E,2E
01186:  DATA 0D,0A
01188:  DATA 0D,0A
0118A:  DATA 00,00
0118C:  DATA 50,48
0118E:  DATA 4F,54
01190:  DATA 4F,20
01192:  DATA 53,41
01194:  DATA 56,49
01196:  DATA 4E,47
01198:  DATA 20,44
0119A:  DATA 4F,4E
0119C:  DATA 45,0D
0119E:  DATA 0A,00
011A0:  DATA 52,65
011A2:  DATA 61,64
011A4:  DATA 20,61
011A6:  DATA 6E,64
011A8:  DATA 20,54
011AA:  DATA 72,61
011AC:  DATA 6E,73
011AE:  DATA 66,65
011B0:  DATA 72,20
011B2:  DATA 64,61
011B4:  DATA 74,61
011B6:  DATA 20,66
011B8:  DATA 72,6F
011BA:  DATA 6D,20
011BC:  DATA 53,4D
011BE:  DATA 46,20
011C0:  DATA 54,4F
011C2:  DATA 20,53
011C4:  DATA 43,46
011C6:  DATA 20,61
011C8:  DATA 6E,64
011CA:  DATA 20,4F
011CC:  DATA 46,20
011CE:  DATA 53,74
011D0:  DATA 61,72
011D2:  DATA 74,0D
011D4:  DATA 0A,00
011D6:  DATA 43,41
011D8:  DATA 4D,20
011DA:  DATA 44,41
011DC:  DATA 54,41
011DE:  DATA 20,53
011E0:  DATA 41,56
011E2:  DATA 49,4E
011E4:  DATA 47,20
011E6:  DATA 46,41
011E8:  DATA 49,4C
011EA:  DATA 55,52
011EC:  DATA 45,44
011EE:  DATA 0D,0A
011F0:  DATA 00,00
011F2:  DATA 43,41
011F4:  DATA 4D,20
011F6:  DATA 41,43
011F8:  DATA 4B,20
011FA:  DATA 46,41
011FC:  DATA 49,4C
011FE:  DATA 55,52
01200:  DATA 45,44
01202:  DATA 0D,0A
01204:  DATA 00,00
01206:  DATA 54,75
01208:  DATA 72,6E
0120A:  DATA 65,64
0120C:  DATA 20,4F
0120E:  DATA 46,46
01210:  DATA 20,43
01212:  DATA 41,4D
01214:  DATA 0D,0A
01216:  DATA 00,00
01218:  DATA 53,65
0121A:  DATA 6E,64
0121C:  DATA 69,6E
0121E:  DATA 67,20
01220:  DATA 68,61
01222:  DATA 6E,64
01224:  DATA 20,73
01226:  DATA 68,61
01228:  DATA 6B,65
0122A:  DATA 20,43
0122C:  DATA 6F,6D
0122E:  DATA 6D,61
01230:  DATA 6E,64
01232:  DATA 20,74
01234:  DATA 6F,20
01236:  DATA 43,41
01238:  DATA 4D,0D
0123A:  DATA 0A,00
0123C:  DATA 41,43
0123E:  DATA 4B,20
01240:  DATA 72,65
01242:  DATA 63,65
01244:  DATA 69,76
01246:  DATA 65,64
01248:  DATA 20,66
0124A:  DATA 72,6F
0124C:  DATA 6D,20
0124E:  DATA 43,41
01250:  DATA 4D,0D
01252:  DATA 0A,0D
01254:  DATA 0A,00
01256:  DATA 53,65
01258:  DATA 6E,64
0125A:  DATA 69,6E
0125C:  DATA 67,20
0125E:  DATA 43,41
01260:  DATA 4D,20
01262:  DATA 4D,4F
01264:  DATA 44,45
01266:  DATA 20,64
01268:  DATA 61,74
0126A:  DATA 61,0D
0126C:  DATA 0A,00
0126E:  DATA 43,61
01270:  DATA 70,74
01272:  DATA 75,72
01274:  DATA 69,6E
01276:  DATA 67,20
01278:  DATA 61,6E
0127A:  DATA 64,20
0127C:  DATA 73,61
0127E:  DATA 76,69
01280:  DATA 6E,67
01282:  DATA 20,69
01284:  DATA 6E,20
01286:  DATA 53,46
01288:  DATA 4D,2E
0128A:  DATA 2E,2E
0128C:  DATA 0D,0A
0128E:  DATA 0D,0A
01290:  DATA 00,00
01292:  DATA 50,48
01294:  DATA 4F,54
01296:  DATA 4F,20
01298:  DATA 25,64
0129A:  DATA 20,53
0129C:  DATA 41,56
0129E:  DATA 49,4E
012A0:  DATA 47,20
012A2:  DATA 44,4F
012A4:  DATA 4E,45
012A6:  DATA 0D,0A
012A8:  DATA 00,00
012AA:  DATA 43,41
012AC:  DATA 4D,20
012AE:  DATA 44,41
012B0:  DATA 54,41
012B2:  DATA 20,53
012B4:  DATA 41,56
012B6:  DATA 49,4E
012B8:  DATA 47,20
012BA:  DATA 46,41
012BC:  DATA 49,4C
012BE:  DATA 55,52
012C0:  DATA 45,44
012C2:  DATA 0D,0A
012C4:  DATA 00,00
012C6:  DATA 43,41
012C8:  DATA 4D,20
012CA:  DATA 41,43
012CC:  DATA 4B,20
012CE:  DATA 46,41
012D0:  DATA 49,4C
012D2:  DATA 55,52
012D4:  DATA 45,44
012D6:  DATA 0D,0A
012D8:  DATA 00,00
012DA:  DATA 54,75
012DC:  DATA 72,6E
012DE:  DATA 65,64
012E0:  DATA 20,4F
012E2:  DATA 46,46
012E4:  DATA 20,43
012E6:  DATA 41,4D
012E8:  DATA 0D,0A
012EA:  DATA 00,00
012EC:  DATA 4B,69
012EE:  DATA 6C,6C
012F0:  DATA 20,63
012F2:  DATA 6F,75
012F4:  DATA 6E,74
012F6:  DATA 65,72
012F8:  DATA 3A,20
012FA:  DATA 25,78
012FC:  DATA 0D,0A
012FE:  DATA 00,00
01300:  DATA 4B,69
01302:  DATA 6C,6C
01304:  DATA 20,63
01306:  DATA 6F,75
01308:  DATA 6E,74
0130A:  DATA 65,72
0130C:  DATA 3A,20
0130E:  DATA 25,78
01310:  DATA 0D,0A
01312:  DATA 00,00
01314:  DATA 73,65
01316:  DATA 6E,64
01318:  DATA 69,6E
0131A:  DATA 67,20
0131C:  DATA 42,43
0131E:  DATA 20,63
01320:  DATA 6F,6D
01322:  DATA 6D,61
01324:  DATA 6E,64
01326:  DATA 20,74
01328:  DATA 6F,20
0132A:  DATA 52,45
0132C:  DATA 53,45
0132E:  DATA 54,20
01330:  DATA 50,49
01332:  DATA 43,0D
01334:  DATA 0A,00
01336:  DATA 48,53
01338:  DATA 53,43
0133A:  DATA 20,44
0133C:  DATA 4F,4E
0133E:  DATA 45,0D
01340:  DATA 0A,00
01342:  DATA 2C,41
01344:  DATA 55,54
01346:  DATA 4F,0D
01348:  DATA 0A,00
0134A:  DATA 2C,4E
0134C:  DATA 4F,52
0134E:  DATA 4D,41
01350:  DATA 4C,0D
01352:  DATA 0A,00
*
0156A:  CLRF   01
0156C:  CLRF   02
0156E:  CLRF   00
01570:  CLRF   03
01572:  MOVLB  3
01574:  MOVF   x87,W
01576:  BNZ   157C
01578:  MOVF   x86,W
0157A:  BZ    15AC
0157C:  MOVLW  10
0157E:  MOVWF  x88
01580:  BCF    FD8.0
01582:  RLCF   x84,F
01584:  RLCF   x85,F
01586:  RLCF   00,F
01588:  RLCF   03,F
0158A:  MOVF   x87,W
0158C:  SUBWF  03,W
0158E:  BNZ   1594
01590:  MOVF   x86,W
01592:  SUBWF  00,W
01594:  BNC   15A4
01596:  MOVF   x86,W
01598:  SUBWF  00,F
0159A:  BTFSS  FD8.0
0159C:  DECF   03,F
0159E:  MOVF   x87,W
015A0:  SUBWF  03,F
015A2:  BSF    FD8.0
015A4:  RLCF   01,F
015A6:  RLCF   02,F
015A8:  DECFSZ x88,F
015AA:  BRA    1580
015AC:  MOVLB  0
015AE:  RETURN 0
*
015BC:  DATA 53,65
015BE:  DATA 6E,74
015C0:  DATA 20,43
015C2:  DATA 4D,44
015C4:  DATA 20,48
015C6:  DATA 65,61
015C8:  DATA 74,65
015CA:  DATA 72,20
015CC:  DATA 4F,4E
015CE:  DATA 0D,0A
015D0:  DATA 00,00
015D2:  DATA 53,65
015D4:  DATA 6E,74
015D6:  DATA 20,43
015D8:  DATA 4D,44
015DA:  DATA 20,48
015DC:  DATA 65,61
015DE:  DATA 74,65
015E0:  DATA 72,20
015E2:  DATA 4F,46
015E4:  DATA 46,0D
015E6:  DATA 0A,00
015E8:  DATA 53,65
015EA:  DATA 6E,74
015EC:  DATA 20,43
015EE:  DATA 4D,44
015F0:  DATA 20,48
015F2:  DATA 65,61
015F4:  DATA 74,65
015F6:  DATA 72,20
015F8:  DATA 41,55
015FA:  DATA 54,4F
015FC:  DATA 0D,0A
015FE:  DATA 00,00
01600:  DATA 53,65
01602:  DATA 6E,74
01604:  DATA 20,43
01606:  DATA 4D,44
01608:  DATA 20,48
0160A:  DATA 65,61
0160C:  DATA 74,65
0160E:  DATA 72,20
01610:  DATA 4F,4E
01612:  DATA 0D,0A
01614:  DATA 00,00
01616:  DATA 53,65
01618:  DATA 6E,74
0161A:  DATA 20,43
0161C:  DATA 4D,44
0161E:  DATA 20,48
01620:  DATA 65,61
01622:  DATA 74,65
01624:  DATA 72,20
01626:  DATA 4F,46
01628:  DATA 46,0D
0162A:  DATA 0A,00
0162C:  DATA 53,65
0162E:  DATA 6E,74
01630:  DATA 20,43
01632:  DATA 4D,44
01634:  DATA 20,48
01636:  DATA 65,61
01638:  DATA 74,65
0163A:  DATA 72,20
0163C:  DATA 41,55
0163E:  DATA 54,4F
01640:  DATA 0D,0A
01642:  DATA 00,00
*
016F0:  MOVLB  3
016F2:  MOVF   x79,W
016F4:  CLRF   01
016F6:  SUBWF  x78,W
016F8:  BC    1700
016FA:  MOVFF  378,00
016FE:  BRA    1718
01700:  CLRF   00
01702:  MOVLW  08
01704:  MOVWF  x7A
01706:  RLCF   x78,F
01708:  RLCF   00,F
0170A:  MOVF   x79,W
0170C:  SUBWF  00,W
0170E:  BTFSC  FD8.0
01710:  MOVWF  00
01712:  RLCF   01,F
01714:  DECFSZ x7A,F
01716:  BRA    1706
01718:  MOVLB  0
0171A:  RETURN 0
*
01796:  DATA 53,74
01798:  DATA 61,72
0179A:  DATA 74,20
0179C:  DATA 4F,70
0179E:  DATA 65,72
017A0:  DATA 61,74
017A2:  DATA 69,6E
017A4:  DATA 67,0D
017A6:  DATA 0A,00
017A8:  DATA 0D,0A
017AA:  DATA 43,57
017AC:  DATA 3A,00
017AE:  DATA 0D,0A
017B0:  DATA 2A,2A
017B2:  DATA 2A,39
017B4:  DATA 30,73
017B6:  DATA 65,63
017B8:  DATA 20,70
017BA:  DATA 61,73
017BC:  DATA 73,65
017BE:  DATA 64,2A
017C0:  DATA 2A,2A
017C2:  DATA 0D,0A
017C4:  DATA 00,00
017C6:  DATA 43,57
017C8:  DATA 3A,00
017CA:  DATA 45,78
017CC:  DATA 65,63
017CE:  DATA 75,74
017D0:  DATA 65,20
017D2:  DATA 72,65
017D4:  DATA 73,65
017D6:  DATA 72,76
017D8:  DATA 65,64
017DA:  DATA 20,63
017DC:  DATA 6F,6D
017DE:  DATA 6D,61
017E0:  DATA 6E,64
017E2:  DATA 0D,0A
017E4:  DATA 00,00
017E6:  DATA 43,4F
017E8:  DATA 4D,20
017EA:  DATA 43,4F
017EC:  DATA 4D,4D
017EE:  DATA 41,4E
017F0:  DATA 44,3A
017F2:  DATA 0D,0A
017F4:  DATA 00,00
017F6:  DATA 43,4F
017F8:  DATA 4D,4D
017FA:  DATA 41,4E
017FC:  DATA 44,20
017FE:  DATA 52,45
01800:  DATA 43,45
01802:  DATA 49,56
01804:  DATA 45,44
01806:  DATA 20,46
01808:  DATA 52,4F
0180A:  DATA 4D,20
0180C:  DATA 50,43
0180E:  DATA 3A,20
01810:  DATA 00,00
*
01B3C:  MOVLW  8E
01B3E:  MOVWF  00
01B40:  MOVFF  347,01
01B44:  MOVFF  346,02
01B48:  CLRF   03
01B4A:  BTFSS  01.7
01B4C:  BRA    1B58
01B4E:  COMF   01,F
01B50:  COMF   02,F
01B52:  INCF   02,F
01B54:  BNZ   1B58
01B56:  INCF   01,F
01B58:  MOVF   01,F
01B5A:  BNZ   1B6E
01B5C:  MOVFF  02,01
01B60:  CLRF   02
01B62:  MOVLW  08
01B64:  SUBWF  00,F
01B66:  MOVF   01,F
01B68:  BNZ   1B6E
01B6A:  CLRF   00
01B6C:  BRA    1B8A
01B6E:  BCF    FD8.0
01B70:  BTFSC  01.7
01B72:  BRA    1B7C
01B74:  RLCF   02,F
01B76:  RLCF   01,F
01B78:  DECF   00,F
01B7A:  BRA    1B6E
01B7C:  MOVLB  3
01B7E:  BTFSS  x47.7
01B80:  BRA    1B86
01B82:  MOVLB  0
01B84:  BRA    1B8A
01B86:  BCF    01.7
01B88:  MOVLB  0
01B8A:  RETURN 0
01B8C:  MOVLB  3
01B8E:  MOVF   x4E,W
01B90:  BTFSC  FD8.2
01B92:  BRA    1C76
01B94:  MOVWF  00
01B96:  MOVF   x52,W
01B98:  BTFSC  FD8.2
01B9A:  BRA    1C76
01B9C:  ADDWF  00,F
01B9E:  BNC   1BA8
01BA0:  MOVLW  81
01BA2:  ADDWF  00,F
01BA4:  BC    1C76
01BA6:  BRA    1BB0
01BA8:  MOVLW  7F
01BAA:  SUBWF  00,F
01BAC:  BNC   1C76
01BAE:  BZ    1C76
01BB0:  MOVFF  34F,356
01BB4:  MOVF   x53,W
01BB6:  XORWF  x56,F
01BB8:  BSF    x4F.7
01BBA:  BSF    x53.7
01BBC:  MOVF   x51,W
01BBE:  MULWF  x55
01BC0:  MOVFF  FF4,358
01BC4:  MOVF   x50,W
01BC6:  MULWF  x54
01BC8:  MOVFF  FF4,03
01BCC:  MOVFF  FF3,357
01BD0:  MULWF  x55
01BD2:  MOVF   FF3,W
01BD4:  ADDWF  x58,F
01BD6:  MOVF   FF4,W
01BD8:  ADDWFC x57,F
01BDA:  MOVLW  00
01BDC:  ADDWFC 03,F
01BDE:  MOVF   x51,W
01BE0:  MULWF  x54
01BE2:  MOVF   FF3,W
01BE4:  ADDWF  x58,F
01BE6:  MOVF   FF4,W
01BE8:  ADDWFC x57,F
01BEA:  MOVLW  00
01BEC:  CLRF   02
01BEE:  ADDWFC 03,F
01BF0:  ADDWFC 02,F
01BF2:  MOVF   x4F,W
01BF4:  MULWF  x55
01BF6:  MOVF   FF3,W
01BF8:  ADDWF  x57,F
01BFA:  MOVF   FF4,W
01BFC:  ADDWFC 03,F
01BFE:  MOVLW  00
01C00:  ADDWFC 02,F
01C02:  MOVF   x4F,W
01C04:  MULWF  x54
01C06:  MOVF   FF3,W
01C08:  ADDWF  03,F
01C0A:  MOVF   FF4,W
01C0C:  ADDWFC 02,F
01C0E:  MOVLW  00
01C10:  CLRF   01
01C12:  ADDWFC 01,F
01C14:  MOVF   x51,W
01C16:  MULWF  x53
01C18:  MOVF   FF3,W
01C1A:  ADDWF  x57,F
01C1C:  MOVF   FF4,W
01C1E:  ADDWFC 03,F
01C20:  MOVLW  00
01C22:  ADDWFC 02,F
01C24:  ADDWFC 01,F
01C26:  MOVF   x50,W
01C28:  MULWF  x53
01C2A:  MOVF   FF3,W
01C2C:  ADDWF  03,F
01C2E:  MOVF   FF4,W
01C30:  ADDWFC 02,F
01C32:  MOVLW  00
01C34:  ADDWFC 01,F
01C36:  MOVF   x4F,W
01C38:  MULWF  x53
01C3A:  MOVF   FF3,W
01C3C:  ADDWF  02,F
01C3E:  MOVF   FF4,W
01C40:  ADDWFC 01,F
01C42:  INCF   00,F
01C44:  BTFSC  01.7
01C46:  BRA    1C52
01C48:  RLCF   x57,F
01C4A:  RLCF   03,F
01C4C:  RLCF   02,F
01C4E:  RLCF   01,F
01C50:  DECF   00,F
01C52:  MOVLW  00
01C54:  BTFSS  x57.7
01C56:  BRA    1C6C
01C58:  INCF   03,F
01C5A:  ADDWFC 02,F
01C5C:  ADDWFC 01,F
01C5E:  MOVF   01,W
01C60:  BNZ   1C6C
01C62:  MOVF   02,W
01C64:  BNZ   1C6C
01C66:  MOVF   03,W
01C68:  BNZ   1C6C
01C6A:  INCF   00,F
01C6C:  BTFSC  x56.7
01C6E:  BSF    01.7
01C70:  BTFSS  x56.7
01C72:  BCF    01.7
01C74:  BRA    1C7E
01C76:  CLRF   00
01C78:  CLRF   01
01C7A:  CLRF   02
01C7C:  CLRF   03
01C7E:  MOVLB  0
01C80:  RETURN 0
01C82:  MOVLW  80
01C84:  BTFSS  FD8.1
01C86:  BRA    1C8C
01C88:  MOVLB  3
01C8A:  XORWF  x4F,F
01C8C:  MOVLB  3
01C8E:  CLRF   x54
01C90:  CLRF   x55
01C92:  MOVFF  34B,353
01C96:  MOVF   x4F,W
01C98:  XORWF  x53,F
01C9A:  MOVF   x4A,W
01C9C:  BTFSC  FD8.2
01C9E:  BRA    1E5E
01CA0:  MOVWF  x52
01CA2:  MOVWF  00
01CA4:  MOVF   x4E,W
01CA6:  BTFSC  FD8.2
01CA8:  BRA    1E70
01CAA:  SUBWF  x52,F
01CAC:  BTFSC  FD8.2
01CAE:  BRA    1DB6
01CB0:  BNC   1D2E
01CB2:  MOVFF  34F,358
01CB6:  BSF    x58.7
01CB8:  MOVFF  350,357
01CBC:  MOVFF  351,356
01CC0:  CLRF   x55
01CC2:  BCF    FD8.0
01CC4:  RRCF   x58,F
01CC6:  RRCF   x57,F
01CC8:  RRCF   x56,F
01CCA:  RRCF   x55,F
01CCC:  DECFSZ x52,F
01CCE:  BRA    1CC0
01CD0:  BTFSS  x53.7
01CD2:  BRA    1CDA
01CD4:  BSF    x54.0
01CD6:  BRA    1E98
01CD8:  BCF    x54.0
01CDA:  BCF    x52.0
01CDC:  BSF    x54.4
01CDE:  MOVLW  03
01CE0:  MOVWF  FEA
01CE2:  MOVLW  4D
01CE4:  MOVWF  FE9
01CE6:  BRA    1EBE
01CE8:  BCF    x54.4
01CEA:  BTFSC  x53.7
01CEC:  BRA    1D02
01CEE:  BTFSS  x52.0
01CF0:  BRA    1D18
01CF2:  RRCF   x58,F
01CF4:  RRCF   x57,F
01CF6:  RRCF   x56,F
01CF8:  RRCF   x55,F
01CFA:  INCF   00,F
01CFC:  BTFSC  FD8.2
01CFE:  BRA    1E8E
01D00:  BRA    1D18
01D02:  BTFSC  x58.7
01D04:  BRA    1D1E
01D06:  BCF    FD8.0
01D08:  RLCF   x55,F
01D0A:  RLCF   x56,F
01D0C:  RLCF   x57,F
01D0E:  RLCF   x58,F
01D10:  DECF   00,F
01D12:  BTFSC  FD8.2
01D14:  BRA    1E8E
01D16:  BRA    1D02
01D18:  BSF    x54.6
01D1A:  BRA    1DF6
01D1C:  BCF    x54.6
01D1E:  MOVFF  34B,353
01D22:  BTFSS  x4B.7
01D24:  BRA    1D2A
01D26:  BSF    x58.7
01D28:  BRA    1E80
01D2A:  BCF    x58.7
01D2C:  BRA    1E80
01D2E:  MOVFF  34E,352
01D32:  MOVFF  34E,00
01D36:  MOVF   x4A,W
01D38:  SUBWF  x52,F
01D3A:  MOVFF  34B,358
01D3E:  BSF    x58.7
01D40:  MOVFF  34C,357
01D44:  MOVFF  34D,356
01D48:  CLRF   x55
01D4A:  BCF    FD8.0
01D4C:  RRCF   x58,F
01D4E:  RRCF   x57,F
01D50:  RRCF   x56,F
01D52:  RRCF   x55,F
01D54:  DECFSZ x52,F
01D56:  BRA    1D48
01D58:  BTFSS  x53.7
01D5A:  BRA    1D62
01D5C:  BSF    x54.1
01D5E:  BRA    1E98
01D60:  BCF    x54.1
01D62:  BCF    x52.0
01D64:  BSF    x54.5
01D66:  MOVLW  03
01D68:  MOVWF  FEA
01D6A:  MOVLW  51
01D6C:  MOVWF  FE9
01D6E:  BRA    1EBE
01D70:  BCF    x54.5
01D72:  BTFSC  x53.7
01D74:  BRA    1D8A
01D76:  BTFSS  x52.0
01D78:  BRA    1DA0
01D7A:  RRCF   x58,F
01D7C:  RRCF   x57,F
01D7E:  RRCF   x56,F
01D80:  RRCF   x55,F
01D82:  INCF   00,F
01D84:  BTFSC  FD8.2
01D86:  BRA    1E8E
01D88:  BRA    1DA0
01D8A:  BTFSC  x58.7
01D8C:  BRA    1DA6
01D8E:  BCF    FD8.0
01D90:  RLCF   x55,F
01D92:  RLCF   x56,F
01D94:  RLCF   x57,F
01D96:  RLCF   x58,F
01D98:  DECF   00,F
01D9A:  BTFSC  FD8.2
01D9C:  BRA    1E8E
01D9E:  BRA    1D8A
01DA0:  BSF    x54.7
01DA2:  BRA    1DF6
01DA4:  BCF    x54.7
01DA6:  MOVFF  34F,353
01DAA:  BTFSS  x4F.7
01DAC:  BRA    1DB2
01DAE:  BSF    x58.7
01DB0:  BRA    1E80
01DB2:  BCF    x58.7
01DB4:  BRA    1E80
01DB6:  MOVFF  34F,358
01DBA:  BSF    x58.7
01DBC:  MOVFF  350,357
01DC0:  MOVFF  351,356
01DC4:  BTFSS  x53.7
01DC6:  BRA    1DD0
01DC8:  BCF    x58.7
01DCA:  BSF    x54.2
01DCC:  BRA    1E98
01DCE:  BCF    x54.2
01DD0:  CLRF   x55
01DD2:  BCF    x52.0
01DD4:  MOVLW  03
01DD6:  MOVWF  FEA
01DD8:  MOVLW  4D
01DDA:  MOVWF  FE9
01DDC:  BRA    1EBE
01DDE:  BTFSC  x53.7
01DE0:  BRA    1E1A
01DE2:  MOVFF  34B,353
01DE6:  BTFSS  x52.0
01DE8:  BRA    1DF6
01DEA:  RRCF   x58,F
01DEC:  RRCF   x57,F
01DEE:  RRCF   x56,F
01DF0:  RRCF   x55,F
01DF2:  INCF   00,F
01DF4:  BZ    1E8E
01DF6:  BTFSS  x55.7
01DF8:  BRA    1E10
01DFA:  INCF   x56,F
01DFC:  BNZ   1E10
01DFE:  INCF   x57,F
01E00:  BNZ   1E10
01E02:  INCF   x58,F
01E04:  BNZ   1E10
01E06:  RRCF   x58,F
01E08:  RRCF   x57,F
01E0A:  RRCF   x56,F
01E0C:  INCF   00,F
01E0E:  BZ    1E8E
01E10:  BTFSC  x54.6
01E12:  BRA    1D1C
01E14:  BTFSC  x54.7
01E16:  BRA    1DA4
01E18:  BRA    1E52
01E1A:  MOVLW  80
01E1C:  XORWF  x58,F
01E1E:  BTFSS  x58.7
01E20:  BRA    1E2A
01E22:  BRA    1E98
01E24:  MOVFF  34F,353
01E28:  BRA    1E3E
01E2A:  MOVFF  34B,353
01E2E:  MOVF   x58,F
01E30:  BNZ   1E3E
01E32:  MOVF   x57,F
01E34:  BNZ   1E3E
01E36:  MOVF   x56,F
01E38:  BNZ   1E3E
01E3A:  CLRF   00
01E3C:  BRA    1E80
01E3E:  BTFSC  x58.7
01E40:  BRA    1E52
01E42:  BCF    FD8.0
01E44:  RLCF   x55,F
01E46:  RLCF   x56,F
01E48:  RLCF   x57,F
01E4A:  RLCF   x58,F
01E4C:  DECFSZ 00,F
01E4E:  BRA    1E3E
01E50:  BRA    1E8E
01E52:  BTFSS  x53.7
01E54:  BRA    1E5A
01E56:  BSF    x58.7
01E58:  BRA    1E80
01E5A:  BCF    x58.7
01E5C:  BRA    1E80
01E5E:  MOVFF  34E,00
01E62:  MOVFF  34F,358
01E66:  MOVFF  350,357
01E6A:  MOVFF  351,356
01E6E:  BRA    1E80
01E70:  MOVFF  34A,00
01E74:  MOVFF  34B,358
01E78:  MOVFF  34C,357
01E7C:  MOVFF  34D,356
01E80:  MOVFF  358,01
01E84:  MOVFF  357,02
01E88:  MOVFF  356,03
01E8C:  BRA    1EF6
01E8E:  CLRF   00
01E90:  CLRF   01
01E92:  CLRF   02
01E94:  CLRF   03
01E96:  BRA    1EF6
01E98:  CLRF   x55
01E9A:  COMF   x56,F
01E9C:  COMF   x57,F
01E9E:  COMF   x58,F
01EA0:  COMF   x55,F
01EA2:  INCF   x55,F
01EA4:  BNZ   1EB0
01EA6:  INCF   x56,F
01EA8:  BNZ   1EB0
01EAA:  INCF   x57,F
01EAC:  BNZ   1EB0
01EAE:  INCF   x58,F
01EB0:  BTFSC  x54.0
01EB2:  BRA    1CD8
01EB4:  BTFSC  x54.1
01EB6:  BRA    1D60
01EB8:  BTFSC  x54.2
01EBA:  BRA    1DCE
01EBC:  BRA    1E24
01EBE:  MOVF   FEF,W
01EC0:  ADDWF  x56,F
01EC2:  BNC   1ECE
01EC4:  INCF   x57,F
01EC6:  BNZ   1ECE
01EC8:  INCF   x58,F
01ECA:  BTFSC  FD8.2
01ECC:  BSF    x52.0
01ECE:  MOVF   FED,F
01ED0:  MOVF   FEF,W
01ED2:  ADDWF  x57,F
01ED4:  BNC   1EDC
01ED6:  INCF   x58,F
01ED8:  BTFSC  FD8.2
01EDA:  BSF    x52.0
01EDC:  MOVF   FED,F
01EDE:  MOVF   FEF,W
01EE0:  BTFSC  FEF.7
01EE2:  BRA    1EE6
01EE4:  XORLW  80
01EE6:  ADDWF  x58,F
01EE8:  BTFSC  FD8.0
01EEA:  BSF    x52.0
01EEC:  BTFSC  x54.4
01EEE:  BRA    1CE8
01EF0:  BTFSC  x54.5
01EF2:  BRA    1D70
01EF4:  BRA    1DDE
01EF6:  MOVLB  0
01EF8:  RETURN 0
01EFA:  MOVLW  8E
01EFC:  MOVWF  00
01EFE:  MOVLB  3
01F00:  MOVF   x46,W
01F02:  SUBWF  00,F
01F04:  MOVFF  347,02
01F08:  MOVFF  348,01
01F0C:  BSF    02.7
01F0E:  MOVF   00,F
01F10:  BZ    1F24
01F12:  BCF    FD8.0
01F14:  MOVF   02,F
01F16:  BNZ   1F1C
01F18:  MOVF   01,F
01F1A:  BZ    1F24
01F1C:  RRCF   02,F
01F1E:  RRCF   01,F
01F20:  DECFSZ 00,F
01F22:  BRA    1F12
01F24:  BTFSS  x47.7
01F26:  BRA    1F32
01F28:  COMF   01,F
01F2A:  COMF   02,F
01F2C:  INCF   01,F
01F2E:  BTFSC  FD8.2
01F30:  INCF   02,F
01F32:  MOVLB  0
01F34:  RETURN 0
01F36:  MOVLW  8E
01F38:  MOVWF  00
01F3A:  MOVFF  342,01
01F3E:  MOVFF  341,02
01F42:  CLRF   03
01F44:  MOVF   01,F
01F46:  BNZ   1F5A
01F48:  MOVFF  02,01
01F4C:  CLRF   02
01F4E:  MOVLW  08
01F50:  SUBWF  00,F
01F52:  MOVF   01,F
01F54:  BNZ   1F5A
01F56:  CLRF   00
01F58:  BRA    1F6A
01F5A:  BCF    FD8.0
01F5C:  BTFSC  01.7
01F5E:  BRA    1F68
01F60:  RLCF   02,F
01F62:  RLCF   01,F
01F64:  DECF   00,F
01F66:  BRA    1F5A
01F68:  BCF    01.7
01F6A:  GOTO   1A012 (RETURN)
01F6E:  MOVLB  3
01F70:  MOVF   x45,W
01F72:  BTFSC  FD8.2
01F74:  BRA    20C0
01F76:  MOVWF  x51
01F78:  MOVF   x49,W
01F7A:  BTFSC  FD8.2
01F7C:  BRA    20C0
01F7E:  SUBWF  x51,F
01F80:  BNC   1F8C
01F82:  MOVLW  7F
01F84:  ADDWF  x51,F
01F86:  BTFSC  FD8.0
01F88:  BRA    20C0
01F8A:  BRA    1F98
01F8C:  MOVLW  81
01F8E:  SUBWF  x51,F
01F90:  BTFSS  FD8.0
01F92:  BRA    20C0
01F94:  BTFSC  FD8.2
01F96:  BRA    20C0
01F98:  MOVFF  351,00
01F9C:  CLRF   01
01F9E:  CLRF   02
01FA0:  CLRF   03
01FA2:  CLRF   x50
01FA4:  MOVFF  346,34F
01FA8:  BSF    x4F.7
01FAA:  MOVFF  347,34E
01FAE:  MOVFF  348,34D
01FB2:  MOVLW  19
01FB4:  MOVWF  x51
01FB6:  MOVF   x4C,W
01FB8:  SUBWF  x4D,F
01FBA:  BC    1FD6
01FBC:  MOVLW  01
01FBE:  SUBWF  x4E,F
01FC0:  BC    1FD6
01FC2:  SUBWF  x4F,F
01FC4:  BC    1FD6
01FC6:  SUBWF  x50,F
01FC8:  BC    1FD6
01FCA:  INCF   x50,F
01FCC:  INCF   x4F,F
01FCE:  INCF   x4E,F
01FD0:  MOVF   x4C,W
01FD2:  ADDWF  x4D,F
01FD4:  BRA    2026
01FD6:  MOVF   x4B,W
01FD8:  SUBWF  x4E,F
01FDA:  BC    2000
01FDC:  MOVLW  01
01FDE:  SUBWF  x4F,F
01FE0:  BC    2000
01FE2:  SUBWF  x50,F
01FE4:  BC    2000
01FE6:  INCF   x50,F
01FE8:  INCF   x4F,F
01FEA:  MOVF   x4B,W
01FEC:  ADDWF  x4E,F
01FEE:  MOVF   x4C,W
01FF0:  ADDWF  x4D,F
01FF2:  BNC   2026
01FF4:  INCF   x4E,F
01FF6:  BNZ   2026
01FF8:  INCF   x4F,F
01FFA:  BNZ   2026
01FFC:  INCF   x50,F
01FFE:  BRA    2026
02000:  MOVF   x4A,W
02002:  IORLW  80
02004:  SUBWF  x4F,F
02006:  BC    2024
02008:  MOVLW  01
0200A:  SUBWF  x50,F
0200C:  BC    2024
0200E:  INCF   x50,F
02010:  MOVF   x4A,W
02012:  IORLW  80
02014:  ADDWF  x4F,F
02016:  MOVF   x4B,W
02018:  ADDWF  x4E,F
0201A:  BNC   1FEE
0201C:  INCF   x4F,F
0201E:  BNZ   1FEE
02020:  INCF   x50,F
02022:  BRA    1FEE
02024:  BSF    03.0
02026:  DECFSZ x51,F
02028:  BRA    202C
0202A:  BRA    2042
0202C:  BCF    FD8.0
0202E:  RLCF   x4D,F
02030:  RLCF   x4E,F
02032:  RLCF   x4F,F
02034:  RLCF   x50,F
02036:  BCF    FD8.0
02038:  RLCF   03,F
0203A:  RLCF   02,F
0203C:  RLCF   01,F
0203E:  RLCF   x52,F
02040:  BRA    1FB6
02042:  BTFSS  x52.0
02044:  BRA    2052
02046:  BCF    FD8.0
02048:  RRCF   01,F
0204A:  RRCF   02,F
0204C:  RRCF   03,F
0204E:  RRCF   x52,F
02050:  BRA    2056
02052:  DECF   00,F
02054:  BZ    20C0
02056:  BTFSC  x52.7
02058:  BRA    2096
0205A:  BCF    FD8.0
0205C:  RLCF   x4D,F
0205E:  RLCF   x4E,F
02060:  RLCF   x4F,F
02062:  RLCF   x50,F
02064:  MOVF   x4C,W
02066:  SUBWF  x4D,F
02068:  BC    2078
0206A:  MOVLW  01
0206C:  SUBWF  x4E,F
0206E:  BC    2078
02070:  SUBWF  x4F,F
02072:  BC    2078
02074:  SUBWF  x50,F
02076:  BNC   20AC
02078:  MOVF   x4B,W
0207A:  SUBWF  x4E,F
0207C:  BC    2088
0207E:  MOVLW  01
02080:  SUBWF  x4F,F
02082:  BC    2088
02084:  SUBWF  x50,F
02086:  BNC   20AC
02088:  MOVF   x4A,W
0208A:  IORLW  80
0208C:  SUBWF  x4F,F
0208E:  BC    2096
02090:  MOVLW  01
02092:  SUBWF  x50,F
02094:  BNC   20AC
02096:  INCF   03,F
02098:  BNZ   20AC
0209A:  INCF   02,F
0209C:  BNZ   20AC
0209E:  INCF   01,F
020A0:  BNZ   20AC
020A2:  INCF   00,F
020A4:  BZ    20C0
020A6:  RRCF   01,F
020A8:  RRCF   02,F
020AA:  RRCF   03,F
020AC:  MOVFF  346,351
020B0:  MOVF   x4A,W
020B2:  XORWF  x51,F
020B4:  BTFSS  x51.7
020B6:  BRA    20BC
020B8:  BSF    01.7
020BA:  BRA    20C8
020BC:  BCF    01.7
020BE:  BRA    20C8
020C0:  CLRF   00
020C2:  CLRF   01
020C4:  CLRF   02
020C6:  CLRF   03
020C8:  MOVLB  0
020CA:  GOTO   1A07E (RETURN)
020CE:  MOVLB  3
020D0:  MOVF   x4E,W
020D2:  SUBLW  B6
020D4:  MOVWF  x4E
020D6:  CLRF   03
020D8:  MOVFF  34F,352
020DC:  BSF    x4F.7
020DE:  BCF    FD8.0
020E0:  RRCF   x4F,F
020E2:  RRCF   x50,F
020E4:  RRCF   x51,F
020E6:  RRCF   03,F
020E8:  RRCF   02,F
020EA:  RRCF   01,F
020EC:  RRCF   00,F
020EE:  DECFSZ x4E,F
020F0:  BRA    20DE
020F2:  BTFSS  x52.7
020F4:  BRA    210C
020F6:  COMF   00,F
020F8:  COMF   01,F
020FA:  COMF   02,F
020FC:  COMF   03,F
020FE:  INCF   00,F
02100:  BTFSC  FD8.2
02102:  INCF   01,F
02104:  BTFSC  FD8.2
02106:  INCF   02,F
02108:  BTFSC  FD8.2
0210A:  INCF   03,F
0210C:  MOVLB  0
0210E:  GOTO   21FC (RETURN)
02112:  BTFSC  FD8.1
02114:  BRA    211E
02116:  MOVLW  03
02118:  MOVWF  FEA
0211A:  MOVLW  56
0211C:  MOVWF  FE9
0211E:  CLRF   00
02120:  CLRF   01
02122:  CLRF   02
02124:  CLRF   03
02126:  MOVLB  3
02128:  CLRF   x56
0212A:  CLRF   x57
0212C:  CLRF   x58
0212E:  CLRF   x59
02130:  MOVF   x55,W
02132:  IORWF  x54,W
02134:  IORWF  x53,W
02136:  IORWF  x52,W
02138:  BZ    2192
0213A:  MOVLW  20
0213C:  MOVWF  x5A
0213E:  BCF    FD8.0
02140:  RLCF   x4E,F
02142:  RLCF   x4F,F
02144:  RLCF   x50,F
02146:  RLCF   x51,F
02148:  RLCF   x56,F
0214A:  RLCF   x57,F
0214C:  RLCF   x58,F
0214E:  RLCF   x59,F
02150:  MOVF   x55,W
02152:  SUBWF  x59,W
02154:  BNZ   2166
02156:  MOVF   x54,W
02158:  SUBWF  x58,W
0215A:  BNZ   2166
0215C:  MOVF   x53,W
0215E:  SUBWF  x57,W
02160:  BNZ   2166
02162:  MOVF   x52,W
02164:  SUBWF  x56,W
02166:  BNC   2186
02168:  MOVF   x52,W
0216A:  SUBWF  x56,F
0216C:  MOVF   x53,W
0216E:  BTFSS  FD8.0
02170:  INCFSZ x53,W
02172:  SUBWF  x57,F
02174:  MOVF   x54,W
02176:  BTFSS  FD8.0
02178:  INCFSZ x54,W
0217A:  SUBWF  x58,F
0217C:  MOVF   x55,W
0217E:  BTFSS  FD8.0
02180:  INCFSZ x55,W
02182:  SUBWF  x59,F
02184:  BSF    FD8.0
02186:  RLCF   00,F
02188:  RLCF   01,F
0218A:  RLCF   02,F
0218C:  RLCF   03,F
0218E:  DECFSZ x5A,F
02190:  BRA    213E
02192:  MOVFF  356,FEF
02196:  MOVFF  357,FEC
0219A:  MOVFF  358,FEC
0219E:  MOVFF  359,FEC
021A2:  MOVLB  0
021A4:  RETURN 0
021A6:  MOVF   FE9,W
021A8:  MOVLB  3
021AA:  MOVWF  x46
021AC:  MOVF   x45,W
021AE:  MOVWF  x48
021B0:  BZ    21E8
021B2:  MOVFF  344,351
021B6:  MOVFF  343,350
021BA:  MOVFF  342,34F
021BE:  MOVFF  341,34E
021C2:  CLRF   x55
021C4:  CLRF   x54
021C6:  MOVLW  20
021C8:  MOVWF  x53
021CA:  MOVLW  82
021CC:  MOVWF  x52
021CE:  MOVLB  0
021D0:  RCALL  1B8C
021D2:  MOVFF  03,344
021D6:  MOVFF  02,343
021DA:  MOVFF  01,342
021DE:  MOVFF  00,341
021E2:  MOVLB  3
021E4:  DECFSZ x48,F
021E6:  BRA    21B2
021E8:  MOVFF  344,351
021EC:  MOVFF  343,350
021F0:  MOVFF  342,34F
021F4:  MOVFF  341,34E
021F8:  MOVLB  0
021FA:  BRA    20CE
021FC:  MOVFF  03,344
02200:  MOVFF  02,343
02204:  MOVFF  01,342
02208:  MOVFF  00,341
0220C:  MOVLB  3
0220E:  BTFSS  x44.7
02210:  BRA    222C
02212:  DECF   x46,F
02214:  BSF    x46.5
02216:  COMF   x41,F
02218:  COMF   x42,F
0221A:  COMF   x43,F
0221C:  COMF   x44,F
0221E:  INCF   x41,F
02220:  BTFSC  FD8.2
02222:  INCF   x42,F
02224:  BTFSC  FD8.2
02226:  INCF   x43,F
02228:  BTFSC  FD8.2
0222A:  INCF   x44,F
0222C:  MOVLW  3B
0222E:  MOVWF  x4D
02230:  MOVLW  9A
02232:  MOVWF  x4C
02234:  MOVLW  CA
02236:  MOVWF  x4B
02238:  CLRF   x4A
0223A:  MOVLW  0A
0223C:  MOVWF  x48
0223E:  MOVF   x45,W
02240:  BTFSC  FD8.2
02242:  INCF   x46,F
02244:  BSF    FD8.1
02246:  MOVLW  03
02248:  MOVWF  FEA
0224A:  MOVLW  41
0224C:  MOVWF  FE9
0224E:  MOVFF  344,351
02252:  MOVFF  343,350
02256:  MOVFF  342,34F
0225A:  MOVFF  341,34E
0225E:  MOVFF  34D,355
02262:  MOVFF  34C,354
02266:  MOVFF  34B,353
0226A:  MOVFF  34A,352
0226E:  MOVLB  0
02270:  RCALL  2112
02272:  MOVF   01,W
02274:  MOVF   00,F
02276:  BNZ   229E
02278:  MOVLB  3
0227A:  INCF   x45,W
0227C:  SUBWF  x48,W
0227E:  BTFSS  FD8.2
02280:  BRA    2286
02282:  MOVLB  0
02284:  BRA    229E
02286:  MOVF   x46,W
02288:  BZ    22A4
0228A:  ANDLW  0F
0228C:  SUBWF  x48,W
0228E:  BZ    2292
02290:  BC    230A
02292:  BTFSC  x46.7
02294:  BRA    230A
02296:  BTFSC  x46.6
02298:  BRA    22A4
0229A:  MOVLW  20
0229C:  BRA    2300
0229E:  MOVLW  20
022A0:  MOVLB  3
022A2:  ANDWF  x46,F
022A4:  BTFSS  x46.5
022A6:  BRA    22C2
022A8:  BCF    x46.5
022AA:  MOVF   x45,W
022AC:  BTFSS  FD8.2
022AE:  DECF   x46,F
022B0:  MOVF   00,W
022B2:  MOVWF  x46
022B4:  MOVLW  2D
022B6:  BTFSS  F9E.4
022B8:  BRA    22B6
022BA:  MOVWF  FAD
022BC:  MOVF   x46,W
022BE:  MOVWF  00
022C0:  CLRF   x46
022C2:  MOVF   x45,W
022C4:  SUBWF  x48,W
022C6:  BNZ   22DE
022C8:  MOVF   00,W
022CA:  MOVWF  x46
022CC:  MOVLW  2E
022CE:  BTFSS  F9E.4
022D0:  BRA    22CE
022D2:  MOVWF  FAD
022D4:  MOVF   x46,W
022D6:  MOVWF  00
022D8:  MOVLW  20
022DA:  ANDWF  x46,F
022DC:  MOVLW  00
022DE:  MOVLW  30
022E0:  BTFSS  x46.5
022E2:  BRA    2300
022E4:  BCF    x46.5
022E6:  MOVF   x45,W
022E8:  BTFSS  FD8.2
022EA:  DECF   x46,F
022EC:  MOVF   00,W
022EE:  MOVWF  x46
022F0:  MOVLW  2D
022F2:  BTFSS  F9E.4
022F4:  BRA    22F2
022F6:  MOVWF  FAD
022F8:  MOVF   x46,W
022FA:  MOVWF  00
022FC:  CLRF   x46
022FE:  MOVLW  30
02300:  ADDWF  00,F
02302:  MOVF   00,W
02304:  BTFSS  F9E.4
02306:  BRA    2304
02308:  MOVWF  FAD
0230A:  BCF    FD8.1
0230C:  MOVFF  34D,351
02310:  MOVFF  34C,350
02314:  MOVFF  34B,34F
02318:  MOVFF  34A,34E
0231C:  CLRF   x55
0231E:  CLRF   x54
02320:  CLRF   x53
02322:  MOVLW  0A
02324:  MOVWF  x52
02326:  MOVLB  0
02328:  RCALL  2112
0232A:  MOVFF  03,34D
0232E:  MOVFF  02,34C
02332:  MOVFF  01,34B
02336:  MOVFF  00,34A
0233A:  MOVLB  3
0233C:  DECFSZ x48,F
0233E:  BRA    2244
02340:  MOVLB  0
02342:  RETURN 0
02344:  MOVFF  346,34D
02348:  MOVLB  3
0234A:  MOVF   x4A,W
0234C:  XORWF  x4D,F
0234E:  BTFSS  x4D.7
02350:  BRA    235C
02352:  BCF    FD8.2
02354:  BCF    FD8.0
02356:  BTFSC  x46.7
02358:  BSF    FD8.0
0235A:  BRA    23BA
0235C:  MOVFF  346,34D
02360:  MOVFF  349,34E
02364:  MOVF   x45,W
02366:  SUBWF  x4E,F
02368:  BZ    2376
0236A:  BTFSS  x4D.7
0236C:  BRA    23BA
0236E:  MOVF   FD8,W
02370:  XORLW  01
02372:  MOVWF  FD8
02374:  BRA    23BA
02376:  MOVFF  34A,34E
0237A:  MOVF   x46,W
0237C:  SUBWF  x4E,F
0237E:  BZ    238C
02380:  BTFSS  x4D.7
02382:  BRA    23BA
02384:  MOVF   FD8,W
02386:  XORLW  01
02388:  MOVWF  FD8
0238A:  BRA    23BA
0238C:  MOVFF  34B,34E
02390:  MOVF   x47,W
02392:  SUBWF  x4E,F
02394:  BZ    23A2
02396:  BTFSS  x4D.7
02398:  BRA    23BA
0239A:  MOVF   FD8,W
0239C:  XORLW  01
0239E:  MOVWF  FD8
023A0:  BRA    23BA
023A2:  MOVFF  34C,34E
023A6:  MOVF   x48,W
023A8:  SUBWF  x4E,F
023AA:  BZ    23B8
023AC:  BTFSS  x4D.7
023AE:  BRA    23BA
023B0:  MOVF   FD8,W
023B2:  XORLW  01
023B4:  MOVWF  FD8
023B6:  BRA    23BA
023B8:  BCF    FD8.0
023BA:  MOVLB  0
023BC:  RETURN 0
*
02404:  MOVLW  20
02406:  MOVLB  3
02408:  BTFSS  x3F.4
0240A:  MOVLW  30
0240C:  MOVWF  x40
0240E:  MOVFF  33E,00
02412:  BTFSS  x3E.7
02414:  BRA    2426
02416:  COMF   00,F
02418:  INCF   00,F
0241A:  MOVFF  00,33E
0241E:  MOVLW  2D
02420:  MOVWF  x40
02422:  BSF    x3F.7
02424:  BSF    x3F.0
02426:  MOVF   01,W
02428:  CLRF   1B
0242A:  BTFSC  FF2.7
0242C:  BSF    1B.7
0242E:  BCF    FF2.7
02430:  MOVFF  33E,378
02434:  MOVLW  64
02436:  MOVWF  x79
02438:  MOVLB  0
0243A:  CALL   16F0
0243E:  BTFSC  1B.7
02440:  BSF    FF2.7
02442:  MOVFF  00,33E
02446:  MOVLW  30
02448:  ADDWF  01,W
0244A:  MOVLB  3
0244C:  MOVWF  x41
0244E:  CLRF   1B
02450:  BTFSC  FF2.7
02452:  BSF    1B.7
02454:  BCF    FF2.7
02456:  MOVFF  33E,378
0245A:  MOVLW  0A
0245C:  MOVWF  x79
0245E:  MOVLB  0
02460:  CALL   16F0
02464:  BTFSC  1B.7
02466:  BSF    FF2.7
02468:  MOVLW  30
0246A:  ADDWF  00,W
0246C:  MOVLB  3
0246E:  MOVWF  x43
02470:  MOVLW  30
02472:  ADDWF  01,W
02474:  MOVWF  x42
02476:  MOVFF  340,00
0247A:  MOVLW  30
0247C:  SUBWF  x41,W
0247E:  BZ    2488
02480:  BSF    x3F.1
02482:  BTFSC  x3F.7
02484:  BSF    x3F.2
02486:  BRA    24AC
02488:  MOVFF  340,341
0248C:  MOVLW  20
0248E:  MOVWF  x40
02490:  MOVLW  30
02492:  SUBWF  x42,W
02494:  BZ    249E
02496:  BSF    x3F.0
02498:  BTFSC  x3F.7
0249A:  BSF    x3F.1
0249C:  BRA    24AC
0249E:  BTFSS  FD8.2
024A0:  BSF    x3F.0
024A2:  BNZ   24AC
024A4:  MOVFF  341,342
024A8:  MOVLW  20
024AA:  MOVWF  x41
024AC:  BTFSC  x3F.2
024AE:  BRA    24BA
024B0:  BTFSC  x3F.1
024B2:  BRA    24C2
024B4:  BTFSC  x3F.0
024B6:  BRA    24CA
024B8:  BRA    24D2
024BA:  MOVF   x40,W
024BC:  BTFSS  F9E.4
024BE:  BRA    24BC
024C0:  MOVWF  FAD
024C2:  MOVF   x41,W
024C4:  BTFSS  F9E.4
024C6:  BRA    24C4
024C8:  MOVWF  FAD
024CA:  MOVF   x42,W
024CC:  BTFSS  F9E.4
024CE:  BRA    24CC
024D0:  MOVWF  FAD
024D2:  MOVF   x43,W
024D4:  BTFSS  F9E.4
024D6:  BRA    24D4
024D8:  MOVWF  FAD
024DA:  MOVLB  0
024DC:  RETURN 0
024DE:  MOVLB  3
024E0:  CLRF   x3C
024E2:  CLRF   x3D
024E4:  MOVLW  01
024E6:  MOVWF  x3E
024E8:  CLRF   FDA
024EA:  CLRF   FD9
024EC:  MOVLW  03
024EE:  MOVWF  x41
024F0:  MOVLW  34
024F2:  MOVWF  x40
024F4:  MOVLW  03
024F6:  MOVWF  FEA
024F8:  MOVLW  38
024FA:  MOVWF  FE9
024FC:  MOVFF  341,FE2
02500:  MOVFF  340,FE1
02504:  MOVFF  33E,33F
02508:  BCF    FD8.0
0250A:  MOVF   FE5,W
0250C:  MULWF  FEE
0250E:  MOVF   FF3,W
02510:  ADDWFC x3C,F
02512:  MOVF   FF4,W
02514:  ADDWFC x3D,F
02516:  DECFSZ x3F,F
02518:  BRA    2508
0251A:  MOVFF  33C,FDE
0251E:  MOVFF  33D,33C
02522:  CLRF   x3D
02524:  BTFSC  FD8.0
02526:  INCF   x3D,F
02528:  INCF   x40,F
0252A:  BTFSC  FD8.2
0252C:  INCF   x41,F
0252E:  INCF   x3E,F
02530:  MOVF   x3E,W
02532:  SUBLW  05
02534:  BNZ   24F4
02536:  MOVLB  0
02538:  RETURN 0
0253A:  MOVLB  3
0253C:  MOVF   x42,W
0253E:  MULWF  x44
02540:  MOVFF  FF3,01
02544:  MOVFF  FF4,00
02548:  MULWF  x45
0254A:  MOVF   FF3,W
0254C:  ADDWF  00,F
0254E:  MOVF   x43,W
02550:  MULWF  x44
02552:  MOVF   FF3,W
02554:  ADDWFC 00,W
02556:  MOVWF  02
02558:  MOVLB  0
0255A:  RETURN 0
*
02582:  ADDWF  FE8,W
02584:  CLRF   FF7
02586:  RLCF   FF7,F
02588:  ADDLW  A3
0258A:  MOVWF  FF6
0258C:  MOVLW  25
0258E:  ADDWFC FF7,F
02590:  MOVLW  00
02592:  MOVWF  FF8
02594:  MOVWF  FFB
02596:  TBLRD*-
02598:  MOVF   FF5,W
0259A:  MOVWF  FFA
0259C:  TBLRD*
0259E:  MOVF   FF5,W
025A0:  MOVWF  FF9
025A2:  DATA F0,B0
025A4:  DATA F8,B0
025A6:  DATA 00,B1
025A8:  DATA 08,B1
025AA:  DATA 10,B1
025AC:  DATA 18,B1
025AE:  DATA 20,B1
025B0:  DATA 28,B1
025B2:  DATA 30,B1
025B4:  DATA 38,B1
025B6:  DATA 40,B1
025B8:  DATA 48,B1
025BA:  DATA 50,B1
025BC:  DATA 58,B1
025BE:  DATA 60,B1
025C0:  MOVFF  FEA,353
025C4:  MOVFF  FE9,352
025C8:  MOVLB  3
025CA:  BTFSS  x4C.7
025CC:  BRA    25DE
025CE:  BSF    x52.7
025D0:  BTFSS  x52.4
025D2:  INCF   x52,F
025D4:  COMF   x4B,F
025D6:  COMF   x4C,F
025D8:  INCF   x4B,F
025DA:  BTFSC  FD8.2
025DC:  INCF   x4C,F
025DE:  SWAPF  x4C,W
025E0:  IORLW  F0
025E2:  MOVWF  x4E
025E4:  ADDWF  x4E,F
025E6:  ADDLW  E2
025E8:  MOVWF  x4F
025EA:  ADDLW  32
025EC:  MOVWF  x51
025EE:  MOVF   x4C,W
025F0:  ANDLW  0F
025F2:  ADDWF  x4F,F
025F4:  ADDWF  x4F,F
025F6:  ADDWF  x51,F
025F8:  ADDLW  E9
025FA:  MOVWF  x50
025FC:  ADDWF  x50,F
025FE:  ADDWF  x50,F
02600:  SWAPF  x4B,W
02602:  ANDLW  0F
02604:  ADDWF  x50,F
02606:  ADDWF  x51,F
02608:  RLCF   x50,F
0260A:  RLCF   x51,F
0260C:  COMF   x51,F
0260E:  RLCF   x51,F
02610:  MOVF   x4B,W
02612:  ANDLW  0F
02614:  ADDWF  x51,F
02616:  RLCF   x4E,F
02618:  MOVLW  07
0261A:  MOVWF  x4D
0261C:  MOVLW  0A
0261E:  DECF   x50,F
02620:  ADDWF  x51,F
02622:  BNC   261E
02624:  DECF   x4F,F
02626:  ADDWF  x50,F
02628:  BNC   2624
0262A:  DECF   x4E,F
0262C:  ADDWF  x4F,F
0262E:  BNC   262A
02630:  DECF   x4D,F
02632:  ADDWF  x4E,F
02634:  BNC   2630
02636:  MOVLW  03
02638:  MOVWF  FEA
0263A:  MOVLW  4D
0263C:  MOVWF  FE9
0263E:  MOVLW  07
02640:  ANDWF  x52,W
02642:  BCF    x52.6
02644:  MOVF   FED,F
02646:  ANDWF  x52,W
02648:  BNZ   2658
0264A:  BTFSC  x52.4
0264C:  MOVF   FEE,F
0264E:  BTFSC  x52.4
02650:  BRA    2658
02652:  MOVLW  20
02654:  MOVWF  00
02656:  BRA    269A
02658:  ADDWF  FE9,F
0265A:  MOVLW  00
0265C:  ADDWFC FEA,F
0265E:  MOVF   FE9,W
02660:  SUBLW  51
02662:  BNZ   266C
02664:  MOVF   FEA,W
02666:  SUBLW  03
02668:  BNZ   266C
0266A:  BSF    x52.6
0266C:  MOVF   FEF,W
0266E:  MOVWF  00
02670:  BNZ   2682
02672:  BTFSC  x52.6
02674:  BRA    2682
02676:  BTFSC  x52.4
02678:  BRA    26A2
0267A:  BTFSC  x52.3
0267C:  BRA    2682
0267E:  MOVLW  20
02680:  BRA    2698
02682:  BTFSS  x52.7
02684:  BRA    2692
02686:  MOVLW  2D
02688:  MOVWF  00
0268A:  MOVF   FED,W
0268C:  BCF    x52.6
0268E:  BCF    x52.7
02690:  BRA    269A
02692:  BSF    x52.3
02694:  BCF    x52.4
02696:  MOVLW  30
02698:  ADDWF  00,F
0269A:  MOVF   00,W
0269C:  BTFSS  F9E.4
0269E:  BRA    269C
026A0:  MOVWF  FAD
026A2:  MOVF   FEE,W
026A4:  BTFSS  x52.6
026A6:  BRA    265E
026A8:  MOVLB  0
026AA:  GOTO   138BA (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
.................... #FUSES NOWDT, NOBROWNOUT, NOPROTECT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
00526:  MOVLW  03
00528:  MOVWF  FEA
0052A:  MOVLW  98
0052C:  MOVWF  FE9
0052E:  MOVF   FEF,W
00530:  BZ    054E
00532:  MOVLW  05
00534:  MOVWF  01
00536:  CLRF   00
00538:  DECFSZ 00,F
0053A:  BRA    0538
0053C:  DECFSZ 01,F
0053E:  BRA    0536
00540:  MOVLW  2E
00542:  MOVWF  00
00544:  DECFSZ 00,F
00546:  BRA    0544
00548:  BRA    054A
0054A:  DECFSZ FEF,F
0054C:  BRA    0532
0054E:  RETURN 0
.................... #build(reset=0x2:0x9, interrupt=0xa:0xa+9) 
....................  
.................... //#include<HAMING_CORRECT.h> 
....................      
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------- 
....................  
.................... #pin_select TX1=PIN_C6                                                           //TX PIN EXT +/- 6v 
.................... #pin_select RX1=PIN_C7                                                           //RX PIN EXT +/- 6V 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc)                          // MAIN to Ext +/- 6v 
*
001D2:  BTFSS  F9E.4
001D4:  BRA    01D2
001D6:  MOVWF  FAD
001D8:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_B6,rcv=PIN_B7,bits=8,stream=pc)           //UART MAIN to ICSP, PGC and PGD pins 
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com)                           //UART Main to COM PIC 
*
01A0A:  BTFSS  FA4.4
01A0C:  BRA    1A0A
01A0E:  MOVLB  F
01A10:  MOVWF  x1D
01A12:  MOVLB  0
01A14:  RETURN 0
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab)                           //UART MAIN to FAB PIC 
*
01AB8:  BTFSS  FA6.4
01ABA:  BRA    1AB8
01ABC:  MOVLB  F
01ABE:  MOVWF  x29
01AC0:  MOVLB  0
01AC2:  RETURN 0
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset)                         //UART MAIN to RESET PIC 
*
015B0:  BTFSS  FA6.6
015B2:  BRA    15B0
015B4:  MOVLB  E
015B6:  MOVWF  xF9
015B8:  MOVLB  0
015BA:  RETURN 0
....................  
.................... #use rs232(baud=9600,parity=N,xmit=pin_F7,rcv=pin_F6,bits=8,stream=ADCS)         //UART MAIN to ADCS 
*
014DA:  BCF    F97.7
014DC:  BCF    F8E.7
014DE:  MOVLW  08
014E0:  MOVWF  01
014E2:  BRA    14E4
014E4:  NOP   
014E6:  BSF    01.7
014E8:  BRA    150A
014EA:  BCF    01.7
014EC:  MOVLB  3
014EE:  RRCF   x84,F
014F0:  MOVLB  0
014F2:  BTFSC  FD8.0
014F4:  BSF    F8E.7
014F6:  BTFSS  FD8.0
014F8:  BCF    F8E.7
014FA:  BSF    01.6
014FC:  BRA    150A
014FE:  BCF    01.6
01500:  DECFSZ 01,F
01502:  BRA    14EC
01504:  BRA    1506
01506:  NOP   
01508:  BSF    F8E.7
0150A:  MOVLW  84
0150C:  MOVWF  FE9
0150E:  DECFSZ FE9,F
01510:  BRA    150E
01512:  BRA    1514
01514:  NOP   
01516:  BTFSC  01.7
01518:  BRA    14EA
0151A:  BTFSC  01.6
0151C:  BRA    14FE
0151E:  RETURN 0
01520:  BSF    F97.6
01522:  BTFSC  F85.6
01524:  BRA    1522
01526:  MOVLW  08
01528:  MOVWF  00
0152A:  MOVLB  3
0152C:  CLRF   x88
0152E:  BSF    00.7
01530:  BRA    154E
01532:  BCF    00.7
01534:  BRA    154E
01536:  BCF    FD8.0
01538:  BTFSC  F85.6
0153A:  BSF    FD8.0
0153C:  RRCF   x88,F
0153E:  BSF    00.6
01540:  BRA    154E
01542:  BCF    00.6
01544:  DECFSZ 00,F
01546:  BRA    1536
01548:  MOVFF  388,01
0154C:  BRA    1566
0154E:  MOVLW  84
01550:  BTFSC  00.7
01552:  MOVLW  24
01554:  MOVWF  01
01556:  DECFSZ 01,F
01558:  BRA    1556
0155A:  BRA    155C
0155C:  BTFSC  00.7
0155E:  BRA    1532
01560:  BTFSC  00.6
01562:  BRA    1542
01564:  BRA    1536
01566:  MOVLB  0
01568:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=CAM)          //UART MAIN to CAM 
*
010C8:  BSF    F98.3
010CA:  BTFSC  F86.3
010CC:  BRA    10CA
010CE:  MOVLW  08
010D0:  MOVWF  00
010D2:  MOVLB  3
010D4:  CLRF   x81
010D6:  BSF    00.7
010D8:  BRA    10F6
010DA:  BCF    00.7
010DC:  BRA    10F6
010DE:  BCF    FD8.0
010E0:  BTFSC  F86.3
010E2:  BSF    FD8.0
010E4:  RRCF   x81,F
010E6:  BSF    00.6
010E8:  BRA    10F6
010EA:  BCF    00.6
010EC:  DECFSZ 00,F
010EE:  BRA    10DE
010F0:  MOVFF  381,01
010F4:  BRA    110E
010F6:  MOVLW  84
010F8:  BTFSC  00.7
010FA:  MOVLW  24
010FC:  MOVWF  01
010FE:  DECFSZ 01,F
01100:  BRA    10FE
01102:  BRA    1104
01104:  BTFSC  00.7
01106:  BRA    10DA
01108:  BTFSC  00.6
0110A:  BRA    10EA
0110C:  BRA    10DE
0110E:  MOVLB  0
01110:  RETURN 0
*
023BE:  BCF    F98.2
023C0:  BCF    F8F.2
023C2:  MOVLW  08
023C4:  MOVWF  01
023C6:  BRA    23C8
023C8:  NOP   
023CA:  BSF    01.7
023CC:  BRA    23EE
023CE:  BCF    01.7
023D0:  MOVLB  3
023D2:  RRCF   x39,F
023D4:  MOVLB  0
023D6:  BTFSC  FD8.0
023D8:  BSF    F8F.2
023DA:  BTFSS  FD8.0
023DC:  BCF    F8F.2
023DE:  BSF    01.6
023E0:  BRA    23EE
023E2:  BCF    01.6
023E4:  DECFSZ 01,F
023E6:  BRA    23D0
023E8:  BRA    23EA
023EA:  NOP   
023EC:  BSF    F8F.2
023EE:  MOVLW  84
023F0:  MOVWF  FE9
023F2:  DECFSZ FE9,F
023F4:  BRA    23F2
023F6:  BRA    23F8
023F8:  NOP   
023FA:  BTFSC  01.7
023FC:  BRA    23CE
023FE:  BTFSC  01.6
02400:  BRA    23E2
02402:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC)          //UART MAIN to MB DCM 
*
01A16:  BCF    F98.0
01A18:  BCF    F8F.0
01A1A:  MOVLW  08
01A1C:  MOVWF  01
01A1E:  BRA    1A20
01A20:  NOP   
01A22:  BSF    01.7
01A24:  BRA    1A46
01A26:  BCF    01.7
01A28:  MOVLB  3
01A2A:  RRCF   x4F,F
01A2C:  MOVLB  0
01A2E:  BTFSC  FD8.0
01A30:  BSF    F8F.0
01A32:  BTFSS  FD8.0
01A34:  BCF    F8F.0
01A36:  BSF    01.6
01A38:  BRA    1A46
01A3A:  BCF    01.6
01A3C:  DECFSZ 01,F
01A3E:  BRA    1A28
01A40:  BRA    1A42
01A42:  NOP   
01A44:  BSF    F8F.0
01A46:  MOVLW  84
01A48:  MOVWF  FE9
01A4A:  DECFSZ FE9,F
01A4C:  BRA    1A4A
01A4E:  BRA    1A50
01A50:  NOP   
01A52:  BTFSC  01.7
01A54:  BRA    1A26
01A56:  BTFSC  01.6
01A58:  BRA    1A3A
01A5A:  RETURN 0
01A5C:  BSF    F98.1
01A5E:  BTFSC  F86.1
01A60:  BRA    1A5E
01A62:  MOVLW  08
01A64:  MOVWF  00
01A66:  MOVLB  3
01A68:  CLRF   x53
01A6A:  BSF    00.7
01A6C:  BRA    1A8A
01A6E:  BCF    00.7
01A70:  BRA    1A8A
01A72:  BCF    FD8.0
01A74:  BTFSC  F86.1
01A76:  BSF    FD8.0
01A78:  RRCF   x53,F
01A7A:  BSF    00.6
01A7C:  BRA    1A8A
01A7E:  BCF    00.6
01A80:  DECFSZ 00,F
01A82:  BRA    1A72
01A84:  MOVFF  353,01
01A88:  BRA    1AA2
01A8A:  MOVLW  84
01A8C:  BTFSC  00.7
01A8E:  MOVLW  24
01A90:  MOVWF  01
01A92:  DECFSZ 01,F
01A94:  BRA    1A92
01A96:  BRA    1A98
01A98:  BTFSC  00.7
01A9A:  BRA    1A6E
01A9C:  BTFSC  00.6
01A9E:  BRA    1A7E
01AA0:  BRA    1A72
01AA2:  MOVLB  0
01AA4:  RETURN 0
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0)        //MAIN flash memory port 
*
004EA:  MOVLB  3
004EC:  MOVF   xB2,W
004EE:  SUBLW  08
004F0:  BZ    04FA
004F2:  MOVWF  xB3
004F4:  RLCF   xB1,F
004F6:  DECFSZ xB3,F
004F8:  BRA    04F4
004FA:  BSF    F96.0
004FC:  BCF    F96.6
004FE:  BCF    F96.1
00500:  BCF    F8D.1
00502:  MOVFF  3B2,3B3
00506:  BTFSS  xB1.7
00508:  BCF    F8D.6
0050A:  BTFSC  xB1.7
0050C:  BSF    F8D.6
0050E:  RLCF   xB1,F
00510:  BSF    F8D.1
00512:  RLCF   01,F
00514:  BTFSS  F84.0
00516:  BCF    01.0
00518:  BTFSC  F84.0
0051A:  BSF    01.0
0051C:  BCF    F8D.1
0051E:  DECFSZ xB3,F
00520:  BRA    0506
00522:  MOVLB  0
00524:  RETURN 0
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0)         //COM flash memory port 
*
00550:  MOVLB  3
00552:  MOVF   x9A,W
00554:  SUBLW  08
00556:  BZ    0560
00558:  MOVWF  x9B
0055A:  RLCF   x99,F
0055C:  DECFSZ x9B,F
0055E:  BRA    055A
00560:  BSF    F93.5
00562:  BCF    F93.4
00564:  BCF    F93.2
00566:  BCF    F8A.2
00568:  MOVFF  39A,39B
0056C:  BTFSS  x99.7
0056E:  BCF    F8A.4
00570:  BTFSC  x99.7
00572:  BSF    F8A.4
00574:  RLCF   x99,F
00576:  BSF    F8A.2
00578:  RLCF   01,F
0057A:  BTFSS  F81.5
0057C:  BCF    01.0
0057E:  BTFSC  F81.5
00580:  BSF    01.0
00582:  BCF    F8A.2
00584:  DECFSZ x9B,F
00586:  BRA    056C
00588:  MOVLB  0
0058A:  RETURN 0
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0)     //MISSION flash memory port 
*
00196:  MOVLB  3
00198:  MOVF   x9A,W
0019A:  SUBLW  08
0019C:  BZ    01A6
0019E:  MOVWF  x9B
001A0:  RLCF   x99,F
001A2:  DECFSZ x9B,F
001A4:  BRA    01A0
001A6:  BSF    F92.0
001A8:  BCF    F92.1
001AA:  BCF    F92.3
001AC:  BCF    F89.3
001AE:  MOVFF  39A,39B
001B2:  BTFSS  x99.7
001B4:  BCF    F89.1
001B6:  BTFSC  x99.7
001B8:  BSF    F89.1
001BA:  RLCF   x99,F
001BC:  BSF    F89.3
001BE:  RLCF   01,F
001C0:  BTFSS  F80.0
001C2:  BCF    01.0
001C4:  BTFSC  F80.0
001C6:  BSF    01.0
001C8:  BCF    F89.3
001CA:  DECFSZ x9B,F
001CC:  BRA    01B2
001CE:  MOVLB  0
001D0:  RETURN 0
....................  
.................... #ORG 0x0000C800, 0x0000EFFF {} 
.................... #ORG 0x0000F000, 0x000117FF {} 
.................... #ORG 0x00011800, 0x00013FFF {} 
.................... #ORG 0x00014000, 0x000167FF {} 
.................... #ORG 0x00016800, 0x00018FFF {} 
.................... #ORG 0x00019000, 0x0001B7FF {} 
.................... #ORG 0x0001B800, 0x0001DFFF {} 
.................... #ORG 0x0001E000, 0x0001FFEF {} 
.................... #endif 
....................  
.................... #include<mainpic_function.h> 
.................... #ifndef MAINPIC_FUNCTION_H 
.................... #define MAINPIC_FUNCTION_H 
....................  
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c>                                       //all flash memory 
.................... #ifndef FLASH_MEMORY_MT25QL01GBBB_OF_C 
.................... #define FLASH_MEMORY_MT25QL01GBBB_OF_C 
....................  
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
.................... #define DIE_ERASE            0xC4 
....................  
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_OF() 
.................... { 
....................    output_low(CS_PIN); 
*
118FA:  BCF    F96.2
118FC:  BCF    F8D.2
....................  
....................    spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
118FE:  MOVLW  06
11900:  MOVLB  3
11902:  MOVWF  xB1
11904:  MOVLW  08
11906:  MOVWF  xB2
11908:  MOVLB  0
1190A:  CALL   04EA
....................  
....................    output_high(CS_PIN); 
1190E:  BCF    F96.2
11910:  BSF    F8D.2
....................    return; 
11912:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_SCF() 
.................... { 
....................    output_low(CS_PIN_2); 
*
11A24:  BCF    F93.3
11A26:  BCF    F8A.3
....................  
....................    ///////////////////////////////////////////////////////////// 
....................    //delay_ms(2); 
....................    spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
11A28:  MOVLW  06
11A2A:  MOVLB  3
11A2C:  MOVWF  x99
11A2E:  MOVLW  08
11A30:  MOVWF  x9A
11A32:  MOVLB  0
11A34:  CALL   0550
....................    ///////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_2);   
11A38:  BCF    F93.3
11A3A:  BSF    F8A.3
....................    return; 
11A3C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_ENABLE_SMF() 
.................... { 
....................    output_low(CS_PIN_3); 
*
11B4E:  BCF    F92.2
11B50:  BCF    F89.2
....................  
....................    ///////////////////////////////////////////////////////////// 
....................    //delay_ms(2); 
....................    spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
11B52:  MOVLW  06
11B54:  MOVLB  3
11B56:  MOVWF  x99
11B58:  MOVLW  08
11B5A:  MOVWF  x9A
11B5C:  MOVLB  0
11B5E:  CALL   0196
....................    ///////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_3); 
11B62:  BCF    F92.2
11B64:  BSF    F89.2
....................    return; 
11B66:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_OF(unsigned int32 sector_address)                              //borra un sector de la flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
12550:  MOVLB  3
12552:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
12556:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
1255A:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
1255E:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_OF(); 
12562:  MOVLB  0
12564:  CALL   118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
12568:  BCF    F96.2
1256A:  BCF    F8D.2
....................    delay_us(2); 
1256C:  MOVLW  02
1256E:  MOVWF  00
12570:  DECFSZ 00,F
12572:  BRA    12570
12574:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR);                                               //SECTOR ERASE COMAND   (0xDC) 
12576:  MOVLW  DC
12578:  MOVLB  3
1257A:  MOVWF  xB1
1257C:  MOVLW  08
1257E:  MOVWF  xB2
12580:  MOVLB  0
12582:  CALL   04EA
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
12586:  MOVFF  38D,3B1
1258A:  MOVLW  08
1258C:  MOVLB  3
1258E:  MOVWF  xB2
12590:  MOVLB  0
12592:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[1]);     
12596:  MOVFF  38E,3B1
1259A:  MOVLW  08
1259C:  MOVLB  3
1259E:  MOVWF  xB2
125A0:  MOVLB  0
125A2:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[2]);     
125A6:  MOVFF  38F,3B1
125AA:  MOVLW  08
125AC:  MOVLB  3
125AE:  MOVWF  xB2
125B0:  MOVLB  0
125B2:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[3]); 
125B6:  MOVFF  390,3B1
125BA:  MOVLW  08
125BC:  MOVLB  3
125BE:  MOVWF  xB2
125C0:  MOVLB  0
125C2:  CALL   04EA
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
125C6:  MOVLW  02
125C8:  MOVWF  00
125CA:  DECFSZ 00,F
125CC:  BRA    125CA
125CE:  NOP   
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
125D0:  BCF    F96.2
125D2:  BSF    F8D.2
....................    //delay_ms(1000); 
....................    delay_ms(750); 
125D4:  MOVLW  03
125D6:  MOVLB  3
125D8:  MOVWF  x91
125DA:  MOVLW  FA
125DC:  MOVWF  x98
125DE:  MOVLB  0
125E0:  CALL   0526
125E4:  MOVLB  3
125E6:  DECFSZ x91,F
125E8:  BRA    125DA
....................     
....................    return; 
125EA:  MOVLB  0
125EC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
125EE:  MOVLB  3
125F0:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
125F4:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
125F8:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
125FC:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
12600:  MOVLB  0
12602:  CALL   11A24
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
12606:  BCF    F93.3
12608:  BCF    F8A.3
....................    delay_us(2); 
1260A:  MOVLW  02
1260C:  MOVWF  00
1260E:  DECFSZ 00,F
12610:  BRA    1260E
12612:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
12614:  MOVLW  DC
12616:  MOVLB  3
12618:  MOVWF  x99
1261A:  MOVLW  08
1261C:  MOVWF  x9A
1261E:  MOVLB  0
12620:  CALL   0550
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
12624:  MOVFF  38D,399
12628:  MOVLW  08
1262A:  MOVLB  3
1262C:  MOVWF  x9A
1262E:  MOVLB  0
12630:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[1]);     
12634:  MOVFF  38E,399
12638:  MOVLW  08
1263A:  MOVLB  3
1263C:  MOVWF  x9A
1263E:  MOVLB  0
12640:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[2]);     
12644:  MOVFF  38F,399
12648:  MOVLW  08
1264A:  MOVLB  3
1264C:  MOVWF  x9A
1264E:  MOVLB  0
12650:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[3]); 
12654:  MOVFF  390,399
12658:  MOVLW  08
1265A:  MOVLB  3
1265C:  MOVWF  x9A
1265E:  MOVLB  0
12660:  CALL   0550
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
12664:  MOVLW  02
12666:  MOVWF  00
12668:  DECFSZ 00,F
1266A:  BRA    12668
1266C:  NOP   
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
1266E:  BCF    F93.3
12670:  BSF    F8A.3
....................    //delay_ms(1000); 
....................    delay_ms(750); 
12672:  MOVLW  03
12674:  MOVLB  3
12676:  MOVWF  x91
12678:  MOVLW  FA
1267A:  MOVWF  x98
1267C:  MOVLB  0
1267E:  CALL   0526
12682:  MOVLB  3
12684:  DECFSZ x91,F
12686:  BRA    12678
....................     
....................    return; 
12688:  MOVLB  0
1268A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
1268C:  MOVLB  3
1268E:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
12692:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
12696:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
1269A:  MOVFF  389,390
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
1269E:  MOVLB  0
126A0:  CALL   11B4E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
126A4:  BCF    F92.2
126A6:  BCF    F89.2
....................    delay_us(2); 
126A8:  MOVLW  02
126AA:  MOVWF  00
126AC:  DECFSZ 00,F
126AE:  BRA    126AC
126B0:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
126B2:  MOVLW  DC
126B4:  MOVLB  3
126B6:  MOVWF  x99
126B8:  MOVLW  08
126BA:  MOVWF  x9A
126BC:  MOVLB  0
126BE:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
126C2:  MOVFF  38D,399
126C6:  MOVLW  08
126C8:  MOVLB  3
126CA:  MOVWF  x9A
126CC:  MOVLB  0
126CE:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
126D2:  MOVFF  38E,399
126D6:  MOVLW  08
126D8:  MOVLB  3
126DA:  MOVWF  x9A
126DC:  MOVLB  0
126DE:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
126E2:  MOVFF  38F,399
126E6:  MOVLW  08
126E8:  MOVLB  3
126EA:  MOVWF  x9A
126EC:  MOVLB  0
126EE:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
126F2:  MOVFF  390,399
126F6:  MOVLW  08
126F8:  MOVLB  3
126FA:  MOVWF  x9A
126FC:  MOVLB  0
126FE:  CALL   0196
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
12702:  MOVLW  02
12704:  MOVWF  00
12706:  DECFSZ 00,F
12708:  BRA    12706
1270A:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
1270C:  BCF    F92.2
1270E:  BSF    F89.2
....................    //delay_ms(1000);   
....................    delay_ms(750); 
12710:  MOVLW  03
12712:  MOVLB  3
12714:  MOVWF  x91
12716:  MOVLW  FA
12718:  MOVWF  x98
1271A:  MOVLB  0
1271C:  CALL   0526
12720:  MOVLB  3
12722:  DECFSZ x91,F
12724:  BRA    12716
....................    return; 
12726:  MOVLB  0
12728:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address)                       //Funcion que borra un sector de 4KB de la Main Flash 
.................... {                                                                                //Recibe la direccion del sector que se quiere borrar 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
11914:  MOVLB  3
11916:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
1191A:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
1191E:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
11922:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_OF();                                                            //Funcion que habilita escritura en Own Flash 
11926:  MOVLB  0
11928:  RCALL  118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
1192A:  BCF    F96.2
1192C:  BCF    F8D.2
....................    delay_us(2); 
1192E:  MOVLW  02
11930:  MOVWF  00
11932:  DECFSZ 00,F
11934:  BRA    11932
11936:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR);                                        //SECTOR ERASE COMAND   (0xDC) 
11938:  MOVLW  21
1193A:  MOVLB  3
1193C:  MOVWF  xB1
1193E:  MOVLW  08
11940:  MOVWF  xB2
11942:  MOVLB  0
11944:  CALL   04EA
....................     
....................    spi_xfer(SPIPORT,adsress[0]);                                                 //Se le pasa la direccion del sector a borrar 
11948:  MOVFF  393,3B1
1194C:  MOVLW  08
1194E:  MOVLB  3
11950:  MOVWF  xB2
11952:  MOVLB  0
11954:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[1]);     
11958:  MOVFF  394,3B1
1195C:  MOVLW  08
1195E:  MOVLB  3
11960:  MOVWF  xB2
11962:  MOVLB  0
11964:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[2]);     
11968:  MOVFF  395,3B1
1196C:  MOVLW  08
1196E:  MOVLB  3
11970:  MOVWF  xB2
11972:  MOVLB  0
11974:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[3]); 
11978:  MOVFF  396,3B1
1197C:  MOVLW  08
1197E:  MOVLB  3
11980:  MOVWF  xB2
11982:  MOVLB  0
11984:  CALL   04EA
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11988:  MOVLW  02
1198A:  MOVWF  00
1198C:  DECFSZ 00,F
1198E:  BRA    1198C
11990:  NOP   
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
11992:  BCF    F96.2
11994:  BSF    F8D.2
....................    delay_ms(100);   
11996:  MOVLW  64
11998:  MOVLB  3
1199A:  MOVWF  x98
1199C:  MOVLB  0
1199E:  CALL   0526
....................     
....................    return; 
119A2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
11A3E:  MOVLB  3
11A40:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
11A44:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
11A48:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
11A4C:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_SCF();                                                           //Funcion que habilita escritura en COM Flash 
11A50:  MOVLB  0
11A52:  RCALL  11A24
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
11A54:  BCF    F93.3
11A56:  BCF    F8A.3
....................    delay_us(2); 
11A58:  MOVLW  02
11A5A:  MOVWF  00
11A5C:  DECFSZ 00,F
11A5E:  BRA    11A5C
11A60:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
11A62:  MOVLW  21
11A64:  MOVLB  3
11A66:  MOVWF  x99
11A68:  MOVLW  08
11A6A:  MOVWF  x9A
11A6C:  MOVLB  0
11A6E:  CALL   0550
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
11A72:  MOVFF  393,399
11A76:  MOVLW  08
11A78:  MOVLB  3
11A7A:  MOVWF  x9A
11A7C:  MOVLB  0
11A7E:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[1]);     
11A82:  MOVFF  394,399
11A86:  MOVLW  08
11A88:  MOVLB  3
11A8A:  MOVWF  x9A
11A8C:  MOVLB  0
11A8E:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[2]);     
11A92:  MOVFF  395,399
11A96:  MOVLW  08
11A98:  MOVLB  3
11A9A:  MOVWF  x9A
11A9C:  MOVLB  0
11A9E:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[3]); 
11AA2:  MOVFF  396,399
11AA6:  MOVLW  08
11AA8:  MOVLB  3
11AAA:  MOVWF  x9A
11AAC:  MOVLB  0
11AAE:  CALL   0550
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11AB2:  MOVLW  02
11AB4:  MOVWF  00
11AB6:  DECFSZ 00,F
11AB8:  BRA    11AB6
11ABA:  NOP   
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
11ABC:  BCF    F93.3
11ABE:  BSF    F8A.3
....................    delay_ms(10);   
11AC0:  MOVLW  0A
11AC2:  MOVLB  3
11AC4:  MOVWF  x98
11AC6:  MOVLB  0
11AC8:  CALL   0526
....................     
....................    return; 
11ACC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
11B68:  MOVLB  3
11B6A:  MOVFF  392,393
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
11B6E:  MOVFF  391,394
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
11B72:  MOVFF  390,395
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
11B76:  MOVFF  38F,396
....................     
....................     
....................    WRITE_ENABLE_SMF();                                                           //Funcion que habilita escritura en Mission Flash 
11B7A:  MOVLB  0
11B7C:  RCALL  11B4E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
11B7E:  BCF    F92.2
11B80:  BCF    F89.2
....................    delay_us(2); 
11B82:  MOVLW  02
11B84:  MOVWF  00
11B86:  DECFSZ 00,F
11B88:  BRA    11B86
11B8A:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
11B8C:  MOVLW  21
11B8E:  MOVLB  3
11B90:  MOVWF  x99
11B92:  MOVLW  08
11B94:  MOVWF  x9A
11B96:  MOVLB  0
11B98:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
11B9C:  MOVFF  393,399
11BA0:  MOVLW  08
11BA2:  MOVLB  3
11BA4:  MOVWF  x9A
11BA6:  MOVLB  0
11BA8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
11BAC:  MOVFF  394,399
11BB0:  MOVLW  08
11BB2:  MOVLB  3
11BB4:  MOVWF  x9A
11BB6:  MOVLB  0
11BB8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
11BBC:  MOVFF  395,399
11BC0:  MOVLW  08
11BC2:  MOVLB  3
11BC4:  MOVWF  x9A
11BC6:  MOVLB  0
11BC8:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11BCC:  MOVFF  396,399
11BD0:  MOVLW  08
11BD2:  MOVLB  3
11BD4:  MOVWF  x9A
11BD6:  MOVLB  0
11BD8:  CALL   0196
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
11BDC:  MOVLW  02
11BDE:  MOVWF  00
11BE0:  DECFSZ 00,F
11BE2:  BRA    11BE0
11BE4:  NOP   
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
11BE6:  BCF    F92.2
11BE8:  BSF    F89.2
....................    delay_ms(1000);   
11BEA:  MOVLW  04
11BEC:  MOVLB  3
11BEE:  MOVWF  x97
11BF0:  MOVLW  FA
11BF2:  MOVWF  x98
11BF4:  MOVLB  0
11BF6:  CALL   0526
11BFA:  MOVLB  3
11BFC:  DECFSZ x97,F
11BFE:  BRA    11BF0
....................     
....................    return; 
11C00:  MOVLB  0
11C02:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data)                  //Funcion que escribe un Byte en la Main Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
119A4:  MOVLB  3
119A6:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
119AA:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
119AE:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
119B2:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_OF(); 
119B6:  MOVLB  0
119B8:  RCALL  118FA
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
119BA:  BCF    F96.2
119BC:  BCF    F8D.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE);                                                 //PAGE WRITE COMAND  (0x12) 
119BE:  MOVLW  12
119C0:  MOVLB  3
119C2:  MOVWF  xB1
119C4:  MOVLW  08
119C6:  MOVWF  xB2
119C8:  MOVLB  0
119CA:  CALL   04EA
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
119CE:  MOVFF  395,3B1
119D2:  MOVLW  08
119D4:  MOVLB  3
119D6:  MOVWF  xB2
119D8:  MOVLB  0
119DA:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[1]);     
119DE:  MOVFF  396,3B1
119E2:  MOVLW  08
119E4:  MOVLB  3
119E6:  MOVWF  xB2
119E8:  MOVLB  0
119EA:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[2]);     
119EE:  MOVFF  397,3B1
119F2:  MOVLW  08
119F4:  MOVLB  3
119F6:  MOVWF  xB2
119F8:  MOVLB  0
119FA:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[3]); 
119FE:  MOVFF  398,3B1
11A02:  MOVLW  08
11A04:  MOVLB  3
11A06:  MOVWF  xB2
11A08:  MOVLB  0
11A0A:  CALL   04EA
....................     
....................    spi_xfer(SPIPORT,data);  
11A0E:  MOVFF  394,3B1
11A12:  MOVLW  08
11A14:  MOVLB  3
11A16:  MOVWF  xB2
11A18:  MOVLB  0
11A1A:  CALL   04EA
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
11A1E:  BCF    F96.2
11A20:  BSF    F8D.2
....................  
....................    //delay_us(5);   
....................     
....................    return; 
11A22:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
11ACE:  MOVLB  3
11AD0:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
11AD4:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
11AD8:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
11ADC:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_SCF(); 
11AE0:  MOVLB  0
11AE2:  RCALL  11A24
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
11AE4:  BCF    F93.3
11AE6:  BCF    F8A.3
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
11AE8:  MOVLW  12
11AEA:  MOVLB  3
11AEC:  MOVWF  x99
11AEE:  MOVLW  08
11AF0:  MOVWF  x9A
11AF2:  MOVLB  0
11AF4:  CALL   0550
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
11AF8:  MOVFF  395,399
11AFC:  MOVLW  08
11AFE:  MOVLB  3
11B00:  MOVWF  x9A
11B02:  MOVLB  0
11B04:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[1]);     
11B08:  MOVFF  396,399
11B0C:  MOVLW  08
11B0E:  MOVLB  3
11B10:  MOVWF  x9A
11B12:  MOVLB  0
11B14:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[2]);     
11B18:  MOVFF  397,399
11B1C:  MOVLW  08
11B1E:  MOVLB  3
11B20:  MOVWF  x9A
11B22:  MOVLB  0
11B24:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[3]); 
11B28:  MOVFF  398,399
11B2C:  MOVLW  08
11B2E:  MOVLB  3
11B30:  MOVWF  x9A
11B32:  MOVLB  0
11B34:  CALL   0550
....................     
....................    spi_xfer(SPIPORT_2,data);  
11B38:  MOVFF  394,399
11B3C:  MOVLW  08
11B3E:  MOVLB  3
11B40:  MOVWF  x9A
11B42:  MOVLB  0
11B44:  CALL   0550
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
11B48:  BCF    F93.3
11B4A:  BSF    F8A.3
....................  
....................    //delay_us(5);   
....................     
....................    return; 
11B4C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
11C04:  MOVLB  3
11C06:  MOVFF  393,395
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
11C0A:  MOVFF  392,396
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
11C0E:  MOVFF  391,397
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
11C12:  MOVFF  390,398
....................     
....................    WRITE_ENABLE_SMF(); 
11C16:  MOVLB  0
11C18:  RCALL  11B4E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
11C1A:  BCF    F92.2
11C1C:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
11C1E:  MOVLW  12
11C20:  MOVLB  3
11C22:  MOVWF  x99
11C24:  MOVLW  08
11C26:  MOVWF  x9A
11C28:  MOVLB  0
11C2A:  CALL   0196
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
11C2E:  MOVFF  395,399
11C32:  MOVLW  08
11C34:  MOVLB  3
11C36:  MOVWF  x9A
11C38:  MOVLB  0
11C3A:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]);     
11C3E:  MOVFF  396,399
11C42:  MOVLW  08
11C44:  MOVLB  3
11C46:  MOVWF  x9A
11C48:  MOVLB  0
11C4A:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]);     
11C4E:  MOVFF  397,399
11C52:  MOVLW  08
11C54:  MOVLB  3
11C56:  MOVWF  x9A
11C58:  MOVLB  0
11C5A:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11C5E:  MOVFF  398,399
11C62:  MOVLW  08
11C64:  MOVLB  3
11C66:  MOVWF  x9A
11C68:  MOVLB  0
11C6A:  CALL   0196
....................     
....................    spi_xfer(SPIPORT_3,data);  
11C6E:  MOVFF  394,399
11C72:  MOVLW  08
11C74:  MOVLB  3
11C76:  MOVWF  x9A
11C78:  MOVLB  0
11C7A:  CALL   0196
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
11C7E:  BCF    F92.2
11C80:  BSF    F89.2
....................  
....................    //delay_us(10);   
....................     
....................    return; 
11C82:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
121C0:  MOVLB  3
121C2:  MOVFF  3AB,3AC
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
121C6:  MOVFF  3AA,3AD
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
121CA:  MOVFF  3A9,3AE
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
121CE:  MOVFF  3A8,3AF
....................  
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
121D2:  BCF    F96.2
121D4:  BCF    F8D.2
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
121D6:  MOVLW  13
121D8:  MOVWF  xB1
121DA:  MOVLW  08
121DC:  MOVWF  xB2
121DE:  MOVLB  0
121E0:  CALL   04EA
....................  
....................    spi_xfer(SPIPORT,adsress[0]); 
121E4:  MOVFF  3AC,3B1
121E8:  MOVLW  08
121EA:  MOVLB  3
121EC:  MOVWF  xB2
121EE:  MOVLB  0
121F0:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[1]); 
121F4:  MOVFF  3AD,3B1
121F8:  MOVLW  08
121FA:  MOVLB  3
121FC:  MOVWF  xB2
121FE:  MOVLB  0
12200:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[2]); 
12204:  MOVFF  3AE,3B1
12208:  MOVLW  08
1220A:  MOVLB  3
1220C:  MOVWF  xB2
1220E:  MOVLB  0
12210:  CALL   04EA
....................    spi_xfer(SPIPORT,adsress[3]); 
12214:  MOVFF  3AF,3B1
12218:  MOVLW  08
1221A:  MOVLB  3
1221C:  MOVWF  xB2
1221E:  MOVLB  0
12220:  CALL   04EA
....................    data = spi_xfer(SPIPORT); 
12224:  MOVLW  01
12226:  MOVLB  3
12228:  MOVWF  xB1
1222A:  MOVLW  08
1222C:  MOVWF  xB2
1222E:  MOVLB  0
12230:  CALL   04EA
12234:  MOVF   01,W
12236:  MOVFF  01,3B0
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
1223A:  BCF    F96.2
1223C:  BSF    F8D.2
....................    return data; 
1223E:  MOVLB  3
12240:  MOVFF  3B0,01
12244:  MOVLB  0
12246:  RETURN 0
....................  
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
12984:  MOVLB  3
12986:  MOVFF  352,353
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
1298A:  MOVFF  351,354
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
1298E:  MOVFF  350,355
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
12992:  MOVFF  34F,356
....................  
....................    output_low(CS_PIN_2);                                                           //lower the CS PIN 
12996:  BCF    F93.3
12998:  BCF    F8A.3
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT_2,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
1299A:  MOVLW  13
1299C:  MOVWF  x99
1299E:  MOVLW  08
129A0:  MOVWF  x9A
129A2:  MOVLB  0
129A4:  CALL   0550
....................  
....................    spi_xfer(SPIPORT_2,adsress[0]); 
129A8:  MOVFF  353,399
129AC:  MOVLW  08
129AE:  MOVLB  3
129B0:  MOVWF  x9A
129B2:  MOVLB  0
129B4:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[1]); 
129B8:  MOVFF  354,399
129BC:  MOVLW  08
129BE:  MOVLB  3
129C0:  MOVWF  x9A
129C2:  MOVLB  0
129C4:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[2]); 
129C8:  MOVFF  355,399
129CC:  MOVLW  08
129CE:  MOVLB  3
129D0:  MOVWF  x9A
129D2:  MOVLB  0
129D4:  CALL   0550
....................    spi_xfer(SPIPORT_2,adsress[3]); 
129D8:  MOVFF  356,399
129DC:  MOVLW  08
129DE:  MOVLB  3
129E0:  MOVWF  x9A
129E2:  MOVLB  0
129E4:  CALL   0550
....................    data = spi_xfer(SPIPORT_2); 
129E8:  MOVLW  02
129EA:  MOVLB  3
129EC:  MOVWF  x99
129EE:  MOVLW  08
129F0:  MOVWF  x9A
129F2:  MOVLB  0
129F4:  CALL   0550
129F8:  MOVF   01,W
129FA:  MOVFF  01,357
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_2);                                                          //take CS PIN higher back 
129FE:  BCF    F93.3
12A00:  BSF    F8A.3
....................    return data; 
12A02:  MOVLB  3
12A04:  MOVFF  357,01
12A08:  MOVLB  0
12A0A:  RETURN 0
....................   
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
11800:  MOVLB  3
11802:  MOVFF  38C,38D
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
11806:  MOVFF  38B,38E
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
1180A:  MOVFF  38A,38F
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
1180E:  MOVFF  389,390
....................     
....................    output_low(CS_PIN_3);                                                           //lower the CS PIN 
11812:  BCF    F92.2
11814:  BCF    F89.2
....................   
....................    ////////////////////////////////////////////////////////////////// 
....................    int8 data; 
....................    spi_xfer(SPIPORT_3,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
11816:  MOVLW  13
11818:  MOVWF  x99
1181A:  MOVLW  08
1181C:  MOVWF  x9A
1181E:  MOVLB  0
11820:  CALL   0196
....................  
....................    spi_xfer(SPIPORT_3,adsress[0]); 
11824:  MOVFF  38D,399
11828:  MOVLW  08
1182A:  MOVLB  3
1182C:  MOVWF  x9A
1182E:  MOVLB  0
11830:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[1]); 
11834:  MOVFF  38E,399
11838:  MOVLW  08
1183A:  MOVLB  3
1183C:  MOVWF  x9A
1183E:  MOVLB  0
11840:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[2]); 
11844:  MOVFF  38F,399
11848:  MOVLW  08
1184A:  MOVLB  3
1184C:  MOVWF  x9A
1184E:  MOVLB  0
11850:  CALL   0196
....................    spi_xfer(SPIPORT_3,adsress[3]); 
11854:  MOVFF  390,399
11858:  MOVLW  08
1185A:  MOVLB  3
1185C:  MOVWF  x9A
1185E:  MOVLB  0
11860:  CALL   0196
....................    data = spi_xfer(SPIPORT_3); 
11864:  MOVLW  03
11866:  MOVLB  3
11868:  MOVWF  x99
1186A:  MOVLW  08
1186C:  MOVWF  x9A
1186E:  MOVLB  0
11870:  CALL   0196
11874:  MOVF   01,W
11876:  MOVFF  01,391
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    output_high(CS_PIN_3);                                                          //take CS PIN higher back 
1187A:  BCF    F92.2
1187C:  BSF    F89.2
....................    return data; 
1187E:  MOVLB  3
11880:  MOVFF  391,01
11884:  MOVLB  0
11886:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte)          //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
134B2:  MOVLB  3
134B4:  CLRF   x4D
134B6:  CLRF   x4C
134B8:  CLRF   x4B
134BA:  CLRF   x4A
134BC:  MOVF   x4D,W
134BE:  SUBWF  x49,W
134C0:  BNC   13522
134C2:  BNZ   134DA
134C4:  MOVF   x4C,W
134C6:  SUBWF  x48,W
134C8:  BNC   13522
134CA:  BNZ   134DA
134CC:  MOVF   x4B,W
134CE:  SUBWF  x47,W
134D0:  BNC   13522
134D2:  BNZ   134DA
134D4:  MOVF   x46,W
134D6:  SUBWF  x4A,W
134D8:  BC    13522
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
134DA:  MOVFF  345,3AB
134DE:  MOVFF  344,3AA
134E2:  MOVFF  343,3A9
134E6:  MOVFF  342,3A8
134EA:  MOVLB  0
134EC:  CALL   121C0
134F0:  MOVFF  01,34E
134F4:  MOVLB  3
134F6:  MOVF   x4E,W
134F8:  MOVLB  0
134FA:  CALL   01D2
....................       ADRESS++; 
134FE:  MOVLW  01
13500:  MOVLB  3
13502:  ADDWF  x42,F
13504:  BTFSC  FD8.0
13506:  INCF   x43,F
13508:  BTFSC  FD8.2
1350A:  INCF   x44,F
1350C:  BTFSC  FD8.2
1350E:  INCF   x45,F
13510:  MOVLW  01
13512:  ADDWF  x4A,F
13514:  BTFSC  FD8.0
13516:  INCF   x4B,F
13518:  BTFSC  FD8.2
1351A:  INCF   x4C,F
1351C:  BTFSC  FD8.2
1351E:  INCF   x4D,F
13520:  BRA    134BC
....................    } 
....................    return; 
13522:  MOVLB  0
13524:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
1364A:  MOVLB  3
1364C:  CLRF   x43
1364E:  CLRF   x42
13650:  CLRF   x41
13652:  CLRF   x40
13654:  MOVF   x43,W
13656:  SUBWF  x3F,W
13658:  BNC   136C0
1365A:  BNZ   13672
1365C:  MOVF   x42,W
1365E:  SUBWF  x3E,W
13660:  BNC   136C0
13662:  BNZ   13672
13664:  MOVF   x41,W
13666:  SUBWF  x3D,W
13668:  BNC   136C0
1366A:  BNZ   13672
1366C:  MOVF   x3C,W
1366E:  SUBWF  x40,W
13670:  BC    136C0
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(ADRESS)); 
13672:  MOVFF  33B,352
13676:  MOVFF  33A,351
1367A:  MOVFF  339,350
1367E:  MOVFF  338,34F
13682:  MOVLB  0
13684:  CALL   12984
13688:  MOVFF  01,344
1368C:  MOVFF  01,3A2
13690:  MOVLW  57
13692:  MOVLB  3
13694:  MOVWF  xA3
13696:  MOVLB  0
13698:  CALL   0734
....................       ADRESS++; 
1369C:  MOVLW  01
1369E:  MOVLB  3
136A0:  ADDWF  x38,F
136A2:  BTFSC  FD8.0
136A4:  INCF   x39,F
136A6:  BTFSC  FD8.2
136A8:  INCF   x3A,F
136AA:  BTFSC  FD8.2
136AC:  INCF   x3B,F
136AE:  MOVLW  01
136B0:  ADDWF  x40,F
136B2:  BTFSC  FD8.0
136B4:  INCF   x41,F
136B6:  BTFSC  FD8.2
136B8:  INCF   x42,F
136BA:  BTFSC  FD8.2
136BC:  INCF   x43,F
136BE:  BRA    13654
....................    } 
....................    return; 
136C0:  MOVLB  0
136C2:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
11888:  MOVLB  3
1188A:  CLRF   x88
1188C:  CLRF   x87
1188E:  CLRF   x86
11890:  CLRF   x85
11892:  MOVF   x88,W
11894:  SUBWF  x84,W
11896:  BNC   118F6
11898:  BNZ   118B0
1189A:  MOVF   x87,W
1189C:  SUBWF  x83,W
1189E:  BNC   118F6
118A0:  BNZ   118B0
118A2:  MOVF   x86,W
118A4:  SUBWF  x82,W
118A6:  BNC   118F6
118A8:  BNZ   118B0
118AA:  MOVF   x81,W
118AC:  SUBWF  x85,W
118AE:  BC    118F6
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
118B0:  MOVFF  380,38C
118B4:  MOVFF  37F,38B
118B8:  MOVFF  37E,38A
118BC:  MOVFF  37D,389
118C0:  MOVLB  0
118C2:  RCALL  11800
118C4:  MOVFF  01,389
118C8:  MOVLB  3
118CA:  MOVF   x89,W
118CC:  MOVLB  0
118CE:  CALL   01D2
....................       ADRESS++; 
118D2:  MOVLW  01
118D4:  MOVLB  3
118D6:  ADDWF  x7D,F
118D8:  BTFSC  FD8.0
118DA:  INCF   x7E,F
118DC:  BTFSC  FD8.2
118DE:  INCF   x7F,F
118E0:  BTFSC  FD8.2
118E2:  INCF   x80,F
118E4:  MOVLW  01
118E6:  ADDWF  x85,F
118E8:  BTFSC  FD8.0
118EA:  INCF   x86,F
118EC:  BTFSC  FD8.2
118EE:  INCF   x87,F
118F0:  BTFSC  FD8.2
118F2:  INCF   x88,F
118F4:  BRA    11892
....................    } 
....................    return; 
118F6:  MOVLB  0
118F8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
135B8:  MOVLB  3
135BA:  CLRF   x47
135BC:  CLRF   x46
135BE:  CLRF   x45
135C0:  CLRF   x44
135C2:  MOVF   x47,W
135C4:  SUBWF  x43,W
135C6:  BNC   13646
135C8:  BNZ   135E0
135CA:  MOVF   x46,W
135CC:  SUBWF  x42,W
135CE:  BNC   13646
135D0:  BNZ   135E0
135D2:  MOVF   x45,W
135D4:  SUBWF  x41,W
135D6:  BNC   13646
135D8:  BNZ   135E0
135DA:  MOVF   x40,W
135DC:  SUBWF  x44,W
135DE:  BC    13646
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
135E0:  MOVFF  33B,38C
135E4:  MOVFF  33A,38B
135E8:  MOVFF  339,38A
135EC:  MOVFF  338,389
135F0:  MOVLB  0
135F2:  CALL   11800
135F6:  MOVFF  01,348
135FA:  MOVFF  33F,393
135FE:  MOVFF  33E,392
13602:  MOVFF  33D,391
13606:  MOVFF  33C,390
1360A:  MOVFF  01,394
1360E:  CALL   119A4
....................       FROM_ADRESS++; 
13612:  MOVLW  01
13614:  MOVLB  3
13616:  ADDWF  x38,F
13618:  BTFSC  FD8.0
1361A:  INCF   x39,F
1361C:  BTFSC  FD8.2
1361E:  INCF   x3A,F
13620:  BTFSC  FD8.2
13622:  INCF   x3B,F
....................       TO_ADRESS++; 
13624:  MOVLW  01
13626:  ADDWF  x3C,F
13628:  BTFSC  FD8.0
1362A:  INCF   x3D,F
1362C:  BTFSC  FD8.2
1362E:  INCF   x3E,F
13630:  BTFSC  FD8.2
13632:  INCF   x3F,F
13634:  MOVLW  01
13636:  ADDWF  x44,F
13638:  BTFSC  FD8.0
1363A:  INCF   x45,F
1363C:  BTFSC  FD8.2
1363E:  INCF   x46,F
13640:  BTFSC  FD8.2
13642:  INCF   x47,F
13644:  BRA    135C2
....................    } 
....................    return; 
13646:  MOVLB  0
13648:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
13526:  MOVLB  3
13528:  CLRF   x47
1352A:  CLRF   x46
1352C:  CLRF   x45
1352E:  CLRF   x44
13530:  MOVF   x47,W
13532:  SUBWF  x43,W
13534:  BNC   135B4
13536:  BNZ   1354E
13538:  MOVF   x46,W
1353A:  SUBWF  x42,W
1353C:  BNC   135B4
1353E:  BNZ   1354E
13540:  MOVF   x45,W
13542:  SUBWF  x41,W
13544:  BNC   135B4
13546:  BNZ   1354E
13548:  MOVF   x40,W
1354A:  SUBWF  x44,W
1354C:  BC    135B4
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
1354E:  MOVFF  33B,38C
13552:  MOVFF  33A,38B
13556:  MOVFF  339,38A
1355A:  MOVFF  338,389
1355E:  MOVLB  0
13560:  CALL   11800
13564:  MOVFF  01,348
13568:  MOVFF  33F,393
1356C:  MOVFF  33E,392
13570:  MOVFF  33D,391
13574:  MOVFF  33C,390
13578:  MOVFF  01,394
1357C:  CALL   11ACE
....................       FROM_ADRESS++; 
13580:  MOVLW  01
13582:  MOVLB  3
13584:  ADDWF  x38,F
13586:  BTFSC  FD8.0
13588:  INCF   x39,F
1358A:  BTFSC  FD8.2
1358C:  INCF   x3A,F
1358E:  BTFSC  FD8.2
13590:  INCF   x3B,F
....................       TO_ADRESS++; 
13592:  MOVLW  01
13594:  ADDWF  x3C,F
13596:  BTFSC  FD8.0
13598:  INCF   x3D,F
1359A:  BTFSC  FD8.2
1359C:  INCF   x3E,F
1359E:  BTFSC  FD8.2
135A0:  INCF   x3F,F
135A2:  MOVLW  01
135A4:  ADDWF  x44,F
135A6:  BTFSC  FD8.0
135A8:  INCF   x45,F
135AA:  BTFSC  FD8.2
135AC:  INCF   x46,F
135AE:  BTFSC  FD8.2
135B0:  INCF   x47,F
135B2:  BRA    13530
....................    } 
....................    return; 
135B4:  MOVLB  0
135B6:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<MEMORY_OPERATION.c> 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
*
12A12:  MOVLW  DA
12A14:  MOVWF  FF6
12A16:  MOVLW  01
12A18:  MOVWF  FF7
12A1A:  MOVLW  00
12A1C:  MOVWF  FF8
12A1E:  MOVLW  0E
12A20:  MOVLB  3
12A22:  MOVWF  xA2
12A24:  MOVLB  0
12A26:  CALL   0702
12A2A:  MOVFF  69,3A2
12A2E:  MOVLW  57
12A30:  MOVLB  3
12A32:  MOVWF  xA3
12A34:  MOVLB  0
12A36:  CALL   0734
12A3A:  MOVLW  0D
12A3C:  BTFSS  F9E.4
12A3E:  BRA    12A3C
12A40:  MOVWF  FAD
12A42:  MOVLW  0A
12A44:  BTFSS  F9E.4
12A46:  BRA    12A44
12A48:  MOVWF  FAD
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
12A4A:  MOVLW  EE
12A4C:  MOVWF  FF6
12A4E:  MOVLW  01
12A50:  MOVWF  FF7
12A52:  MOVLW  00
12A54:  MOVWF  FF8
12A56:  MOVLW  0E
12A58:  MOVLB  3
12A5A:  MOVWF  xA2
12A5C:  MOVLB  0
12A5E:  CALL   0702
12A62:  MOVFF  6B,3A2
12A66:  MOVLW  57
12A68:  MOVLB  3
12A6A:  MOVWF  xA3
12A6C:  MOVLB  0
12A6E:  CALL   0734
12A72:  MOVLW  0D
12A74:  BTFSS  F9E.4
12A76:  BRA    12A74
12A78:  MOVWF  FAD
12A7A:  MOVLW  0A
12A7C:  BTFSS  F9E.4
12A7E:  BRA    12A7C
12A80:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
12A82:  MOVLW  02
12A84:  MOVWF  FF6
12A86:  MOVLW  02
12A88:  MOVWF  FF7
12A8A:  MOVLW  00
12A8C:  MOVWF  FF8
12A8E:  MOVLW  0F
12A90:  MOVLB  3
12A92:  MOVWF  xA2
12A94:  MOVLB  0
12A96:  CALL   0702
12A9A:  MOVFF  75,3A2
12A9E:  MOVLW  57
12AA0:  MOVLB  3
12AA2:  MOVWF  xA3
12AA4:  MOVLB  0
12AA6:  CALL   0734
12AAA:  MOVLW  0D
12AAC:  BTFSS  F9E.4
12AAE:  BRA    12AAC
12AB0:  MOVWF  FAD
12AB2:  MOVLW  0A
12AB4:  BTFSS  F9E.4
12AB6:  BRA    12AB4
12AB8:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
12ABA:  MOVLW  16
12ABC:  MOVWF  FF6
12ABE:  MOVLW  02
12AC0:  MOVWF  FF7
12AC2:  MOVLW  00
12AC4:  MOVWF  FF8
12AC6:  MOVLW  0E
12AC8:  MOVLB  3
12ACA:  MOVWF  xA2
12ACC:  MOVLB  0
12ACE:  CALL   0702
12AD2:  MOVFF  76,3A2
12AD6:  MOVLW  57
12AD8:  MOVLB  3
12ADA:  MOVWF  xA3
12ADC:  MOVLB  0
12ADE:  CALL   0734
12AE2:  MOVLW  0D
12AE4:  BTFSS  F9E.4
12AE6:  BRA    12AE4
12AE8:  MOVWF  FAD
12AEA:  MOVLW  0A
12AEC:  BTFSS  F9E.4
12AEE:  BRA    12AEC
12AF0:  MOVWF  FAD
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
12AF2:  MOVLW  2A
12AF4:  MOVWF  FF6
12AF6:  MOVLW  02
12AF8:  MOVWF  FF7
12AFA:  MOVLW  00
12AFC:  MOVWF  FF8
12AFE:  MOVLW  13
12B00:  MOVLB  3
12B02:  MOVWF  xA2
12B04:  MOVLB  0
12B06:  CALL   0702
12B0A:  MOVFF  77,3A2
12B0E:  MOVLW  57
12B10:  MOVLB  3
12B12:  MOVWF  xA3
12B14:  MOVLB  0
12B16:  CALL   0734
12B1A:  MOVLW  0D
12B1C:  BTFSS  F9E.4
12B1E:  BRA    12B1C
12B20:  MOVWF  FAD
12B22:  MOVLW  0A
12B24:  BTFSS  F9E.4
12B26:  BRA    12B24
12B28:  MOVWF  FAD
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
12B2A:  MOVLW  42
12B2C:  MOVWF  FF6
12B2E:  MOVLW  02
12B30:  MOVWF  FF7
12B32:  MOVLW  00
12B34:  MOVWF  FF8
12B36:  MOVLW  09
12B38:  MOVLB  3
12B3A:  MOVWF  xA2
12B3C:  MOVLB  0
12B3E:  CALL   0702
12B42:  MOVFF  78,3A2
12B46:  MOVLW  57
12B48:  MOVLB  3
12B4A:  MOVWF  xA3
12B4C:  MOVLB  0
12B4E:  CALL   0734
12B52:  MOVLW  0D
12B54:  BTFSS  F9E.4
12B56:  BRA    12B54
12B58:  MOVWF  FAD
12B5A:  MOVLW  0A
12B5C:  BTFSS  F9E.4
12B5E:  BRA    12B5C
12B60:  MOVWF  FAD
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
12B62:  MOVLW  50
12B64:  MOVWF  FF6
12B66:  MOVLW  02
12B68:  MOVWF  FF7
12B6A:  MOVLW  00
12B6C:  MOVWF  FF8
12B6E:  MOVLW  09
12B70:  MOVLB  3
12B72:  MOVWF  xA2
12B74:  MOVLB  0
12B76:  CALL   0702
12B7A:  MOVFF  79,3A2
12B7E:  MOVLW  57
12B80:  MOVLB  3
12B82:  MOVWF  xA3
12B84:  MOVLB  0
12B86:  CALL   0734
12B8A:  MOVLW  0D
12B8C:  BTFSS  F9E.4
12B8E:  BRA    12B8C
12B90:  MOVWF  FAD
12B92:  MOVLW  0A
12B94:  BTFSS  F9E.4
12B96:  BRA    12B94
12B98:  MOVWF  FAD
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
12B9A:  MOVLW  5E
12B9C:  MOVWF  FF6
12B9E:  MOVLW  02
12BA0:  MOVWF  FF7
12BA2:  MOVLW  00
12BA4:  MOVWF  FF8
12BA6:  MOVLW  0A
12BA8:  MOVLB  3
12BAA:  MOVWF  xA2
12BAC:  MOVLB  0
12BAE:  CALL   0702
12BB2:  MOVFF  7A,3A2
12BB6:  MOVLW  57
12BB8:  MOVLB  3
12BBA:  MOVWF  xA3
12BBC:  MOVLB  0
12BBE:  CALL   0734
12BC2:  MOVLW  0D
12BC4:  BTFSS  F9E.4
12BC6:  BRA    12BC4
12BC8:  MOVWF  FAD
12BCA:  MOVLW  0A
12BCC:  BTFSS  F9E.4
12BCE:  BRA    12BCC
12BD0:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
12BD2:  MOVLW  6E
12BD4:  MOVWF  FF6
12BD6:  MOVLW  02
12BD8:  MOVWF  FF7
12BDA:  MOVLW  00
12BDC:  MOVWF  FF8
12BDE:  MOVLW  0F
12BE0:  MOVLB  3
12BE2:  MOVWF  xA2
12BE4:  MOVLB  0
12BE6:  CALL   0702
12BEA:  MOVFF  7B,3A2
12BEE:  MOVLW  57
12BF0:  MOVLB  3
12BF2:  MOVWF  xA3
12BF4:  MOVLB  0
12BF6:  CALL   0734
12BFA:  MOVLW  0D
12BFC:  BTFSS  F9E.4
12BFE:  BRA    12BFC
12C00:  MOVWF  FAD
12C02:  MOVLW  0A
12C04:  BTFSS  F9E.4
12C06:  BRA    12C04
12C08:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
12C0A:  MOVLW  82
12C0C:  MOVWF  FF6
12C0E:  MOVLW  02
12C10:  MOVWF  FF7
12C12:  MOVLW  00
12C14:  MOVWF  FF8
12C16:  MOVLW  17
12C18:  MOVLB  3
12C1A:  MOVWF  xA2
12C1C:  MOVLB  0
12C1E:  CALL   0702
12C22:  MOVFF  68,3A2
12C26:  MOVLW  57
12C28:  MOVLB  3
12C2A:  MOVWF  xA3
12C2C:  MOVLB  0
12C2E:  CALL   0734
12C32:  MOVLW  0D
12C34:  BTFSS  F9E.4
12C36:  BRA    12C34
12C38:  MOVWF  FAD
12C3A:  MOVLW  0A
12C3C:  BTFSS  F9E.4
12C3E:  BRA    12C3C
12C40:  MOVWF  FAD
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
12C42:  MOVLW  9E
12C44:  MOVWF  FF6
12C46:  MOVLW  02
12C48:  MOVWF  FF7
12C4A:  MOVLW  00
12C4C:  MOVWF  FF8
12C4E:  MOVLW  0F
12C50:  MOVLB  3
12C52:  MOVWF  xA2
12C54:  MOVLB  0
12C56:  CALL   0702
12C5A:  MOVFF  7C,3A2
12C5E:  MOVLW  57
12C60:  MOVLB  3
12C62:  MOVWF  xA3
12C64:  MOVLB  0
12C66:  CALL   0734
12C6A:  MOVLW  AF
12C6C:  MOVWF  FF6
12C6E:  MOVLW  02
12C70:  MOVWF  FF7
12C72:  MOVLW  00
12C74:  MOVWF  FF8
12C76:  MOVLW  04
12C78:  MOVLB  3
12C7A:  MOVWF  xA2
12C7C:  MOVLB  0
12C7E:  CALL   0702
....................    return; 
12C82:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
12C84:  MOVLW  B4
12C86:  MOVWF  FF6
12C88:  MOVLW  02
12C8A:  MOVWF  FF7
12C8C:  MOVLW  00
12C8E:  MOVWF  FF8
12C90:  MOVLW  13
12C92:  MOVLB  3
12C94:  MOVWF  xA2
12C96:  MOVLB  0
12C98:  CALL   0702
12C9C:  MOVFF  33,3A2
12CA0:  MOVLW  57
12CA2:  MOVLB  3
12CA4:  MOVWF  xA3
12CA6:  MOVLB  0
12CA8:  CALL   0734
12CAC:  MOVFF  32,3A2
12CB0:  MOVLW  57
12CB2:  MOVLB  3
12CB4:  MOVWF  xA3
12CB6:  MOVLB  0
12CB8:  CALL   0734
12CBC:  MOVFF  31,3A2
12CC0:  MOVLW  57
12CC2:  MOVLB  3
12CC4:  MOVWF  xA3
12CC6:  MOVLB  0
12CC8:  CALL   0734
12CCC:  MOVFF  30,3A2
12CD0:  MOVLW  57
12CD2:  MOVLB  3
12CD4:  MOVWF  xA3
12CD6:  MOVLB  0
12CD8:  CALL   0734
12CDC:  MOVLW  CA
12CDE:  MOVWF  FF6
12CE0:  MOVLW  02
12CE2:  MOVWF  FF7
12CE4:  MOVLW  00
12CE6:  MOVWF  FF8
12CE8:  MOVLW  04
12CEA:  MOVLB  3
12CEC:  MOVWF  xA2
12CEE:  MOVLB  0
12CF0:  CALL   0702
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
12CF4:  MOVFF  3B,32D
12CF8:  MOVLB  3
12CFA:  CLRF   x2E
12CFC:  CLRF   x2F
12CFE:  CLRF   x30
12D00:  MOVFF  3A,332
12D04:  MOVFF  3B,333
12D08:  CLRF   x34
12D0A:  CLRF   x35
12D0C:  MOVFF  39,337
12D10:  MOVFF  3A,338
12D14:  MOVFF  3B,339
12D18:  CLRF   x3A
12D1A:  MOVLW  D0
12D1C:  MOVWF  FF6
12D1E:  MOVLW  02
12D20:  MOVWF  FF7
12D22:  MOVLW  00
12D24:  MOVWF  FF8
12D26:  MOVLW  12
12D28:  MOVWF  xA2
12D2A:  MOVLB  0
12D2C:  CALL   0702
12D30:  MOVFF  32D,3A2
12D34:  MOVLW  57
12D36:  MOVLB  3
12D38:  MOVWF  xA3
12D3A:  MOVLB  0
12D3C:  CALL   0734
12D40:  MOVFF  332,3A2
12D44:  MOVLW  57
12D46:  MOVLB  3
12D48:  MOVWF  xA3
12D4A:  MOVLB  0
12D4C:  CALL   0734
12D50:  MOVFF  337,3A2
12D54:  MOVLW  57
12D56:  MOVLB  3
12D58:  MOVWF  xA3
12D5A:  MOVLB  0
12D5C:  CALL   0734
12D60:  MOVFF  38,3A2
12D64:  MOVLW  57
12D66:  MOVLB  3
12D68:  MOVWF  xA3
12D6A:  MOVLB  0
12D6C:  CALL   0734
12D70:  MOVLW  0D
12D72:  BTFSS  F9E.4
12D74:  BRA    12D72
12D76:  MOVWF  FAD
12D78:  MOVLW  0A
12D7A:  BTFSS  F9E.4
12D7C:  BRA    12D7A
12D7E:  MOVWF  FAD
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
12D80:  MOVFF  3F,32D
12D84:  MOVLB  3
12D86:  CLRF   x2E
12D88:  CLRF   x2F
12D8A:  CLRF   x30
12D8C:  MOVFF  3E,332
12D90:  MOVFF  3F,333
12D94:  CLRF   x34
12D96:  CLRF   x35
12D98:  MOVFF  3D,337
12D9C:  MOVFF  3E,338
12DA0:  MOVFF  3F,339
12DA4:  CLRF   x3A
12DA6:  MOVLW  EE
12DA8:  MOVWF  FF6
12DAA:  MOVLW  02
12DAC:  MOVWF  FF7
12DAE:  MOVLW  00
12DB0:  MOVWF  FF8
12DB2:  MOVLW  1A
12DB4:  MOVWF  xA2
12DB6:  MOVLB  0
12DB8:  CALL   0702
12DBC:  MOVFF  32D,3A2
12DC0:  MOVLW  57
12DC2:  MOVLB  3
12DC4:  MOVWF  xA3
12DC6:  MOVLB  0
12DC8:  CALL   0734
12DCC:  MOVFF  332,3A2
12DD0:  MOVLW  57
12DD2:  MOVLB  3
12DD4:  MOVWF  xA3
12DD6:  MOVLB  0
12DD8:  CALL   0734
12DDC:  MOVFF  337,3A2
12DE0:  MOVLW  57
12DE2:  MOVLB  3
12DE4:  MOVWF  xA3
12DE6:  MOVLB  0
12DE8:  CALL   0734
12DEC:  MOVFF  3C,3A2
12DF0:  MOVLW  57
12DF2:  MOVLB  3
12DF4:  MOVWF  xA3
12DF6:  MOVLB  0
12DF8:  CALL   0734
12DFC:  MOVLW  0D
12DFE:  BTFSS  F9E.4
12E00:  BRA    12DFE
12E02:  MOVWF  FAD
12E04:  MOVLW  0A
12E06:  BTFSS  F9E.4
12E08:  BRA    12E06
12E0A:  MOVWF  FAD
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
12E0C:  MOVFF  43,32D
12E10:  MOVLB  3
12E12:  CLRF   x2E
12E14:  CLRF   x2F
12E16:  CLRF   x30
12E18:  MOVFF  42,332
12E1C:  MOVFF  43,333
12E20:  CLRF   x34
12E22:  CLRF   x35
12E24:  MOVFF  41,337
12E28:  MOVFF  42,338
12E2C:  MOVFF  43,339
12E30:  CLRF   x3A
12E32:  MOVLW  14
12E34:  MOVWF  FF6
12E36:  MOVLW  03
12E38:  MOVWF  FF7
12E3A:  MOVLW  00
12E3C:  MOVWF  FF8
12E3E:  MOVLW  16
12E40:  MOVWF  xA2
12E42:  MOVLB  0
12E44:  CALL   0702
12E48:  MOVFF  32D,3A2
12E4C:  MOVLW  57
12E4E:  MOVLB  3
12E50:  MOVWF  xA3
12E52:  MOVLB  0
12E54:  CALL   0734
12E58:  MOVFF  332,3A2
12E5C:  MOVLW  57
12E5E:  MOVLB  3
12E60:  MOVWF  xA3
12E62:  MOVLB  0
12E64:  CALL   0734
12E68:  MOVFF  337,3A2
12E6C:  MOVLW  57
12E6E:  MOVLB  3
12E70:  MOVWF  xA3
12E72:  MOVLB  0
12E74:  CALL   0734
12E78:  MOVFF  40,3A2
12E7C:  MOVLW  57
12E7E:  MOVLB  3
12E80:  MOVWF  xA3
12E82:  MOVLB  0
12E84:  CALL   0734
12E88:  MOVLW  0D
12E8A:  BTFSS  F9E.4
12E8C:  BRA    12E8A
12E8E:  MOVWF  FAD
12E90:  MOVLW  0A
12E92:  BTFSS  F9E.4
12E94:  BRA    12E92
12E96:  MOVWF  FAD
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
12E98:  MOVFF  47,32D
12E9C:  MOVLB  3
12E9E:  CLRF   x2E
12EA0:  CLRF   x2F
12EA2:  CLRF   x30
12EA4:  MOVFF  46,332
12EA8:  MOVFF  47,333
12EAC:  CLRF   x34
12EAE:  CLRF   x35
12EB0:  MOVFF  45,337
12EB4:  MOVFF  46,338
12EB8:  MOVFF  47,339
12EBC:  CLRF   x3A
12EBE:  MOVLW  36
12EC0:  MOVWF  FF6
12EC2:  MOVLW  03
12EC4:  MOVWF  FF7
12EC6:  MOVLW  00
12EC8:  MOVWF  FF8
12ECA:  MOVLW  0C
12ECC:  MOVWF  xA2
12ECE:  MOVLB  0
12ED0:  CALL   0702
12ED4:  MOVFF  32D,3A2
12ED8:  MOVLW  57
12EDA:  MOVLB  3
12EDC:  MOVWF  xA3
12EDE:  MOVLB  0
12EE0:  CALL   0734
12EE4:  MOVFF  332,3A2
12EE8:  MOVLW  57
12EEA:  MOVLB  3
12EEC:  MOVWF  xA3
12EEE:  MOVLB  0
12EF0:  CALL   0734
12EF4:  MOVFF  337,3A2
12EF8:  MOVLW  57
12EFA:  MOVLB  3
12EFC:  MOVWF  xA3
12EFE:  MOVLB  0
12F00:  CALL   0734
12F04:  MOVFF  44,3A2
12F08:  MOVLW  57
12F0A:  MOVLB  3
12F0C:  MOVWF  xA3
12F0E:  MOVLB  0
12F10:  CALL   0734
12F14:  MOVLW  0D
12F16:  BTFSS  F9E.4
12F18:  BRA    12F16
12F1A:  MOVWF  FAD
12F1C:  MOVLW  0A
12F1E:  BTFSS  F9E.4
12F20:  BRA    12F1E
12F22:  MOVWF  FAD
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
12F24:  MOVFF  4B,32D
12F28:  MOVLB  3
12F2A:  CLRF   x2E
12F2C:  CLRF   x2F
12F2E:  CLRF   x30
12F30:  MOVFF  4A,332
12F34:  MOVFF  4B,333
12F38:  CLRF   x34
12F3A:  CLRF   x35
12F3C:  MOVFF  49,337
12F40:  MOVFF  4A,338
12F44:  MOVFF  4B,339
12F48:  CLRF   x3A
12F4A:  MOVLW  4E
12F4C:  MOVWF  FF6
12F4E:  MOVLW  03
12F50:  MOVWF  FF7
12F52:  MOVLW  00
12F54:  MOVWF  FF8
12F56:  MOVLW  0F
12F58:  MOVWF  xA2
12F5A:  MOVLB  0
12F5C:  CALL   0702
12F60:  MOVFF  32D,3A2
12F64:  MOVLW  57
12F66:  MOVLB  3
12F68:  MOVWF  xA3
12F6A:  MOVLB  0
12F6C:  CALL   0734
12F70:  MOVFF  332,3A2
12F74:  MOVLW  57
12F76:  MOVLB  3
12F78:  MOVWF  xA3
12F7A:  MOVLB  0
12F7C:  CALL   0734
12F80:  MOVFF  337,3A2
12F84:  MOVLW  57
12F86:  MOVLB  3
12F88:  MOVWF  xA3
12F8A:  MOVLB  0
12F8C:  CALL   0734
12F90:  MOVFF  48,3A2
12F94:  MOVLW  57
12F96:  MOVLB  3
12F98:  MOVWF  xA3
12F9A:  MOVLB  0
12F9C:  CALL   0734
12FA0:  MOVLW  0D
12FA2:  BTFSS  F9E.4
12FA4:  BRA    12FA2
12FA6:  MOVWF  FAD
12FA8:  MOVLW  0A
12FAA:  BTFSS  F9E.4
12FAC:  BRA    12FAA
12FAE:  MOVWF  FAD
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
12FB0:  MOVFF  4F,32D
12FB4:  MOVLB  3
12FB6:  CLRF   x2E
12FB8:  CLRF   x2F
12FBA:  CLRF   x30
12FBC:  MOVFF  4E,332
12FC0:  MOVFF  4F,333
12FC4:  CLRF   x34
12FC6:  CLRF   x35
12FC8:  MOVFF  4D,337
12FCC:  MOVFF  4E,338
12FD0:  MOVFF  4F,339
12FD4:  CLRF   x3A
12FD6:  MOVLW  68
12FD8:  MOVWF  FF6
12FDA:  MOVLW  03
12FDC:  MOVWF  FF7
12FDE:  MOVLW  00
12FE0:  MOVWF  FF8
12FE2:  MOVLW  0F
12FE4:  MOVWF  xA2
12FE6:  MOVLB  0
12FE8:  CALL   0702
12FEC:  MOVFF  32D,3A2
12FF0:  MOVLW  57
12FF2:  MOVLB  3
12FF4:  MOVWF  xA3
12FF6:  MOVLB  0
12FF8:  CALL   0734
12FFC:  MOVFF  332,3A2
13000:  MOVLW  57
13002:  MOVLB  3
13004:  MOVWF  xA3
13006:  MOVLB  0
13008:  CALL   0734
1300C:  MOVFF  337,3A2
13010:  MOVLW  57
13012:  MOVLB  3
13014:  MOVWF  xA3
13016:  MOVLB  0
13018:  CALL   0734
1301C:  MOVFF  4C,3A2
13020:  MOVLW  57
13022:  MOVLB  3
13024:  MOVWF  xA3
13026:  MOVLB  0
13028:  CALL   0734
1302C:  MOVLW  0D
1302E:  BTFSS  F9E.4
13030:  BRA    1302E
13032:  MOVWF  FAD
13034:  MOVLW  0A
13036:  BTFSS  F9E.4
13038:  BRA    13036
1303A:  MOVWF  FAD
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
1303C:  MOVFF  53,32D
13040:  MOVLB  3
13042:  CLRF   x2E
13044:  CLRF   x2F
13046:  CLRF   x30
13048:  MOVFF  52,332
1304C:  MOVFF  53,333
13050:  CLRF   x34
13052:  CLRF   x35
13054:  MOVFF  51,337
13058:  MOVFF  52,338
1305C:  MOVFF  53,339
13060:  CLRF   x3A
13062:  MOVLW  82
13064:  MOVWF  FF6
13066:  MOVLW  03
13068:  MOVWF  FF7
1306A:  MOVLW  00
1306C:  MOVWF  FF8
1306E:  MOVLW  14
13070:  MOVWF  xA2
13072:  MOVLB  0
13074:  CALL   0702
13078:  MOVFF  32D,3A2
1307C:  MOVLW  57
1307E:  MOVLB  3
13080:  MOVWF  xA3
13082:  MOVLB  0
13084:  CALL   0734
13088:  MOVFF  332,3A2
1308C:  MOVLW  57
1308E:  MOVLB  3
13090:  MOVWF  xA3
13092:  MOVLB  0
13094:  CALL   0734
13098:  MOVFF  337,3A2
1309C:  MOVLW  57
1309E:  MOVLB  3
130A0:  MOVWF  xA3
130A2:  MOVLB  0
130A4:  CALL   0734
130A8:  MOVFF  50,3A2
130AC:  MOVLW  57
130AE:  MOVLB  3
130B0:  MOVWF  xA3
130B2:  MOVLB  0
130B4:  CALL   0734
130B8:  MOVLW  0D
130BA:  BTFSS  F9E.4
130BC:  BRA    130BA
130BE:  MOVWF  FAD
130C0:  MOVLW  0A
130C2:  BTFSS  F9E.4
130C4:  BRA    130C2
130C6:  MOVWF  FAD
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
130C8:  MOVFF  57,32D
130CC:  MOVLB  3
130CE:  CLRF   x2E
130D0:  CLRF   x2F
130D2:  CLRF   x30
130D4:  MOVFF  56,332
130D8:  MOVFF  57,333
130DC:  CLRF   x34
130DE:  CLRF   x35
130E0:  MOVFF  55,337
130E4:  MOVFF  56,338
130E8:  MOVFF  57,339
130EC:  CLRF   x3A
130EE:  MOVLW  A2
130F0:  MOVWF  FF6
130F2:  MOVLW  03
130F4:  MOVWF  FF7
130F6:  MOVLW  00
130F8:  MOVWF  FF8
130FA:  MOVLW  11
130FC:  MOVWF  xA2
130FE:  MOVLB  0
13100:  CALL   0702
13104:  MOVFF  32D,3A2
13108:  MOVLW  57
1310A:  MOVLB  3
1310C:  MOVWF  xA3
1310E:  MOVLB  0
13110:  CALL   0734
13114:  MOVFF  332,3A2
13118:  MOVLW  57
1311A:  MOVLB  3
1311C:  MOVWF  xA3
1311E:  MOVLB  0
13120:  CALL   0734
13124:  MOVFF  337,3A2
13128:  MOVLW  57
1312A:  MOVLB  3
1312C:  MOVWF  xA3
1312E:  MOVLB  0
13130:  CALL   0734
13134:  MOVFF  54,3A2
13138:  MOVLW  57
1313A:  MOVLB  3
1313C:  MOVWF  xA3
1313E:  MOVLB  0
13140:  CALL   0734
13144:  MOVLW  0D
13146:  BTFSS  F9E.4
13148:  BRA    13146
1314A:  MOVWF  FAD
1314C:  MOVLW  0A
1314E:  BTFSS  F9E.4
13150:  BRA    1314E
13152:  MOVWF  FAD
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
13154:  MOVFF  5B,32D
13158:  MOVLB  3
1315A:  CLRF   x2E
1315C:  CLRF   x2F
1315E:  CLRF   x30
13160:  MOVFF  5A,332
13164:  MOVFF  5B,333
13168:  CLRF   x34
1316A:  CLRF   x35
1316C:  MOVFF  59,337
13170:  MOVFF  5A,338
13174:  MOVFF  5B,339
13178:  CLRF   x3A
1317A:  MOVLW  BE
1317C:  MOVWF  FF6
1317E:  MOVLW  03
13180:  MOVWF  FF7
13182:  MOVLW  00
13184:  MOVWF  FF8
13186:  MOVLW  15
13188:  MOVWF  xA2
1318A:  MOVLB  0
1318C:  CALL   0702
13190:  MOVFF  32D,3A2
13194:  MOVLW  57
13196:  MOVLB  3
13198:  MOVWF  xA3
1319A:  MOVLB  0
1319C:  CALL   0734
131A0:  MOVFF  332,3A2
131A4:  MOVLW  57
131A6:  MOVLB  3
131A8:  MOVWF  xA3
131AA:  MOVLB  0
131AC:  CALL   0734
131B0:  MOVFF  337,3A2
131B4:  MOVLW  57
131B6:  MOVLB  3
131B8:  MOVWF  xA3
131BA:  MOVLB  0
131BC:  CALL   0734
131C0:  MOVFF  58,3A2
131C4:  MOVLW  57
131C6:  MOVLB  3
131C8:  MOVWF  xA3
131CA:  MOVLB  0
131CC:  CALL   0734
131D0:  MOVLW  0D
131D2:  BTFSS  F9E.4
131D4:  BRA    131D2
131D6:  MOVWF  FAD
131D8:  MOVLW  0A
131DA:  BTFSS  F9E.4
131DC:  BRA    131DA
131DE:  MOVWF  FAD
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
131E0:  MOVFF  5F,32D
131E4:  MOVLB  3
131E6:  CLRF   x2E
131E8:  CLRF   x2F
131EA:  CLRF   x30
131EC:  MOVFF  5E,332
131F0:  MOVFF  5F,333
131F4:  CLRF   x34
131F6:  CLRF   x35
131F8:  MOVFF  5D,337
131FC:  MOVFF  5E,338
13200:  MOVFF  5F,339
13204:  CLRF   x3A
13206:  MOVLW  DE
13208:  MOVWF  FF6
1320A:  MOVLW  03
1320C:  MOVWF  FF7
1320E:  MOVLW  00
13210:  MOVWF  FF8
13212:  MOVLW  15
13214:  MOVWF  xA2
13216:  MOVLB  0
13218:  CALL   0702
1321C:  MOVFF  32D,3A2
13220:  MOVLW  57
13222:  MOVLB  3
13224:  MOVWF  xA3
13226:  MOVLB  0
13228:  CALL   0734
1322C:  MOVFF  332,3A2
13230:  MOVLW  57
13232:  MOVLB  3
13234:  MOVWF  xA3
13236:  MOVLB  0
13238:  CALL   0734
1323C:  MOVFF  337,3A2
13240:  MOVLW  57
13242:  MOVLB  3
13244:  MOVWF  xA3
13246:  MOVLB  0
13248:  CALL   0734
1324C:  MOVFF  5C,3A2
13250:  MOVLW  57
13252:  MOVLB  3
13254:  MOVWF  xA3
13256:  MOVLB  0
13258:  CALL   0734
1325C:  MOVLW  0D
1325E:  BTFSS  F9E.4
13260:  BRA    1325E
13262:  MOVWF  FAD
13264:  MOVLW  0A
13266:  BTFSS  F9E.4
13268:  BRA    13266
1326A:  MOVWF  FAD
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
1326C:  MOVLW  FE
1326E:  MOVWF  FF6
13270:  MOVLW  03
13272:  MOVWF  FF7
13274:  MOVLW  00
13276:  MOVWF  FF8
13278:  MOVLW  06
1327A:  MOVLB  3
1327C:  MOVWF  xA2
1327E:  MOVLB  0
13280:  CALL   0702
13284:  MOVFF  37,3A2
13288:  MOVLW  57
1328A:  MOVLB  3
1328C:  MOVWF  xA3
1328E:  MOVLB  0
13290:  CALL   0734
13294:  MOVFF  36,3A2
13298:  MOVLW  57
1329A:  MOVLB  3
1329C:  MOVWF  xA3
1329E:  MOVLB  0
132A0:  CALL   0734
132A4:  MOVFF  35,3A2
132A8:  MOVLW  57
132AA:  MOVLB  3
132AC:  MOVWF  xA3
132AE:  MOVLB  0
132B0:  CALL   0734
132B4:  MOVFF  34,3A2
132B8:  MOVLW  57
132BA:  MOVLB  3
132BC:  MOVWF  xA3
132BE:  MOVLB  0
132C0:  CALL   0734
132C4:  MOVLW  07
132C6:  MOVWF  FF6
132C8:  MOVLW  04
132CA:  MOVWF  FF7
132CC:  MOVLW  00
132CE:  MOVWF  FF8
132D0:  MOVLW  08
132D2:  MOVLB  3
132D4:  MOVWF  xA2
132D6:  MOVLB  0
132D8:  CALL   0702
....................    return; 
132DC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
*
13C2E:  BSF    FD0.6
13C30:  MOVFF  62,FF8
13C34:  MOVFF  61,FF7
13C38:  MOVFF  60,FF6
13C3C:  BSF    F7F.4
13C3E:  CALL   05CC
13C42:  CLRF   FF8
....................    return; 
13C44:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
*
11C84:  MOVLB  3
11C86:  CLRF   x7E
11C88:  MOVFF  68,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
11C8C:  BSF    FD0.6
11C8E:  MOVFF  62,FF8
11C92:  MOVFF  61,FF7
11C96:  MOVFF  60,FF6
11C9A:  MOVLB  0
11C9C:  CALL   05B6
11CA0:  MOVFF  60,FF6
11CA4:  MOVFF  37D,FF5
11CA8:  TBLWT*+
11CAA:  MOVFF  37E,FF5
11CAE:  TBLWT*
11CB0:  CALL   05CC
11CB4:  CLRF   FF8
11CB6:  CLRF   FF8
....................    DATA = (int16)PASSED_DAYS; 
11CB8:  MOVFF  6A,37E
11CBC:  MOVFF  69,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
11CC0:  MOVLW  02
11CC2:  ADDWF  x60,W
11CC4:  MOVLB  3
11CC6:  MOVWF  x7F
11CC8:  MOVLW  00
11CCA:  MOVLB  0
11CCC:  ADDWFC x61,W
11CCE:  MOVLB  3
11CD0:  MOVWF  x80
11CD2:  MOVLW  00
11CD4:  MOVLB  0
11CD6:  ADDWFC x62,W
11CD8:  MOVLB  3
11CDA:  MOVWF  x81
11CDC:  MOVLW  00
11CDE:  MOVLB  0
11CE0:  ADDWFC x63,W
11CE2:  MOVLB  3
11CE4:  MOVWF  x82
11CE6:  BSF    FD0.6
11CE8:  MOVFF  381,FF8
11CEC:  MOVFF  380,FF7
11CF0:  MOVFF  37F,FF6
11CF4:  MOVLB  0
11CF6:  CALL   05B6
11CFA:  MOVFF  37F,FF6
11CFE:  MOVFF  37D,FF5
11D02:  TBLWT*+
11D04:  MOVFF  37E,FF5
11D08:  TBLWT*
11D0A:  CALL   05CC
11D0E:  CLRF   FF8
11D10:  CLRF   FF8
....................    DATA = (int16)RESERVE_CHECK; 
11D12:  MOVLB  3
11D14:  CLRF   x7E
11D16:  MOVFF  6B,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
11D1A:  MOVLW  04
11D1C:  MOVLB  0
11D1E:  ADDWF  x60,W
11D20:  MOVLB  3
11D22:  MOVWF  x7F
11D24:  MOVLW  00
11D26:  MOVLB  0
11D28:  ADDWFC x61,W
11D2A:  MOVLB  3
11D2C:  MOVWF  x80
11D2E:  MOVLW  00
11D30:  MOVLB  0
11D32:  ADDWFC x62,W
11D34:  MOVLB  3
11D36:  MOVWF  x81
11D38:  MOVLW  00
11D3A:  MOVLB  0
11D3C:  ADDWFC x63,W
11D3E:  MOVLB  3
11D40:  MOVWF  x82
11D42:  BSF    FD0.6
11D44:  MOVFF  381,FF8
11D48:  MOVFF  380,FF7
11D4C:  MOVFF  37F,FF6
11D50:  MOVLB  0
11D52:  CALL   05B6
11D56:  MOVFF  37F,FF6
11D5A:  MOVFF  37D,FF5
11D5E:  TBLWT*+
11D60:  MOVFF  37E,FF5
11D64:  TBLWT*
11D66:  CALL   05CC
11D6A:  CLRF   FF8
11D6C:  CLRF   FF8
....................    DATA = (int16)RESERVE_MIN_FLAG; 
11D6E:  MOVLB  3
11D70:  CLRF   x7E
11D72:  MOVFF  6C,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
11D76:  MOVLW  06
11D78:  MOVLB  0
11D7A:  ADDWF  x60,W
11D7C:  MOVLB  3
11D7E:  MOVWF  x7F
11D80:  MOVLW  00
11D82:  MOVLB  0
11D84:  ADDWFC x61,W
11D86:  MOVLB  3
11D88:  MOVWF  x80
11D8A:  MOVLW  00
11D8C:  MOVLB  0
11D8E:  ADDWFC x62,W
11D90:  MOVLB  3
11D92:  MOVWF  x81
11D94:  MOVLW  00
11D96:  MOVLB  0
11D98:  ADDWFC x63,W
11D9A:  MOVLB  3
11D9C:  MOVWF  x82
11D9E:  BSF    FD0.6
11DA0:  MOVFF  381,FF8
11DA4:  MOVFF  380,FF7
11DA8:  MOVFF  37F,FF6
11DAC:  MOVLB  0
11DAE:  CALL   05B6
11DB2:  MOVFF  37F,FF6
11DB6:  MOVFF  37D,FF5
11DBA:  TBLWT*+
11DBC:  MOVFF  37E,FF5
11DC0:  TBLWT*
11DC2:  CALL   05CC
11DC6:  CLRF   FF8
11DC8:  CLRF   FF8
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
11DCA:  MOVLB  3
11DCC:  CLRF   x7E
11DCE:  MOVFF  6D,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
11DD2:  MOVLW  08
11DD4:  MOVLB  0
11DD6:  ADDWF  x60,W
11DD8:  MOVLB  3
11DDA:  MOVWF  x7F
11DDC:  MOVLW  00
11DDE:  MOVLB  0
11DE0:  ADDWFC x61,W
11DE2:  MOVLB  3
11DE4:  MOVWF  x80
11DE6:  MOVLW  00
11DE8:  MOVLB  0
11DEA:  ADDWFC x62,W
11DEC:  MOVLB  3
11DEE:  MOVWF  x81
11DF0:  MOVLW  00
11DF2:  MOVLB  0
11DF4:  ADDWFC x63,W
11DF6:  MOVLB  3
11DF8:  MOVWF  x82
11DFA:  BSF    FD0.6
11DFC:  MOVFF  381,FF8
11E00:  MOVFF  380,FF7
11E04:  MOVFF  37F,FF6
11E08:  MOVLB  0
11E0A:  CALL   05B6
11E0E:  MOVFF  37F,FF6
11E12:  MOVFF  37D,FF5
11E16:  TBLWT*+
11E18:  MOVFF  37E,FF5
11E1C:  TBLWT*
11E1E:  CALL   05CC
11E22:  CLRF   FF8
11E24:  CLRF   FF8
....................    DATA = (int16)MISSION_CONTENTS; 
11E26:  MOVLB  3
11E28:  CLRF   x7E
11E2A:  MOVFF  6E,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
11E2E:  MOVLW  0A
11E30:  MOVLB  0
11E32:  ADDWF  x60,W
11E34:  MOVLB  3
11E36:  MOVWF  x7F
11E38:  MOVLW  00
11E3A:  MOVLB  0
11E3C:  ADDWFC x61,W
11E3E:  MOVLB  3
11E40:  MOVWF  x80
11E42:  MOVLW  00
11E44:  MOVLB  0
11E46:  ADDWFC x62,W
11E48:  MOVLB  3
11E4A:  MOVWF  x81
11E4C:  MOVLW  00
11E4E:  MOVLB  0
11E50:  ADDWFC x63,W
11E52:  MOVLB  3
11E54:  MOVWF  x82
11E56:  BSF    FD0.6
11E58:  MOVFF  381,FF8
11E5C:  MOVFF  380,FF7
11E60:  MOVFF  37F,FF6
11E64:  MOVLB  0
11E66:  CALL   05B6
11E6A:  MOVFF  37F,FF6
11E6E:  MOVFF  37D,FF5
11E72:  TBLWT*+
11E74:  MOVFF  37E,FF5
11E78:  TBLWT*
11E7A:  CALL   05CC
11E7E:  CLRF   FF8
11E80:  CLRF   FF8
....................    DATA = (int16)MISSION_DETAIL; 
11E82:  MOVLB  3
11E84:  CLRF   x7E
11E86:  MOVFF  6F,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
11E8A:  MOVLW  0C
11E8C:  MOVLB  0
11E8E:  ADDWF  x60,W
11E90:  MOVLB  3
11E92:  MOVWF  x7F
11E94:  MOVLW  00
11E96:  MOVLB  0
11E98:  ADDWFC x61,W
11E9A:  MOVLB  3
11E9C:  MOVWF  x80
11E9E:  MOVLW  00
11EA0:  MOVLB  0
11EA2:  ADDWFC x62,W
11EA4:  MOVLB  3
11EA6:  MOVWF  x81
11EA8:  MOVLW  00
11EAA:  MOVLB  0
11EAC:  ADDWFC x63,W
11EAE:  MOVLB  3
11EB0:  MOVWF  x82
11EB2:  BSF    FD0.6
11EB4:  MOVFF  381,FF8
11EB8:  MOVFF  380,FF7
11EBC:  MOVFF  37F,FF6
11EC0:  MOVLB  0
11EC2:  CALL   05B6
11EC6:  MOVFF  37F,FF6
11ECA:  MOVFF  37D,FF5
11ECE:  TBLWT*+
11ED0:  MOVFF  37E,FF5
11ED4:  TBLWT*
11ED6:  CALL   05CC
11EDA:  CLRF   FF8
11EDC:  CLRF   FF8
....................    DATA = (int16)Kill_FLAG_MAIN; 
11EDE:  MOVLB  3
11EE0:  CLRF   x7E
11EE2:  MOVFF  75,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
11EE6:  MOVLW  0E
11EE8:  MOVLB  0
11EEA:  ADDWF  x60,W
11EEC:  MOVLB  3
11EEE:  MOVWF  x7F
11EF0:  MOVLW  00
11EF2:  MOVLB  0
11EF4:  ADDWFC x61,W
11EF6:  MOVLB  3
11EF8:  MOVWF  x80
11EFA:  MOVLW  00
11EFC:  MOVLB  0
11EFE:  ADDWFC x62,W
11F00:  MOVLB  3
11F02:  MOVWF  x81
11F04:  MOVLW  00
11F06:  MOVLB  0
11F08:  ADDWFC x63,W
11F0A:  MOVLB  3
11F0C:  MOVWF  x82
11F0E:  BSF    FD0.6
11F10:  MOVFF  381,FF8
11F14:  MOVFF  380,FF7
11F18:  MOVFF  37F,FF6
11F1C:  MOVLB  0
11F1E:  CALL   05B6
11F22:  MOVFF  37F,FF6
11F26:  MOVFF  37D,FF5
11F2A:  TBLWT*+
11F2C:  MOVFF  37E,FF5
11F30:  TBLWT*
11F32:  CALL   05CC
11F36:  CLRF   FF8
11F38:  CLRF   FF8
....................    DATA = (int16)Kill_FLAG_FAB; 
11F3A:  MOVLB  3
11F3C:  CLRF   x7E
11F3E:  MOVFF  76,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
11F42:  MOVLW  10
11F44:  MOVLB  0
11F46:  ADDWF  x60,W
11F48:  MOVLB  3
11F4A:  MOVWF  x7F
11F4C:  MOVLW  00
11F4E:  MOVLB  0
11F50:  ADDWFC x61,W
11F52:  MOVLB  3
11F54:  MOVWF  x80
11F56:  MOVLW  00
11F58:  MOVLB  0
11F5A:  ADDWFC x62,W
11F5C:  MOVLB  3
11F5E:  MOVWF  x81
11F60:  MOVLW  00
11F62:  MOVLB  0
11F64:  ADDWFC x63,W
11F66:  MOVLB  3
11F68:  MOVWF  x82
11F6A:  BSF    FD0.6
11F6C:  MOVFF  381,FF8
11F70:  MOVFF  380,FF7
11F74:  MOVFF  37F,FF6
11F78:  MOVLB  0
11F7A:  CALL   05B6
11F7E:  MOVFF  37F,FF6
11F82:  MOVFF  37D,FF5
11F86:  TBLWT*+
11F88:  MOVFF  37E,FF5
11F8C:  TBLWT*
11F8E:  CALL   05CC
11F92:  CLRF   FF8
11F94:  CLRF   FF8
....................    DATA = (int16)FIRST_HSSC_DONE; 
11F96:  MOVLB  3
11F98:  CLRF   x7E
11F9A:  MOVFF  77,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
11F9E:  MOVLW  12
11FA0:  MOVLB  0
11FA2:  ADDWF  x60,W
11FA4:  MOVLB  3
11FA6:  MOVWF  x7F
11FA8:  MOVLW  00
11FAA:  MOVLB  0
11FAC:  ADDWFC x61,W
11FAE:  MOVLB  3
11FB0:  MOVWF  x80
11FB2:  MOVLW  00
11FB4:  MOVLB  0
11FB6:  ADDWFC x62,W
11FB8:  MOVLB  3
11FBA:  MOVWF  x81
11FBC:  MOVLW  00
11FBE:  MOVLB  0
11FC0:  ADDWFC x63,W
11FC2:  MOVLB  3
11FC4:  MOVWF  x82
11FC6:  BSF    FD0.6
11FC8:  MOVFF  381,FF8
11FCC:  MOVFF  380,FF7
11FD0:  MOVFF  37F,FF6
11FD4:  MOVLB  0
11FD6:  CALL   05B6
11FDA:  MOVFF  37F,FF6
11FDE:  MOVFF  37D,FF5
11FE2:  TBLWT*+
11FE4:  MOVFF  37E,FF5
11FE8:  TBLWT*
11FEA:  CALL   05CC
11FEE:  CLRF   FF8
11FF0:  CLRF   FF8
....................    DATA = (int16)AUTO_CAM_DONE; 
11FF2:  MOVLB  3
11FF4:  CLRF   x7E
11FF6:  MOVFF  78,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
11FFA:  MOVLW  14
11FFC:  MOVLB  0
11FFE:  ADDWF  x60,W
12000:  MOVLB  3
12002:  MOVWF  x7F
12004:  MOVLW  00
12006:  MOVLB  0
12008:  ADDWFC x61,W
1200A:  MOVLB  3
1200C:  MOVWF  x80
1200E:  MOVLW  00
12010:  MOVLB  0
12012:  ADDWFC x62,W
12014:  MOVLB  3
12016:  MOVWF  x81
12018:  MOVLW  00
1201A:  MOVLB  0
1201C:  ADDWFC x63,W
1201E:  MOVLB  3
12020:  MOVWF  x82
12022:  BSF    FD0.6
12024:  MOVFF  381,FF8
12028:  MOVFF  380,FF7
1202C:  MOVFF  37F,FF6
12030:  MOVLB  0
12032:  CALL   05B6
12036:  MOVFF  37F,FF6
1203A:  MOVFF  37D,FF5
1203E:  TBLWT*+
12040:  MOVFF  37E,FF5
12044:  TBLWT*
12046:  CALL   05CC
1204A:  CLRF   FF8
1204C:  CLRF   FF8
....................    DATA = (int16)AUTO_MBP_DONE; 
1204E:  MOVLB  3
12050:  CLRF   x7E
12052:  MOVFF  79,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
12056:  MOVLW  16
12058:  MOVLB  0
1205A:  ADDWF  x60,W
1205C:  MOVLB  3
1205E:  MOVWF  x7F
12060:  MOVLW  00
12062:  MOVLB  0
12064:  ADDWFC x61,W
12066:  MOVLB  3
12068:  MOVWF  x80
1206A:  MOVLW  00
1206C:  MOVLB  0
1206E:  ADDWFC x62,W
12070:  MOVLB  3
12072:  MOVWF  x81
12074:  MOVLW  00
12076:  MOVLB  0
12078:  ADDWFC x63,W
1207A:  MOVLB  3
1207C:  MOVWF  x82
1207E:  BSF    FD0.6
12080:  MOVFF  381,FF8
12084:  MOVFF  380,FF7
12088:  MOVFF  37F,FF6
1208C:  MOVLB  0
1208E:  CALL   05B6
12092:  MOVFF  37F,FF6
12096:  MOVFF  37D,FF5
1209A:  TBLWT*+
1209C:  MOVFF  37E,FF5
120A0:  TBLWT*
120A2:  CALL   05CC
120A6:  CLRF   FF8
120A8:  CLRF   FF8
....................    DATA = (int16)AUTO_ADCS_DONE; 
120AA:  MOVLB  3
120AC:  CLRF   x7E
120AE:  MOVFF  7A,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
120B2:  MOVLW  18
120B4:  MOVLB  0
120B6:  ADDWF  x60,W
120B8:  MOVLB  3
120BA:  MOVWF  x7F
120BC:  MOVLW  00
120BE:  MOVLB  0
120C0:  ADDWFC x61,W
120C2:  MOVLB  3
120C4:  MOVWF  x80
120C6:  MOVLW  00
120C8:  MOVLB  0
120CA:  ADDWFC x62,W
120CC:  MOVLB  3
120CE:  MOVWF  x81
120D0:  MOVLW  00
120D2:  MOVLB  0
120D4:  ADDWFC x63,W
120D6:  MOVLB  3
120D8:  MOVWF  x82
120DA:  BSF    FD0.6
120DC:  MOVFF  381,FF8
120E0:  MOVFF  380,FF7
120E4:  MOVFF  37F,FF6
120E8:  MOVLB  0
120EA:  CALL   05B6
120EE:  MOVFF  37F,FF6
120F2:  MOVFF  37D,FF5
120F6:  TBLWT*+
120F8:  MOVFF  37E,FF5
120FC:  TBLWT*
120FE:  CALL   05CC
12102:  CLRF   FF8
12104:  CLRF   FF8
....................    DATA = (int16)ANT_DEP_STATUS; 
12106:  MOVLB  3
12108:  CLRF   x7E
1210A:  MOVFF  7B,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
1210E:  MOVLW  1A
12110:  MOVLB  0
12112:  ADDWF  x60,W
12114:  MOVLB  3
12116:  MOVWF  x7F
12118:  MOVLW  00
1211A:  MOVLB  0
1211C:  ADDWFC x61,W
1211E:  MOVLB  3
12120:  MOVWF  x80
12122:  MOVLW  00
12124:  MOVLB  0
12126:  ADDWFC x62,W
12128:  MOVLB  3
1212A:  MOVWF  x81
1212C:  MOVLW  00
1212E:  MOVLB  0
12130:  ADDWFC x63,W
12132:  MOVLB  3
12134:  MOVWF  x82
12136:  BSF    FD0.6
12138:  MOVFF  381,FF8
1213C:  MOVFF  380,FF7
12140:  MOVFF  37F,FF6
12144:  MOVLB  0
12146:  CALL   05B6
1214A:  MOVFF  37F,FF6
1214E:  MOVFF  37D,FF5
12152:  TBLWT*+
12154:  MOVFF  37E,FF5
12158:  TBLWT*
1215A:  CALL   05CC
1215E:  CLRF   FF8
12160:  CLRF   FF8
....................    DATA = (int16)UPLINK_SUCCESS; 
12162:  MOVLB  3
12164:  CLRF   x7E
12166:  MOVFF  7C,37D
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
1216A:  MOVLW  1C
1216C:  MOVLB  0
1216E:  ADDWF  x60,W
12170:  MOVLB  3
12172:  MOVWF  x7F
12174:  MOVLW  00
12176:  MOVLB  0
12178:  ADDWFC x61,W
1217A:  MOVLB  3
1217C:  MOVWF  x80
1217E:  MOVLW  00
12180:  MOVLB  0
12182:  ADDWFC x62,W
12184:  MOVLB  3
12186:  MOVWF  x81
12188:  MOVLW  00
1218A:  MOVLB  0
1218C:  ADDWFC x63,W
1218E:  MOVLB  3
12190:  MOVWF  x82
12192:  BSF    FD0.6
12194:  MOVFF  381,FF8
12198:  MOVFF  380,FF7
1219C:  MOVFF  37F,FF6
121A0:  MOVLB  0
121A2:  CALL   05B6
121A6:  MOVFF  37F,FF6
121AA:  MOVFF  37D,FF5
121AE:  TBLWT*+
121B0:  MOVFF  37E,FF5
121B4:  TBLWT*
121B6:  CALL   05CC
121BA:  CLRF   FF8
121BC:  CLRF   FF8
....................    return; 
121BE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
*
14C82:  MOVFF  FF2,32E
14C86:  BCF    FF2.7
14C88:  MOVFF  62,FF8
14C8C:  MOVFF  61,FF7
14C90:  MOVFF  60,FF6
14C94:  TBLRD*+
14C96:  MOVF   FF5,W
14C98:  TBLRD*
14C9A:  MOVFF  FF5,03
14C9E:  CLRF   FF8
14CA0:  MOVLB  3
14CA2:  BTFSC  x2E.7
14CA4:  BSF    FF2.7
14CA6:  MOVWF  x2E
14CA8:  MOVFF  03,32F
14CAC:  INCFSZ x2E,W
14CAE:  BRA    14CB6
14CB0:  INCFSZ x2F,W
14CB2:  BRA    14CB6
14CB4:  BRA    15148
14CB6:  MOVLW  1A
14CB8:  MOVLB  0
14CBA:  ADDWF  x60,W
14CBC:  MOVLB  3
14CBE:  MOVWF  x2E
14CC0:  MOVLW  00
14CC2:  MOVLB  0
14CC4:  ADDWFC x61,W
14CC6:  MOVLB  3
14CC8:  MOVWF  x2F
14CCA:  MOVLW  00
14CCC:  MOVLB  0
14CCE:  ADDWFC x62,W
14CD0:  MOVLB  3
14CD2:  MOVWF  x30
14CD4:  MOVLW  00
14CD6:  MOVLB  0
14CD8:  ADDWFC x63,W
14CDA:  MOVLB  3
14CDC:  MOVWF  x31
14CDE:  MOVFF  FF2,332
14CE2:  BCF    FF2.7
14CE4:  MOVFF  330,FF8
14CE8:  MOVFF  32F,FF7
14CEC:  MOVFF  32E,FF6
14CF0:  TBLRD*+
14CF2:  MOVF   FF5,W
14CF4:  TBLRD*
14CF6:  MOVFF  FF5,03
14CFA:  CLRF   FF8
14CFC:  BTFSC  x32.7
14CFE:  BSF    FF2.7
14D00:  MOVWF  x2E
14D02:  MOVFF  03,32F
14D06:  INCFSZ x2E,W
14D08:  BRA    14D10
14D0A:  INCFSZ x2F,W
14D0C:  BRA    14D10
14D0E:  BRA    15148
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
14D10:  MOVFF  FF2,32E
14D14:  BCF    FF2.7
14D16:  MOVFF  62,FF8
14D1A:  MOVFF  61,FF7
14D1E:  MOVFF  60,FF6
14D22:  TBLRD*+
14D24:  MOVF   FF5,W
14D26:  TBLRD*
14D28:  MOVFF  FF5,03
14D2C:  CLRF   FF8
14D2E:  BTFSC  x2E.7
14D30:  BSF    FF2.7
14D32:  MOVLB  0
14D34:  MOVWF  x68
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
14D36:  MOVLW  02
14D38:  ADDWF  x60,W
14D3A:  MOVLB  3
14D3C:  MOVWF  x2E
14D3E:  MOVLW  00
14D40:  MOVLB  0
14D42:  ADDWFC x61,W
14D44:  MOVLB  3
14D46:  MOVWF  x2F
14D48:  MOVLW  00
14D4A:  MOVLB  0
14D4C:  ADDWFC x62,W
14D4E:  MOVLB  3
14D50:  MOVWF  x30
14D52:  MOVLW  00
14D54:  MOVLB  0
14D56:  ADDWFC x63,W
14D58:  MOVLB  3
14D5A:  MOVFF  FF2,332
14D5E:  BCF    FF2.7
14D60:  MOVFF  330,FF8
14D64:  MOVFF  32F,FF7
14D68:  MOVFF  32E,FF6
14D6C:  TBLRD*+
14D6E:  MOVF   FF5,W
14D70:  TBLRD*
14D72:  MOVFF  FF5,03
14D76:  CLRF   FF8
14D78:  BTFSC  x32.7
14D7A:  BSF    FF2.7
14D7C:  MOVLB  0
14D7E:  MOVWF  x69
14D80:  MOVFF  03,6A
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
14D84:  MOVLW  04
14D86:  ADDWF  x60,W
14D88:  MOVLB  3
14D8A:  MOVWF  x2E
14D8C:  MOVLW  00
14D8E:  MOVLB  0
14D90:  ADDWFC x61,W
14D92:  MOVLB  3
14D94:  MOVWF  x2F
14D96:  MOVLW  00
14D98:  MOVLB  0
14D9A:  ADDWFC x62,W
14D9C:  MOVLB  3
14D9E:  MOVWF  x30
14DA0:  MOVLW  00
14DA2:  MOVLB  0
14DA4:  ADDWFC x63,W
14DA6:  MOVLB  3
14DA8:  MOVFF  FF2,332
14DAC:  BCF    FF2.7
14DAE:  MOVFF  330,FF8
14DB2:  MOVFF  32F,FF7
14DB6:  MOVFF  32E,FF6
14DBA:  TBLRD*+
14DBC:  MOVF   FF5,W
14DBE:  TBLRD*
14DC0:  MOVFF  FF5,03
14DC4:  CLRF   FF8
14DC6:  BTFSC  x32.7
14DC8:  BSF    FF2.7
14DCA:  MOVLB  0
14DCC:  MOVWF  x6B
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
14DCE:  MOVLW  06
14DD0:  ADDWF  x60,W
14DD2:  MOVLB  3
14DD4:  MOVWF  x2E
14DD6:  MOVLW  00
14DD8:  MOVLB  0
14DDA:  ADDWFC x61,W
14DDC:  MOVLB  3
14DDE:  MOVWF  x2F
14DE0:  MOVLW  00
14DE2:  MOVLB  0
14DE4:  ADDWFC x62,W
14DE6:  MOVLB  3
14DE8:  MOVWF  x30
14DEA:  MOVLW  00
14DEC:  MOVLB  0
14DEE:  ADDWFC x63,W
14DF0:  MOVLB  3
14DF2:  MOVFF  FF2,332
14DF6:  BCF    FF2.7
14DF8:  MOVFF  330,FF8
14DFC:  MOVFF  32F,FF7
14E00:  MOVFF  32E,FF6
14E04:  TBLRD*+
14E06:  MOVF   FF5,W
14E08:  TBLRD*
14E0A:  MOVFF  FF5,03
14E0E:  CLRF   FF8
14E10:  BTFSC  x32.7
14E12:  BSF    FF2.7
14E14:  MOVLB  0
14E16:  MOVWF  x6C
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
14E18:  MOVLW  08
14E1A:  ADDWF  x60,W
14E1C:  MOVLB  3
14E1E:  MOVWF  x2E
14E20:  MOVLW  00
14E22:  MOVLB  0
14E24:  ADDWFC x61,W
14E26:  MOVLB  3
14E28:  MOVWF  x2F
14E2A:  MOVLW  00
14E2C:  MOVLB  0
14E2E:  ADDWFC x62,W
14E30:  MOVLB  3
14E32:  MOVWF  x30
14E34:  MOVLW  00
14E36:  MOVLB  0
14E38:  ADDWFC x63,W
14E3A:  MOVLB  3
14E3C:  MOVFF  FF2,332
14E40:  BCF    FF2.7
14E42:  MOVFF  330,FF8
14E46:  MOVFF  32F,FF7
14E4A:  MOVFF  32E,FF6
14E4E:  TBLRD*+
14E50:  MOVF   FF5,W
14E52:  TBLRD*
14E54:  MOVFF  FF5,03
14E58:  CLRF   FF8
14E5A:  BTFSC  x32.7
14E5C:  BSF    FF2.7
14E5E:  MOVLB  0
14E60:  MOVWF  x6D
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
14E62:  MOVLW  0A
14E64:  ADDWF  x60,W
14E66:  MOVLB  3
14E68:  MOVWF  x2E
14E6A:  MOVLW  00
14E6C:  MOVLB  0
14E6E:  ADDWFC x61,W
14E70:  MOVLB  3
14E72:  MOVWF  x2F
14E74:  MOVLW  00
14E76:  MOVLB  0
14E78:  ADDWFC x62,W
14E7A:  MOVLB  3
14E7C:  MOVWF  x30
14E7E:  MOVLW  00
14E80:  MOVLB  0
14E82:  ADDWFC x63,W
14E84:  MOVLB  3
14E86:  MOVFF  FF2,332
14E8A:  BCF    FF2.7
14E8C:  MOVFF  330,FF8
14E90:  MOVFF  32F,FF7
14E94:  MOVFF  32E,FF6
14E98:  TBLRD*+
14E9A:  MOVF   FF5,W
14E9C:  TBLRD*
14E9E:  MOVFF  FF5,03
14EA2:  CLRF   FF8
14EA4:  BTFSC  x32.7
14EA6:  BSF    FF2.7
14EA8:  MOVLB  0
14EAA:  MOVWF  x6E
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
14EAC:  MOVLW  0C
14EAE:  ADDWF  x60,W
14EB0:  MOVLB  3
14EB2:  MOVWF  x2E
14EB4:  MOVLW  00
14EB6:  MOVLB  0
14EB8:  ADDWFC x61,W
14EBA:  MOVLB  3
14EBC:  MOVWF  x2F
14EBE:  MOVLW  00
14EC0:  MOVLB  0
14EC2:  ADDWFC x62,W
14EC4:  MOVLB  3
14EC6:  MOVWF  x30
14EC8:  MOVLW  00
14ECA:  MOVLB  0
14ECC:  ADDWFC x63,W
14ECE:  MOVLB  3
14ED0:  MOVFF  FF2,332
14ED4:  BCF    FF2.7
14ED6:  MOVFF  330,FF8
14EDA:  MOVFF  32F,FF7
14EDE:  MOVFF  32E,FF6
14EE2:  TBLRD*+
14EE4:  MOVF   FF5,W
14EE6:  TBLRD*
14EE8:  MOVFF  FF5,03
14EEC:  CLRF   FF8
14EEE:  BTFSC  x32.7
14EF0:  BSF    FF2.7
14EF2:  MOVLB  0
14EF4:  MOVWF  x6F
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
14EF6:  MOVLW  0E
14EF8:  ADDWF  x60,W
14EFA:  MOVLB  3
14EFC:  MOVWF  x2E
14EFE:  MOVLW  00
14F00:  MOVLB  0
14F02:  ADDWFC x61,W
14F04:  MOVLB  3
14F06:  MOVWF  x2F
14F08:  MOVLW  00
14F0A:  MOVLB  0
14F0C:  ADDWFC x62,W
14F0E:  MOVLB  3
14F10:  MOVWF  x30
14F12:  MOVLW  00
14F14:  MOVLB  0
14F16:  ADDWFC x63,W
14F18:  MOVLB  3
14F1A:  MOVFF  FF2,332
14F1E:  BCF    FF2.7
14F20:  MOVFF  330,FF8
14F24:  MOVFF  32F,FF7
14F28:  MOVFF  32E,FF6
14F2C:  TBLRD*+
14F2E:  MOVF   FF5,W
14F30:  TBLRD*
14F32:  MOVFF  FF5,03
14F36:  CLRF   FF8
14F38:  BTFSC  x32.7
14F3A:  BSF    FF2.7
14F3C:  MOVLB  0
14F3E:  MOVWF  x75
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
14F40:  MOVLW  10
14F42:  ADDWF  x60,W
14F44:  MOVLB  3
14F46:  MOVWF  x2E
14F48:  MOVLW  00
14F4A:  MOVLB  0
14F4C:  ADDWFC x61,W
14F4E:  MOVLB  3
14F50:  MOVWF  x2F
14F52:  MOVLW  00
14F54:  MOVLB  0
14F56:  ADDWFC x62,W
14F58:  MOVLB  3
14F5A:  MOVWF  x30
14F5C:  MOVLW  00
14F5E:  MOVLB  0
14F60:  ADDWFC x63,W
14F62:  MOVLB  3
14F64:  MOVFF  FF2,332
14F68:  BCF    FF2.7
14F6A:  MOVFF  330,FF8
14F6E:  MOVFF  32F,FF7
14F72:  MOVFF  32E,FF6
14F76:  TBLRD*+
14F78:  MOVF   FF5,W
14F7A:  TBLRD*
14F7C:  MOVFF  FF5,03
14F80:  CLRF   FF8
14F82:  BTFSC  x32.7
14F84:  BSF    FF2.7
14F86:  MOVLB  0
14F88:  MOVWF  x76
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
14F8A:  MOVLW  12
14F8C:  ADDWF  x60,W
14F8E:  MOVLB  3
14F90:  MOVWF  x2E
14F92:  MOVLW  00
14F94:  MOVLB  0
14F96:  ADDWFC x61,W
14F98:  MOVLB  3
14F9A:  MOVWF  x2F
14F9C:  MOVLW  00
14F9E:  MOVLB  0
14FA0:  ADDWFC x62,W
14FA2:  MOVLB  3
14FA4:  MOVWF  x30
14FA6:  MOVLW  00
14FA8:  MOVLB  0
14FAA:  ADDWFC x63,W
14FAC:  MOVLB  3
14FAE:  MOVFF  FF2,332
14FB2:  BCF    FF2.7
14FB4:  MOVFF  330,FF8
14FB8:  MOVFF  32F,FF7
14FBC:  MOVFF  32E,FF6
14FC0:  TBLRD*+
14FC2:  MOVF   FF5,W
14FC4:  TBLRD*
14FC6:  MOVFF  FF5,03
14FCA:  CLRF   FF8
14FCC:  BTFSC  x32.7
14FCE:  BSF    FF2.7
14FD0:  MOVLB  0
14FD2:  MOVWF  x77
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
14FD4:  MOVLW  14
14FD6:  ADDWF  x60,W
14FD8:  MOVLB  3
14FDA:  MOVWF  x2E
14FDC:  MOVLW  00
14FDE:  MOVLB  0
14FE0:  ADDWFC x61,W
14FE2:  MOVLB  3
14FE4:  MOVWF  x2F
14FE6:  MOVLW  00
14FE8:  MOVLB  0
14FEA:  ADDWFC x62,W
14FEC:  MOVLB  3
14FEE:  MOVWF  x30
14FF0:  MOVLW  00
14FF2:  MOVLB  0
14FF4:  ADDWFC x63,W
14FF6:  MOVLB  3
14FF8:  MOVFF  FF2,332
14FFC:  BCF    FF2.7
14FFE:  MOVFF  330,FF8
15002:  MOVFF  32F,FF7
15006:  MOVFF  32E,FF6
1500A:  TBLRD*+
1500C:  MOVF   FF5,W
1500E:  TBLRD*
15010:  MOVFF  FF5,03
15014:  CLRF   FF8
15016:  BTFSC  x32.7
15018:  BSF    FF2.7
1501A:  MOVLB  0
1501C:  MOVWF  x78
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
1501E:  MOVLW  16
15020:  ADDWF  x60,W
15022:  MOVLB  3
15024:  MOVWF  x2E
15026:  MOVLW  00
15028:  MOVLB  0
1502A:  ADDWFC x61,W
1502C:  MOVLB  3
1502E:  MOVWF  x2F
15030:  MOVLW  00
15032:  MOVLB  0
15034:  ADDWFC x62,W
15036:  MOVLB  3
15038:  MOVWF  x30
1503A:  MOVLW  00
1503C:  MOVLB  0
1503E:  ADDWFC x63,W
15040:  MOVLB  3
15042:  MOVFF  FF2,332
15046:  BCF    FF2.7
15048:  MOVFF  330,FF8
1504C:  MOVFF  32F,FF7
15050:  MOVFF  32E,FF6
15054:  TBLRD*+
15056:  MOVF   FF5,W
15058:  TBLRD*
1505A:  MOVFF  FF5,03
1505E:  CLRF   FF8
15060:  BTFSC  x32.7
15062:  BSF    FF2.7
15064:  MOVLB  0
15066:  MOVWF  x79
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
15068:  MOVLW  18
1506A:  ADDWF  x60,W
1506C:  MOVLB  3
1506E:  MOVWF  x2E
15070:  MOVLW  00
15072:  MOVLB  0
15074:  ADDWFC x61,W
15076:  MOVLB  3
15078:  MOVWF  x2F
1507A:  MOVLW  00
1507C:  MOVLB  0
1507E:  ADDWFC x62,W
15080:  MOVLB  3
15082:  MOVWF  x30
15084:  MOVLW  00
15086:  MOVLB  0
15088:  ADDWFC x63,W
1508A:  MOVLB  3
1508C:  MOVFF  FF2,332
15090:  BCF    FF2.7
15092:  MOVFF  330,FF8
15096:  MOVFF  32F,FF7
1509A:  MOVFF  32E,FF6
1509E:  TBLRD*+
150A0:  MOVF   FF5,W
150A2:  TBLRD*
150A4:  MOVFF  FF5,03
150A8:  CLRF   FF8
150AA:  BTFSC  x32.7
150AC:  BSF    FF2.7
150AE:  MOVLB  0
150B0:  MOVWF  x7A
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
150B2:  MOVLW  1A
150B4:  ADDWF  x60,W
150B6:  MOVLB  3
150B8:  MOVWF  x2E
150BA:  MOVLW  00
150BC:  MOVLB  0
150BE:  ADDWFC x61,W
150C0:  MOVLB  3
150C2:  MOVWF  x2F
150C4:  MOVLW  00
150C6:  MOVLB  0
150C8:  ADDWFC x62,W
150CA:  MOVLB  3
150CC:  MOVWF  x30
150CE:  MOVLW  00
150D0:  MOVLB  0
150D2:  ADDWFC x63,W
150D4:  MOVLB  3
150D6:  MOVFF  FF2,332
150DA:  BCF    FF2.7
150DC:  MOVFF  330,FF8
150E0:  MOVFF  32F,FF7
150E4:  MOVFF  32E,FF6
150E8:  TBLRD*+
150EA:  MOVF   FF5,W
150EC:  TBLRD*
150EE:  MOVFF  FF5,03
150F2:  CLRF   FF8
150F4:  BTFSC  x32.7
150F6:  BSF    FF2.7
150F8:  MOVLB  0
150FA:  MOVWF  x7B
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
150FC:  MOVLW  1C
150FE:  ADDWF  x60,W
15100:  MOVLB  3
15102:  MOVWF  x2E
15104:  MOVLW  00
15106:  MOVLB  0
15108:  ADDWFC x61,W
1510A:  MOVLB  3
1510C:  MOVWF  x2F
1510E:  MOVLW  00
15110:  MOVLB  0
15112:  ADDWFC x62,W
15114:  MOVLB  3
15116:  MOVWF  x30
15118:  MOVLW  00
1511A:  MOVLB  0
1511C:  ADDWFC x63,W
1511E:  MOVLB  3
15120:  MOVFF  FF2,332
15124:  BCF    FF2.7
15126:  MOVFF  330,FF8
1512A:  MOVFF  32F,FF7
1512E:  MOVFF  32E,FF6
15132:  TBLRD*+
15134:  MOVF   FF5,W
15136:  TBLRD*
15138:  MOVFF  FF5,03
1513C:  CLRF   FF8
1513E:  BTFSC  x32.7
15140:  BSF    FF2.7
15142:  MOVLB  0
15144:  MOVWF  x7C
15146:  MOVLB  3
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
15148:  MOVLW  10
1514A:  MOVWF  FF6
1514C:  MOVLW  04
1514E:  MOVWF  FF7
15150:  MOVLW  00
15152:  MOVWF  FF8
15154:  MOVLW  0E
15156:  MOVWF  xA2
15158:  MOVLB  0
1515A:  CALL   0702
1515E:  MOVFF  6A,3A2
15162:  MOVLW  57
15164:  MOVLB  3
15166:  MOVWF  xA3
15168:  MOVLB  0
1516A:  CALL   0734
1516E:  MOVFF  69,3A2
15172:  MOVLW  57
15174:  MOVLB  3
15176:  MOVWF  xA3
15178:  MOVLB  0
1517A:  CALL   0734
1517E:  MOVLW  0D
15180:  BTFSS  F9E.4
15182:  BRA    15180
15184:  MOVWF  FAD
15186:  MOVLW  0A
15188:  BTFSS  F9E.4
1518A:  BRA    15188
1518C:  MOVWF  FAD
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
1518E:  MOVLW  24
15190:  MOVWF  FF6
15192:  MOVLW  04
15194:  MOVWF  FF7
15196:  MOVLW  00
15198:  MOVWF  FF8
1519A:  MOVLW  0E
1519C:  MOVLB  3
1519E:  MOVWF  xA2
151A0:  MOVLB  0
151A2:  CALL   0702
151A6:  MOVFF  6B,3A2
151AA:  MOVLW  57
151AC:  MOVLB  3
151AE:  MOVWF  xA3
151B0:  MOVLB  0
151B2:  CALL   0734
151B6:  MOVLW  0D
151B8:  BTFSS  F9E.4
151BA:  BRA    151B8
151BC:  MOVWF  FAD
151BE:  MOVLW  0A
151C0:  BTFSS  F9E.4
151C2:  BRA    151C0
151C4:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
151C6:  MOVLW  38
151C8:  MOVWF  FF6
151CA:  MOVLW  04
151CC:  MOVWF  FF7
151CE:  MOVLW  00
151D0:  MOVWF  FF8
151D2:  MOVLW  0F
151D4:  MOVLB  3
151D6:  MOVWF  xA2
151D8:  MOVLB  0
151DA:  CALL   0702
151DE:  MOVFF  75,3A2
151E2:  MOVLW  57
151E4:  MOVLB  3
151E6:  MOVWF  xA3
151E8:  MOVLB  0
151EA:  CALL   0734
151EE:  MOVLW  0D
151F0:  BTFSS  F9E.4
151F2:  BRA    151F0
151F4:  MOVWF  FAD
151F6:  MOVLW  0A
151F8:  BTFSS  F9E.4
151FA:  BRA    151F8
151FC:  MOVWF  FAD
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
151FE:  MOVLW  4C
15200:  MOVWF  FF6
15202:  MOVLW  04
15204:  MOVWF  FF7
15206:  MOVLW  00
15208:  MOVWF  FF8
1520A:  MOVLW  0E
1520C:  MOVLB  3
1520E:  MOVWF  xA2
15210:  MOVLB  0
15212:  CALL   0702
15216:  MOVFF  76,3A2
1521A:  MOVLW  57
1521C:  MOVLB  3
1521E:  MOVWF  xA3
15220:  MOVLB  0
15222:  CALL   0734
15226:  MOVLW  0D
15228:  BTFSS  F9E.4
1522A:  BRA    15228
1522C:  MOVWF  FAD
1522E:  MOVLW  0A
15230:  BTFSS  F9E.4
15232:  BRA    15230
15234:  MOVWF  FAD
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
15236:  MOVLW  60
15238:  MOVWF  FF6
1523A:  MOVLW  04
1523C:  MOVWF  FF7
1523E:  MOVLW  00
15240:  MOVWF  FF8
15242:  MOVLW  13
15244:  MOVLB  3
15246:  MOVWF  xA2
15248:  MOVLB  0
1524A:  CALL   0702
1524E:  MOVFF  77,3A2
15252:  MOVLW  57
15254:  MOVLB  3
15256:  MOVWF  xA3
15258:  MOVLB  0
1525A:  CALL   0734
1525E:  MOVLW  0D
15260:  BTFSS  F9E.4
15262:  BRA    15260
15264:  MOVWF  FAD
15266:  MOVLW  0A
15268:  BTFSS  F9E.4
1526A:  BRA    15268
1526C:  MOVWF  FAD
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
1526E:  MOVLW  78
15270:  MOVWF  FF6
15272:  MOVLW  04
15274:  MOVWF  FF7
15276:  MOVLW  00
15278:  MOVWF  FF8
1527A:  MOVLW  09
1527C:  MOVLB  3
1527E:  MOVWF  xA2
15280:  MOVLB  0
15282:  CALL   0702
15286:  MOVFF  78,3A2
1528A:  MOVLW  57
1528C:  MOVLB  3
1528E:  MOVWF  xA3
15290:  MOVLB  0
15292:  CALL   0734
15296:  MOVLW  0D
15298:  BTFSS  F9E.4
1529A:  BRA    15298
1529C:  MOVWF  FAD
1529E:  MOVLW  0A
152A0:  BTFSS  F9E.4
152A2:  BRA    152A0
152A4:  MOVWF  FAD
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
152A6:  MOVLW  86
152A8:  MOVWF  FF6
152AA:  MOVLW  04
152AC:  MOVWF  FF7
152AE:  MOVLW  00
152B0:  MOVWF  FF8
152B2:  MOVLW  09
152B4:  MOVLB  3
152B6:  MOVWF  xA2
152B8:  MOVLB  0
152BA:  CALL   0702
152BE:  MOVFF  79,3A2
152C2:  MOVLW  57
152C4:  MOVLB  3
152C6:  MOVWF  xA3
152C8:  MOVLB  0
152CA:  CALL   0734
152CE:  MOVLW  0D
152D0:  BTFSS  F9E.4
152D2:  BRA    152D0
152D4:  MOVWF  FAD
152D6:  MOVLW  0A
152D8:  BTFSS  F9E.4
152DA:  BRA    152D8
152DC:  MOVWF  FAD
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
152DE:  MOVLW  94
152E0:  MOVWF  FF6
152E2:  MOVLW  04
152E4:  MOVWF  FF7
152E6:  MOVLW  00
152E8:  MOVWF  FF8
152EA:  MOVLW  0A
152EC:  MOVLB  3
152EE:  MOVWF  xA2
152F0:  MOVLB  0
152F2:  CALL   0702
152F6:  MOVFF  7A,3A2
152FA:  MOVLW  57
152FC:  MOVLB  3
152FE:  MOVWF  xA3
15300:  MOVLB  0
15302:  CALL   0734
15306:  MOVLW  0D
15308:  BTFSS  F9E.4
1530A:  BRA    15308
1530C:  MOVWF  FAD
1530E:  MOVLW  0A
15310:  BTFSS  F9E.4
15312:  BRA    15310
15314:  MOVWF  FAD
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
15316:  MOVLW  A4
15318:  MOVWF  FF6
1531A:  MOVLW  04
1531C:  MOVWF  FF7
1531E:  MOVLW  00
15320:  MOVWF  FF8
15322:  MOVLW  0F
15324:  MOVLB  3
15326:  MOVWF  xA2
15328:  MOVLB  0
1532A:  CALL   0702
1532E:  MOVFF  7B,3A2
15332:  MOVLW  57
15334:  MOVLB  3
15336:  MOVWF  xA3
15338:  MOVLB  0
1533A:  CALL   0734
1533E:  MOVLW  0D
15340:  BTFSS  F9E.4
15342:  BRA    15340
15344:  MOVWF  FAD
15346:  MOVLW  0A
15348:  BTFSS  F9E.4
1534A:  BRA    15348
1534C:  MOVWF  FAD
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
1534E:  MOVLW  B8
15350:  MOVWF  FF6
15352:  MOVLW  04
15354:  MOVWF  FF7
15356:  MOVLW  00
15358:  MOVWF  FF8
1535A:  MOVLW  0F
1535C:  MOVLB  3
1535E:  MOVWF  xA2
15360:  MOVLB  0
15362:  CALL   0702
15366:  MOVFF  7C,3A2
1536A:  MOVLW  57
1536C:  MOVLB  3
1536E:  MOVWF  xA3
15370:  MOVLB  0
15372:  CALL   0734
15376:  MOVLW  C9
15378:  MOVWF  FF6
1537A:  MOVLW  04
1537C:  MOVWF  FF7
1537E:  MOVLW  00
15380:  MOVWF  FF8
15382:  MOVLW  04
15384:  MOVLB  3
15386:  MOVWF  xA2
15388:  MOVLB  0
1538A:  CALL   0702
....................     
....................    return; 
1538E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
*
148EE:  MOVFF  FF2,339
148F2:  BCF    FF2.7
148F4:  MOVFF  66,FF8
148F8:  MOVFF  65,FF7
148FC:  MOVFF  64,FF6
14900:  TBLRD*+
14902:  MOVF   FF5,W
14904:  TBLRD*
14906:  MOVFF  FF5,03
1490A:  CLRF   FF8
1490C:  MOVLB  3
1490E:  BTFSC  x39.7
14910:  BSF    FF2.7
14912:  MOVWF  x31
14914:  MOVFF  03,332
14918:  MOVLW  02
1491A:  MOVLB  0
1491C:  ADDWF  x64,W
1491E:  MOVLB  3
14920:  MOVWF  x39
14922:  MOVLW  00
14924:  MOVLB  0
14926:  ADDWFC x65,W
14928:  MOVLB  3
1492A:  MOVWF  x3A
1492C:  MOVLW  00
1492E:  MOVLB  0
14930:  ADDWFC x66,W
14932:  MOVLB  3
14934:  MOVWF  x3B
14936:  MOVLW  00
14938:  MOVLB  0
1493A:  ADDWFC x67,W
1493C:  MOVLB  3
1493E:  MOVWF  x3C
14940:  MOVFF  FF2,33D
14944:  BCF    FF2.7
14946:  MOVFF  33B,FF8
1494A:  MOVFF  33A,FF7
1494E:  MOVFF  339,FF6
14952:  TBLRD*+
14954:  MOVF   FF5,W
14956:  TBLRD*
14958:  MOVFF  FF5,03
1495C:  CLRF   FF8
1495E:  BTFSC  x3D.7
14960:  BSF    FF2.7
14962:  MOVWF  x33
14964:  MOVFF  03,334
14968:  CLRF   x39
1496A:  CLRF   x3A
1496C:  CLRF   02
1496E:  CLRF   03
14970:  MOVF   x33,W
14972:  IORWF  x39,W
14974:  MOVWF  x35
14976:  MOVF   x34,W
14978:  IORWF  x3A,W
1497A:  MOVWF  x36
1497C:  MOVF   02,W
1497E:  IORWF  x31,W
14980:  MOVWF  x37
14982:  MOVF   03,W
14984:  IORWF  x32,W
14986:  MOVWF  x38
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
14988:  INCFSZ x35,W
1498A:  BRA    1499A
1498C:  INCFSZ x36,W
1498E:  BRA    1499A
14990:  INCFSZ x37,W
14992:  BRA    1499A
14994:  INCFSZ x38,W
14996:  BRA    1499A
14998:  BRA    149AA
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
1499A:  MOVFF  338,33
1499E:  MOVFF  337,32
149A2:  MOVFF  336,31
149A6:  MOVFF  335,30
....................    } 
....................    return; 
149AA:  MOVLB  0
149AC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
*
14000:  MOVFF  68,D3
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
14004:  MOVFF  6A,D4
....................    flag_info_bffr[2] = PASSED_DAYS; 
14008:  MOVFF  69,D5
....................    flag_info_bffr[3] = RESERVE_CHECK; 
1400C:  MOVFF  6B,D6
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
14010:  MOVFF  6D,D7
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
14014:  MOVFF  6C,D8
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
14018:  MOVFF  6E,D9
....................    flag_info_bffr[7] = MISSION_DETAIL; 
1401C:  MOVFF  6F,DA
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
14020:  MOVFF  75,DB
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
14024:  MOVFF  76,DC
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
14028:  MOVFF  77,DD
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
1402C:  MOVFF  78,DE
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
14030:  MOVFF  79,DF
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
14034:  MOVFF  7A,E0
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
14038:  MOVFF  7B,E1
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
1403C:  MOVFF  7C,E2
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
14040:  BCF    F92.5
14042:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
14044:  BCF    F94.4
14046:  BCF    F8B.4
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
14048:  MOVFF  3B,392
1404C:  MOVFF  3A,391
14050:  MOVFF  39,390
14054:  MOVFF  38,38F
14058:  CALL   11914
....................    delay_ms(200); 
1405C:  MOVLW  C8
1405E:  MOVLB  3
14060:  MOVWF  x98
14062:  MOVLB  0
14064:  CALL   0526
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
14068:  MOVLB  3
1406A:  CLRF   x85
1406C:  MOVF   x85,W
1406E:  SUBLW  0F
14070:  BNC   140C0
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
14072:  MOVF   x85,W
14074:  ADDWF  38,W
14076:  MOVWF  x86
14078:  MOVLW  00
1407A:  ADDWFC 39,W
1407C:  MOVWF  x87
1407E:  MOVLW  00
14080:  ADDWFC 3A,W
14082:  MOVWF  x88
14084:  MOVLW  00
14086:  ADDWFC 3B,W
14088:  MOVWF  x89
1408A:  CLRF   03
1408C:  MOVF   x85,W
1408E:  ADDLW  D3
14090:  MOVWF  FE9
14092:  MOVLW  00
14094:  ADDWFC 03,W
14096:  MOVWF  FEA
14098:  MOVFF  FEF,394
1409C:  MOVFF  389,393
140A0:  MOVFF  388,392
140A4:  MOVFF  387,391
140A8:  MOVFF  386,390
140AC:  MOVLB  0
140AE:  CALL   119A4
....................       delay_us(10); 
140B2:  MOVLW  0D
140B4:  MOVWF  00
140B6:  DECFSZ 00,F
140B8:  BRA    140B6
140BA:  MOVLB  3
140BC:  INCF   x85,F
140BE:  BRA    1406C
....................    } 
....................    delay_ms(10); 
140C0:  MOVLW  0A
140C2:  MOVWF  x98
140C4:  MOVLB  0
140C6:  CALL   0526
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
140CA:  MOVFF  3B,392
140CE:  MOVFF  3A,391
140D2:  MOVFF  39,390
140D6:  MOVFF  38,38F
140DA:  CALL   11A3E
....................    delay_ms(200); 
140DE:  MOVLW  C8
140E0:  MOVLB  3
140E2:  MOVWF  x98
140E4:  MOVLB  0
140E6:  CALL   0526
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
140EA:  MOVLB  3
140EC:  CLRF   x85
140EE:  MOVF   x85,W
140F0:  SUBLW  0F
140F2:  BNC   14142
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
140F4:  MOVF   x85,W
140F6:  ADDWF  38,W
140F8:  MOVWF  x86
140FA:  MOVLW  00
140FC:  ADDWFC 39,W
140FE:  MOVWF  x87
14100:  MOVLW  00
14102:  ADDWFC 3A,W
14104:  MOVWF  x88
14106:  MOVLW  00
14108:  ADDWFC 3B,W
1410A:  MOVWF  x89
1410C:  CLRF   03
1410E:  MOVF   x85,W
14110:  ADDLW  D3
14112:  MOVWF  FE9
14114:  MOVLW  00
14116:  ADDWFC 03,W
14118:  MOVWF  FEA
1411A:  MOVFF  FEF,394
1411E:  MOVFF  389,393
14122:  MOVFF  388,392
14126:  MOVFF  387,391
1412A:  MOVFF  386,390
1412E:  MOVLB  0
14130:  CALL   11ACE
....................       delay_us(10); 
14134:  MOVLW  0D
14136:  MOVWF  00
14138:  DECFSZ 00,F
1413A:  BRA    14138
1413C:  MOVLB  3
1413E:  INCF   x85,F
14140:  BRA    140EE
....................    } 
....................    delay_ms(10); 
14142:  MOVLW  0A
14144:  MOVWF  x98
14146:  MOVLB  0
14148:  CALL   0526
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
1414C:  MOVFF  3B,392
14150:  MOVFF  3A,391
14154:  MOVFF  39,390
14158:  MOVFF  38,38F
1415C:  CALL   11B68
....................    delay_ms(200); 
14160:  MOVLW  C8
14162:  MOVLB  3
14164:  MOVWF  x98
14166:  MOVLB  0
14168:  CALL   0526
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
1416C:  MOVLB  3
1416E:  CLRF   x85
14170:  MOVF   x85,W
14172:  SUBLW  0F
14174:  BNC   141C4
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
14176:  MOVF   x85,W
14178:  ADDWF  38,W
1417A:  MOVWF  x86
1417C:  MOVLW  00
1417E:  ADDWFC 39,W
14180:  MOVWF  x87
14182:  MOVLW  00
14184:  ADDWFC 3A,W
14186:  MOVWF  x88
14188:  MOVLW  00
1418A:  ADDWFC 3B,W
1418C:  MOVWF  x89
1418E:  CLRF   03
14190:  MOVF   x85,W
14192:  ADDLW  D3
14194:  MOVWF  FE9
14196:  MOVLW  00
14198:  ADDWFC 03,W
1419A:  MOVWF  FEA
1419C:  MOVFF  FEF,394
141A0:  MOVFF  389,393
141A4:  MOVFF  388,392
141A8:  MOVFF  387,391
141AC:  MOVFF  386,390
141B0:  MOVLB  0
141B2:  CALL   11C04
....................       delay_us(10); 
141B6:  MOVLW  0D
141B8:  MOVWF  00
141BA:  DECFSZ 00,F
141BC:  BRA    141BA
141BE:  MOVLB  3
141C0:  INCF   x85,F
141C2:  BRA    14170
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
141C4:  BCF    F94.4
141C6:  BSF    F8B.4
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
141C8:  MOVLW  CE
141CA:  MOVWF  FF6
141CC:  MOVLW  04
141CE:  MOVWF  FF7
141D0:  MOVLW  00
141D2:  MOVWF  FF8
141D4:  MOVLB  0
141D6:  CALL   058C
....................    return; 
141DA:  RETURN 0
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
141DC:  CLRF   x6A
141DE:  CLRF   x69
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
141E0:  CLRF   x75
....................    Kill_FLAG_FAB = 0; 
141E2:  CLRF   x76
....................    FIRST_HSSC_DONE = 0; 
141E4:  CLRF   x77
....................    AUTO_CAM_DONE = 0; 
141E6:  CLRF   x78
....................    AUTO_MBP_DONE = 0; 
141E8:  CLRF   x79
....................    AUTO_ADCS_DONE = 0; 
141EA:  CLRF   x7A
....................    ANT_DEP_STATUS = 0; 
141EC:  CLRF   x7B
....................    UPLINK_SUCCESS = 0; 
141EE:  CLRF   x7C
....................    STORE_FLAG_INFO(); 
141F0:  RCALL  14000
....................    WRITE_FLAG_to_EEPROM(); 
141F2:  CALL   11C84
....................    return; 
141F6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
*
149AE:  BCF    F94.4
149B0:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //Main side 
149B2:  BCF    F92.5
149B4:  BCF    F89.5
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
149B6:  MOVLB  3
149B8:  CLRF   xAB
149BA:  CLRF   xAA
149BC:  CLRF   xA9
149BE:  CLRF   xA8
149C0:  MOVLB  0
149C2:  CALL   121C0
149C6:  INCFSZ 01,W
149C8:  BRA    14AD6
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
149CA:  MOVLB  3
149CC:  CLRF   x52
149CE:  CLRF   x51
149D0:  CLRF   x50
149D2:  CLRF   x4F
149D4:  MOVLB  0
149D6:  CALL   12984
149DA:  INCFSZ 01,W
149DC:  BRA    14A6E
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
149DE:  MOVLB  3
149E0:  CLRF   x8C
149E2:  CLRF   x8B
149E4:  CLRF   x8A
149E6:  CLRF   x89
149E8:  MOVLB  0
149EA:  CALL   11800
149EE:  INCFSZ 01,W
149F0:  BRA    14A06
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
149F2:  RCALL  148EE
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
149F4:  MOVFF  33,32D
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
149F8:  MOVFF  32,32E
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
149FC:  MOVFF  31,32F
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
14A00:  MOVFF  30,330
....................          }else{ 
14A04:  BRA    14A6C
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
14A06:  MOVLB  3
14A08:  CLRF   x8C
14A0A:  CLRF   x8B
14A0C:  CLRF   x8A
14A0E:  CLRF   x89
14A10:  MOVLB  0
14A12:  CALL   11800
14A16:  MOVFF  01,32D
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
14A1A:  MOVLB  3
14A1C:  CLRF   x8C
14A1E:  CLRF   x8B
14A20:  CLRF   x8A
14A22:  MOVLW  01
14A24:  MOVWF  x89
14A26:  MOVLB  0
14A28:  CALL   11800
14A2C:  MOVFF  01,32E
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
14A30:  MOVLB  3
14A32:  CLRF   x8C
14A34:  CLRF   x8B
14A36:  CLRF   x8A
14A38:  MOVLW  02
14A3A:  MOVWF  x89
14A3C:  MOVLB  0
14A3E:  CALL   11800
14A42:  MOVFF  01,32F
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
14A46:  MOVLB  3
14A48:  CLRF   x8C
14A4A:  CLRF   x8B
14A4C:  CLRF   x8A
14A4E:  MOVLW  03
14A50:  MOVWF  x89
14A52:  MOVLB  0
14A54:  CALL   11800
14A58:  MOVFF  01,330
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14A5C:  MOVFF  32D,33
14A60:  MOVFF  32E,32
14A64:  MOVFF  32F,31
14A68:  MOVFF  330,30
....................          } 
....................       }else{ 
14A6C:  BRA    14AD4
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
14A6E:  MOVLB  3
14A70:  CLRF   x52
14A72:  CLRF   x51
14A74:  CLRF   x50
14A76:  CLRF   x4F
14A78:  MOVLB  0
14A7A:  CALL   12984
14A7E:  MOVFF  01,32D
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
14A82:  MOVLB  3
14A84:  CLRF   x52
14A86:  CLRF   x51
14A88:  CLRF   x50
14A8A:  MOVLW  01
14A8C:  MOVWF  x4F
14A8E:  MOVLB  0
14A90:  CALL   12984
14A94:  MOVFF  01,32E
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
14A98:  MOVLB  3
14A9A:  CLRF   x52
14A9C:  CLRF   x51
14A9E:  CLRF   x50
14AA0:  MOVLW  02
14AA2:  MOVWF  x4F
14AA4:  MOVLB  0
14AA6:  CALL   12984
14AAA:  MOVFF  01,32F
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
14AAE:  MOVLB  3
14AB0:  CLRF   x52
14AB2:  CLRF   x51
14AB4:  CLRF   x50
14AB6:  MOVLW  03
14AB8:  MOVWF  x4F
14ABA:  MOVLB  0
14ABC:  CALL   12984
14AC0:  MOVFF  01,330
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14AC4:  MOVFF  32D,33
14AC8:  MOVFF  32E,32
14ACC:  MOVFF  32F,31
14AD0:  MOVFF  330,30
....................       } 
....................    }else{ 
14AD4:  BRA    14B3C
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
14AD6:  MOVLB  3
14AD8:  CLRF   xAB
14ADA:  CLRF   xAA
14ADC:  CLRF   xA9
14ADE:  CLRF   xA8
14AE0:  MOVLB  0
14AE2:  CALL   121C0
14AE6:  MOVFF  01,32D
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
14AEA:  MOVLB  3
14AEC:  CLRF   xAB
14AEE:  CLRF   xAA
14AF0:  CLRF   xA9
14AF2:  MOVLW  01
14AF4:  MOVWF  xA8
14AF6:  MOVLB  0
14AF8:  CALL   121C0
14AFC:  MOVFF  01,32E
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
14B00:  MOVLB  3
14B02:  CLRF   xAB
14B04:  CLRF   xAA
14B06:  CLRF   xA9
14B08:  MOVLW  02
14B0A:  MOVWF  xA8
14B0C:  MOVLB  0
14B0E:  CALL   121C0
14B12:  MOVFF  01,32F
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
14B16:  MOVLB  3
14B18:  CLRF   xAB
14B1A:  CLRF   xAA
14B1C:  CLRF   xA9
14B1E:  MOVLW  03
14B20:  MOVWF  xA8
14B22:  MOVLB  0
14B24:  CALL   121C0
14B28:  MOVFF  01,330
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
14B2C:  MOVFF  32D,33
14B30:  MOVFF  32E,32
14B34:  MOVFF  32F,31
14B38:  MOVFF  330,30
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
14B3C:  MOVLB  3
14B3E:  CLRF   x2C
14B40:  MOVF   x2C,W
14B42:  SUBLW  03
14B44:  BNC   14BB6
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
14B46:  CLRF   03
14B48:  MOVF   x2C,W
14B4A:  ADDLW  2D
14B4C:  MOVWF  FE9
14B4E:  MOVLW  03
14B50:  ADDWFC 03,W
14B52:  MOVWF  FEA
14B54:  MOVFF  FEF,394
14B58:  CLRF   x93
14B5A:  CLRF   x92
14B5C:  CLRF   x91
14B5E:  MOVFF  32C,390
14B62:  MOVLB  0
14B64:  CALL   119A4
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
14B68:  CLRF   03
14B6A:  MOVLB  3
14B6C:  MOVF   x2C,W
14B6E:  ADDLW  2D
14B70:  MOVWF  FE9
14B72:  MOVLW  03
14B74:  ADDWFC 03,W
14B76:  MOVWF  FEA
14B78:  MOVFF  FEF,394
14B7C:  CLRF   x93
14B7E:  CLRF   x92
14B80:  CLRF   x91
14B82:  MOVFF  32C,390
14B86:  MOVLB  0
14B88:  CALL   11ACE
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
14B8C:  CLRF   03
14B8E:  MOVLB  3
14B90:  MOVF   x2C,W
14B92:  ADDLW  2D
14B94:  MOVWF  FE9
14B96:  MOVLW  03
14B98:  ADDWFC 03,W
14B9A:  MOVWF  FEA
14B9C:  MOVFF  FEF,394
14BA0:  CLRF   x93
14BA2:  CLRF   x92
14BA4:  CLRF   x91
14BA6:  MOVFF  32C,390
14BAA:  MOVLB  0
14BAC:  CALL   11C04
14BB0:  MOVLB  3
14BB2:  INCF   x2C,F
14BB4:  BRA    14B40
....................    } 
....................    output_high(PIN_C4); 
14BB6:  BCF    F94.4
14BB8:  BSF    F8B.4
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
14BBA:  MOVLW  EA
14BBC:  MOVWF  FF6
14BBE:  MOVLW  05
14BC0:  MOVWF  FF7
14BC2:  MOVLW  00
14BC4:  MOVWF  FF8
14BC6:  MOVLW  18
14BC8:  MOVWF  xA2
14BCA:  MOVLB  0
14BCC:  CALL   0702
14BD0:  MOVFF  33,3A2
14BD4:  MOVLW  57
14BD6:  MOVLB  3
14BD8:  MOVWF  xA3
14BDA:  MOVLB  0
14BDC:  CALL   0734
14BE0:  MOVFF  32,3A2
14BE4:  MOVLW  57
14BE6:  MOVLB  3
14BE8:  MOVWF  xA3
14BEA:  MOVLB  0
14BEC:  CALL   0734
14BF0:  MOVFF  31,3A2
14BF4:  MOVLW  57
14BF6:  MOVLB  3
14BF8:  MOVWF  xA3
14BFA:  MOVLB  0
14BFC:  CALL   0734
14C00:  MOVFF  30,3A2
14C04:  MOVLW  57
14C06:  MOVLB  3
14C08:  MOVWF  xA3
14C0A:  MOVLB  0
14C0C:  CALL   0734
14C10:  MOVLW  0D
14C12:  BTFSS  F9E.4
14C14:  BRA    14C12
14C16:  MOVWF  FAD
14C18:  MOVLW  0A
14C1A:  BTFSS  F9E.4
14C1C:  BRA    14C1A
14C1E:  MOVWF  FAD
....................    return; 
14C20:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
*
141F8:  MOVLW  25
141FA:  ADDWF  30,W
141FC:  MOVLB  3
141FE:  MOVWF  x8F
14200:  MOVLW  00
14202:  ADDWFC 31,W
14204:  MOVWF  x90
14206:  MOVLW  00
14208:  ADDWFC 32,W
1420A:  MOVWF  x91
1420C:  MOVLW  00
1420E:  ADDWFC 33,W
14210:  MOVWF  x92
14212:  MOVWF  xAB
14214:  MOVFF  391,3AA
14218:  MOVFF  390,3A9
1421C:  MOVFF  38F,3A8
14220:  MOVLB  0
14222:  CALL   121C0
14226:  MOVFF  01,38F
1422A:  MOVLW  26
1422C:  ADDWF  30,W
1422E:  MOVLB  3
14230:  MOVWF  x90
14232:  MOVLW  00
14234:  ADDWFC 31,W
14236:  MOVWF  x91
14238:  MOVLW  00
1423A:  ADDWFC 32,W
1423C:  MOVWF  x92
1423E:  MOVLW  00
14240:  ADDWFC 33,W
14242:  MOVWF  x93
14244:  MOVWF  xAB
14246:  MOVFF  392,3AA
1424A:  MOVFF  391,3A9
1424E:  MOVFF  390,3A8
14252:  MOVLB  0
14254:  CALL   121C0
14258:  MOVFF  01,390
1425C:  MOVLW  27
1425E:  ADDWF  30,W
14260:  MOVLB  3
14262:  MOVWF  x91
14264:  MOVLW  00
14266:  ADDWFC 31,W
14268:  MOVWF  x92
1426A:  MOVLW  00
1426C:  ADDWFC 32,W
1426E:  MOVWF  x93
14270:  MOVLW  00
14272:  ADDWFC 33,W
14274:  MOVWF  x94
14276:  MOVWF  xAB
14278:  MOVFF  393,3AA
1427C:  MOVFF  392,3A9
14280:  MOVFF  391,3A8
14284:  MOVLB  0
14286:  CALL   121C0
1428A:  MOVFF  01,391
1428E:  MOVLW  28
14290:  ADDWF  30,W
14292:  MOVLB  3
14294:  MOVWF  x92
14296:  MOVLW  00
14298:  ADDWFC 31,W
1429A:  MOVWF  x93
1429C:  MOVLW  00
1429E:  ADDWFC 32,W
142A0:  MOVWF  x94
142A2:  MOVLW  00
142A4:  ADDWFC 33,W
142A6:  MOVWF  x95
142A8:  MOVWF  xAB
142AA:  MOVFF  394,3AA
142AE:  MOVFF  393,3A9
142B2:  MOVFF  392,3A8
142B6:  MOVLB  0
142B8:  CALL   121C0
142BC:  MOVFF  38F,389
142C0:  MOVFF  390,388
142C4:  MOVFF  391,387
142C8:  MOVFF  01,386
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
142CC:  MOVLW  08
142CE:  MOVWF  FF6
142D0:  MOVLW  06
142D2:  MOVWF  FF7
142D4:  MOVLW  00
142D6:  MOVWF  FF8
142D8:  MOVLW  0B
142DA:  MOVLB  3
142DC:  MOVWF  xA2
142DE:  MOVLB  0
142E0:  CALL   0702
142E4:  MOVFF  389,3A2
142E8:  MOVLW  57
142EA:  MOVLB  3
142EC:  MOVWF  xA3
142EE:  MOVLB  0
142F0:  CALL   0734
142F4:  MOVFF  388,3A2
142F8:  MOVLW  57
142FA:  MOVLB  3
142FC:  MOVWF  xA3
142FE:  MOVLB  0
14300:  CALL   0734
14304:  MOVFF  387,3A2
14308:  MOVLW  57
1430A:  MOVLB  3
1430C:  MOVWF  xA3
1430E:  MOVLB  0
14310:  CALL   0734
14314:  MOVFF  386,3A2
14318:  MOVLW  57
1431A:  MOVLB  3
1431C:  MOVWF  xA3
1431E:  MOVLB  0
14320:  CALL   0734
14324:  MOVLW  0D
14326:  BTFSS  F9E.4
14328:  BRA    14326
1432A:  MOVWF  FAD
1432C:  MOVLW  0A
1432E:  BTFSS  F9E.4
14330:  BRA    1432E
14332:  MOVWF  FAD
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
14334:  MOVLB  3
14336:  MOVF   x89,F
14338:  BNZ   1435A
1433A:  MOVF   x88,W
1433C:  SUBLW  00
1433E:  BTFSC  FD8.0
14340:  BRA    144C4
14342:  XORLW  FF
14344:  BNZ   1435A
14346:  MOVF   x87,W
14348:  SUBLW  72
1434A:  BTFSC  FD8.0
1434C:  BRA    144C4
1434E:  XORLW  FF
14350:  BNZ   1435A
14352:  MOVF   x86,W
14354:  SUBLW  18
14356:  BTFSC  FD8.0
14358:  BRA    144C4
1435A:  INCFSZ x86,W
1435C:  BRA    1436C
1435E:  INCFSZ x87,W
14360:  BRA    1436C
14362:  INCFSZ x88,W
14364:  BRA    1436C
14366:  INCFSZ x89,W
14368:  BRA    1436C
1436A:  BRA    144C4
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
1436C:  BCF    F92.5
1436E:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
14370:  BCF    F94.4
14372:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_OF(0); 
14374:  CLRF   x92
14376:  CLRF   x91
14378:  CLRF   x90
1437A:  CLRF   x8F
1437C:  MOVLB  0
1437E:  CALL   11914
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
14382:  MOVLB  3
14384:  CLRF   x92
14386:  CLRF   x91
14388:  CLRF   x90
1438A:  CLRF   x8F
1438C:  MOVLB  0
1438E:  CALL   11A3E
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
14392:  MOVLB  3
14394:  CLRF   x92
14396:  CLRF   x91
14398:  CLRF   x90
1439A:  CLRF   x8F
1439C:  MOVLB  0
1439E:  CALL   11B68
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
143A2:  CLRF   37
143A4:  CLRF   36
143A6:  CLRF   35
143A8:  CLRF   34
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
143AA:  MOVLW  10
143AC:  ADDWF  31,F
143AE:  MOVLW  00
143B0:  ADDWFC 32,F
143B2:  ADDWFC 33,F
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
143B4:  BCF    F94.4
143B6:  BSF    F8B.4
....................        
....................       unsigned int8 address_place[4] = {}; 
143B8:  MOVLB  3
143BA:  CLRF   x8A
143BC:  CLRF   x8B
143BE:  CLRF   x8C
143C0:  CLRF   x8D
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
143C2:  MOVFF  33,38A
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
143C6:  MOVFF  32,38B
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
143CA:  MOVFF  31,38C
....................       address_place[3] = ADD_INFO_ADDRESS; 
143CE:  MOVFF  30,38D
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
143D2:  BCF    F92.5
143D4:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
143D6:  BCF    F94.4
143D8:  BCF    F8B.4
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
143DA:  CLRF   x8E
143DC:  MOVF   x8E,W
143DE:  SUBLW  03
143E0:  BNC   1446A
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
143E2:  CLRF   03
143E4:  MOVF   x8E,W
143E6:  ADDLW  8A
143E8:  MOVWF  FE9
143EA:  MOVLW  03
143EC:  ADDWFC 03,W
143EE:  MOVWF  FEA
143F0:  MOVFF  FEF,394
143F4:  CLRF   x93
143F6:  CLRF   x92
143F8:  CLRF   x91
143FA:  MOVFF  38E,390
143FE:  MOVLB  0
14400:  CALL   119A4
....................          delay_us(10); 
14404:  MOVLW  0D
14406:  MOVWF  00
14408:  DECFSZ 00,F
1440A:  BRA    14408
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
1440C:  CLRF   03
1440E:  MOVLB  3
14410:  MOVF   x8E,W
14412:  ADDLW  8A
14414:  MOVWF  FE9
14416:  MOVLW  03
14418:  ADDWFC 03,W
1441A:  MOVWF  FEA
1441C:  MOVFF  FEF,394
14420:  CLRF   x93
14422:  CLRF   x92
14424:  CLRF   x91
14426:  MOVFF  38E,390
1442A:  MOVLB  0
1442C:  CALL   11ACE
....................          delay_us(10); 
14430:  MOVLW  0D
14432:  MOVWF  00
14434:  DECFSZ 00,F
14436:  BRA    14434
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
14438:  CLRF   03
1443A:  MOVLB  3
1443C:  MOVF   x8E,W
1443E:  ADDLW  8A
14440:  MOVWF  FE9
14442:  MOVLW  03
14444:  ADDWFC 03,W
14446:  MOVWF  FEA
14448:  MOVFF  FEF,394
1444C:  CLRF   x93
1444E:  CLRF   x92
14450:  CLRF   x91
14452:  MOVFF  38E,390
14456:  MOVLB  0
14458:  CALL   11C04
....................          delay_us(10); 
1445C:  MOVLW  0D
1445E:  MOVWF  00
14460:  DECFSZ 00,F
14462:  BRA    14460
14464:  MOVLB  3
14466:  INCF   x8E,F
14468:  BRA    143DC
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
1446A:  BCF    F94.4
1446C:  BSF    F8B.4
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
1446E:  MOVLW  1A
14470:  MOVWF  FF6
14472:  MOVLW  06
14474:  MOVWF  FF7
14476:  MOVLW  00
14478:  MOVWF  FF8
1447A:  MOVLB  0
1447C:  CALL   058C
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
14480:  MOVLB  3
14482:  CLRF   x8E
14484:  MOVF   x8E,W
14486:  SUBLW  03
14488:  BNC   144B4
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
1448A:  CLRF   xAB
1448C:  CLRF   xAA
1448E:  CLRF   xA9
14490:  MOVFF  38E,3A8
14494:  MOVLB  0
14496:  CALL   121C0
1449A:  MOVFF  01,38F
1449E:  MOVFF  01,3A2
144A2:  MOVLW  57
144A4:  MOVLB  3
144A6:  MOVWF  xA3
144A8:  MOVLB  0
144AA:  CALL   0734
144AE:  MOVLB  3
144B0:  INCF   x8E,F
144B2:  BRA    14484
....................       } 
....................       fprintf(PC,"\r\n"); 
144B4:  MOVLW  0D
144B6:  BTFSS  F9E.4
144B8:  BRA    144B6
144BA:  MOVWF  FAD
144BC:  MOVLW  0A
144BE:  BTFSS  F9E.4
144C0:  BRA    144BE
144C2:  MOVWF  FAD
....................    } 
....................     
....................    return; 
144C4:  MOVLB  0
144C6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
*
14C22:  MOVLB  3
14C24:  CLRF   x2E
14C26:  MOVF   x2E,W
14C28:  SUBLW  0F
14C2A:  BNC   14C7E
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
14C2C:  CLRF   03
14C2E:  MOVF   x2E,W
14C30:  ADDLW  D3
14C32:  MOVWF  01
14C34:  MOVLW  00
14C36:  ADDWFC 03,F
14C38:  MOVFF  01,32F
14C3C:  MOVFF  03,330
14C40:  MOVF   x2E,W
14C42:  ADDWF  38,W
14C44:  MOVWF  x31
14C46:  MOVLW  00
14C48:  ADDWFC 39,W
14C4A:  MOVWF  x32
14C4C:  MOVLW  00
14C4E:  ADDWFC 3A,W
14C50:  MOVWF  x33
14C52:  MOVLW  00
14C54:  ADDWFC 3B,W
14C56:  MOVWF  x34
14C58:  MOVWF  xAB
14C5A:  MOVFF  333,3AA
14C5E:  MOVFF  332,3A9
14C62:  MOVFF  331,3A8
14C66:  MOVLB  0
14C68:  CALL   121C0
14C6C:  MOVFF  330,FEA
14C70:  MOVFF  32F,FE9
14C74:  MOVFF  01,FEF
14C78:  MOVLB  3
14C7A:  INCF   x2E,F
14C7C:  BRA    14C26
....................       //delay_ms(1); 
....................    } 
....................    return; 
14C7E:  MOVLB  0
14C80:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
*
144C8:  MOVLW  32
144CA:  MOVWF  FF6
144CC:  MOVLW  06
144CE:  MOVWF  FF7
144D0:  MOVLW  00
144D2:  MOVWF  FF8
144D4:  CALL   058C
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
144D8:  MOVLW  01
144DA:  ADDWF  34,F
144DC:  BTFSC  FD8.0
144DE:  INCF   35,F
144E0:  BTFSC  FD8.2
144E2:  INCF   36,F
144E4:  BTFSC  FD8.2
144E6:  INCF   37,F
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
144E8:  RCALL  141F8
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
144EA:  MOVFF  3B,AA
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
144EE:  MOVFF  3A,AB
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
144F2:  MOVFF  39,AC
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
144F6:  MOVFF  38,AD
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
144FA:  MOVFF  3F,AE
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
144FE:  MOVFF  3E,AF
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
14502:  MOVFF  3D,B0
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
14506:  MOVFF  3C,B1
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
1450A:  MOVFF  43,B2
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
1450E:  MOVFF  42,B3
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
14512:  MOVFF  41,B4
....................    sec_add_bfr[11] = SAT_LOG; 
14516:  MOVFF  40,B5
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
1451A:  MOVFF  47,B6
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
1451E:  MOVFF  46,B7
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
14522:  MOVFF  45,B8
....................    sec_add_bfr[15] = CAM_ADDRESS; 
14526:  MOVFF  44,B9
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
1452A:  MOVFF  4B,BA
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
1452E:  MOVFF  4A,BB
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
14532:  MOVFF  49,BC
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
14536:  MOVFF  48,BD
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
1453A:  MOVFF  4F,BE
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
1453E:  MOVFF  4E,BF
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
14542:  MOVFF  4D,C0
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
14546:  MOVFF  4C,C1
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
1454A:  MOVFF  53,C2
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
1454E:  MOVFF  52,C3
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
14552:  MOVFF  51,C4
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
14556:  MOVFF  50,C5
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
1455A:  MOVFF  5B,C6
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
1455E:  MOVFF  5A,C7
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
14562:  MOVFF  59,C8
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
14566:  MOVFF  58,C9
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
1456A:  MOVFF  5F,CA
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
1456E:  MOVFF  5E,CB
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
14572:  MOVFF  5D,CC
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
14576:  MOVFF  5C,CD
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
1457A:  MOVFF  68,CE
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
1457E:  MOVFF  37,CF
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
14582:  MOVFF  36,D0
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
14586:  MOVFF  35,D1
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
1458A:  MOVFF  34,D2
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
1458E:  BCF    F92.5
14590:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
14592:  BCF    F94.4
14594:  BCF    F8B.4
....................    int8 num = 0; 
14596:  MOVLB  3
14598:  CLRF   x85
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
1459A:  MOVFF  33,392
1459E:  MOVFF  32,391
145A2:  MOVFF  31,390
145A6:  MOVFF  30,38F
145AA:  MOVLB  0
145AC:  CALL   11914
....................    delay_ms(200); 
145B0:  MOVLW  C8
145B2:  MOVLB  3
145B4:  MOVWF  x98
145B6:  MOVLB  0
145B8:  CALL   0526
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
145BC:  MOVLB  3
145BE:  CLRF   x85
145C0:  MOVF   x85,W
145C2:  SUBLW  28
145C4:  BNC   14614
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
145C6:  MOVF   x85,W
145C8:  ADDWF  30,W
145CA:  MOVWF  x86
145CC:  MOVLW  00
145CE:  ADDWFC 31,W
145D0:  MOVWF  x87
145D2:  MOVLW  00
145D4:  ADDWFC 32,W
145D6:  MOVWF  x88
145D8:  MOVLW  00
145DA:  ADDWFC 33,W
145DC:  MOVWF  x89
145DE:  CLRF   03
145E0:  MOVF   x85,W
145E2:  ADDLW  AA
145E4:  MOVWF  FE9
145E6:  MOVLW  00
145E8:  ADDWFC 03,W
145EA:  MOVWF  FEA
145EC:  MOVFF  FEF,394
145F0:  MOVFF  389,393
145F4:  MOVFF  388,392
145F8:  MOVFF  387,391
145FC:  MOVFF  386,390
14600:  MOVLB  0
14602:  CALL   119A4
....................       delay_us(10); 
14606:  MOVLW  0D
14608:  MOVWF  00
1460A:  DECFSZ 00,F
1460C:  BRA    1460A
1460E:  MOVLB  3
14610:  INCF   x85,F
14612:  BRA    145C0
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
14614:  MOVFF  33,392
14618:  MOVFF  32,391
1461C:  MOVFF  31,390
14620:  MOVFF  30,38F
14624:  MOVLB  0
14626:  CALL   11A3E
....................    delay_ms(200); 
1462A:  MOVLW  C8
1462C:  MOVLB  3
1462E:  MOVWF  x98
14630:  MOVLB  0
14632:  CALL   0526
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
14636:  MOVLB  3
14638:  CLRF   x85
1463A:  MOVF   x85,W
1463C:  SUBLW  28
1463E:  BNC   1468E
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
14640:  MOVF   x85,W
14642:  ADDWF  30,W
14644:  MOVWF  x86
14646:  MOVLW  00
14648:  ADDWFC 31,W
1464A:  MOVWF  x87
1464C:  MOVLW  00
1464E:  ADDWFC 32,W
14650:  MOVWF  x88
14652:  MOVLW  00
14654:  ADDWFC 33,W
14656:  MOVWF  x89
14658:  CLRF   03
1465A:  MOVF   x85,W
1465C:  ADDLW  AA
1465E:  MOVWF  FE9
14660:  MOVLW  00
14662:  ADDWFC 03,W
14664:  MOVWF  FEA
14666:  MOVFF  FEF,394
1466A:  MOVFF  389,393
1466E:  MOVFF  388,392
14672:  MOVFF  387,391
14676:  MOVFF  386,390
1467A:  MOVLB  0
1467C:  CALL   11ACE
....................       delay_us(10); 
14680:  MOVLW  0D
14682:  MOVWF  00
14684:  DECFSZ 00,F
14686:  BRA    14684
14688:  MOVLB  3
1468A:  INCF   x85,F
1468C:  BRA    1463A
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
1468E:  MOVFF  33,392
14692:  MOVFF  32,391
14696:  MOVFF  31,390
1469A:  MOVFF  30,38F
1469E:  MOVLB  0
146A0:  CALL   11B68
....................    delay_ms(200); 
146A4:  MOVLW  C8
146A6:  MOVLB  3
146A8:  MOVWF  x98
146AA:  MOVLB  0
146AC:  CALL   0526
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
146B0:  MOVLB  3
146B2:  CLRF   x85
146B4:  MOVF   x85,W
146B6:  SUBLW  28
146B8:  BNC   14708
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
146BA:  MOVF   x85,W
146BC:  ADDWF  30,W
146BE:  MOVWF  x86
146C0:  MOVLW  00
146C2:  ADDWFC 31,W
146C4:  MOVWF  x87
146C6:  MOVLW  00
146C8:  ADDWFC 32,W
146CA:  MOVWF  x88
146CC:  MOVLW  00
146CE:  ADDWFC 33,W
146D0:  MOVWF  x89
146D2:  CLRF   03
146D4:  MOVF   x85,W
146D6:  ADDLW  AA
146D8:  MOVWF  FE9
146DA:  MOVLW  00
146DC:  ADDWFC 03,W
146DE:  MOVWF  FEA
146E0:  MOVFF  FEF,394
146E4:  MOVFF  389,393
146E8:  MOVFF  388,392
146EC:  MOVFF  387,391
146F0:  MOVFF  386,390
146F4:  MOVLB  0
146F6:  CALL   11C04
....................       delay_us(10); 
146FA:  MOVLW  0D
146FC:  MOVWF  00
146FE:  DECFSZ 00,F
14700:  BRA    146FE
14702:  MOVLB  3
14704:  INCF   x85,F
14706:  BRA    146B4
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
14708:  BCF    F94.4
1470A:  BSF    F8B.4
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
1470C:  MOVLW  56
1470E:  MOVWF  FF6
14710:  MOVLW  06
14712:  MOVWF  FF7
14714:  MOVLW  00
14716:  MOVWF  FF8
14718:  MOVLW  18
1471A:  MOVWF  xA2
1471C:  MOVLB  0
1471E:  CALL   0702
14722:  MOVFF  33,3A2
14726:  MOVLW  57
14728:  MOVLB  3
1472A:  MOVWF  xA3
1472C:  MOVLB  0
1472E:  CALL   0734
14732:  MOVFF  32,3A2
14736:  MOVLW  57
14738:  MOVLB  3
1473A:  MOVWF  xA3
1473C:  MOVLB  0
1473E:  CALL   0734
14742:  MOVFF  31,3A2
14746:  MOVLW  57
14748:  MOVLB  3
1474A:  MOVWF  xA3
1474C:  MOVLB  0
1474E:  CALL   0734
14752:  MOVFF  30,3A2
14756:  MOVLW  57
14758:  MOVLB  3
1475A:  MOVWF  xA3
1475C:  MOVLB  0
1475E:  CALL   0734
14762:  MOVLW  0D
14764:  BTFSS  F9E.4
14766:  BRA    14764
14768:  MOVWF  FAD
1476A:  MOVLW  0A
1476C:  BTFSS  F9E.4
1476E:  BRA    1476C
14770:  MOVWF  FAD
....................    return; 
14772:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
*
15390:  MOVLB  3
15392:  CLRF   x2E
15394:  MOVF   x2E,W
15396:  SUBLW  28
15398:  BNC   153EC
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
1539A:  CLRF   03
1539C:  MOVF   x2E,W
1539E:  ADDLW  AA
153A0:  MOVWF  01
153A2:  MOVLW  00
153A4:  ADDWFC 03,F
153A6:  MOVFF  01,32F
153AA:  MOVFF  03,330
153AE:  MOVF   x2E,W
153B0:  ADDWF  30,W
153B2:  MOVWF  x31
153B4:  MOVLW  00
153B6:  ADDWFC 31,W
153B8:  MOVWF  x32
153BA:  MOVLW  00
153BC:  ADDWFC 32,W
153BE:  MOVWF  x33
153C0:  MOVLW  00
153C2:  ADDWFC 33,W
153C4:  MOVWF  x34
153C6:  MOVWF  xAB
153C8:  MOVFF  333,3AA
153CC:  MOVFF  332,3A9
153D0:  MOVFF  331,3A8
153D4:  MOVLB  0
153D6:  CALL   121C0
153DA:  MOVFF  330,FEA
153DE:  MOVFF  32F,FE9
153E2:  MOVFF  01,FEF
153E6:  MOVLB  3
153E8:  INCF   x2E,F
153EA:  BRA    15394
....................    } 
....................    return; 
153EC:  MOVLB  0
153EE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
*
15492:  BCF    F94.4
15494:  BCF    F8B.4
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
15496:  MOVLB  3
15498:  CLRF   x2E
1549A:  MOVF   x2E,W
1549C:  SUBLW  28
1549E:  BNC   154F2
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
154A0:  CLRF   03
154A2:  MOVF   x2E,W
154A4:  ADDLW  AA
154A6:  MOVWF  01
154A8:  MOVLW  00
154AA:  ADDWFC 03,F
154AC:  MOVFF  01,32F
154B0:  MOVFF  03,330
154B4:  MOVF   x2E,W
154B6:  ADDWF  30,W
154B8:  MOVWF  x31
154BA:  MOVLW  00
154BC:  ADDWFC 31,W
154BE:  MOVWF  x32
154C0:  MOVLW  00
154C2:  ADDWFC 32,W
154C4:  MOVWF  x33
154C6:  MOVLW  00
154C8:  ADDWFC 33,W
154CA:  MOVWF  x34
154CC:  MOVWF  x52
154CE:  MOVFF  333,351
154D2:  MOVFF  332,350
154D6:  MOVFF  331,34F
154DA:  MOVLB  0
154DC:  CALL   12984
154E0:  MOVFF  330,FEA
154E4:  MOVFF  32F,FE9
154E8:  MOVFF  01,FEF
154EC:  MOVLB  3
154EE:  INCF   x2E,F
154F0:  BRA    1549A
....................    } 
....................    output_high(PIN_C4); 
154F2:  BCF    F94.4
154F4:  BSF    F8B.4
....................    return; 
154F6:  MOVLB  0
154F8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
154FA:  BCF    F92.5
154FC:  BCF    F89.5
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
154FE:  MOVLB  3
15500:  CLRF   x2E
15502:  MOVF   x2E,W
15504:  SUBLW  28
15506:  BNC   1555A
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
15508:  CLRF   03
1550A:  MOVF   x2E,W
1550C:  ADDLW  AA
1550E:  MOVWF  01
15510:  MOVLW  00
15512:  ADDWFC 03,F
15514:  MOVFF  01,32F
15518:  MOVFF  03,330
1551C:  MOVF   x2E,W
1551E:  ADDWF  30,W
15520:  MOVWF  x31
15522:  MOVLW  00
15524:  ADDWFC 31,W
15526:  MOVWF  x32
15528:  MOVLW  00
1552A:  ADDWFC 32,W
1552C:  MOVWF  x33
1552E:  MOVLW  00
15530:  ADDWFC 33,W
15532:  MOVWF  x34
15534:  MOVWF  x8C
15536:  MOVFF  333,38B
1553A:  MOVFF  332,38A
1553E:  MOVFF  331,389
15542:  MOVLB  0
15544:  CALL   11800
15548:  MOVFF  330,FEA
1554C:  MOVFF  32F,FE9
15550:  MOVFF  01,FEF
15554:  MOVLB  3
15556:  INCF   x2E,F
15558:  BRA    15502
....................    } 
....................    return; 
1555A:  MOVLB  0
1555C:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
*
153F0:  MOVFF  AA,3B
153F4:  MOVFF  AB,3A
153F8:  MOVFF  AC,39
153FC:  MOVFF  AD,38
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
15400:  MOVFF  AE,3F
15404:  MOVFF  AF,3E
15408:  MOVFF  B0,3D
1540C:  MOVFF  B1,3C
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
15410:  MOVFF  B2,43
15414:  MOVFF  B3,42
15418:  MOVFF  B4,41
1541C:  MOVFF  B5,40
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
15420:  MOVFF  B6,47
15424:  MOVFF  B7,46
15428:  MOVFF  B8,45
1542C:  MOVFF  B9,44
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
15430:  MOVFF  BA,4B
15434:  MOVFF  BB,4A
15438:  MOVFF  BC,49
1543C:  MOVFF  BD,48
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
15440:  MOVFF  BE,4F
15444:  MOVFF  BF,4E
15448:  MOVFF  C0,4D
1544C:  MOVFF  C1,4C
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
15450:  MOVFF  C2,53
15454:  MOVFF  C3,52
15458:  MOVFF  C4,51
1545C:  MOVFF  C5,50
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
15460:  MOVFF  C6,5B
15464:  MOVFF  C7,5A
15468:  MOVFF  C8,59
1546C:  MOVFF  C9,58
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
15470:  MOVFF  CA,5F
15474:  MOVFF  CB,5E
15478:  MOVFF  CC,5D
1547C:  MOVFF  CD,5C
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
15480:  MOVFF  CE,37
15484:  MOVFF  CF,36
15488:  MOVFF  D0,35
1548C:  MOVFF  D1,34
....................     
....................    return; 
15490:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
*
1555E:  MOVLB  3
15560:  CLRF   x2C
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
15562:  MOVLB  0
15564:  RCALL  15390
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
15566:  MOVLW  25
15568:  MOVLB  3
1556A:  MOVWF  x2D
1556C:  MOVF   x2D,W
1556E:  SUBLW  28
15570:  BNC   1558A
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
15572:  CLRF   03
15574:  MOVF   x2D,W
15576:  ADDLW  AA
15578:  MOVWF  FE9
1557A:  MOVLW  00
1557C:  ADDWFC 03,W
1557E:  MOVWF  FEA
15580:  INCFSZ FEF,W
15582:  BRA    15586
....................       { 
....................          checksum++; 
15584:  INCF   x2C,F
....................       } 
15586:  INCF   x2D,F
15588:  BRA    1556C
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
1558A:  MOVF   x2C,W
1558C:  SUBLW  04
1558E:  BZ    155D2
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
15590:  CLRF   x2D
15592:  MOVF   x2D,W
15594:  SUBLW  28
15596:  BNC   155BA
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
15598:  CLRF   03
1559A:  MOVF   x2D,W
1559C:  ADDLW  AA
1559E:  MOVWF  FE9
155A0:  MOVLW  00
155A2:  ADDWFC 03,W
155A4:  MOVWF  FEA
155A6:  MOVFF  FEF,3A2
155AA:  MOVLW  57
155AC:  MOVWF  xA3
155AE:  MOVLB  0
155B0:  CALL   0734
155B4:  MOVLB  3
155B6:  INCF   x2D,F
155B8:  BRA    15592
....................       } 
....................       fprintf(PC,"\r\n"); 
155BA:  MOVLW  0D
155BC:  BTFSS  F9E.4
155BE:  BRA    155BC
155C0:  MOVWF  FAD
155C2:  MOVLW  0A
155C4:  BTFSS  F9E.4
155C6:  BRA    155C4
155C8:  MOVWF  FAD
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
155CA:  MOVLB  0
155CC:  RCALL  153F0
....................    }else{                                                                        //if there is nothing, check from SCF 
155CE:  BRA    156BE
155D0:  MOVLB  3
....................       output_low(PIN_C4); 
155D2:  BCF    F94.4
155D4:  BCF    F8B.4
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
155D6:  MOVLB  0
155D8:  RCALL  15492
....................       output_high(PIN_C4); 
155DA:  BCF    F94.4
155DC:  BSF    F8B.4
....................       checksum = 0; 
155DE:  MOVLB  3
155E0:  CLRF   x2C
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
155E2:  MOVLW  25
155E4:  MOVWF  x2D
155E6:  MOVF   x2D,W
155E8:  SUBLW  28
155EA:  BNC   15604
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
155EC:  CLRF   03
155EE:  MOVF   x2D,W
155F0:  ADDLW  AA
155F2:  MOVWF  FE9
155F4:  MOVLW  00
155F6:  ADDWFC 03,W
155F8:  MOVWF  FEA
155FA:  INCFSZ FEF,W
155FC:  BRA    15600
....................          { 
....................             checksum++; 
155FE:  INCF   x2C,F
....................          } 
15600:  INCF   x2D,F
15602:  BRA    155E6
....................       } 
....................       if(checksum != 4) 
15604:  MOVF   x2C,W
15606:  SUBLW  04
15608:  BZ    1564C
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
1560A:  CLRF   x2D
1560C:  MOVF   x2D,W
1560E:  SUBLW  28
15610:  BNC   15634
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
15612:  CLRF   03
15614:  MOVF   x2D,W
15616:  ADDLW  AA
15618:  MOVWF  FE9
1561A:  MOVLW  00
1561C:  ADDWFC 03,W
1561E:  MOVWF  FEA
15620:  MOVFF  FEF,3A2
15624:  MOVLW  57
15626:  MOVWF  xA3
15628:  MOVLB  0
1562A:  CALL   0734
1562E:  MOVLB  3
15630:  INCF   x2D,F
15632:  BRA    1560C
....................          } 
....................          fprintf(PC,"\r\n"); 
15634:  MOVLW  0D
15636:  BTFSS  F9E.4
15638:  BRA    15636
1563A:  MOVWF  FAD
1563C:  MOVLW  0A
1563E:  BTFSS  F9E.4
15640:  BRA    1563E
15642:  MOVWF  FAD
....................          MAKE_ADDRESS_DATA(); 
15644:  MOVLB  0
15646:  RCALL  153F0
....................       }else{                                                                     //if there is nothing, check from SMF 
15648:  BRA    156BE
1564A:  MOVLB  3
....................          output_low(PIN_A5); 
1564C:  BCF    F92.5
1564E:  BCF    F89.5
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
15650:  MOVLB  0
15652:  RCALL  154FA
....................          checksum = 0; 
15654:  MOVLB  3
15656:  CLRF   x2C
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
15658:  MOVLW  25
1565A:  MOVWF  x2D
1565C:  MOVF   x2D,W
1565E:  SUBLW  28
15660:  BNC   1567A
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
15662:  CLRF   03
15664:  MOVF   x2D,W
15666:  ADDLW  AA
15668:  MOVWF  FE9
1566A:  MOVLW  00
1566C:  ADDWFC 03,W
1566E:  MOVWF  FEA
15670:  INCFSZ FEF,W
15672:  BRA    15676
....................             { 
....................                checksum++; 
15674:  INCF   x2C,F
....................             } 
15676:  INCF   x2D,F
15678:  BRA    1565C
....................          } 
....................          if(checksum != 4) 
1567A:  MOVF   x2C,W
1567C:  SUBLW  04
1567E:  BZ    156C0
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
15680:  CLRF   x2D
15682:  MOVF   x2D,W
15684:  SUBLW  28
15686:  BNC   156AA
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
15688:  CLRF   03
1568A:  MOVF   x2D,W
1568C:  ADDLW  AA
1568E:  MOVWF  FE9
15690:  MOVLW  00
15692:  ADDWFC 03,W
15694:  MOVWF  FEA
15696:  MOVFF  FEF,3A2
1569A:  MOVLW  57
1569C:  MOVWF  xA3
1569E:  MOVLB  0
156A0:  CALL   0734
156A4:  MOVLB  3
156A6:  INCF   x2D,F
156A8:  BRA    15682
....................             } 
....................             fprintf(PC,"\r\n"); 
156AA:  MOVLW  0D
156AC:  BTFSS  F9E.4
156AE:  BRA    156AC
156B0:  MOVWF  FAD
156B2:  MOVLW  0A
156B4:  BTFSS  F9E.4
156B6:  BRA    156B4
156B8:  MOVWF  FAD
....................             MAKE_ADDRESS_DATA(); 
156BA:  MOVLB  0
156BC:  RCALL  153F0
156BE:  MOVLB  3
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
156C0:  CLRF   x2C
....................    return; 
156C2:  MOVLB  0
156C4:  RETURN 0
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
*
15B08:  MOVLW  74
15B0A:  MOVWF  FF6
15B0C:  MOVLW  06
15B0E:  MOVWF  FF7
15B10:  MOVLW  00
15B12:  MOVWF  FF8
15B14:  CALL   058C
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
15B18:  BCF    F92.5
15B1A:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
15B1C:  BCF    F94.4
15B1E:  BCF    F8B.4
....................     
....................    sector_erase_OF(0); 
15B20:  MOVLB  3
15B22:  CLRF   x8C
15B24:  CLRF   x8B
15B26:  CLRF   x8A
15B28:  CLRF   x89
15B2A:  MOVLB  0
15B2C:  CALL   12550
....................    sector_erase_SCF(0); 
15B30:  MOVLB  3
15B32:  CLRF   x8C
15B34:  CLRF   x8B
15B36:  CLRF   x8A
15B38:  CLRF   x89
15B3A:  MOVLB  0
15B3C:  CALL   125EE
....................    sector_erase_SMF(0); 
15B40:  MOVLB  3
15B42:  CLRF   x8C
15B44:  CLRF   x8B
15B46:  CLRF   x8A
15B48:  CLRF   x89
15B4A:  MOVLB  0
15B4C:  CALL   1268C
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
15B50:  MOVFF  4F,38C
15B54:  MOVFF  4E,38B
15B58:  MOVFF  4D,38A
15B5C:  MOVFF  4C,389
15B60:  CALL   12550
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
15B64:  MOVFF  4F,38C
15B68:  MOVFF  4E,38B
15B6C:  MOVFF  4D,38A
15B70:  MOVFF  4C,389
15B74:  CALL   125EE
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
15B78:  MOVFF  4F,38C
15B7C:  MOVFF  4E,38B
15B80:  MOVFF  4D,38A
15B84:  MOVFF  4C,389
15B88:  CALL   1268C
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
15B8C:  MOVLB  3
15B8E:  CLRF   x37
15B90:  MOVF   x37,W
15B92:  SUBLW  04
15B94:  BTFSS  FD8.0
15B96:  BRA    15FF8
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
15B98:  CLRF   01
15B9A:  CLRF   02
15B9C:  MOVFF  01,03
15BA0:  MOVFF  337,02
15BA4:  CLRF   00
15BA6:  CLRF   01
15BA8:  MOVF   00,W
15BAA:  ADDWF  38,W
15BAC:  MOVWF  x39
15BAE:  MOVF   01,W
15BB0:  ADDWFC 39,W
15BB2:  MOVWF  x3A
15BB4:  MOVF   x37,W
15BB6:  ADDWFC 3A,W
15BB8:  MOVWF  x3B
15BBA:  MOVF   03,W
15BBC:  ADDWFC 3B,W
15BBE:  MOVWF  x3C
15BC0:  MOVWF  x8C
15BC2:  MOVFF  33B,38B
15BC6:  MOVFF  33A,38A
15BCA:  MOVFF  339,389
15BCE:  MOVLB  0
15BD0:  CALL   12550
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
15BD4:  CLRF   01
15BD6:  CLRF   02
15BD8:  MOVFF  01,03
15BDC:  MOVFF  337,02
15BE0:  CLRF   00
15BE2:  CLRF   01
15BE4:  MOVF   00,W
15BE6:  ADDWF  44,W
15BE8:  MOVLB  3
15BEA:  MOVWF  x39
15BEC:  MOVF   01,W
15BEE:  ADDWFC 45,W
15BF0:  MOVWF  x3A
15BF2:  MOVF   x37,W
15BF4:  ADDWFC 46,W
15BF6:  MOVWF  x3B
15BF8:  MOVF   03,W
15BFA:  ADDWFC 47,W
15BFC:  MOVWF  x3C
15BFE:  MOVWF  x8C
15C00:  MOVFF  33B,38B
15C04:  MOVFF  33A,38A
15C08:  MOVFF  339,389
15C0C:  MOVLB  0
15C0E:  CALL   12550
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
15C12:  CLRF   01
15C14:  CLRF   02
15C16:  MOVFF  01,03
15C1A:  MOVFF  337,02
15C1E:  CLRF   00
15C20:  CLRF   01
15C22:  MOVF   00,W
15C24:  ADDWF  48,W
15C26:  MOVLB  3
15C28:  MOVWF  x39
15C2A:  MOVF   01,W
15C2C:  ADDWFC 49,W
15C2E:  MOVWF  x3A
15C30:  MOVF   x37,W
15C32:  ADDWFC 4A,W
15C34:  MOVWF  x3B
15C36:  MOVF   03,W
15C38:  ADDWFC 4B,W
15C3A:  MOVWF  x3C
15C3C:  MOVWF  x8C
15C3E:  MOVFF  33B,38B
15C42:  MOVFF  33A,38A
15C46:  MOVFF  339,389
15C4A:  MOVLB  0
15C4C:  CALL   12550
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
15C50:  CLRF   01
15C52:  CLRF   02
15C54:  MOVFF  01,03
15C58:  MOVFF  337,02
15C5C:  CLRF   00
15C5E:  CLRF   01
15C60:  MOVF   00,W
15C62:  ADDWF  50,W
15C64:  MOVLB  3
15C66:  MOVWF  x39
15C68:  MOVF   01,W
15C6A:  ADDWFC 51,W
15C6C:  MOVWF  x3A
15C6E:  MOVF   x37,W
15C70:  ADDWFC 52,W
15C72:  MOVWF  x3B
15C74:  MOVF   03,W
15C76:  ADDWFC 53,W
15C78:  MOVWF  x3C
15C7A:  MOVWF  x8C
15C7C:  MOVFF  33B,38B
15C80:  MOVFF  33A,38A
15C84:  MOVFF  339,389
15C88:  MOVLB  0
15C8A:  CALL   12550
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
15C8E:  CLRF   01
15C90:  CLRF   02
15C92:  MOVFF  01,03
15C96:  MOVFF  337,02
15C9A:  CLRF   00
15C9C:  CLRF   01
15C9E:  MOVF   00,W
15CA0:  ADDWF  58,W
15CA2:  MOVLB  3
15CA4:  MOVWF  x39
15CA6:  MOVF   01,W
15CA8:  ADDWFC 59,W
15CAA:  MOVWF  x3A
15CAC:  MOVF   x37,W
15CAE:  ADDWFC 5A,W
15CB0:  MOVWF  x3B
15CB2:  MOVF   03,W
15CB4:  ADDWFC 5B,W
15CB6:  MOVWF  x3C
15CB8:  MOVWF  x8C
15CBA:  MOVFF  33B,38B
15CBE:  MOVFF  33A,38A
15CC2:  MOVFF  339,389
15CC6:  MOVLB  0
15CC8:  CALL   12550
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
15CCC:  CLRF   01
15CCE:  CLRF   02
15CD0:  MOVFF  01,03
15CD4:  MOVFF  337,02
15CD8:  CLRF   00
15CDA:  CLRF   01
15CDC:  MOVF   00,W
15CDE:  ADDWF  5C,W
15CE0:  MOVLB  3
15CE2:  MOVWF  x39
15CE4:  MOVF   01,W
15CE6:  ADDWFC 5D,W
15CE8:  MOVWF  x3A
15CEA:  MOVF   x37,W
15CEC:  ADDWFC 5E,W
15CEE:  MOVWF  x3B
15CF0:  MOVF   03,W
15CF2:  ADDWFC 5F,W
15CF4:  MOVWF  x3C
15CF6:  MOVWF  x8C
15CF8:  MOVFF  33B,38B
15CFC:  MOVFF  33A,38A
15D00:  MOVFF  339,389
15D04:  MOVLB  0
15D06:  CALL   12550
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
15D0A:  CLRF   01
15D0C:  CLRF   02
15D0E:  MOVFF  01,03
15D12:  MOVFF  337,02
15D16:  CLRF   00
15D18:  CLRF   01
15D1A:  MOVF   00,W
15D1C:  ADDWF  38,W
15D1E:  MOVLB  3
15D20:  MOVWF  x39
15D22:  MOVF   01,W
15D24:  ADDWFC 39,W
15D26:  MOVWF  x3A
15D28:  MOVF   x37,W
15D2A:  ADDWFC 3A,W
15D2C:  MOVWF  x3B
15D2E:  MOVF   03,W
15D30:  ADDWFC 3B,W
15D32:  MOVWF  x3C
15D34:  MOVWF  x8C
15D36:  MOVFF  33B,38B
15D3A:  MOVFF  33A,38A
15D3E:  MOVFF  339,389
15D42:  MOVLB  0
15D44:  CALL   125EE
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
15D48:  CLRF   01
15D4A:  CLRF   02
15D4C:  MOVFF  01,03
15D50:  MOVFF  337,02
15D54:  CLRF   00
15D56:  CLRF   01
15D58:  MOVF   00,W
15D5A:  ADDWF  44,W
15D5C:  MOVLB  3
15D5E:  MOVWF  x39
15D60:  MOVF   01,W
15D62:  ADDWFC 45,W
15D64:  MOVWF  x3A
15D66:  MOVF   x37,W
15D68:  ADDWFC 46,W
15D6A:  MOVWF  x3B
15D6C:  MOVF   03,W
15D6E:  ADDWFC 47,W
15D70:  MOVWF  x3C
15D72:  MOVWF  x8C
15D74:  MOVFF  33B,38B
15D78:  MOVFF  33A,38A
15D7C:  MOVFF  339,389
15D80:  MOVLB  0
15D82:  CALL   125EE
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
15D86:  CLRF   01
15D88:  CLRF   02
15D8A:  MOVFF  01,03
15D8E:  MOVFF  337,02
15D92:  CLRF   00
15D94:  CLRF   01
15D96:  MOVF   00,W
15D98:  ADDWF  48,W
15D9A:  MOVLB  3
15D9C:  MOVWF  x39
15D9E:  MOVF   01,W
15DA0:  ADDWFC 49,W
15DA2:  MOVWF  x3A
15DA4:  MOVF   x37,W
15DA6:  ADDWFC 4A,W
15DA8:  MOVWF  x3B
15DAA:  MOVF   03,W
15DAC:  ADDWFC 4B,W
15DAE:  MOVWF  x3C
15DB0:  MOVWF  x8C
15DB2:  MOVFF  33B,38B
15DB6:  MOVFF  33A,38A
15DBA:  MOVFF  339,389
15DBE:  MOVLB  0
15DC0:  CALL   125EE
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
15DC4:  CLRF   01
15DC6:  CLRF   02
15DC8:  MOVFF  01,03
15DCC:  MOVFF  337,02
15DD0:  CLRF   00
15DD2:  CLRF   01
15DD4:  MOVF   00,W
15DD6:  ADDWF  50,W
15DD8:  MOVLB  3
15DDA:  MOVWF  x39
15DDC:  MOVF   01,W
15DDE:  ADDWFC 51,W
15DE0:  MOVWF  x3A
15DE2:  MOVF   x37,W
15DE4:  ADDWFC 52,W
15DE6:  MOVWF  x3B
15DE8:  MOVF   03,W
15DEA:  ADDWFC 53,W
15DEC:  MOVWF  x3C
15DEE:  MOVWF  x8C
15DF0:  MOVFF  33B,38B
15DF4:  MOVFF  33A,38A
15DF8:  MOVFF  339,389
15DFC:  MOVLB  0
15DFE:  CALL   125EE
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
15E02:  CLRF   01
15E04:  CLRF   02
15E06:  MOVFF  01,03
15E0A:  MOVFF  337,02
15E0E:  CLRF   00
15E10:  CLRF   01
15E12:  MOVF   00,W
15E14:  ADDWF  58,W
15E16:  MOVLB  3
15E18:  MOVWF  x39
15E1A:  MOVF   01,W
15E1C:  ADDWFC 59,W
15E1E:  MOVWF  x3A
15E20:  MOVF   x37,W
15E22:  ADDWFC 5A,W
15E24:  MOVWF  x3B
15E26:  MOVF   03,W
15E28:  ADDWFC 5B,W
15E2A:  MOVWF  x3C
15E2C:  MOVWF  x8C
15E2E:  MOVFF  33B,38B
15E32:  MOVFF  33A,38A
15E36:  MOVFF  339,389
15E3A:  MOVLB  0
15E3C:  CALL   125EE
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
15E40:  CLRF   01
15E42:  CLRF   02
15E44:  MOVFF  01,03
15E48:  MOVFF  337,02
15E4C:  CLRF   00
15E4E:  CLRF   01
15E50:  MOVF   00,W
15E52:  ADDWF  5C,W
15E54:  MOVLB  3
15E56:  MOVWF  x39
15E58:  MOVF   01,W
15E5A:  ADDWFC 5D,W
15E5C:  MOVWF  x3A
15E5E:  MOVF   x37,W
15E60:  ADDWFC 5E,W
15E62:  MOVWF  x3B
15E64:  MOVF   03,W
15E66:  ADDWFC 5F,W
15E68:  MOVWF  x3C
15E6A:  MOVWF  x8C
15E6C:  MOVFF  33B,38B
15E70:  MOVFF  33A,38A
15E74:  MOVFF  339,389
15E78:  MOVLB  0
15E7A:  CALL   125EE
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
15E7E:  CLRF   01
15E80:  CLRF   02
15E82:  MOVFF  01,03
15E86:  MOVFF  337,02
15E8A:  CLRF   00
15E8C:  CLRF   01
15E8E:  MOVF   00,W
15E90:  ADDWF  38,W
15E92:  MOVLB  3
15E94:  MOVWF  x39
15E96:  MOVF   01,W
15E98:  ADDWFC 39,W
15E9A:  MOVWF  x3A
15E9C:  MOVF   x37,W
15E9E:  ADDWFC 3A,W
15EA0:  MOVWF  x3B
15EA2:  MOVF   03,W
15EA4:  ADDWFC 3B,W
15EA6:  MOVWF  x3C
15EA8:  MOVWF  x8C
15EAA:  MOVFF  33B,38B
15EAE:  MOVFF  33A,38A
15EB2:  MOVFF  339,389
15EB6:  MOVLB  0
15EB8:  CALL   1268C
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
15EBC:  CLRF   01
15EBE:  CLRF   02
15EC0:  MOVFF  01,03
15EC4:  MOVFF  337,02
15EC8:  CLRF   00
15ECA:  CLRF   01
15ECC:  MOVF   00,W
15ECE:  ADDWF  44,W
15ED0:  MOVLB  3
15ED2:  MOVWF  x39
15ED4:  MOVF   01,W
15ED6:  ADDWFC 45,W
15ED8:  MOVWF  x3A
15EDA:  MOVF   x37,W
15EDC:  ADDWFC 46,W
15EDE:  MOVWF  x3B
15EE0:  MOVF   03,W
15EE2:  ADDWFC 47,W
15EE4:  MOVWF  x3C
15EE6:  MOVWF  x8C
15EE8:  MOVFF  33B,38B
15EEC:  MOVFF  33A,38A
15EF0:  MOVFF  339,389
15EF4:  MOVLB  0
15EF6:  CALL   1268C
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
15EFA:  CLRF   01
15EFC:  CLRF   02
15EFE:  MOVFF  01,03
15F02:  MOVFF  337,02
15F06:  CLRF   00
15F08:  CLRF   01
15F0A:  MOVF   00,W
15F0C:  ADDWF  48,W
15F0E:  MOVLB  3
15F10:  MOVWF  x39
15F12:  MOVF   01,W
15F14:  ADDWFC 49,W
15F16:  MOVWF  x3A
15F18:  MOVF   x37,W
15F1A:  ADDWFC 4A,W
15F1C:  MOVWF  x3B
15F1E:  MOVF   03,W
15F20:  ADDWFC 4B,W
15F22:  MOVWF  x3C
15F24:  MOVWF  x8C
15F26:  MOVFF  33B,38B
15F2A:  MOVFF  33A,38A
15F2E:  MOVFF  339,389
15F32:  MOVLB  0
15F34:  CALL   1268C
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
15F38:  CLRF   01
15F3A:  CLRF   02
15F3C:  MOVFF  01,03
15F40:  MOVFF  337,02
15F44:  CLRF   00
15F46:  CLRF   01
15F48:  MOVF   00,W
15F4A:  ADDWF  50,W
15F4C:  MOVLB  3
15F4E:  MOVWF  x39
15F50:  MOVF   01,W
15F52:  ADDWFC 51,W
15F54:  MOVWF  x3A
15F56:  MOVF   x37,W
15F58:  ADDWFC 52,W
15F5A:  MOVWF  x3B
15F5C:  MOVF   03,W
15F5E:  ADDWFC 53,W
15F60:  MOVWF  x3C
15F62:  MOVWF  x8C
15F64:  MOVFF  33B,38B
15F68:  MOVFF  33A,38A
15F6C:  MOVFF  339,389
15F70:  MOVLB  0
15F72:  CALL   1268C
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
15F76:  CLRF   01
15F78:  CLRF   02
15F7A:  MOVFF  01,03
15F7E:  MOVFF  337,02
15F82:  CLRF   00
15F84:  CLRF   01
15F86:  MOVF   00,W
15F88:  ADDWF  58,W
15F8A:  MOVLB  3
15F8C:  MOVWF  x39
15F8E:  MOVF   01,W
15F90:  ADDWFC 59,W
15F92:  MOVWF  x3A
15F94:  MOVF   x37,W
15F96:  ADDWFC 5A,W
15F98:  MOVWF  x3B
15F9A:  MOVF   03,W
15F9C:  ADDWFC 5B,W
15F9E:  MOVWF  x3C
15FA0:  MOVWF  x8C
15FA2:  MOVFF  33B,38B
15FA6:  MOVFF  33A,38A
15FAA:  MOVFF  339,389
15FAE:  MOVLB  0
15FB0:  CALL   1268C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
15FB4:  CLRF   01
15FB6:  CLRF   02
15FB8:  MOVFF  01,03
15FBC:  MOVFF  337,02
15FC0:  CLRF   00
15FC2:  CLRF   01
15FC4:  MOVF   00,W
15FC6:  ADDWF  5C,W
15FC8:  MOVLB  3
15FCA:  MOVWF  x39
15FCC:  MOVF   01,W
15FCE:  ADDWFC 5D,W
15FD0:  MOVWF  x3A
15FD2:  MOVF   x37,W
15FD4:  ADDWFC 5E,W
15FD6:  MOVWF  x3B
15FD8:  MOVF   03,W
15FDA:  ADDWFC 5F,W
15FDC:  MOVWF  x3C
15FDE:  MOVWF  x8C
15FE0:  MOVFF  33B,38B
15FE4:  MOVFF  33A,38A
15FE8:  MOVFF  339,389
15FEC:  MOVLB  0
15FEE:  CALL   1268C
15FF2:  MOVLB  3
15FF4:  INCF   x37,F
15FF6:  BRA    15B90
....................    } 
....................    for(num = 5; num < 10; num++) 
15FF8:  MOVLW  05
15FFA:  MOVWF  x37
15FFC:  MOVF   x37,W
15FFE:  SUBLW  09
16000:  BTFSS  FD8.0
16002:  BRA    16236
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
16004:  CLRF   01
16006:  CLRF   02
16008:  MOVFF  01,03
1600C:  MOVFF  337,02
16010:  CLRF   00
16012:  CLRF   01
16014:  MOVF   00,W
16016:  ADDWF  44,W
16018:  MOVWF  x39
1601A:  MOVF   01,W
1601C:  ADDWFC 45,W
1601E:  MOVWF  x3A
16020:  MOVF   x37,W
16022:  ADDWFC 46,W
16024:  MOVWF  x3B
16026:  MOVF   03,W
16028:  ADDWFC 47,W
1602A:  MOVWF  x3C
1602C:  MOVWF  x8C
1602E:  MOVFF  33B,38B
16032:  MOVFF  33A,38A
16036:  MOVFF  339,389
1603A:  MOVLB  0
1603C:  CALL   12550
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
16040:  CLRF   01
16042:  CLRF   02
16044:  MOVFF  01,03
16048:  MOVFF  337,02
1604C:  CLRF   00
1604E:  CLRF   01
16050:  MOVF   00,W
16052:  ADDWF  48,W
16054:  MOVLB  3
16056:  MOVWF  x39
16058:  MOVF   01,W
1605A:  ADDWFC 49,W
1605C:  MOVWF  x3A
1605E:  MOVF   x37,W
16060:  ADDWFC 4A,W
16062:  MOVWF  x3B
16064:  MOVF   03,W
16066:  ADDWFC 4B,W
16068:  MOVWF  x3C
1606A:  MOVWF  x8C
1606C:  MOVFF  33B,38B
16070:  MOVFF  33A,38A
16074:  MOVFF  339,389
16078:  MOVLB  0
1607A:  CALL   12550
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
1607E:  CLRF   01
16080:  CLRF   02
16082:  MOVFF  01,03
16086:  MOVFF  337,02
1608A:  CLRF   00
1608C:  CLRF   01
1608E:  MOVF   00,W
16090:  ADDWF  5C,W
16092:  MOVLB  3
16094:  MOVWF  x39
16096:  MOVF   01,W
16098:  ADDWFC 5D,W
1609A:  MOVWF  x3A
1609C:  MOVF   x37,W
1609E:  ADDWFC 5E,W
160A0:  MOVWF  x3B
160A2:  MOVF   03,W
160A4:  ADDWFC 5F,W
160A6:  MOVWF  x3C
160A8:  MOVWF  x8C
160AA:  MOVFF  33B,38B
160AE:  MOVFF  33A,38A
160B2:  MOVFF  339,389
160B6:  MOVLB  0
160B8:  CALL   12550
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
160BC:  CLRF   01
160BE:  CLRF   02
160C0:  MOVFF  01,03
160C4:  MOVFF  337,02
160C8:  CLRF   00
160CA:  CLRF   01
160CC:  MOVF   00,W
160CE:  ADDWF  44,W
160D0:  MOVLB  3
160D2:  MOVWF  x39
160D4:  MOVF   01,W
160D6:  ADDWFC 45,W
160D8:  MOVWF  x3A
160DA:  MOVF   x37,W
160DC:  ADDWFC 46,W
160DE:  MOVWF  x3B
160E0:  MOVF   03,W
160E2:  ADDWFC 47,W
160E4:  MOVWF  x3C
160E6:  MOVWF  x8C
160E8:  MOVFF  33B,38B
160EC:  MOVFF  33A,38A
160F0:  MOVFF  339,389
160F4:  MOVLB  0
160F6:  CALL   125EE
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
160FA:  CLRF   01
160FC:  CLRF   02
160FE:  MOVFF  01,03
16102:  MOVFF  337,02
16106:  CLRF   00
16108:  CLRF   01
1610A:  MOVF   00,W
1610C:  ADDWF  48,W
1610E:  MOVLB  3
16110:  MOVWF  x39
16112:  MOVF   01,W
16114:  ADDWFC 49,W
16116:  MOVWF  x3A
16118:  MOVF   x37,W
1611A:  ADDWFC 4A,W
1611C:  MOVWF  x3B
1611E:  MOVF   03,W
16120:  ADDWFC 4B,W
16122:  MOVWF  x3C
16124:  MOVWF  x8C
16126:  MOVFF  33B,38B
1612A:  MOVFF  33A,38A
1612E:  MOVFF  339,389
16132:  MOVLB  0
16134:  CALL   125EE
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
16138:  CLRF   01
1613A:  CLRF   02
1613C:  MOVFF  01,03
16140:  MOVFF  337,02
16144:  CLRF   00
16146:  CLRF   01
16148:  MOVF   00,W
1614A:  ADDWF  5C,W
1614C:  MOVLB  3
1614E:  MOVWF  x39
16150:  MOVF   01,W
16152:  ADDWFC 5D,W
16154:  MOVWF  x3A
16156:  MOVF   x37,W
16158:  ADDWFC 5E,W
1615A:  MOVWF  x3B
1615C:  MOVF   03,W
1615E:  ADDWFC 5F,W
16160:  MOVWF  x3C
16162:  MOVWF  x8C
16164:  MOVFF  33B,38B
16168:  MOVFF  33A,38A
1616C:  MOVFF  339,389
16170:  MOVLB  0
16172:  CALL   125EE
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
16176:  CLRF   01
16178:  CLRF   02
1617A:  MOVFF  01,03
1617E:  MOVFF  337,02
16182:  CLRF   00
16184:  CLRF   01
16186:  MOVF   00,W
16188:  ADDWF  44,W
1618A:  MOVLB  3
1618C:  MOVWF  x39
1618E:  MOVF   01,W
16190:  ADDWFC 45,W
16192:  MOVWF  x3A
16194:  MOVF   x37,W
16196:  ADDWFC 46,W
16198:  MOVWF  x3B
1619A:  MOVF   03,W
1619C:  ADDWFC 47,W
1619E:  MOVWF  x3C
161A0:  MOVWF  x8C
161A2:  MOVFF  33B,38B
161A6:  MOVFF  33A,38A
161AA:  MOVFF  339,389
161AE:  MOVLB  0
161B0:  CALL   1268C
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
161B4:  CLRF   01
161B6:  CLRF   02
161B8:  MOVFF  01,03
161BC:  MOVFF  337,02
161C0:  CLRF   00
161C2:  CLRF   01
161C4:  MOVF   00,W
161C6:  ADDWF  48,W
161C8:  MOVLB  3
161CA:  MOVWF  x39
161CC:  MOVF   01,W
161CE:  ADDWFC 49,W
161D0:  MOVWF  x3A
161D2:  MOVF   x37,W
161D4:  ADDWFC 4A,W
161D6:  MOVWF  x3B
161D8:  MOVF   03,W
161DA:  ADDWFC 4B,W
161DC:  MOVWF  x3C
161DE:  MOVWF  x8C
161E0:  MOVFF  33B,38B
161E4:  MOVFF  33A,38A
161E8:  MOVFF  339,389
161EC:  MOVLB  0
161EE:  CALL   1268C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
161F2:  CLRF   01
161F4:  CLRF   02
161F6:  MOVFF  01,03
161FA:  MOVFF  337,02
161FE:  CLRF   00
16200:  CLRF   01
16202:  MOVF   00,W
16204:  ADDWF  5C,W
16206:  MOVLB  3
16208:  MOVWF  x39
1620A:  MOVF   01,W
1620C:  ADDWFC 5D,W
1620E:  MOVWF  x3A
16210:  MOVF   x37,W
16212:  ADDWFC 5E,W
16214:  MOVWF  x3B
16216:  MOVF   03,W
16218:  ADDWFC 5F,W
1621A:  MOVWF  x3C
1621C:  MOVWF  x8C
1621E:  MOVFF  33B,38B
16222:  MOVFF  33A,38A
16226:  MOVFF  339,389
1622A:  MOVLB  0
1622C:  CALL   1268C
16230:  MOVLB  3
16232:  INCF   x37,F
16234:  BRA    15FFC
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
16236:  BCF    F94.4
16238:  BSF    F8B.4
....................    delay_ms(10000); 
1623A:  MOVLW  28
1623C:  MOVWF  x39
1623E:  MOVLW  FA
16240:  MOVWF  x98
16242:  MOVLB  0
16244:  CALL   0526
16248:  MOVLB  3
1624A:  DECFSZ x39,F
1624C:  BRA    1623E
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
1624E:  MOVLW  90
16250:  MOVWF  FF6
16252:  MOVLW  06
16254:  MOVWF  FF7
16256:  MOVLW  00
16258:  MOVWF  FF8
1625A:  MOVLB  0
1625C:  CALL   058C
....................    for(int t=60; t>0; t--){ 
16260:  MOVLW  3C
16262:  MOVLB  3
16264:  MOVWF  x38
16266:  MOVF   x38,F
16268:  BZ    162C2
....................    fprintf(PC,"Remaining time: %d  \r", t); 
1626A:  MOVLW  AA
1626C:  MOVWF  FF6
1626E:  MOVLW  06
16270:  MOVWF  FF7
16272:  MOVLW  00
16274:  MOVWF  FF8
16276:  MOVLW  10
16278:  MOVWF  xA2
1627A:  MOVLB  0
1627C:  CALL   0702
16280:  MOVFF  338,33E
16284:  MOVLW  18
16286:  MOVLB  3
16288:  MOVWF  x3F
1628A:  MOVLB  0
1628C:  CALL   2404
16290:  MOVLW  BC
16292:  MOVWF  FF6
16294:  MOVLW  06
16296:  MOVWF  FF7
16298:  MOVLW  00
1629A:  MOVWF  FF8
1629C:  MOVLW  03
1629E:  MOVLB  3
162A0:  MOVWF  xA2
162A2:  MOVLB  0
162A4:  CALL   0702
....................    delay_ms(1000); 
162A8:  MOVLW  04
162AA:  MOVLB  3
162AC:  MOVWF  x39
162AE:  MOVLW  FA
162B0:  MOVWF  x98
162B2:  MOVLB  0
162B4:  CALL   0526
162B8:  MOVLB  3
162BA:  DECFSZ x39,F
162BC:  BRA    162AE
162BE:  DECF   x38,F
162C0:  BRA    16266
....................    } 
....................    //delay_ms(60000); 
....................    return; 
162C2:  MOVLB  0
162C4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
*
156C6:  MOVF   43,F
156C8:  BNZ   156E4
156CA:  MOVF   42,W
156CC:  SUBLW  06
156CE:  BC    15734
156D0:  XORLW  FF
156D2:  BNZ   156E4
156D4:  MOVF   41,W
156D6:  SUBLW  FE
156D8:  BC    15734
156DA:  XORLW  FF
156DC:  BNZ   156E4
156DE:  MOVF   40,W
156E0:  SUBLW  E9
156E2:  BC    15734
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
156E4:  MOVLB  3
156E6:  CLRF   x8C
156E8:  MOVLW  07
156EA:  MOVWF  x8B
156EC:  CLRF   x8A
156EE:  CLRF   x89
156F0:  MOVLB  0
156F2:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
156F6:  BCF    F94.4
156F8:  BCF    F8B.4
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
156FA:  MOVLB  3
156FC:  CLRF   x8C
156FE:  MOVLW  07
15700:  MOVWF  x8B
15702:  CLRF   x8A
15704:  CLRF   x89
15706:  MOVLB  0
15708:  CALL   125EE
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
1570C:  BCF    F94.4
1570E:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
15710:  BCF    F92.5
15712:  BCF    F89.5
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
15714:  MOVLB  3
15716:  CLRF   x8C
15718:  MOVLW  07
1571A:  MOVWF  x8B
1571C:  CLRF   x8A
1571E:  CLRF   x89
15720:  MOVLB  0
15722:  CALL   1268C
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
15726:  CLRF   43
15728:  MOVLW  07
1572A:  MOVWF  42
1572C:  CLRF   41
1572E:  CLRF   40
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
15730:  CALL   144C8
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
15734:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
*
1589A:  MOVF   47,F
1589C:  BNZ   158A4
1589E:  MOVF   46,W
158A0:  SUBLW  5F
158A2:  BC    158F4
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
158A4:  MOVLB  3
158A6:  CLRF   x8C
158A8:  MOVLW  09
158AA:  MOVWF  x8B
158AC:  CLRF   x8A
158AE:  CLRF   x89
158B0:  MOVLB  0
158B2:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
158B6:  BCF    F94.4
158B8:  BCF    F8B.4
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
158BA:  MOVLB  3
158BC:  CLRF   x8C
158BE:  MOVLW  09
158C0:  MOVWF  x8B
158C2:  CLRF   x8A
158C4:  CLRF   x89
158C6:  MOVLB  0
158C8:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
158CC:  BCF    F94.4
158CE:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
158D0:  BCF    F92.5
158D2:  BCF    F89.5
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
158D4:  MOVLB  3
158D6:  CLRF   x8C
158D8:  MOVLW  09
158DA:  MOVWF  x8B
158DC:  CLRF   x8A
158DE:  CLRF   x89
158E0:  MOVLB  0
158E2:  CALL   1268C
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
158E6:  CLRF   47
158E8:  MOVLW  09
158EA:  MOVWF  46
158EC:  CLRF   45
158EE:  CLRF   44
....................       STORE_ADRESS_DATA_TO_FLASH(); 
158F0:  CALL   144C8
....................    } 
....................    return; 
158F4:  RETURN 0
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
*
15736:  MOVF   48,F
15738:  BNZ   1574A
1573A:  MOVF   49,F
1573C:  BNZ   1574A
1573E:  MOVF   4A,F
15740:  BNZ   1574A
15742:  MOVF   4B,F
15744:  BNZ   1574A
15746:  MOVLW  00
15748:  BRA    1574C
1574A:  MOVLW  01
1574C:  MOVLB  3
1574E:  CLRF   x31
15750:  CLRF   x30
15752:  CLRF   x2F
15754:  MOVWF  x2E
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
15756:  MOVF   4B,W
15758:  SUBLW  03
1575A:  BC    157CC
1575C:  XORLW  FF
1575E:  BNZ   1577A
15760:  MOVF   4A,W
15762:  SUBLW  47
15764:  BC    157CC
15766:  XORLW  FF
15768:  BNZ   1577A
1576A:  MOVF   49,W
1576C:  SUBLW  FE
1576E:  BC    157CC
15770:  XORLW  FF
15772:  BNZ   1577A
15774:  MOVF   48,W
15776:  SUBLW  07
15778:  BC    157CC
....................    { 
....................       sector_erase_OF(SECT*98); 
1577A:  CLRF   x8C
1577C:  MOVLW  62
1577E:  MOVWF  x8B
15780:  CLRF   x8A
15782:  CLRF   x89
15784:  MOVLB  0
15786:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
1578A:  BCF    F94.4
1578C:  BCF    F8B.4
....................       sector_erase_SCF(SECT*98); 
1578E:  MOVLB  3
15790:  CLRF   x8C
15792:  MOVLW  62
15794:  MOVWF  x8B
15796:  CLRF   x8A
15798:  CLRF   x89
1579A:  MOVLB  0
1579C:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
157A0:  BCF    F94.4
157A2:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
157A4:  BCF    F92.5
157A6:  BCF    F89.5
....................       sector_erase_SMF(SECT*98); 
157A8:  MOVLB  3
157AA:  CLRF   x8C
157AC:  MOVLW  62
157AE:  MOVWF  x8B
157B0:  CLRF   x8A
157B2:  CLRF   x89
157B4:  MOVLB  0
157B6:  CALL   1268C
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
157BA:  CLRF   4B
157BC:  MOVLW  08
157BE:  MOVWF  4A
157C0:  CLRF   49
157C2:  CLRF   48
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
157C4:  CALL   144C8
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
157C8:  BRA    15894
157CA:  MOVLB  3
157CC:  MOVLW  00
157CE:  BSF    FD8.0
157D0:  SUBFWB x2E,W
157D2:  MOVWF  x32
157D4:  MOVLW  00
157D6:  SUBFWB x2F,W
157D8:  MOVWF  x33
157DA:  MOVLW  01
157DC:  SUBFWB x30,W
157DE:  MOVWF  x34
157E0:  MOVLW  00
157E2:  SUBFWB x31,W
157E4:  MOVWF  x35
157E6:  MOVF   x35,F
157E8:  BNZ   15896
157EA:  MOVF   x34,F
157EC:  BNZ   15896
157EE:  MOVF   x33,F
157F0:  BNZ   15896
157F2:  MOVF   x32,W
157F4:  SUBLW  76
157F6:  BNC   15896
....................       fprintf(PC,"erasing next sector\r\n"); 
157F8:  MOVLW  C0
157FA:  MOVWF  FF6
157FC:  MOVLW  06
157FE:  MOVWF  FF7
15800:  MOVLW  00
15802:  MOVWF  FF8
15804:  MOVLB  0
15806:  CALL   058C
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
1580A:  MOVFF  48,332
1580E:  MOVLB  3
15810:  MOVFF  49,333
15814:  MOVLW  01
15816:  ADDWF  4A,W
15818:  MOVWF  x34
1581A:  MOVLW  00
1581C:  ADDWFC 4B,W
1581E:  MOVWF  x35
15820:  MOVWF  x8C
15822:  MOVFF  334,38B
15826:  MOVFF  49,38A
1582A:  MOVFF  48,389
1582E:  MOVLB  0
15830:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
15834:  BCF    F94.4
15836:  BCF    F8B.4
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
15838:  MOVFF  48,332
1583C:  MOVLB  3
1583E:  MOVFF  49,333
15842:  MOVLW  01
15844:  ADDWF  4A,W
15846:  MOVWF  x34
15848:  MOVLW  00
1584A:  ADDWFC 4B,W
1584C:  MOVWF  x35
1584E:  MOVWF  x8C
15850:  MOVFF  334,38B
15854:  MOVFF  49,38A
15858:  MOVFF  48,389
1585C:  MOVLB  0
1585E:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15862:  BCF    F94.4
15864:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
15866:  BCF    F92.5
15868:  BCF    F89.5
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
1586A:  MOVFF  48,332
1586E:  MOVLB  3
15870:  MOVFF  49,333
15874:  MOVLW  01
15876:  ADDWF  4A,W
15878:  MOVWF  x34
1587A:  MOVLW  00
1587C:  ADDWFC 4B,W
1587E:  MOVWF  x35
15880:  MOVWF  x8C
15882:  MOVFF  334,38B
15886:  MOVFF  49,38A
1588A:  MOVFF  48,389
1588E:  MOVLB  0
15890:  CALL   1268C
15894:  MOVLB  3
....................    } 
....................    return; 
15896:  MOVLB  0
15898:  RETURN 0
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
*
0189E:  MOVF   4C,F
018A0:  BNZ   18B2
018A2:  MOVF   4D,F
018A4:  BNZ   18B2
018A6:  MOVF   4E,F
018A8:  BNZ   18B2
018AA:  MOVF   4F,F
018AC:  BNZ   18B2
018AE:  MOVLW  00
018B0:  BRA    18B4
018B2:  MOVLW  01
018B4:  MOVLB  3
018B6:  CLRF   x31
018B8:  CLRF   x30
018BA:  CLRF   x2F
018BC:  MOVWF  x2E
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
018BE:  MOVF   4F,W
018C0:  SUBLW  03
018C2:  BC    193C
018C4:  XORLW  FF
018C6:  BNZ   18E2
018C8:  MOVF   4E,W
018CA:  SUBLW  70
018CC:  BC    193C
018CE:  XORLW  FF
018D0:  BNZ   18E2
018D2:  MOVF   4D,W
018D4:  SUBLW  FE
018D6:  BC    193C
018D8:  XORLW  FF
018DA:  BNZ   18E2
018DC:  MOVF   4C,W
018DE:  SUBLW  F5
018E0:  BC    193C
....................    {   
....................       sector_erase_OF(SECT*1098); 
018E2:  MOVLW  04
018E4:  MOVWF  x8C
018E6:  MOVLW  4A
018E8:  MOVWF  x8B
018EA:  CLRF   x8A
018EC:  CLRF   x89
018EE:  MOVLB  0
018F0:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
018F4:  BCF    F94.4
018F6:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1098); 
018F8:  MOVLW  04
018FA:  MOVLB  3
018FC:  MOVWF  x8C
018FE:  MOVLW  4A
01900:  MOVWF  x8B
01902:  CLRF   x8A
01904:  CLRF   x89
01906:  MOVLB  0
01908:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
0190C:  BCF    F94.4
0190E:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
01910:  BCF    F92.5
01912:  BCF    F89.5
....................       sector_erase_SMF(SECT*1098); 
01914:  MOVLW  04
01916:  MOVLB  3
01918:  MOVWF  x8C
0191A:  MOVLW  4A
0191C:  MOVWF  x8B
0191E:  CLRF   x8A
01920:  CLRF   x89
01922:  MOVLB  0
01924:  CALL   1268C
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
01928:  MOVLW  04
0192A:  MOVWF  4F
0192C:  MOVLW  4A
0192E:  MOVWF  4E
01930:  CLRF   4D
01932:  CLRF   4C
....................       STORE_ADRESS_DATA_TO_FLASH(); 
01934:  CALL   144C8
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
01938:  BRA    1A04
0193A:  MOVLB  3
0193C:  MOVLW  00
0193E:  BSF    FD8.0
01940:  SUBFWB x2E,W
01942:  MOVWF  x32
01944:  MOVLW  00
01946:  SUBFWB x2F,W
01948:  MOVWF  x33
0194A:  MOVLW  01
0194C:  SUBFWB x30,W
0194E:  MOVWF  x34
01950:  MOVLW  00
01952:  SUBFWB x31,W
01954:  MOVWF  x35
01956:  MOVF   x35,F
01958:  BNZ   1A06
0195A:  MOVF   x34,F
0195C:  BNZ   1A06
0195E:  MOVF   x33,F
01960:  BNZ   1A06
01962:  MOVF   x32,W
01964:  SUBLW  04
01966:  BNC   1A06
....................       fprintf(PC,"erasing next sector\r\n"); 
01968:  MOVLW  D6
0196A:  MOVWF  FF6
0196C:  MOVLW  06
0196E:  MOVWF  FF7
01970:  MOVLW  00
01972:  MOVWF  FF8
01974:  MOVLB  0
01976:  CALL   058C
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
0197A:  MOVFF  4C,332
0197E:  MOVLB  3
01980:  MOVFF  4D,333
01984:  MOVLW  01
01986:  ADDWF  4E,W
01988:  MOVWF  x34
0198A:  MOVLW  00
0198C:  ADDWFC 4F,W
0198E:  MOVWF  x35
01990:  MOVWF  x8C
01992:  MOVFF  334,38B
01996:  MOVFF  4D,38A
0199A:  MOVFF  4C,389
0199E:  MOVLB  0
019A0:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
019A4:  BCF    F94.4
019A6:  BCF    F8B.4
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
019A8:  MOVFF  4C,332
019AC:  MOVLB  3
019AE:  MOVFF  4D,333
019B2:  MOVLW  01
019B4:  ADDWF  4E,W
019B6:  MOVWF  x34
019B8:  MOVLW  00
019BA:  ADDWFC 4F,W
019BC:  MOVWF  x35
019BE:  MOVWF  x8C
019C0:  MOVFF  334,38B
019C4:  MOVFF  4D,38A
019C8:  MOVFF  4C,389
019CC:  MOVLB  0
019CE:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
019D2:  BCF    F94.4
019D4:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
019D6:  BCF    F92.5
019D8:  BCF    F89.5
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
019DA:  MOVFF  4C,332
019DE:  MOVLB  3
019E0:  MOVFF  4D,333
019E4:  MOVLW  01
019E6:  ADDWF  4E,W
019E8:  MOVWF  x34
019EA:  MOVLW  00
019EC:  ADDWFC 4F,W
019EE:  MOVWF  x35
019F0:  MOVWF  x8C
019F2:  MOVFF  334,38B
019F6:  MOVFF  4D,38A
019FA:  MOVFF  4C,389
019FE:  MOVLB  0
01A00:  CALL   1268C
01A04:  MOVLB  3
....................        
....................    } 
....................    return; 
01A06:  MOVLB  0
01A08:  RETURN 0
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
*
01354:  MOVF   53,W
01356:  SUBLW  05
01358:  BC    13D2
0135A:  XORLW  FF
0135C:  BNZ   1378
0135E:  MOVF   52,W
01360:  SUBLW  5E
01362:  BC    13D2
01364:  XORLW  FF
01366:  BNZ   1378
01368:  MOVF   51,W
0136A:  SUBLW  C5
0136C:  BC    13D2
0136E:  XORLW  FF
01370:  BNZ   1378
01372:  MOVF   50,W
01374:  SUBLW  3F
01376:  BC    13D2
....................    { 
....................       sector_erase_OF(SECT*1140); 
01378:  MOVLW  04
0137A:  MOVLB  3
0137C:  MOVWF  x8C
0137E:  MOVLW  74
01380:  MOVWF  x8B
01382:  CLRF   x8A
01384:  CLRF   x89
01386:  MOVLB  0
01388:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
0138C:  BCF    F94.4
0138E:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1140); 
01390:  MOVLW  04
01392:  MOVLB  3
01394:  MOVWF  x8C
01396:  MOVLW  74
01398:  MOVWF  x8B
0139A:  CLRF   x8A
0139C:  CLRF   x89
0139E:  MOVLB  0
013A0:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
013A4:  BCF    F94.4
013A6:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
013A8:  BCF    F92.5
013AA:  BCF    F89.5
....................       sector_erase_SMF(SECT*1140); 
013AC:  MOVLW  04
013AE:  MOVLB  3
013B0:  MOVWF  x8C
013B2:  MOVLW  74
013B4:  MOVWF  x8B
013B6:  CLRF   x8A
013B8:  CLRF   x89
013BA:  MOVLB  0
013BC:  CALL   1268C
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
013C0:  MOVLW  04
013C2:  MOVWF  53
013C4:  MOVLW  74
013C6:  MOVWF  52
013C8:  CLRF   51
013CA:  CLRF   50
....................       STORE_ADRESS_DATA_TO_FLASH(); 
013CC:  CALL   144C8
....................    }else{                                                                        //if value will be close to the sector 
013D0:  BRA    14D4
....................       fprintf(PC,"erasing next sector\r\n"); 
013D2:  MOVLW  EC
013D4:  MOVWF  FF6
013D6:  MOVLW  06
013D8:  MOVWF  FF7
013DA:  MOVLW  00
013DC:  MOVWF  FF8
013DE:  CALL   058C
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
013E2:  MOVLW  01
013E4:  MOVLB  3
013E6:  MOVWF  x84
013E8:  MOVF   x84,W
013EA:  SUBLW  09
013EC:  BNC   1430
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
013EE:  CLRF   01
013F0:  CLRF   02
013F2:  MOVFF  01,03
013F6:  MOVFF  384,02
013FA:  CLRF   00
013FC:  CLRF   01
013FE:  MOVF   00,W
01400:  ADDWF  50,W
01402:  MOVWF  x85
01404:  MOVF   01,W
01406:  ADDWFC 51,W
01408:  MOVWF  x86
0140A:  MOVF   x84,W
0140C:  ADDWFC 52,W
0140E:  MOVWF  x87
01410:  MOVF   03,W
01412:  ADDWFC 53,W
01414:  MOVWF  x88
01416:  MOVWF  x8C
01418:  MOVFF  387,38B
0141C:  MOVFF  386,38A
01420:  MOVFF  385,389
01424:  MOVLB  0
01426:  CALL   12550
0142A:  MOVLB  3
0142C:  INCF   x84,F
0142E:  BRA    13E8
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
01430:  BCF    F94.4
01432:  BCF    F8B.4
....................       for(i = 1; i < 10; i++) 
01434:  MOVLW  01
01436:  MOVWF  x84
01438:  MOVF   x84,W
0143A:  SUBLW  09
0143C:  BNC   1480
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
0143E:  CLRF   01
01440:  CLRF   02
01442:  MOVFF  01,03
01446:  MOVFF  384,02
0144A:  CLRF   00
0144C:  CLRF   01
0144E:  MOVF   00,W
01450:  ADDWF  50,W
01452:  MOVWF  x85
01454:  MOVF   01,W
01456:  ADDWFC 51,W
01458:  MOVWF  x86
0145A:  MOVF   x84,W
0145C:  ADDWFC 52,W
0145E:  MOVWF  x87
01460:  MOVF   03,W
01462:  ADDWFC 53,W
01464:  MOVWF  x88
01466:  MOVWF  x8C
01468:  MOVFF  387,38B
0146C:  MOVFF  386,38A
01470:  MOVFF  385,389
01474:  MOVLB  0
01476:  CALL   125EE
0147A:  MOVLB  3
0147C:  INCF   x84,F
0147E:  BRA    1438
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
01480:  BCF    F94.4
01482:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
01484:  BCF    F92.5
01486:  BCF    F89.5
....................       for(i = 1; i < 10; i++) 
01488:  MOVLW  01
0148A:  MOVWF  x84
0148C:  MOVF   x84,W
0148E:  SUBLW  09
01490:  BNC   14D4
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
01492:  CLRF   01
01494:  CLRF   02
01496:  MOVFF  01,03
0149A:  MOVFF  384,02
0149E:  CLRF   00
014A0:  CLRF   01
014A2:  MOVF   00,W
014A4:  ADDWF  50,W
014A6:  MOVWF  x85
014A8:  MOVF   01,W
014AA:  ADDWFC 51,W
014AC:  MOVWF  x86
014AE:  MOVF   x84,W
014B0:  ADDWFC 52,W
014B2:  MOVWF  x87
014B4:  MOVF   03,W
014B6:  ADDWFC 53,W
014B8:  MOVWF  x88
014BA:  MOVWF  x8C
014BC:  MOVFF  387,38B
014C0:  MOVFF  386,38A
014C4:  MOVFF  385,389
014C8:  MOVLB  0
014CA:  CALL   1268C
014CE:  MOVLB  3
014D0:  INCF   x84,F
014D2:  BRA    148C
014D4:  MOVLB  0
....................       } 
....................    } 
....................    return; 
014D6:  GOTO   127DE (RETURN)
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
*
14774:  MOVF   58,F
14776:  BNZ   14788
14778:  MOVF   59,F
1477A:  BNZ   14788
1477C:  MOVF   5A,F
1477E:  BNZ   14788
14780:  MOVF   5B,F
14782:  BNZ   14788
14784:  MOVLW  00
14786:  BRA    1478A
14788:  MOVLW  01
1478A:  MOVLB  3
1478C:  CLRF   x80
1478E:  CLRF   x7F
14790:  CLRF   x7E
14792:  MOVWF  x7D
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
14794:  MOVF   5B,W
14796:  SUBLW  05
14798:  BC    14816
1479A:  XORLW  FF
1479C:  BNZ   147B8
1479E:  MOVF   5A,W
147A0:  SUBLW  65
147A2:  BC    14816
147A4:  XORLW  FF
147A6:  BNZ   147B8
147A8:  MOVF   59,W
147AA:  SUBLW  FD
147AC:  BC    14816
147AE:  XORLW  FF
147B0:  BNZ   147B8
147B2:  MOVF   58,W
147B4:  SUBLW  60
147B6:  BC    14816
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
147B8:  MOVLW  06
147BA:  MOVWF  x92
147BC:  MOVLW  67
147BE:  MOVWF  x91
147C0:  MOVLW  10
147C2:  MOVWF  x90
147C4:  CLRF   x8F
147C6:  MOVLB  0
147C8:  CALL   11914
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
147CC:  BCF    F94.4
147CE:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
147D0:  MOVLW  27
147D2:  MOVLB  3
147D4:  MOVWF  x92
147D6:  MOVLW  70
147D8:  MOVWF  x91
147DA:  CLRF   x90
147DC:  CLRF   x8F
147DE:  MOVLB  0
147E0:  CALL   11A3E
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
147E4:  BCF    F94.4
147E6:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
147E8:  BCF    F92.5
147EA:  BCF    F89.5
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
147EC:  MOVLW  06
147EE:  MOVLB  3
147F0:  MOVWF  x92
147F2:  MOVLW  67
147F4:  MOVWF  x91
147F6:  MOVLW  10
147F8:  MOVWF  x90
147FA:  CLRF   x8F
147FC:  MOVLB  0
147FE:  CALL   11B68
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
14802:  MOVLW  06
14804:  MOVWF  5B
14806:  MOVLW  67
14808:  MOVWF  5A
1480A:  MOVLW  10
1480C:  MOVWF  59
1480E:  CLRF   58
....................       STORE_ADRESS_DATA_TO_FLASH(); 
14810:  RCALL  144C8
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
14812:  BRA    148E8
14814:  MOVLB  3
14816:  MOVLW  00
14818:  BSF    FD8.0
1481A:  SUBFWB x7D,W
1481C:  MOVWF  x81
1481E:  MOVLW  10
14820:  SUBFWB x7E,W
14822:  MOVWF  x82
14824:  MOVLW  00
14826:  SUBFWB x7F,W
14828:  MOVWF  x83
1482A:  MOVLW  00
1482C:  SUBFWB x80,W
1482E:  MOVWF  x84
14830:  MOVF   x84,F
14832:  BNZ   148EA
14834:  MOVF   x83,F
14836:  BNZ   148EA
14838:  MOVF   x82,W
1483A:  SUBLW  03
1483C:  BNC   148EA
1483E:  BNZ   14846
14840:  MOVF   x81,W
14842:  SUBLW  1F
14844:  BNC   148EA
....................       fprintf(PC,"erasing next sector\r\n"); 
14846:  MOVLW  7A
14848:  MOVWF  FF6
1484A:  MOVLW  07
1484C:  MOVWF  FF7
1484E:  MOVLW  00
14850:  MOVWF  FF8
14852:  MOVLB  0
14854:  CALL   058C
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
14858:  MOVFF  58,381
1485C:  MOVLB  3
1485E:  MOVLW  10
14860:  ADDWF  59,W
14862:  MOVWF  x82
14864:  MOVLW  00
14866:  ADDWFC 5A,W
14868:  MOVWF  x83
1486A:  MOVLW  00
1486C:  ADDWFC 5B,W
1486E:  MOVWF  x84
14870:  MOVWF  x92
14872:  MOVFF  383,391
14876:  MOVFF  382,390
1487A:  MOVFF  58,38F
1487E:  MOVLB  0
14880:  CALL   11914
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
14884:  BCF    F94.4
14886:  BCF    F8B.4
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
14888:  MOVFF  58,381
1488C:  MOVLB  3
1488E:  MOVLW  10
14890:  ADDWF  59,W
14892:  MOVWF  x82
14894:  MOVLW  00
14896:  ADDWFC 5A,W
14898:  MOVWF  x83
1489A:  MOVLW  00
1489C:  ADDWFC 5B,W
1489E:  MOVWF  x84
148A0:  MOVWF  x92
148A2:  MOVFF  383,391
148A6:  MOVFF  382,390
148AA:  MOVFF  58,38F
148AE:  MOVLB  0
148B0:  CALL   11A3E
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
148B4:  BCF    F94.4
148B6:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
148B8:  BCF    F92.5
148BA:  BCF    F89.5
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
148BC:  MOVFF  58,381
148C0:  MOVLB  3
148C2:  MOVLW  10
148C4:  ADDWF  59,W
148C6:  MOVWF  x82
148C8:  MOVLW  00
148CA:  ADDWFC 5A,W
148CC:  MOVWF  x83
148CE:  MOVLW  00
148D0:  ADDWFC 5B,W
148D2:  MOVWF  x84
148D4:  MOVWF  x92
148D6:  MOVFF  383,391
148DA:  MOVFF  382,390
148DE:  MOVFF  58,38F
148E2:  MOVLB  0
148E4:  CALL   11B68
148E8:  MOVLB  3
....................    } 
....................    return; 
148EA:  MOVLB  0
148EC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
*
158F6:  MOVF   5F,W
158F8:  SUBLW  06
158FA:  BC    15970
158FC:  XORLW  FF
158FE:  BNZ   1591A
15900:  MOVF   5E,W
15902:  SUBLW  FB
15904:  BC    15970
15906:  XORLW  FF
15908:  BNZ   1591A
1590A:  MOVF   5D,W
1590C:  SUBLW  45
1590E:  BC    15970
15910:  XORLW  FF
15912:  BNZ   1591A
15914:  MOVF   5C,W
15916:  SUBLW  7F
15918:  BC    15970
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
1591A:  MOVLW  06
1591C:  MOVLB  3
1591E:  MOVWF  x8C
15920:  MOVLW  6A
15922:  MOVWF  x8B
15924:  CLRF   x8A
15926:  CLRF   x89
15928:  MOVLB  0
1592A:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
1592E:  BCF    F94.4
15930:  BCF    F8B.4
....................       sector_erase_SCF(SECT*1642); 
15932:  MOVLW  06
15934:  MOVLB  3
15936:  MOVWF  x8C
15938:  MOVLW  6A
1593A:  MOVWF  x8B
1593C:  CLRF   x8A
1593E:  CLRF   x89
15940:  MOVLB  0
15942:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15946:  BCF    F94.4
15948:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
1594A:  BCF    F92.5
1594C:  BCF    F89.5
....................       sector_erase_SMF(SECT*1642); 
1594E:  MOVLW  06
15950:  MOVLB  3
15952:  MOVWF  x8C
15954:  MOVLW  6A
15956:  MOVWF  x8B
15958:  CLRF   x8A
1595A:  CLRF   x89
1595C:  MOVLB  0
1595E:  CALL   1268C
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
15962:  MOVLW  06
15964:  MOVWF  5F
15966:  MOVLW  6A
15968:  MOVWF  5E
1596A:  CLRF   5D
1596C:  CLRF   5C
....................    }else{                                                                        //if value will be close to the sector 
1596E:  BRA    15B06
....................       fprintf(PC,"erasing next sector\r\n"); 
15970:  MOVLW  90
15972:  MOVWF  FF6
15974:  MOVLW  07
15976:  MOVWF  FF7
15978:  MOVLW  00
1597A:  MOVWF  FF8
1597C:  CALL   058C
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
15980:  MOVFF  5C,33D
15984:  MOVLB  3
15986:  MOVFF  5D,33E
1598A:  MOVLW  01
1598C:  ADDWF  5E,W
1598E:  MOVWF  x3F
15990:  MOVLW  00
15992:  ADDWFC 5F,W
15994:  MOVWF  x40
15996:  MOVWF  x8C
15998:  MOVFF  33F,38B
1599C:  MOVFF  5D,38A
159A0:  MOVFF  5C,389
159A4:  MOVLB  0
159A6:  CALL   12550
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
159AA:  MOVFF  5C,33D
159AE:  MOVLB  3
159B0:  MOVFF  5D,33E
159B4:  MOVLW  02
159B6:  ADDWF  5E,W
159B8:  MOVWF  x3F
159BA:  MOVLW  00
159BC:  ADDWFC 5F,W
159BE:  MOVWF  x40
159C0:  MOVWF  x8C
159C2:  MOVFF  33F,38B
159C6:  MOVFF  5D,38A
159CA:  MOVFF  5C,389
159CE:  MOVLB  0
159D0:  CALL   12550
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
159D4:  MOVFF  5C,33D
159D8:  MOVLB  3
159DA:  MOVFF  5D,33E
159DE:  MOVLW  03
159E0:  ADDWF  5E,W
159E2:  MOVWF  x3F
159E4:  MOVLW  00
159E6:  ADDWFC 5F,W
159E8:  MOVWF  x40
159EA:  MOVWF  x8C
159EC:  MOVFF  33F,38B
159F0:  MOVFF  5D,38A
159F4:  MOVFF  5C,389
159F8:  MOVLB  0
159FA:  CALL   12550
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
159FE:  BCF    F94.4
15A00:  BCF    F8B.4
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
15A02:  MOVFF  5C,33D
15A06:  MOVLB  3
15A08:  MOVFF  5D,33E
15A0C:  MOVLW  01
15A0E:  ADDWF  5E,W
15A10:  MOVWF  x3F
15A12:  MOVLW  00
15A14:  ADDWFC 5F,W
15A16:  MOVWF  x40
15A18:  MOVWF  x8C
15A1A:  MOVFF  33F,38B
15A1E:  MOVFF  5D,38A
15A22:  MOVFF  5C,389
15A26:  MOVLB  0
15A28:  CALL   125EE
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
15A2C:  MOVFF  5C,33D
15A30:  MOVLB  3
15A32:  MOVFF  5D,33E
15A36:  MOVLW  02
15A38:  ADDWF  5E,W
15A3A:  MOVWF  x3F
15A3C:  MOVLW  00
15A3E:  ADDWFC 5F,W
15A40:  MOVWF  x40
15A42:  MOVWF  x8C
15A44:  MOVFF  33F,38B
15A48:  MOVFF  5D,38A
15A4C:  MOVFF  5C,389
15A50:  MOVLB  0
15A52:  CALL   125EE
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
15A56:  MOVFF  5C,33D
15A5A:  MOVLB  3
15A5C:  MOVFF  5D,33E
15A60:  MOVLW  03
15A62:  ADDWF  5E,W
15A64:  MOVWF  x3F
15A66:  MOVLW  00
15A68:  ADDWFC 5F,W
15A6A:  MOVWF  x40
15A6C:  MOVWF  x8C
15A6E:  MOVFF  33F,38B
15A72:  MOVFF  5D,38A
15A76:  MOVFF  5C,389
15A7A:  MOVLB  0
15A7C:  CALL   125EE
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
15A80:  BCF    F94.4
15A82:  BSF    F8B.4
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
15A84:  BCF    F92.5
15A86:  BCF    F89.5
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
15A88:  MOVFF  5C,33D
15A8C:  MOVLB  3
15A8E:  MOVFF  5D,33E
15A92:  MOVLW  01
15A94:  ADDWF  5E,W
15A96:  MOVWF  x3F
15A98:  MOVLW  00
15A9A:  ADDWFC 5F,W
15A9C:  MOVWF  x40
15A9E:  MOVWF  x8C
15AA0:  MOVFF  33F,38B
15AA4:  MOVFF  5D,38A
15AA8:  MOVFF  5C,389
15AAC:  MOVLB  0
15AAE:  CALL   1268C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
15AB2:  MOVFF  5C,33D
15AB6:  MOVLB  3
15AB8:  MOVFF  5D,33E
15ABC:  MOVLW  02
15ABE:  ADDWF  5E,W
15AC0:  MOVWF  x3F
15AC2:  MOVLW  00
15AC4:  ADDWFC 5F,W
15AC6:  MOVWF  x40
15AC8:  MOVWF  x8C
15ACA:  MOVFF  33F,38B
15ACE:  MOVFF  5D,38A
15AD2:  MOVFF  5C,389
15AD6:  MOVLB  0
15AD8:  CALL   1268C
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
15ADC:  MOVFF  5C,33D
15AE0:  MOVLB  3
15AE2:  MOVFF  5D,33E
15AE6:  MOVLW  03
15AE8:  ADDWF  5E,W
15AEA:  MOVWF  x3F
15AEC:  MOVLW  00
15AEE:  ADDWFC 5F,W
15AF0:  MOVWF  x40
15AF2:  MOVWF  x8C
15AF4:  MOVFF  33F,38B
15AF8:  MOVFF  5D,38A
15AFC:  MOVFF  5C,389
15B00:  MOVLB  0
15B02:  CALL   1268C
....................    } 
....................    return; 
15B06:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<reserve_function.c> 
.................... #ifndef RESERVE_FUNCTION_C 
.................... #define RESERVE_FUNCTION_C 
....................  
.................... #define table_size 80 
.................... unsigned int8 reserve_table[table_size+1] = {}; 
.................... unsigned int8 table_num = 0; 
.................... #ORG 0x00016800 
.................... void initialize_table()                                                          //Funcion que inicializa una tabla 
.................... {                                                                                //completa todas las posiciones con 0xff 
....................    for(int num = 0; num < table_size; num++) 
*
16DFE:  MOVLB  3
16E00:  CLRF   x39
16E02:  MOVF   x39,W
16E04:  SUBLW  4F
16E06:  BNC   16E1C
....................    { 
....................       reserve_table[num] = 0xff; 
16E08:  CLRF   03
16E0A:  MOVF   x39,W
16E0C:  ADDLW  E5
16E0E:  MOVWF  FE9
16E10:  MOVLW  00
16E12:  ADDWFC 03,W
16E14:  MOVWF  FEA
16E16:  SETF   FEF
16E18:  INCF   x39,F
16E1A:  BRA    16E02
....................    } 
....................    reserve_table[80] = 0;                                                        //Coloca en la ultima posicion 0 como cantidad de espacios utilizados 
16E1C:  MOVLB  1
16E1E:  CLRF   x35
....................    return; 
16E20:  MOVLB  0
16E22:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //                          ***Sort Function*** 
.................... //This is for sorting the saved reservation commands in ascending order. 
.................... // 
.................... //reserved_table[j-9] reserved_table[j-8] reserved_table[j-7] reserved_table[j-6] reserved_table[j-5] reserved_table[j-4] reserved_table[j-3] reserved_table[j-2] 
.................... //reserved_table[j-1]  reserved_table[j]  reserved_table[j+1] reserved_table[j+2] reserved_table[j+3] reserved_table[j+4] reserved_table[j+5] reserved_table[j+6]  
.................... // 
.................... //j-9 and j-1 data are the contents information(like mission) 
.................... //j-8 and j data are the time data(execute the command reserved_table[j] min later ) 
.................... //j-7 and j+1 data are the contents detail information 
.................... // 
.................... //by comapring j-8 and j data,if it is needed, swhich j-9 and j-1, j-8 and j, j-7 and j+1....etc 
.................... //////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #ORG 0x00016800 
.................... int8 count_reservation()                                                         //Funcion que cuenta la cantidad de posiciones en la tabla con datos distintos de 0xFF  
*
16DC6:  MOVLB  3
16DC8:  CLRF   x39
.................... { 
....................    int8 counter = 0; 
....................    for(int num = 1; num < table_size - 6; num = num + 8) 
16DCA:  MOVLW  01
16DCC:  MOVWF  x3A
16DCE:  MOVF   x3A,W
16DD0:  SUBLW  49
16DD2:  BNC   16DF2
....................    { 
....................       if(reserve_table[num-1] != 0xff) 
16DD4:  MOVLW  01
16DD6:  SUBWF  x3A,W
16DD8:  CLRF   03
16DDA:  ADDLW  E5
16DDC:  MOVWF  FE9
16DDE:  MOVLW  00
16DE0:  ADDWFC 03,W
16DE2:  MOVWF  FEA
16DE4:  INCFSZ FEF,W
16DE6:  BRA    16DEA
16DE8:  BRA    16DEC
....................       { 
....................          counter++; 
16DEA:  INCF   x39,F
....................       } 
16DEC:  MOVLW  08
16DEE:  ADDWF  x3A,F
16DF0:  BRA    16DCE
....................    } 
....................    return counter * 8; 
16DF2:  MOVF   x39,W
16DF4:  MULLW  08
16DF6:  MOVFF  FF3,01
16DFA:  MOVLB  0
16DFC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void sort_table()                                                                //(command info, time info, mission mode)~10compare the time and so in ascending formrt 
.................... { 
....................    for(int i = 1; i < table_size - 7; i = i + 8){ 
*
17D48:  MOVLW  01
17D4A:  MOVLB  3
17D4C:  MOVWF  x2D
17D4E:  MOVF   x2D,W
17D50:  SUBLW  48
17D52:  BTFSS  FD8.0
17D54:  BRA    18064
....................  
....................       //compare from lower site 
....................       for(int j = table_size - 7; j > i; j = j - 8){ 
17D56:  MOVLW  49
17D58:  MOVWF  x2E
17D5A:  MOVF   x2E,W
17D5C:  SUBWF  x2D,W
17D5E:  BTFSC  FD8.0
17D60:  BRA    1805E
....................  
....................          // if upper value is larger, switch the values 
....................          if(reserve_table[j] < reserve_table[j-8]){                              //compare the time of [j]th and [j-8]th 
17D62:  CLRF   03
17D64:  MOVF   x2E,W
17D66:  ADDLW  E5
17D68:  MOVWF  FE9
17D6A:  MOVLW  00
17D6C:  ADDWFC 03,W
17D6E:  MOVWF  FEA
17D70:  MOVFF  FEF,337
17D74:  MOVLW  08
17D76:  SUBWF  x2E,W
17D78:  CLRF   03
17D7A:  ADDLW  E5
17D7C:  MOVWF  FE9
17D7E:  MOVLW  00
17D80:  ADDWFC 03,W
17D82:  MOVWF  FEA
17D84:  MOVF   FEF,W
17D86:  SUBWF  x37,W
17D88:  BTFSC  FD8.0
17D8A:  BRA    18058
....................             int t1 = reserve_table[j+6]; 
....................             int t2 = reserve_table[j+5]; 
....................             int t3 = reserve_table[j+4]; 
....................             int t4 = reserve_table[j+3]; 
....................             int t5 = reserve_table[j+2]; 
....................             int t6 = reserve_table[j+1]; 
....................             int t7 = reserve_table[j]; 
....................             int t8 = reserve_table[j-1]; 
17D8C:  MOVLW  06
17D8E:  ADDWF  x2E,W
17D90:  CLRF   03
17D92:  ADDLW  E5
17D94:  MOVWF  FE9
17D96:  MOVLW  00
17D98:  ADDWFC 03,W
17D9A:  MOVWF  FEA
17D9C:  MOVFF  FEF,32F
17DA0:  MOVLW  05
17DA2:  ADDWF  x2E,W
17DA4:  CLRF   03
17DA6:  ADDLW  E5
17DA8:  MOVWF  FE9
17DAA:  MOVLW  00
17DAC:  ADDWFC 03,W
17DAE:  MOVWF  FEA
17DB0:  MOVFF  FEF,330
17DB4:  MOVLW  04
17DB6:  ADDWF  x2E,W
17DB8:  CLRF   03
17DBA:  ADDLW  E5
17DBC:  MOVWF  FE9
17DBE:  MOVLW  00
17DC0:  ADDWFC 03,W
17DC2:  MOVWF  FEA
17DC4:  MOVFF  FEF,331
17DC8:  MOVLW  03
17DCA:  ADDWF  x2E,W
17DCC:  CLRF   03
17DCE:  ADDLW  E5
17DD0:  MOVWF  FE9
17DD2:  MOVLW  00
17DD4:  ADDWFC 03,W
17DD6:  MOVWF  FEA
17DD8:  MOVFF  FEF,332
17DDC:  MOVLW  02
17DDE:  ADDWF  x2E,W
17DE0:  CLRF   03
17DE2:  ADDLW  E5
17DE4:  MOVWF  FE9
17DE6:  MOVLW  00
17DE8:  ADDWFC 03,W
17DEA:  MOVWF  FEA
17DEC:  MOVFF  FEF,333
17DF0:  MOVLW  01
17DF2:  ADDWF  x2E,W
17DF4:  CLRF   03
17DF6:  ADDLW  E5
17DF8:  MOVWF  FE9
17DFA:  MOVLW  00
17DFC:  ADDWFC 03,W
17DFE:  MOVWF  FEA
17E00:  MOVFF  FEF,334
17E04:  CLRF   03
17E06:  MOVF   x2E,W
17E08:  ADDLW  E5
17E0A:  MOVWF  FE9
17E0C:  MOVLW  00
17E0E:  ADDWFC 03,W
17E10:  MOVWF  FEA
17E12:  MOVFF  FEF,335
17E16:  MOVLW  01
17E18:  SUBWF  x2E,W
17E1A:  CLRF   03
17E1C:  ADDLW  E5
17E1E:  MOVWF  FE9
17E20:  MOVLW  00
17E22:  ADDWFC 03,W
17E24:  MOVWF  FEA
17E26:  MOVFF  FEF,336
....................  
....................             reserve_table[j+6] = reserve_table[j-2]; 
17E2A:  MOVLW  06
17E2C:  ADDWF  x2E,W
17E2E:  CLRF   03
17E30:  ADDLW  E5
17E32:  MOVWF  01
17E34:  MOVLW  00
17E36:  ADDWFC 03,F
17E38:  MOVFF  03,338
17E3C:  MOVLW  02
17E3E:  SUBWF  x2E,W
17E40:  CLRF   03
17E42:  ADDLW  E5
17E44:  MOVWF  FE9
17E46:  MOVLW  00
17E48:  ADDWFC 03,W
17E4A:  MOVWF  FEA
17E4C:  MOVFF  FEF,339
17E50:  MOVFF  338,FEA
17E54:  MOVFF  01,FE9
17E58:  MOVFF  339,FEF
....................             reserve_table[j+5] = reserve_table[j-3]; 
17E5C:  MOVLW  05
17E5E:  ADDWF  x2E,W
17E60:  CLRF   03
17E62:  ADDLW  E5
17E64:  MOVWF  01
17E66:  MOVLW  00
17E68:  ADDWFC 03,F
17E6A:  MOVFF  03,338
17E6E:  MOVLW  03
17E70:  SUBWF  x2E,W
17E72:  CLRF   03
17E74:  ADDLW  E5
17E76:  MOVWF  FE9
17E78:  MOVLW  00
17E7A:  ADDWFC 03,W
17E7C:  MOVWF  FEA
17E7E:  MOVFF  FEF,339
17E82:  MOVFF  338,FEA
17E86:  MOVFF  01,FE9
17E8A:  MOVFF  339,FEF
....................             reserve_table[j+4] = reserve_table[j-4]; 
17E8E:  MOVLW  04
17E90:  ADDWF  x2E,W
17E92:  CLRF   03
17E94:  ADDLW  E5
17E96:  MOVWF  01
17E98:  MOVLW  00
17E9A:  ADDWFC 03,F
17E9C:  MOVFF  03,338
17EA0:  MOVLW  04
17EA2:  SUBWF  x2E,W
17EA4:  CLRF   03
17EA6:  ADDLW  E5
17EA8:  MOVWF  FE9
17EAA:  MOVLW  00
17EAC:  ADDWFC 03,W
17EAE:  MOVWF  FEA
17EB0:  MOVFF  FEF,339
17EB4:  MOVFF  338,FEA
17EB8:  MOVFF  01,FE9
17EBC:  MOVFF  339,FEF
....................             reserve_table[j+3] = reserve_table[j-5]; 
17EC0:  MOVLW  03
17EC2:  ADDWF  x2E,W
17EC4:  CLRF   03
17EC6:  ADDLW  E5
17EC8:  MOVWF  01
17ECA:  MOVLW  00
17ECC:  ADDWFC 03,F
17ECE:  MOVFF  03,338
17ED2:  MOVLW  05
17ED4:  SUBWF  x2E,W
17ED6:  CLRF   03
17ED8:  ADDLW  E5
17EDA:  MOVWF  FE9
17EDC:  MOVLW  00
17EDE:  ADDWFC 03,W
17EE0:  MOVWF  FEA
17EE2:  MOVFF  FEF,339
17EE6:  MOVFF  338,FEA
17EEA:  MOVFF  01,FE9
17EEE:  MOVFF  339,FEF
....................             reserve_table[j+2] = reserve_table[j-6]; 
17EF2:  MOVLW  02
17EF4:  ADDWF  x2E,W
17EF6:  CLRF   03
17EF8:  ADDLW  E5
17EFA:  MOVWF  01
17EFC:  MOVLW  00
17EFE:  ADDWFC 03,F
17F00:  MOVFF  03,338
17F04:  MOVLW  06
17F06:  SUBWF  x2E,W
17F08:  CLRF   03
17F0A:  ADDLW  E5
17F0C:  MOVWF  FE9
17F0E:  MOVLW  00
17F10:  ADDWFC 03,W
17F12:  MOVWF  FEA
17F14:  MOVFF  FEF,339
17F18:  MOVFF  338,FEA
17F1C:  MOVFF  01,FE9
17F20:  MOVFF  339,FEF
....................             reserve_table[j+1] = reserve_table[j-7]; 
17F24:  MOVLW  01
17F26:  ADDWF  x2E,W
17F28:  CLRF   03
17F2A:  ADDLW  E5
17F2C:  MOVWF  01
17F2E:  MOVLW  00
17F30:  ADDWFC 03,F
17F32:  MOVFF  03,338
17F36:  MOVLW  07
17F38:  SUBWF  x2E,W
17F3A:  CLRF   03
17F3C:  ADDLW  E5
17F3E:  MOVWF  FE9
17F40:  MOVLW  00
17F42:  ADDWFC 03,W
17F44:  MOVWF  FEA
17F46:  MOVFF  FEF,339
17F4A:  MOVFF  338,FEA
17F4E:  MOVFF  01,FE9
17F52:  MOVFF  339,FEF
....................             reserve_table[j] = reserve_table[j-8]; 
17F56:  CLRF   03
17F58:  MOVF   x2E,W
17F5A:  ADDLW  E5
17F5C:  MOVWF  01
17F5E:  MOVLW  00
17F60:  ADDWFC 03,F
17F62:  MOVFF  03,338
17F66:  MOVLW  08
17F68:  SUBWF  x2E,W
17F6A:  CLRF   03
17F6C:  ADDLW  E5
17F6E:  MOVWF  FE9
17F70:  MOVLW  00
17F72:  ADDWFC 03,W
17F74:  MOVWF  FEA
17F76:  MOVFF  FEF,339
17F7A:  MOVFF  338,FEA
17F7E:  MOVFF  01,FE9
17F82:  MOVFF  339,FEF
....................             reserve_table[j-1] = reserve_table[j-9]; 
17F86:  MOVLW  01
17F88:  SUBWF  x2E,W
17F8A:  CLRF   03
17F8C:  ADDLW  E5
17F8E:  MOVWF  01
17F90:  MOVLW  00
17F92:  ADDWFC 03,F
17F94:  MOVFF  03,338
17F98:  MOVLW  09
17F9A:  SUBWF  x2E,W
17F9C:  CLRF   03
17F9E:  ADDLW  E5
17FA0:  MOVWF  FE9
17FA2:  MOVLW  00
17FA4:  ADDWFC 03,W
17FA6:  MOVWF  FEA
17FA8:  MOVFF  FEF,339
17FAC:  MOVFF  338,FEA
17FB0:  MOVFF  01,FE9
17FB4:  MOVFF  339,FEF
....................  
....................             reserve_table[j-2] = t1; 
17FB8:  MOVLW  02
17FBA:  SUBWF  x2E,W
17FBC:  CLRF   03
17FBE:  ADDLW  E5
17FC0:  MOVWF  FE9
17FC2:  MOVLW  00
17FC4:  ADDWFC 03,W
17FC6:  MOVWF  FEA
17FC8:  MOVFF  32F,FEF
....................             reserve_table[j-3] = t2; 
17FCC:  MOVLW  03
17FCE:  SUBWF  x2E,W
17FD0:  CLRF   03
17FD2:  ADDLW  E5
17FD4:  MOVWF  FE9
17FD6:  MOVLW  00
17FD8:  ADDWFC 03,W
17FDA:  MOVWF  FEA
17FDC:  MOVFF  330,FEF
....................             reserve_table[j-4] = t3; 
17FE0:  MOVLW  04
17FE2:  SUBWF  x2E,W
17FE4:  CLRF   03
17FE6:  ADDLW  E5
17FE8:  MOVWF  FE9
17FEA:  MOVLW  00
17FEC:  ADDWFC 03,W
17FEE:  MOVWF  FEA
17FF0:  MOVFF  331,FEF
....................             reserve_table[j-5] = t4; 
17FF4:  MOVLW  05
17FF6:  SUBWF  x2E,W
17FF8:  CLRF   03
17FFA:  ADDLW  E5
17FFC:  MOVWF  FE9
17FFE:  MOVLW  00
18000:  ADDWFC 03,W
18002:  MOVWF  FEA
18004:  MOVFF  332,FEF
....................             reserve_table[j-6] = t5; 
18008:  MOVLW  06
1800A:  SUBWF  x2E,W
1800C:  CLRF   03
1800E:  ADDLW  E5
18010:  MOVWF  FE9
18012:  MOVLW  00
18014:  ADDWFC 03,W
18016:  MOVWF  FEA
18018:  MOVFF  333,FEF
....................             reserve_table[j-7] = t6; 
1801C:  MOVLW  07
1801E:  SUBWF  x2E,W
18020:  CLRF   03
18022:  ADDLW  E5
18024:  MOVWF  FE9
18026:  MOVLW  00
18028:  ADDWFC 03,W
1802A:  MOVWF  FEA
1802C:  MOVFF  334,FEF
....................             reserve_table[j-8] = t7; 
18030:  MOVLW  08
18032:  SUBWF  x2E,W
18034:  CLRF   03
18036:  ADDLW  E5
18038:  MOVWF  FE9
1803A:  MOVLW  00
1803C:  ADDWFC 03,W
1803E:  MOVWF  FEA
18040:  MOVFF  335,FEF
....................             reserve_table[j-9] = t8; 
18044:  MOVLW  09
18046:  SUBWF  x2E,W
18048:  CLRF   03
1804A:  ADDLW  E5
1804C:  MOVWF  FE9
1804E:  MOVLW  00
18050:  ADDWFC 03,W
18052:  MOVWF  FEA
18054:  MOVFF  336,FEF
....................  
....................  
....................          } 
18058:  MOVLW  08
1805A:  SUBWF  x2E,F
1805C:  BRA    17D5A
....................       } 
1805E:  MOVLW  08
18060:  ADDWF  x2D,F
18062:  BRA    17D4E
....................    } 
.................... return; 
18064:  MOVLB  0
18066:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Save_RSV() 
.................... { 
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
*
16800:  BCF    F92.5
16802:  BCF    F89.5
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
16804:  BCF    F94.4
16806:  BCF    F8B.4
....................    SUBSECTOR_4KB_ERASE_OF(RSV_DATA_ADDRESS); 
16808:  MOVFF  3F,392
1680C:  MOVFF  3E,391
16810:  MOVFF  3D,390
16814:  MOVFF  3C,38F
16818:  CALL   11914
....................    delay_ms(100); 
1681C:  MOVLW  64
1681E:  MOVLB  3
16820:  MOVWF  x98
16822:  MOVLB  0
16824:  CALL   0526
....................    SUBSECTOR_4KB_ERASE_SCF(RSV_DATA_ADDRESS); 
16828:  MOVFF  3F,392
1682C:  MOVFF  3E,391
16830:  MOVFF  3D,390
16834:  MOVFF  3C,38F
16838:  CALL   11A3E
....................    delay_ms(100); 
1683C:  MOVLW  64
1683E:  MOVLB  3
16840:  MOVWF  x98
16842:  MOVLB  0
16844:  CALL   0526
....................    SUBSECTOR_4KB_ERASE_SMF(RSV_DATA_ADDRESS); 
16848:  MOVFF  3F,392
1684C:  MOVFF  3E,391
16850:  MOVFF  3D,390
16854:  MOVFF  3C,38F
16858:  CALL   11B68
....................    delay_ms(100); 
1685C:  MOVLW  64
1685E:  MOVLB  3
16860:  MOVWF  x98
16862:  MOVLB  0
16864:  CALL   0526
....................     
....................    for(int num = 0; num < table_size + 1; num++)                                 //save in flash memory reserve_table[] content 
16868:  MOVLB  3
1686A:  CLRF   x85
1686C:  MOVF   x85,W
1686E:  SUBLW  50
16870:  BNC   1693C
....................    { 
....................       WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
16872:  MOVF   x85,W
16874:  ADDWF  3C,W
16876:  MOVWF  x86
16878:  MOVLW  00
1687A:  ADDWFC 3D,W
1687C:  MOVWF  x87
1687E:  MOVLW  00
16880:  ADDWFC 3E,W
16882:  MOVWF  x88
16884:  MOVLW  00
16886:  ADDWFC 3F,W
16888:  MOVWF  x89
1688A:  CLRF   03
1688C:  MOVF   x85,W
1688E:  ADDLW  E5
16890:  MOVWF  FE9
16892:  MOVLW  00
16894:  ADDWFC 03,W
16896:  MOVWF  FEA
16898:  MOVFF  FEF,394
1689C:  MOVFF  389,393
168A0:  MOVFF  388,392
168A4:  MOVFF  387,391
168A8:  MOVFF  386,390
168AC:  MOVLB  0
168AE:  CALL   119A4
....................       WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
168B2:  MOVLB  3
168B4:  MOVF   x85,W
168B6:  ADDWF  3C,W
168B8:  MOVWF  x86
168BA:  MOVLW  00
168BC:  ADDWFC 3D,W
168BE:  MOVWF  x87
168C0:  MOVLW  00
168C2:  ADDWFC 3E,W
168C4:  MOVWF  x88
168C6:  MOVLW  00
168C8:  ADDWFC 3F,W
168CA:  MOVWF  x89
168CC:  CLRF   03
168CE:  MOVF   x85,W
168D0:  ADDLW  E5
168D2:  MOVWF  FE9
168D4:  MOVLW  00
168D6:  ADDWFC 03,W
168D8:  MOVWF  FEA
168DA:  MOVFF  FEF,394
168DE:  MOVFF  389,393
168E2:  MOVFF  388,392
168E6:  MOVFF  387,391
168EA:  MOVFF  386,390
168EE:  MOVLB  0
168F0:  CALL   11C04
....................       WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+num,reserve_table[num]); 
168F4:  MOVLB  3
168F6:  MOVF   x85,W
168F8:  ADDWF  3C,W
168FA:  MOVWF  x86
168FC:  MOVLW  00
168FE:  ADDWFC 3D,W
16900:  MOVWF  x87
16902:  MOVLW  00
16904:  ADDWFC 3E,W
16906:  MOVWF  x88
16908:  MOVLW  00
1690A:  ADDWFC 3F,W
1690C:  MOVWF  x89
1690E:  CLRF   03
16910:  MOVF   x85,W
16912:  ADDLW  E5
16914:  MOVWF  FE9
16916:  MOVLW  00
16918:  ADDWFC 03,W
1691A:  MOVWF  FEA
1691C:  MOVFF  FEF,394
16920:  MOVFF  389,393
16924:  MOVFF  388,392
16928:  MOVFF  387,391
1692C:  MOVFF  386,390
16930:  MOVLB  0
16932:  CALL   11ACE
16936:  MOVLB  3
16938:  INCF   x85,F
1693A:  BRA    1686C
....................    } 
....................     
....................    WRITE_DATA_BYTE_OF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG);                     // save reserve flag 
1693C:  MOVLW  51
1693E:  ADDWF  3C,W
16940:  MOVWF  x86
16942:  MOVLW  00
16944:  ADDWFC 3D,W
16946:  MOVWF  x87
16948:  MOVLW  00
1694A:  ADDWFC 3E,W
1694C:  MOVWF  x88
1694E:  MOVLW  00
16950:  ADDWFC 3F,W
16952:  MOVWF  x89
16954:  MOVWF  x93
16956:  MOVFF  388,392
1695A:  MOVFF  387,391
1695E:  MOVFF  386,390
16962:  MOVFF  6C,394
16966:  MOVLB  0
16968:  CALL   119A4
....................    WRITE_DATA_BYTE_SCF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG); 
1696C:  MOVLW  51
1696E:  ADDWF  3C,W
16970:  MOVLB  3
16972:  MOVWF  x86
16974:  MOVLW  00
16976:  ADDWFC 3D,W
16978:  MOVWF  x87
1697A:  MOVLW  00
1697C:  ADDWFC 3E,W
1697E:  MOVWF  x88
16980:  MOVLW  00
16982:  ADDWFC 3F,W
16984:  MOVWF  x89
16986:  MOVWF  x93
16988:  MOVFF  388,392
1698C:  MOVFF  387,391
16990:  MOVFF  386,390
16994:  MOVFF  6C,394
16998:  MOVLB  0
1699A:  CALL   11ACE
....................    WRITE_DATA_BYTE_SMF(RSV_DATA_ADDRESS+81,RESERVE_MIN_FLAG); 
1699E:  MOVLW  51
169A0:  ADDWF  3C,W
169A2:  MOVLB  3
169A4:  MOVWF  x86
169A6:  MOVLW  00
169A8:  ADDWFC 3D,W
169AA:  MOVWF  x87
169AC:  MOVLW  00
169AE:  ADDWFC 3E,W
169B0:  MOVWF  x88
169B2:  MOVLW  00
169B4:  ADDWFC 3F,W
169B6:  MOVWF  x89
169B8:  MOVWF  x93
169BA:  MOVFF  388,392
169BE:  MOVFF  387,391
169C2:  MOVFF  386,390
169C6:  MOVFF  6C,394
169CA:  MOVLB  0
169CC:  CALL   11C04
....................    for(num = 0; num < table_size + 1; num++)                                     //show in PC RSV DATA 
169D0:  MOVLB  3
169D2:  CLRF   x85
169D4:  MOVF   x85,W
169D6:  SUBLW  50
169D8:  BNC   16A20
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num)); 
169DA:  MOVF   x85,W
169DC:  ADDWF  3C,W
169DE:  MOVWF  x86
169E0:  MOVLW  00
169E2:  ADDWFC 3D,W
169E4:  MOVWF  x87
169E6:  MOVLW  00
169E8:  ADDWFC 3E,W
169EA:  MOVWF  x88
169EC:  MOVLW  00
169EE:  ADDWFC 3F,W
169F0:  MOVWF  x89
169F2:  MOVWF  xAB
169F4:  MOVFF  388,3AA
169F8:  MOVFF  387,3A9
169FC:  MOVFF  386,3A8
16A00:  MOVLB  0
16A02:  CALL   121C0
16A06:  MOVFF  01,386
16A0A:  MOVFF  01,3A2
16A0E:  MOVLW  57
16A10:  MOVLB  3
16A12:  MOVWF  xA3
16A14:  MOVLB  0
16A16:  CALL   0734
16A1A:  MOVLB  3
16A1C:  INCF   x85,F
16A1E:  BRA    169D4
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX MAINSIDE 
16A20:  BCF    F94.4
16A22:  BSF    F8B.4
....................    fprintf(PC,"\r\n"); 
16A24:  MOVLW  0D
16A26:  BTFSS  F9E.4
16A28:  BRA    16A26
16A2A:  MOVWF  FAD
16A2C:  MOVLW  0A
16A2E:  BTFSS  F9E.4
16A30:  BRA    16A2E
16A32:  MOVWF  FAD
....................    return; 
16A34:  MOVLB  0
16A36:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void table_refresh()                                                             //table and flags are come back to default  
.................... { 
....................    for(int i = 0; i < table_size; i++) 
16A38:  MOVLB  3
16A3A:  CLRF   x7D
16A3C:  MOVF   x7D,W
16A3E:  SUBLW  4F
16A40:  BNC   16A56
....................    { 
....................       reserve_table[i] = 0xff; 
16A42:  CLRF   03
16A44:  MOVF   x7D,W
16A46:  ADDLW  E5
16A48:  MOVWF  FE9
16A4A:  MOVLW  00
16A4C:  ADDWFC 03,W
16A4E:  MOVWF  FEA
16A50:  SETF   FEF
16A52:  INCF   x7D,F
16A54:  BRA    16A3C
....................    } 
....................    reserve_table[80] = 0; 
16A56:  MOVLB  1
16A58:  CLRF   x35
....................    RESERVE_MIN_FLAG = 0; 
16A5A:  MOVLB  0
16A5C:  CLRF   x6C
....................    RESERVE_SEC_FLAG = 0; 
16A5E:  CLRF   x7D
....................    RESERVE_CHECK = 0; 
16A60:  CLRF   x6B
....................    MISSION_CONTENTS = 0;                                                         //closest mission command 
16A62:  CLRF   x6E
....................    RESERVE_TARGET_FLAG = 0;                                                      //closest time data 
16A64:  CLRF   x6D
....................    MISSION_DETAIL = 0;                                                           //closest mission command detail 
16A66:  CLRF   x6F
....................    RESERVE_ADDRESS_1 = 0;                                                        //closest mission address 
16A68:  CLRF   x70
....................    RESERVE_ADDRESS_2 = 0;                                                        //closest mission address 
16A6A:  CLRF   x71
....................    RESERVE_ADDRESS_3 = 0;                                                        //closest mission address 
16A6C:  CLRF   x72
....................    RESERVE_ADDRESS_4 = 0;                                                        //closest mission address 
16A6E:  CLRF   x73
....................    RESERVE_PACKET_NUM = 0;                                                       //closest mission pckt number 
16A70:  CLRF   x74
....................    Save_RSV(); 
16A72:  RCALL  16800
....................    return; 
16A74:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Get_RSV() 
.................... { 
....................    //fprintf(PC,"%x"); 
....................    for(int num = 0; num < table_size+1; num++)                                   //Carga en el vector reserve_table[] los datos leidos de la flash memory  
*
16E24:  MOVLB  3
16E26:  CLRF   x38
16E28:  MOVF   x38,W
16E2A:  SUBLW  50
16E2C:  BNC   16E80
....................    {                                                                             //desde la posicion RSV_DATA_ADDRESS hasta el tamao de la tabla 
....................       reserve_table[num]=READ_DATA_BYTE_OF(RSV_DATA_ADDRESS + num);              //import reservation table info 
16E2E:  CLRF   03
16E30:  MOVF   x38,W
16E32:  ADDLW  E5
16E34:  MOVWF  01
16E36:  MOVLW  00
16E38:  ADDWFC 03,F
16E3A:  MOVFF  01,339
16E3E:  MOVFF  03,33A
16E42:  MOVF   x38,W
16E44:  ADDWF  3C,W
16E46:  MOVWF  x3B
16E48:  MOVLW  00
16E4A:  ADDWFC 3D,W
16E4C:  MOVWF  x3C
16E4E:  MOVLW  00
16E50:  ADDWFC 3E,W
16E52:  MOVWF  x3D
16E54:  MOVLW  00
16E56:  ADDWFC 3F,W
16E58:  MOVWF  x3E
16E5A:  MOVWF  xAB
16E5C:  MOVFF  33D,3AA
16E60:  MOVFF  33C,3A9
16E64:  MOVFF  33B,3A8
16E68:  MOVLB  0
16E6A:  CALL   121C0
16E6E:  MOVFF  33A,FEA
16E72:  MOVFF  339,FE9
16E76:  MOVFF  01,FEF
16E7A:  MOVLB  3
16E7C:  INCF   x38,F
16E7E:  BRA    16E28
....................    } 
....................    reserve_table[80] = count_reservation();                                      //Carga en la posicion 30 la cantidad de posiciones ocupadas con datos 
16E80:  MOVLB  0
16E82:  RCALL  16DC6
16E84:  MOVFF  01,135
....................    //   RESERVE_MIN_FLAG = READ_DATA_BYTE_OF(RSV_DATA_ADDRESS+31); 
....................    if(reserve_table[80] == 0xFF || reserve_table[80] == 0x00)                    //Si la tabla no tiene datos almacenados 
16E88:  MOVLB  1
16E8A:  INCFSZ x35,W
16E8C:  BRA    16E90
16E8E:  BRA    16E94
16E90:  MOVF   x35,F
16E92:  BNZ   16E9A
....................    { 
....................       initialize_table();                                                        //completa con 0xff toda la tabla 
16E94:  MOVLB  0
16E96:  RCALL  16DFE
16E98:  MOVLB  1
....................    } 
....................    table_num = reserve_table[80];                                                //guarda en table_num la cantidad de datos que contiene la tabla 
16E9A:  MOVFF  135,136
....................    if(table_num != 0x00)                                                         //yes-->get reserved command and target time 
16E9E:  MOVF   x36,F
16EA0:  BZ    16ECC
....................    { 
....................       RESERVE_CHECK = 1;                                                         //LA tabla esta utilizada 
16EA2:  MOVLW  01
16EA4:  MOVLB  0
16EA6:  MOVWF  x6B
....................       MISSION_CONTENTS = reserve_table[0];                                       //closest mission command 
16EA8:  MOVFF  E5,6E
....................       RESERVE_TARGET_FLAG = reserve_table[1];                                    //closest time data 
16EAC:  MOVFF  E6,6D
....................       MISSION_DETAIL = reserve_table[2];                                         //closest mission command detail 
16EB0:  MOVFF  E7,6F
....................       RESERVE_ADDRESS_1 = reserve_table[3];                                      //closest mission address 
16EB4:  MOVFF  E8,70
....................       RESERVE_ADDRESS_2 = reserve_table[4];                                      //closest mission address 
16EB8:  MOVFF  E9,71
....................       RESERVE_ADDRESS_3 = reserve_table[5];                                      //closest mission address 
16EBC:  MOVFF  EA,72
....................       RESERVE_ADDRESS_4 = reserve_table[6];                                      //closest mission address 
16EC0:  MOVFF  EB,73
....................       RESERVE_PACKET_NUM = reserve_table[7];                                     //closest mission pckt number 
16EC4:  MOVFF  EC,74
....................    }else{ 
16EC8:  BRA    16EE0
16ECA:  MOVLB  1
....................       RESERVE_CHECK = 0;                                                         //la tabla no esta utilizada 
16ECC:  MOVLB  0
16ECE:  CLRF   x6B
....................       MISSION_CONTENTS = 0xff;                                                   //closest mission command 
16ED0:  SETF   x6E
....................       RESERVE_TARGET_FLAG = 0xff;                                                //closest time data 
16ED2:  SETF   x6D
....................       MISSION_DETAIL = 0xff;                                                     //closest mission command detail 
16ED4:  SETF   x6F
....................       RESERVE_ADDRESS_1 = 0xff;                                                  //closest mission address 
16ED6:  SETF   x70
....................       RESERVE_ADDRESS_2 = 0xff;                                                  //closest mission address 
16ED8:  SETF   x71
....................       RESERVE_ADDRESS_3 = 0xff;                                                  //closest mission address 
16EDA:  SETF   x72
....................       RESERVE_ADDRESS_4 = 0xff;                                                  //closest mission address 
16EDC:  SETF   x73
....................       RESERVE_PACKET_NUM = 0xff;                                                 //closest mission pckt number 
16EDE:  SETF   x74
....................    } 
....................    return; 
16EE0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Disp_RSV()                                                                  //show the reserve status (reserve command and reserve table) 
.................... { 
....................    Get_RSV();                                                                    //get the info from the main flash 
*
1723A:  RCALL  16E24
....................    for(int num = 0; num < table_size + 1; num++) 
1723C:  MOVLB  3
1723E:  CLRF   x37
17240:  MOVF   x37,W
17242:  SUBLW  50
17244:  BNC   17268
....................    { 
....................       fprintf(PC,"%x",reserve_table[num]); 
17246:  CLRF   03
17248:  MOVF   x37,W
1724A:  ADDLW  E5
1724C:  MOVWF  FE9
1724E:  MOVLW  00
17250:  ADDWFC 03,W
17252:  MOVWF  FEA
17254:  MOVFF  FEF,3A2
17258:  MOVLW  57
1725A:  MOVWF  xA3
1725C:  MOVLB  0
1725E:  CALL   0734
17262:  MOVLB  3
17264:  INCF   x37,F
17266:  BRA    17240
....................    } 
....................    fprintf(PC,"\r\n"); 
17268:  MOVLW  0D
1726A:  BTFSS  F9E.4
1726C:  BRA    1726A
1726E:  MOVWF  FAD
17270:  MOVLW  0A
17272:  BTFSS  F9E.4
17274:  BRA    17272
17276:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_CHECK = %x\r\n",RESERVE_CHECK); 
17278:  MOVLW  A6
1727A:  MOVWF  FF6
1727C:  MOVLW  07
1727E:  MOVWF  FF7
17280:  MOVLW  00
17282:  MOVWF  FF8
17284:  MOVLW  10
17286:  MOVWF  xA2
17288:  MOVLB  0
1728A:  CALL   0702
1728E:  MOVFF  6B,3A2
17292:  MOVLW  57
17294:  MOVLB  3
17296:  MOVWF  xA3
17298:  MOVLB  0
1729A:  CALL   0734
1729E:  MOVLW  0D
172A0:  BTFSS  F9E.4
172A2:  BRA    172A0
172A4:  MOVWF  FAD
172A6:  MOVLW  0A
172A8:  BTFSS  F9E.4
172AA:  BRA    172A8
172AC:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION_CONTENTS = %x\r\n",MISSION_CONTENTS); 
172AE:  MOVLW  BC
172B0:  MOVWF  FF6
172B2:  MOVLW  07
172B4:  MOVWF  FF7
172B6:  MOVLW  00
172B8:  MOVWF  FF8
172BA:  MOVLW  19
172BC:  MOVLB  3
172BE:  MOVWF  xA2
172C0:  MOVLB  0
172C2:  CALL   0702
172C6:  MOVFF  6E,3A2
172CA:  MOVLW  57
172CC:  MOVLB  3
172CE:  MOVWF  xA3
172D0:  MOVLB  0
172D2:  CALL   0734
172D6:  MOVLW  0D
172D8:  BTFSS  F9E.4
172DA:  BRA    172D8
172DC:  MOVWF  FAD
172DE:  MOVLW  0A
172E0:  BTFSS  F9E.4
172E2:  BRA    172E0
172E4:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_TARGET_FLAG = %x\r\n",RESERVE_TARGET_FLAG); 
172E6:  MOVLW  DA
172E8:  MOVWF  FF6
172EA:  MOVLW  07
172EC:  MOVWF  FF7
172EE:  MOVLW  00
172F0:  MOVWF  FF8
172F2:  MOVLW  16
172F4:  MOVLB  3
172F6:  MOVWF  xA2
172F8:  MOVLB  0
172FA:  CALL   0702
172FE:  MOVFF  6D,3A2
17302:  MOVLW  57
17304:  MOVLB  3
17306:  MOVWF  xA3
17308:  MOVLB  0
1730A:  CALL   0734
1730E:  MOVLW  0D
17310:  BTFSS  F9E.4
17312:  BRA    17310
17314:  MOVWF  FAD
17316:  MOVLW  0A
17318:  BTFSS  F9E.4
1731A:  BRA    17318
1731C:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION DETAIL = %x\r\n",MISSION_DETAIL); 
1731E:  MOVLW  F6
17320:  MOVWF  FF6
17322:  MOVLW  07
17324:  MOVWF  FF7
17326:  MOVLW  00
17328:  MOVWF  FF8
1732A:  MOVLW  17
1732C:  MOVLB  3
1732E:  MOVWF  xA2
17330:  MOVLB  0
17332:  CALL   0702
17336:  MOVFF  6F,3A2
1733A:  MOVLW  57
1733C:  MOVLB  3
1733E:  MOVWF  xA3
17340:  MOVLB  0
17342:  CALL   0734
17346:  MOVLW  0D
17348:  BTFSS  F9E.4
1734A:  BRA    17348
1734C:  MOVWF  FAD
1734E:  MOVLW  0A
17350:  BTFSS  F9E.4
17352:  BRA    17350
17354:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION ADDRESS = %x%x%x%x\r\n",RESERVE_ADDRESS_1,RESERVE_ADDRESS_2,RESERVE_ADDRESS_3,RESERVE_ADDRESS_4); 
17356:  MOVLW  12
17358:  MOVWF  FF6
1735A:  MOVLW  08
1735C:  MOVWF  FF7
1735E:  MOVLW  00
17360:  MOVWF  FF8
17362:  MOVLW  18
17364:  MOVLB  3
17366:  MOVWF  xA2
17368:  MOVLB  0
1736A:  CALL   0702
1736E:  MOVFF  70,3A2
17372:  MOVLW  57
17374:  MOVLB  3
17376:  MOVWF  xA3
17378:  MOVLB  0
1737A:  CALL   0734
1737E:  MOVFF  71,3A2
17382:  MOVLW  57
17384:  MOVLB  3
17386:  MOVWF  xA3
17388:  MOVLB  0
1738A:  CALL   0734
1738E:  MOVFF  72,3A2
17392:  MOVLW  57
17394:  MOVLB  3
17396:  MOVWF  xA3
17398:  MOVLB  0
1739A:  CALL   0734
1739E:  MOVFF  73,3A2
173A2:  MOVLW  57
173A4:  MOVLB  3
173A6:  MOVWF  xA3
173A8:  MOVLB  0
173AA:  CALL   0734
173AE:  MOVLW  0D
173B0:  BTFSS  F9E.4
173B2:  BRA    173B0
173B4:  MOVWF  FAD
173B6:  MOVLW  0A
173B8:  BTFSS  F9E.4
173BA:  BRA    173B8
173BC:  MOVWF  FAD
....................    fprintf(PC,"NEXT FUNCTION PCKT NUMBER = %x\r\n",RESERVE_MIN_FLAG); 
173BE:  MOVLW  36
173C0:  MOVWF  FF6
173C2:  MOVLW  08
173C4:  MOVWF  FF7
173C6:  MOVLW  00
173C8:  MOVWF  FF8
173CA:  MOVLW  1C
173CC:  MOVLB  3
173CE:  MOVWF  xA2
173D0:  MOVLB  0
173D2:  CALL   0702
173D6:  MOVFF  6C,3A2
173DA:  MOVLW  57
173DC:  MOVLB  3
173DE:  MOVWF  xA3
173E0:  MOVLB  0
173E2:  CALL   0734
173E6:  MOVLW  0D
173E8:  BTFSS  F9E.4
173EA:  BRA    173E8
173EC:  MOVWF  FAD
173EE:  MOVLW  0A
173F0:  BTFSS  F9E.4
173F2:  BRA    173F0
173F4:  MOVWF  FAD
....................    fprintf(PC,"RESERVE_MIN_FLAG = %x\r\n",RESERVE_MIN_FLAG); 
173F6:  MOVLW  58
173F8:  MOVWF  FF6
173FA:  MOVLW  08
173FC:  MOVWF  FF7
173FE:  MOVLW  00
17400:  MOVWF  FF8
17402:  MOVLW  13
17404:  MOVLB  3
17406:  MOVWF  xA2
17408:  MOVLB  0
1740A:  CALL   0702
1740E:  MOVFF  6C,3A2
17412:  MOVLW  57
17414:  MOVLB  3
17416:  MOVWF  xA3
17418:  MOVLB  0
1741A:  CALL   0734
1741E:  MOVLW  0D
17420:  BTFSS  F9E.4
17422:  BRA    17420
17424:  MOVWF  FAD
17426:  MOVLW  0A
17428:  BTFSS  F9E.4
1742A:  BRA    17428
1742C:  MOVWF  FAD
....................    fprintf(PC,"TABLE NUM = %x\r\n",table_num); 
1742E:  MOVLW  70
17430:  MOVWF  FF6
17432:  MOVLW  08
17434:  MOVWF  FF7
17436:  MOVLW  00
17438:  MOVWF  FF8
1743A:  MOVLW  0C
1743C:  MOVLB  3
1743E:  MOVWF  xA2
17440:  MOVLB  0
17442:  CALL   0702
17446:  MOVFF  136,3A2
1744A:  MOVLW  57
1744C:  MOVLB  3
1744E:  MOVWF  xA3
17450:  MOVLB  0
17452:  CALL   0734
17456:  MOVLW  0D
17458:  BTFSS  F9E.4
1745A:  BRA    17458
1745C:  MOVWF  FAD
1745E:  MOVLW  0A
17460:  BTFSS  F9E.4
17462:  BRA    17460
17464:  MOVWF  FAD
....................     
....................    return; 
17466:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void input_reservation_COM()                                                     //put the command from COM into the table and sort in ascending form 
.................... { 
....................    //!   reserve_table[table_num] = CMD_FROM_PC[0];                                 //input the data about mission content 
....................    //!   reserve_table[table_num + 1] = CMD_FROM_PC[1];                             //input the data about time data 
....................    //!   reserve_table[table_num + 2] = CMD_FROM_PC[2];                             //input the data about mission detail mode 
....................    //fprintf(PC,"Table num: %x\r\n",reserve_table[80]);                          //show the amount of bytes ocupied in the table 
....................    table_num = reserve_table[80]; 
*
18136:  MOVFF  135,136
....................    if(reserve_table[80] == 80) 
1813A:  MOVLB  1
1813C:  MOVF   x35,W
1813E:  SUBLW  50
18140:  BNZ   18158
....................    { 
....................       fprintf(PC,"Reservation table is Full!\r\n\r\n"); 
18142:  MOVLW  82
18144:  MOVWF  FF6
18146:  MOVLW  08
18148:  MOVWF  FF7
1814A:  MOVLW  00
1814C:  MOVWF  FF8
1814E:  MOVLB  0
18150:  CALL   058C
....................    }else{ 
18154:  BRA    1833C
18156:  MOVLB  1
....................       if(RESERVE_CHECK != 0x00)                                                  //if the table is in use 
18158:  MOVLB  0
1815A:  MOVF   x6B,F
1815C:  BTFSC  FD8.2
1815E:  BRA    18294
....................       { 
....................          for(int num = 1; num < table_size - 6; num = num + 8)                   //check all command data placed in the table and update the time 
18160:  MOVLW  01
18162:  MOVLB  3
18164:  MOVWF  x2C
18166:  MOVF   x2C,W
18168:  SUBLW  49
1816A:  BNC   181E6
....................          { 
....................             if(reserve_table[num-1] != 0xff)                                      
1816C:  MOVLW  01
1816E:  SUBWF  x2C,W
18170:  CLRF   03
18172:  ADDLW  E5
18174:  MOVWF  FE9
18176:  MOVLW  00
18178:  ADDWFC 03,W
1817A:  MOVWF  FEA
1817C:  INCFSZ FEF,W
1817E:  BRA    18182
18180:  BRA    181E0
....................             { 
....................                if(reserve_table[num] > RESERVE_MIN_FLAG) 
18182:  CLRF   03
18184:  MOVF   x2C,W
18186:  ADDLW  E5
18188:  MOVWF  FE9
1818A:  MOVLW  00
1818C:  ADDWFC 03,W
1818E:  MOVWF  FEA
18190:  MOVF   FEF,W
18192:  MOVLB  0
18194:  SUBWF  x6C,W
18196:  BC    181CE
....................                { 
....................                   reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;    //update the time of all commands 
18198:  CLRF   03
1819A:  MOVLB  3
1819C:  MOVF   x2C,W
1819E:  ADDLW  E5
181A0:  MOVWF  01
181A2:  MOVLW  00
181A4:  ADDWFC 03,F
181A6:  MOVFF  03,32E
181AA:  CLRF   03
181AC:  MOVF   x2C,W
181AE:  ADDLW  E5
181B0:  MOVWF  FE9
181B2:  MOVLW  00
181B4:  ADDWFC 03,W
181B6:  MOVWF  FEA
181B8:  MOVLB  0
181BA:  MOVF   x6C,W
181BC:  SUBWF  FEF,W
181BE:  MOVLB  3
181C0:  MOVFF  32E,FEA
181C4:  MOVFF  01,FE9
181C8:  MOVWF  FEF
....................                }else{ 
181CA:  BRA    181E0
181CC:  MOVLB  0
....................                   reserve_table[num] = 0; 
181CE:  CLRF   03
181D0:  MOVLB  3
181D2:  MOVF   x2C,W
181D4:  ADDLW  E5
181D6:  MOVWF  FE9
181D8:  MOVLW  00
181DA:  ADDWFC 03,W
181DC:  MOVWF  FEA
181DE:  CLRF   FEF
....................                } 
....................             } 
181E0:  MOVLW  08
181E2:  ADDWF  x2C,F
181E4:  BRA    18166
....................          } 
....................          reserve_table[table_num] = in_bffr_main[4];                             //input the data about mission content 
181E6:  CLRF   03
181E8:  MOVLB  1
181EA:  MOVF   x36,W
181EC:  ADDLW  E5
181EE:  MOVWF  FE9
181F0:  MOVLW  00
181F2:  ADDWFC 03,W
181F4:  MOVWF  FEA
181F6:  MOVFF  8A,FEF
....................          reserve_table[table_num + 1] = in_bffr_main[5];                         //input data about time 
181FA:  MOVLW  01
181FC:  ADDWF  x36,W
181FE:  CLRF   03
18200:  ADDLW  E5
18202:  MOVWF  FE9
18204:  MOVLW  00
18206:  ADDWFC 03,W
18208:  MOVWF  FEA
1820A:  MOVFF  8B,FEF
....................          reserve_table[table_num + 2] = in_bffr_main[6];                         //input the data about mission detail mode 
1820E:  MOVLW  02
18210:  ADDWF  x36,W
18212:  CLRF   03
18214:  ADDLW  E5
18216:  MOVWF  FE9
18218:  MOVLW  00
1821A:  ADDWFC 03,W
1821C:  MOVWF  FEA
1821E:  MOVFF  8C,FEF
....................          reserve_table[table_num + 3] = in_bffr_main[7];                         //input address 
18222:  MOVLW  03
18224:  ADDWF  x36,W
18226:  CLRF   03
18228:  ADDLW  E5
1822A:  MOVWF  FE9
1822C:  MOVLW  00
1822E:  ADDWFC 03,W
18230:  MOVWF  FEA
18232:  MOVFF  8D,FEF
....................          reserve_table[table_num + 4] = in_bffr_main[8];                         //input address 
18236:  MOVLW  04
18238:  ADDWF  x36,W
1823A:  CLRF   03
1823C:  ADDLW  E5
1823E:  MOVWF  FE9
18240:  MOVLW  00
18242:  ADDWFC 03,W
18244:  MOVWF  FEA
18246:  MOVFF  8E,FEF
....................          reserve_table[table_num + 5] = in_bffr_main[9];                         //input address 
1824A:  MOVLW  05
1824C:  ADDWF  x36,W
1824E:  CLRF   03
18250:  ADDLW  E5
18252:  MOVWF  FE9
18254:  MOVLW  00
18256:  ADDWFC 03,W
18258:  MOVWF  FEA
1825A:  MOVFF  8F,FEF
....................          reserve_table[table_num + 6] = in_bffr_main[10];                        //input address 
1825E:  MOVLW  06
18260:  ADDWF  x36,W
18262:  CLRF   03
18264:  ADDLW  E5
18266:  MOVWF  FE9
18268:  MOVLW  00
1826A:  ADDWFC 03,W
1826C:  MOVWF  FEA
1826E:  MOVFF  90,FEF
....................          reserve_table[table_num + 7] = in_bffr_main[11];                        //input packet number 
18272:  MOVLW  07
18274:  ADDWF  x36,W
18276:  CLRF   03
18278:  ADDLW  E5
1827A:  MOVWF  FE9
1827C:  MOVLW  00
1827E:  ADDWFC 03,W
18280:  MOVWF  FEA
18282:  MOVFF  91,FEF
....................          if(RESERVE_MIN_FLAG != 0)                                               //RESERVE_MIN_FLAG = 0 --> no need to update the target flag 
18286:  MOVLB  0
18288:  MOVF   x6C,F
1828A:  BZ    18292
....................          { 
....................             RESERVE_TARGET_FLAG = RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG; 
1828C:  MOVF   x6C,W
1828E:  SUBWF  x6D,F
....................             RESERVE_MIN_FLAG = 0; 
18290:  CLRF   x6C
....................          } 
....................       }else{                                                                     //if first reservation 
18292:  BRA    1833A
....................          RESERVE_MIN_FLAG = 0; 
18294:  CLRF   x6C
....................          RESERVE_SEC_FLAG = 0; 
18296:  CLRF   x7D
....................          reserve_table[table_num] = in_bffr_main[4];                             //input the data about mission content 
18298:  CLRF   03
1829A:  MOVLB  1
1829C:  MOVF   x36,W
1829E:  ADDLW  E5
182A0:  MOVWF  FE9
182A2:  MOVLW  00
182A4:  ADDWFC 03,W
182A6:  MOVWF  FEA
182A8:  MOVFF  8A,FEF
....................          reserve_table[table_num + 1] = in_bffr_main[5];                         //input time data 
182AC:  MOVLW  01
182AE:  ADDWF  x36,W
182B0:  CLRF   03
182B2:  ADDLW  E5
182B4:  MOVWF  FE9
182B6:  MOVLW  00
182B8:  ADDWFC 03,W
182BA:  MOVWF  FEA
182BC:  MOVFF  8B,FEF
....................          reserve_table[table_num + 2] = in_bffr_main[6];                         //input the data about mission mode detail 
182C0:  MOVLW  02
182C2:  ADDWF  x36,W
182C4:  CLRF   03
182C6:  ADDLW  E5
182C8:  MOVWF  FE9
182CA:  MOVLW  00
182CC:  ADDWFC 03,W
182CE:  MOVWF  FEA
182D0:  MOVFF  8C,FEF
....................          reserve_table[table_num + 3] = in_bffr_main[7];                         //input address 
182D4:  MOVLW  03
182D6:  ADDWF  x36,W
182D8:  CLRF   03
182DA:  ADDLW  E5
182DC:  MOVWF  FE9
182DE:  MOVLW  00
182E0:  ADDWFC 03,W
182E2:  MOVWF  FEA
182E4:  MOVFF  8D,FEF
....................          reserve_table[table_num + 4] = in_bffr_main[8];                         //input address 
182E8:  MOVLW  04
182EA:  ADDWF  x36,W
182EC:  CLRF   03
182EE:  ADDLW  E5
182F0:  MOVWF  FE9
182F2:  MOVLW  00
182F4:  ADDWFC 03,W
182F6:  MOVWF  FEA
182F8:  MOVFF  8E,FEF
....................          reserve_table[table_num + 5] = in_bffr_main[9];                         //input address 
182FC:  MOVLW  05
182FE:  ADDWF  x36,W
18300:  CLRF   03
18302:  ADDLW  E5
18304:  MOVWF  FE9
18306:  MOVLW  00
18308:  ADDWFC 03,W
1830A:  MOVWF  FEA
1830C:  MOVFF  8F,FEF
....................          reserve_table[table_num + 6] = in_bffr_main[10];                        //input address 
18310:  MOVLW  06
18312:  ADDWF  x36,W
18314:  CLRF   03
18316:  ADDLW  E5
18318:  MOVWF  FE9
1831A:  MOVLW  00
1831C:  ADDWFC 03,W
1831E:  MOVWF  FEA
18320:  MOVFF  90,FEF
....................          reserve_table[table_num + 7] = in_bffr_main[11];                        //input packet number 
18324:  MOVLW  07
18326:  ADDWF  x36,W
18328:  CLRF   03
1832A:  ADDLW  E5
1832C:  MOVWF  FE9
1832E:  MOVLW  00
18330:  ADDWFC 03,W
18332:  MOVWF  FEA
18334:  MOVFF  91,FEF
18338:  MOVLB  0
....................       } 
....................       //table_num = table_num + 3; 
....................       //reserve_table[30] = table_num; 
....................       sort_table(); 
1833A:  RCALL  17D48
....................       //!      for(int num = 0; num < table_size+1; num++) 
....................       //!      { 
....................       //!         fprintf(PC,"%x",reserve_table[num]);//show for the test 
....................       //!      } 
....................    } 
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
1833C:  CALL   16DC6
18340:  MOVFF  01,135
....................    return; 
18344:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void input_reservation_PC()                                                      //put the command from PC into the table and sort 
.................... { 
....................    fprintf(PC,"Table num: %x\r\n",reserve_table[80]);                            //print the table 
*
18394:  MOVLW  A2
18396:  MOVWF  FF6
18398:  MOVLW  08
1839A:  MOVWF  FF7
1839C:  MOVLW  00
1839E:  MOVWF  FF8
183A0:  MOVLW  0B
183A2:  MOVLB  3
183A4:  MOVWF  xA2
183A6:  MOVLB  0
183A8:  CALL   0702
183AC:  MOVFF  135,3A2
183B0:  MOVLW  57
183B2:  MOVLB  3
183B4:  MOVWF  xA3
183B6:  MOVLB  0
183B8:  CALL   0734
183BC:  MOVLW  0D
183BE:  BTFSS  F9E.4
183C0:  BRA    183BE
183C2:  MOVWF  FAD
183C4:  MOVLW  0A
183C6:  BTFSS  F9E.4
183C8:  BRA    183C6
183CA:  MOVWF  FAD
....................    table_num = reserve_table[80]; 
183CC:  MOVFF  135,136
....................    if(reserve_table[80] == 80) 
183D0:  MOVLB  1
183D2:  MOVF   x35,W
183D4:  SUBLW  50
183D6:  BNZ   183EE
....................    { 
....................       fprintf(PC,"Reservation table is Full!\r\n\r\n"); 
183D8:  MOVLW  B2
183DA:  MOVWF  FF6
183DC:  MOVLW  08
183DE:  MOVWF  FF7
183E0:  MOVLW  00
183E2:  MOVWF  FF8
183E4:  MOVLB  0
183E6:  CALL   058C
....................    }else{ 
183EA:  BRA    185D4
183EC:  MOVLB  1
....................       if(RESERVE_CHECK != 0x00)                                                  //if new reservation is faster than target time 
183EE:  MOVLB  0
183F0:  MOVF   x6B,F
183F2:  BTFSC  FD8.2
183F4:  BRA    1852A
....................       { 
....................          for(int num = 1; num < table_size - 6; num = num + 8) 
183F6:  MOVLW  01
183F8:  MOVLB  3
183FA:  MOVWF  x2C
183FC:  MOVF   x2C,W
183FE:  SUBLW  49
18400:  BNC   1847C
....................          { 
....................             if(reserve_table[num-1] != 0xff)                                     //check all command data placed in the table and update the time 
18402:  MOVLW  01
18404:  SUBWF  x2C,W
18406:  CLRF   03
18408:  ADDLW  E5
1840A:  MOVWF  FE9
1840C:  MOVLW  00
1840E:  ADDWFC 03,W
18410:  MOVWF  FEA
18412:  INCFSZ FEF,W
18414:  BRA    18418
18416:  BRA    18476
....................             { 
....................                if(reserve_table[num] > RESERVE_MIN_FLAG) 
18418:  CLRF   03
1841A:  MOVF   x2C,W
1841C:  ADDLW  E5
1841E:  MOVWF  FE9
18420:  MOVLW  00
18422:  ADDWFC 03,W
18424:  MOVWF  FEA
18426:  MOVF   FEF,W
18428:  MOVLB  0
1842A:  SUBWF  x6C,W
1842C:  BC    18464
....................                { 
....................                   reserve_table[num] = reserve_table[num] - RESERVE_MIN_FLAG;    //update the time of all commands 
1842E:  CLRF   03
18430:  MOVLB  3
18432:  MOVF   x2C,W
18434:  ADDLW  E5
18436:  MOVWF  01
18438:  MOVLW  00
1843A:  ADDWFC 03,F
1843C:  MOVFF  03,32E
18440:  CLRF   03
18442:  MOVF   x2C,W
18444:  ADDLW  E5
18446:  MOVWF  FE9
18448:  MOVLW  00
1844A:  ADDWFC 03,W
1844C:  MOVWF  FEA
1844E:  MOVLB  0
18450:  MOVF   x6C,W
18452:  SUBWF  FEF,W
18454:  MOVLB  3
18456:  MOVFF  32E,FEA
1845A:  MOVFF  01,FE9
1845E:  MOVWF  FEF
....................                }else{ 
18460:  BRA    18476
18462:  MOVLB  0
....................                   reserve_table[num] = 0; 
18464:  CLRF   03
18466:  MOVLB  3
18468:  MOVF   x2C,W
1846A:  ADDLW  E5
1846C:  MOVWF  FE9
1846E:  MOVLW  00
18470:  ADDWFC 03,W
18472:  MOVWF  FEA
18474:  CLRF   FEF
....................                } 
....................             } 
18476:  MOVLW  08
18478:  ADDWF  x2C,F
1847A:  BRA    183FC
....................          } 
....................          reserve_table[table_num] = CMD_FROM_PC[0];                              //input the data about mission content 
1847C:  CLRF   03
1847E:  MOVLB  1
18480:  MOVF   x36,W
18482:  ADDLW  E5
18484:  MOVWF  FE9
18486:  MOVLW  00
18488:  ADDWFC 03,W
1848A:  MOVWF  FEA
1848C:  MOVFF  7E,FEF
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1];                          //input reservation time 
18490:  MOVLW  01
18492:  ADDWF  x36,W
18494:  CLRF   03
18496:  ADDLW  E5
18498:  MOVWF  FE9
1849A:  MOVLW  00
1849C:  ADDWFC 03,W
1849E:  MOVWF  FEA
184A0:  MOVFF  7F,FEF
....................          reserve_table[table_num + 2] = CMD_FROM_PC[2];                          //input the data about mission detail mode 
184A4:  MOVLW  02
184A6:  ADDWF  x36,W
184A8:  CLRF   03
184AA:  ADDLW  E5
184AC:  MOVWF  FE9
184AE:  MOVLW  00
184B0:  ADDWFC 03,W
184B2:  MOVWF  FEA
184B4:  MOVFF  80,FEF
....................          reserve_table[table_num + 3] = CMD_FROM_PC[3];                          //input address 
184B8:  MOVLW  03
184BA:  ADDWF  x36,W
184BC:  CLRF   03
184BE:  ADDLW  E5
184C0:  MOVWF  FE9
184C2:  MOVLW  00
184C4:  ADDWFC 03,W
184C6:  MOVWF  FEA
184C8:  MOVFF  81,FEF
....................          reserve_table[table_num + 4] = CMD_FROM_PC[4];                          //input address 
184CC:  MOVLW  04
184CE:  ADDWF  x36,W
184D0:  CLRF   03
184D2:  ADDLW  E5
184D4:  MOVWF  FE9
184D6:  MOVLW  00
184D8:  ADDWFC 03,W
184DA:  MOVWF  FEA
184DC:  MOVFF  82,FEF
....................          reserve_table[table_num + 5] = CMD_FROM_PC[5];                          //input address 
184E0:  MOVLW  05
184E2:  ADDWF  x36,W
184E4:  CLRF   03
184E6:  ADDLW  E5
184E8:  MOVWF  FE9
184EA:  MOVLW  00
184EC:  ADDWFC 03,W
184EE:  MOVWF  FEA
184F0:  MOVFF  83,FEF
....................          reserve_table[table_num + 6] = CMD_FROM_PC[6];                          //input address 
184F4:  MOVLW  06
184F6:  ADDWF  x36,W
184F8:  CLRF   03
184FA:  ADDLW  E5
184FC:  MOVWF  FE9
184FE:  MOVLW  00
18500:  ADDWFC 03,W
18502:  MOVWF  FEA
18504:  MOVFF  84,FEF
....................          reserve_table[table_num + 7] = CMD_FROM_PC[7];                          //input packet number 
18508:  MOVLW  07
1850A:  ADDWF  x36,W
1850C:  CLRF   03
1850E:  ADDLW  E5
18510:  MOVWF  FE9
18512:  MOVLW  00
18514:  ADDWFC 03,W
18516:  MOVWF  FEA
18518:  MOVFF  85,FEF
....................           
....................          if(RESERVE_MIN_FLAG != 0)                                               //RESERVE_MIN_FLAG = 0 --> no need to update the target flag 
1851C:  MOVLB  0
1851E:  MOVF   x6C,F
18520:  BZ    18528
....................          { 
....................             RESERVE_TARGET_FLAG = RESERVE_TARGET_FLAG - RESERVE_MIN_FLAG; 
18522:  MOVF   x6C,W
18524:  SUBWF  x6D,F
....................             RESERVE_MIN_FLAG = 0; 
18526:  CLRF   x6C
....................          } 
....................       }else{                                                                     //if first reservation 
18528:  BRA    185D0
....................          RESERVE_MIN_FLAG = 0; 
1852A:  CLRF   x6C
....................          RESERVE_SEC_FLAG = 0; 
1852C:  CLRF   x7D
....................          reserve_table[table_num] = CMD_FROM_PC[0];                              //input the data about mission content 
1852E:  CLRF   03
18530:  MOVLB  1
18532:  MOVF   x36,W
18534:  ADDLW  E5
18536:  MOVWF  FE9
18538:  MOVLW  00
1853A:  ADDWFC 03,W
1853C:  MOVWF  FEA
1853E:  MOVFF  7E,FEF
....................          reserve_table[table_num + 1] = CMD_FROM_PC[1]; 
18542:  MOVLW  01
18544:  ADDWF  x36,W
18546:  CLRF   03
18548:  ADDLW  E5
1854A:  MOVWF  FE9
1854C:  MOVLW  00
1854E:  ADDWFC 03,W
18550:  MOVWF  FEA
18552:  MOVFF  7F,FEF
....................          reserve_table[table_num + 2] = CMD_FROM_PC[2];                          //input the data about mission detail mode 
18556:  MOVLW  02
18558:  ADDWF  x36,W
1855A:  CLRF   03
1855C:  ADDLW  E5
1855E:  MOVWF  FE9
18560:  MOVLW  00
18562:  ADDWFC 03,W
18564:  MOVWF  FEA
18566:  MOVFF  80,FEF
....................          reserve_table[table_num + 3] = CMD_FROM_PC[3];                          //input address 
1856A:  MOVLW  03
1856C:  ADDWF  x36,W
1856E:  CLRF   03
18570:  ADDLW  E5
18572:  MOVWF  FE9
18574:  MOVLW  00
18576:  ADDWFC 03,W
18578:  MOVWF  FEA
1857A:  MOVFF  81,FEF
....................          reserve_table[table_num + 4] = CMD_FROM_PC[4];                          //input address 
1857E:  MOVLW  04
18580:  ADDWF  x36,W
18582:  CLRF   03
18584:  ADDLW  E5
18586:  MOVWF  FE9
18588:  MOVLW  00
1858A:  ADDWFC 03,W
1858C:  MOVWF  FEA
1858E:  MOVFF  82,FEF
....................          reserve_table[table_num + 5] = CMD_FROM_PC[5];                          //input address 
18592:  MOVLW  05
18594:  ADDWF  x36,W
18596:  CLRF   03
18598:  ADDLW  E5
1859A:  MOVWF  FE9
1859C:  MOVLW  00
1859E:  ADDWFC 03,W
185A0:  MOVWF  FEA
185A2:  MOVFF  83,FEF
....................          reserve_table[table_num + 6] = CMD_FROM_PC[6];                          //input address 
185A6:  MOVLW  06
185A8:  ADDWF  x36,W
185AA:  CLRF   03
185AC:  ADDLW  E5
185AE:  MOVWF  FE9
185B0:  MOVLW  00
185B2:  ADDWFC 03,W
185B4:  MOVWF  FEA
185B6:  MOVFF  84,FEF
....................          reserve_table[table_num + 7] = CMD_FROM_PC[7];                          //input packet number 
185BA:  MOVLW  07
185BC:  ADDWF  x36,W
185BE:  CLRF   03
185C0:  ADDLW  E5
185C2:  MOVWF  FE9
185C4:  MOVLW  00
185C6:  ADDWFC 03,W
185C8:  MOVWF  FEA
185CA:  MOVFF  85,FEF
185CE:  MOVLB  0
....................       }       
....................       sort_table(); 
185D0:  CALL   17D48
....................    } 
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
185D4:  CALL   16DC6
185D8:  MOVFF  01,135
....................    return; 
185DC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Remove_1_Reservation()                                                      //after executing the mission, it should be finished 
.................... { 
....................    for(int i = 1; i < table_size - 6; i = i + 8) 
*
18068:  MOVLW  01
1806A:  MOVLB  3
1806C:  MOVWF  x2C
1806E:  MOVF   x2C,W
18070:  SUBLW  49
18072:  BNC   180C0
....................    { 
....................       if(reserve_table[i-1] != 0xff)                                             //check whether command data is placed 
18074:  MOVLW  01
18076:  SUBWF  x2C,W
18078:  CLRF   03
1807A:  ADDLW  E5
1807C:  MOVWF  FE9
1807E:  MOVLW  00
18080:  ADDWFC 03,W
18082:  MOVWF  FEA
18084:  INCFSZ FEF,W
18086:  BRA    1808A
18088:  BRA    180BA
....................       { 
....................          reserve_table[i] = reserve_table[i] - RESERVE_TARGET_FLAG;              //update the time of all commands 
1808A:  CLRF   03
1808C:  MOVF   x2C,W
1808E:  ADDLW  E5
18090:  MOVWF  01
18092:  MOVLW  00
18094:  ADDWFC 03,F
18096:  MOVFF  03,32E
1809A:  CLRF   03
1809C:  MOVF   x2C,W
1809E:  ADDLW  E5
180A0:  MOVWF  FE9
180A2:  MOVLW  00
180A4:  ADDWFC 03,W
180A6:  MOVWF  FEA
180A8:  MOVLB  0
180AA:  MOVF   x6D,W
180AC:  SUBWF  FEF,W
180AE:  MOVLB  3
180B0:  MOVFF  32E,FEA
180B4:  MOVFF  01,FE9
180B8:  MOVWF  FEF
....................       } 
180BA:  MOVLW  08
180BC:  ADDWF  x2C,F
180BE:  BRA    1806E
....................    } 
....................    reserve_table[0] = 0xff;                                                      //delete the finished mission data, put 0xFF to move at the end of the table 
180C0:  MOVLB  0
180C2:  SETF   xE5
....................    reserve_table[1] = 0xff;                                                      //delete the finished mission data 
180C4:  SETF   xE6
....................    reserve_table[2] = 0xff;                                                      //delete the finished mission data  
180C6:  SETF   xE7
....................    reserve_table[3] = 0xff;                                                      //delete the finished mission data 
180C8:  SETF   xE8
....................    reserve_table[4] = 0xff;                                                      //delete the finished mission data 
180CA:  SETF   xE9
....................    reserve_table[5] = 0xff;                                                      //delete the finished mission data 
180CC:  SETF   xEA
....................    reserve_table[6] = 0xff;                                                      //delete the finished mission data 
180CE:  SETF   xEB
....................    reserve_table[7] = 0xff;                                                      //delete the finished mission data 
180D0:  SETF   xEC
....................    sort_table(); 
180D2:  RCALL  17D48
....................    reserve_table[80] = count_reservation();                                      //update the table number data 
180D4:  CALL   16DC6
180D8:  MOVFF  01,135
....................     
....................    fprintf(PC,"Removed finished mission command:"); 
180DC:  MOVLW  D2
180DE:  MOVWF  FF6
180E0:  MOVLW  08
180E2:  MOVWF  FF7
180E4:  MOVLW  00
180E6:  MOVWF  FF8
180E8:  CALL   058C
....................    Save_RSV(); 
180EC:  CALL   16800
....................    fprintf(PC,"\r\n"); 
180F0:  MOVLW  0D
180F2:  BTFSS  F9E.4
180F4:  BRA    180F2
180F6:  MOVWF  FAD
180F8:  MOVLW  0A
180FA:  BTFSS  F9E.4
180FC:  BRA    180FA
180FE:  MOVWF  FAD
....................    return; 
18100:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_command_COM()                                                       //reservation from COM 
.................... { 
....................    fprintf(PC,"Reserve CMD from COM\r\n"); 
*
18346:  MOVLW  F4
18348:  MOVWF  FF6
1834A:  MOVLW  08
1834C:  MOVWF  FF7
1834E:  MOVLW  00
18350:  MOVWF  FF8
18352:  CALL   058C
....................    input_reservation_COM();                                                      //put the command from COM into the table and sort in ascending form 
18356:  RCALL  18136
....................    Save_RSV();                                                                   //save reserve table to flash memory 
18358:  CALL   16800
....................    RESERVE_CHECK = 1;                                                            // table check flag in HIGH 
1835C:  MOVLW  01
1835E:  MOVWF  x6B
....................    if(reserve_table[80] == 0x00 || reserve_table[80] == 0xff) 
18360:  MOVLB  1
18362:  MOVF   x35,F
18364:  BZ    1836A
18366:  INCFSZ x35,W
18368:  BRA    18370
....................    { 
....................       RESERVE_MIN_FLAG = 0;                                                      //reset time flag 
1836A:  MOVLB  0
1836C:  CLRF   x6C
1836E:  MOVLB  1
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];                                          //closest mission command 
18370:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //closest time data 
18374:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
18378:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
1837C:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
18380:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
18384:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
18388:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
1838C:  MOVFF  EC,74
18390:  MOVLB  0
18392:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_command_PC()                                                        //reservation from PC 
.................... { 
....................    fprintf(PC,"Reserve CMD from PC\r\n"); 
*
185DE:  MOVLW  0C
185E0:  MOVWF  FF6
185E2:  MOVLW  09
185E4:  MOVWF  FF7
185E6:  MOVLW  00
185E8:  MOVWF  FF8
185EA:  CALL   058C
....................    input_reservation_PC();                                                       //put the command from PC into the table and sort in ascending form 
185EE:  RCALL  18394
....................    Save_RSV();                                                                   //save reserve table to flash memory 
185F0:  CALL   16800
....................    RESERVE_CHECK = 1; 
185F4:  MOVLW  01
185F6:  MOVWF  x6B
....................    if(reserve_table[80] == 0x00 || reserve_table[80] == 0xff)                    //for only first reservation 
185F8:  MOVLB  1
185FA:  MOVF   x35,F
185FC:  BZ    18602
185FE:  INCFSZ x35,W
18600:  BRA    18608
....................    { 
....................       RESERVE_MIN_FLAG = 0;                                                      //reset time flag 
18602:  MOVLB  0
18604:  CLRF   x6C
18606:  MOVLB  1
....................    } 
....................    MISSION_CONTENTS = reserve_table[0];                                          //closest mission command 
18608:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //closest time data 
1860C:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
18610:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
18614:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
18618:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
1861C:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
18620:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
18624:  MOVFF  EC,74
18628:  MOVLB  0
1862A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void Reserve_next()                                                              //after finish execution of reservation command, this function should be execute 
.................... { 
....................    fprintf(PC,"Reserve next\r\n"); 
*
18102:  MOVLW  22
18104:  MOVWF  FF6
18106:  MOVLW  09
18108:  MOVWF  FF7
1810A:  MOVLW  00
1810C:  MOVWF  FF8
1810E:  CALL   058C
....................    //Save_RSV();//save reserve table to flash memory 
....................     
....................    //RESERVE_CHECK = 1; 
....................    RESERVE_MIN_FLAG = 0;                                                         //reset time flag 
18112:  CLRF   x6C
....................    MISSION_CONTENTS = reserve_table[0];                                          //update closest mission command 
18114:  MOVFF  E5,6E
....................    RESERVE_TARGET_FLAG = reserve_table[1];                                       //update closest time data (it is the time after 1 mission) 
18118:  MOVFF  E6,6D
....................    MISSION_DETAIL = reserve_table[2];                                            //closest mission command detail 
1811C:  MOVFF  E7,6F
....................    RESERVE_ADDRESS_1 = reserve_table[3];                                         //closest mission address 
18120:  MOVFF  E8,70
....................    RESERVE_ADDRESS_2 = reserve_table[4];                                         //closest mission address 
18124:  MOVFF  E9,71
....................    RESERVE_ADDRESS_3 = reserve_table[5];                                         //closest mission address 
18128:  MOVFF  EA,72
....................    RESERVE_ADDRESS_4 = reserve_table[6];                                         //closest mission address 
1812C:  MOVFF  EB,73
....................    RESERVE_PACKET_NUM = reserve_table[7];                                        //closest mission pckt number 
18130:  MOVFF  EC,74
18134:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<SATELLITE_LOG.c> 
.................... #ifndef SATELLITE_LOG_C 
.................... #define SATELLITE_LOG_C 
....................  
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {}; 
.................... #ORG 0x00016800 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
*
16A98:  MOVLB  3
16A9A:  CLRF   x8C
16A9C:  CLRF   x8B
16A9E:  CLRF   x8A
16AA0:  CLRF   x89
16AA2:  MOVF   x8C,W
16AA4:  SUBWF  x88,W
16AA6:  BNC   16AD2
16AA8:  BNZ   16AC0
16AAA:  MOVF   x8B,W
16AAC:  SUBWF  x87,W
16AAE:  BNC   16AD2
16AB0:  BNZ   16AC0
16AB2:  MOVF   x8A,W
16AB4:  SUBWF  x86,W
16AB6:  BNC   16AD2
16AB8:  BNZ   16AC0
16ABA:  MOVF   x85,W
16ABC:  SUBWF  x89,W
16ABE:  BC    16AD2
....................    {} 
16AC0:  MOVLW  01
16AC2:  ADDWF  x89,F
16AC4:  BTFSC  FD8.0
16AC6:  INCF   x8A,F
16AC8:  BTFSC  FD8.2
16ACA:  INCF   x8B,F
16ACC:  BTFSC  FD8.2
16ACE:  INCF   x8C,F
16AD0:  BRA    16AA2
....................    return; 
16AD2:  MOVLB  0
16AD4:  RETURN 0
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
.................... #ORG 0x00016800 
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
*
16A76:  MOVLB  3
16A78:  CLRF   x85
16A7A:  MOVF   x85,W
16A7C:  SUBLW  0A
16A7E:  BNC   16A94
....................    { 
....................       reset_bffr[num] = 0; 
16A80:  CLRF   03
16A82:  MOVF   x85,W
16A84:  ADDLW  9E
16A86:  MOVWF  FE9
16A88:  MOVLW  00
16A8A:  ADDWFC 03,W
16A8C:  MOVWF  FEA
16A8E:  CLRF   FEF
16A90:  INCF   x85,F
16A92:  BRA    16A7A
....................    } 
....................    return; 
16A94:  MOVLB  0
16A96:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
*
16B20:  CALL   14000
....................    Save_RSV();                                                                   //save in flash memory reserve_table[] content 
16B24:  RCALL  16800
....................    STORE_ADRESS_DATA_TO_FLASH(); 
16B26:  CALL   144C8
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
16B2A:  MOVLW  7A
16B2C:  SUBWF  48,W
16B2E:  MOVLB  3
16B30:  MOVWF  x85
16B32:  MOVLW  00
16B34:  SUBWFB 49,W
16B36:  MOVWF  x86
16B38:  MOVLW  00
16B3A:  SUBWFB 4A,W
16B3C:  MOVWF  x87
16B3E:  MOVLW  00
16B40:  SUBWFB 4B,W
16B42:  MOVWF  x88
16B44:  MOVWF  xAB
16B46:  MOVFF  387,3AA
16B4A:  MOVFF  386,3A9
16B4E:  MOVFF  385,3A8
16B52:  MOVLB  0
16B54:  CALL   121C0
16B58:  MOVFF  01,385
16B5C:  MOVFF  01,3A2
16B60:  MOVLW  57
16B62:  MOVLB  3
16B64:  MOVWF  xA3
16B66:  MOVLB  0
16B68:  CALL   0734
16B6C:  MOVLW  2C
16B6E:  BTFSS  F9E.4
16B70:  BRA    16B6E
16B72:  MOVWF  FAD
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
16B74:  MOVLW  79
16B76:  SUBWF  48,W
16B78:  MOVLB  3
16B7A:  MOVWF  x85
16B7C:  MOVLW  00
16B7E:  SUBWFB 49,W
16B80:  MOVWF  x86
16B82:  MOVLW  00
16B84:  SUBWFB 4A,W
16B86:  MOVWF  x87
16B88:  MOVLW  00
16B8A:  SUBWFB 4B,W
16B8C:  MOVWF  x88
16B8E:  MOVWF  xAB
16B90:  MOVFF  387,3AA
16B94:  MOVFF  386,3A9
16B98:  MOVFF  385,3A8
16B9C:  MOVLB  0
16B9E:  CALL   121C0
16BA2:  MOVFF  01,385
16BA6:  MOVFF  01,3A2
16BAA:  MOVLW  57
16BAC:  MOVLB  3
16BAE:  MOVWF  xA3
16BB0:  MOVLB  0
16BB2:  CALL   0734
16BB6:  MOVLW  2C
16BB8:  BTFSS  F9E.4
16BBA:  BRA    16BB8
16BBC:  MOVWF  FAD
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
16BBE:  MOVLW  78
16BC0:  SUBWF  48,W
16BC2:  MOVLB  3
16BC4:  MOVWF  x85
16BC6:  MOVLW  00
16BC8:  SUBWFB 49,W
16BCA:  MOVWF  x86
16BCC:  MOVLW  00
16BCE:  SUBWFB 4A,W
16BD0:  MOVWF  x87
16BD2:  MOVLW  00
16BD4:  SUBWFB 4B,W
16BD6:  MOVWF  x88
16BD8:  MOVWF  xAB
16BDA:  MOVFF  387,3AA
16BDE:  MOVFF  386,3A9
16BE2:  MOVFF  385,3A8
16BE6:  MOVLB  0
16BE8:  CALL   121C0
16BEC:  MOVFF  01,385
16BF0:  MOVFF  01,3A2
16BF4:  MOVLW  57
16BF6:  MOVLB  3
16BF8:  MOVWF  xA3
16BFA:  MOVLB  0
16BFC:  CALL   0734
16C00:  MOVLW  2C
16C02:  BTFSS  F9E.4
16C04:  BRA    16C02
16C06:  MOVWF  FAD
....................    fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
16C08:  MOVLW  77
16C0A:  SUBWF  48,W
16C0C:  MOVLB  3
16C0E:  MOVWF  x85
16C10:  MOVLW  00
16C12:  SUBWFB 49,W
16C14:  MOVWF  x86
16C16:  MOVLW  00
16C18:  SUBWFB 4A,W
16C1A:  MOVWF  x87
16C1C:  MOVLW  00
16C1E:  SUBWFB 4B,W
16C20:  MOVWF  x88
16C22:  MOVWF  xAB
16C24:  MOVFF  387,3AA
16C28:  MOVFF  386,3A9
16C2C:  MOVFF  385,3A8
16C30:  MOVLB  0
16C32:  CALL   121C0
16C36:  MOVFF  01,385
16C3A:  MOVFF  01,3A2
16C3E:  MOVLW  57
16C40:  MOVLB  3
16C42:  MOVWF  xA3
16C44:  MOVLB  0
16C46:  CALL   0734
....................    fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
16C4A:  MOVLW  76
16C4C:  SUBWF  48,W
16C4E:  MOVLB  3
16C50:  MOVWF  x85
16C52:  MOVLW  00
16C54:  SUBWFB 49,W
16C56:  MOVWF  x86
16C58:  MOVLW  00
16C5A:  SUBWFB 4A,W
16C5C:  MOVWF  x87
16C5E:  MOVLW  00
16C60:  SUBWFB 4B,W
16C62:  MOVWF  x88
16C64:  MOVWF  xAB
16C66:  MOVFF  387,3AA
16C6A:  MOVFF  386,3A9
16C6E:  MOVFF  385,3A8
16C72:  MOVLB  0
16C74:  CALL   121C0
16C78:  MOVFF  01,385
16C7C:  MOVFF  01,3A2
16C80:  MOVLW  57
16C82:  MOVLB  3
16C84:  MOVWF  xA3
16C86:  MOVLB  0
16C88:  CALL   0734
16C8C:  MOVLW  0D
16C8E:  BTFSS  F9E.4
16C90:  BRA    16C8E
16C92:  MOVWF  FAD
16C94:  MOVLW  0A
16C96:  BTFSS  F9E.4
16C98:  BRA    16C96
16C9A:  MOVWF  FAD
....................    for(int i = 0; i<100; i++) 
16C9C:  MOVLB  3
16C9E:  CLRF   x84
16CA0:  MOVF   x84,W
16CA2:  SUBLW  63
16CA4:  BNC   16CC0
....................    { 
....................       fputc(0x27,reset);                                                      //send command for satellite reset 
16CA6:  MOVLW  27
16CA8:  MOVLB  0
16CAA:  CALL   15B0
....................       delay_ms(10); 
16CAE:  MOVLW  0A
16CB0:  MOVLB  3
16CB2:  MOVWF  x98
16CB4:  MOVLB  0
16CB6:  CALL   0526
16CBA:  MOVLB  3
16CBC:  INCF   x84,F
16CBE:  BRA    16CA0
....................    } 
....................  
....................    RESET_DATA = 0; 
16CC0:  MOVLB  0
16CC2:  CLRF   x9D
....................    fprintf(PC,"Ready for reset"); 
16CC4:  MOVLW  32
16CC6:  MOVWF  FF6
16CC8:  MOVLW  09
16CCA:  MOVWF  FF7
16CCC:  MOVLW  00
16CCE:  MOVWF  FF8
16CD0:  CALL   058C
....................    delay_ms(1000); 
16CD4:  MOVLW  04
16CD6:  MOVLB  3
16CD8:  MOVWF  x85
16CDA:  MOVLW  FA
16CDC:  MOVWF  x98
16CDE:  MOVLB  0
16CE0:  CALL   0526
16CE4:  MOVLB  3
16CE6:  DECFSZ x85,F
16CE8:  BRA    16CDA
....................    return; 
16CEA:  MOVLB  0
16CEC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
16CEE:  DECFSZ xA9,W
16CF0:  BRA    16CF4
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
16CF2:  RCALL  16B20
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
16CF4:  RCALL  16A76
....................    RESET_DATA = 0; 
16CF6:  CLRF   x9D
....................    return; 
16CF8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
*
16AD6:  RCALL  16A76
....................    RESET_DATA = 0; 
16AD8:  CLRF   x9D
....................    for(int m=0; m<10; m++) 
16ADA:  MOVLB  3
16ADC:  CLRF   x84
16ADE:  MOVF   x84,W
16AE0:  SUBLW  09
16AE2:  BNC   16B1C
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
16AE4:  MOVLW  28
16AE6:  MOVLB  0
16AE8:  CALL   15B0
....................       delay_ms(10); 
16AEC:  MOVLW  0A
16AEE:  MOVLB  3
16AF0:  MOVWF  x98
16AF2:  MOVLB  0
16AF4:  CALL   0526
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
16AF8:  MOVLB  3
16AFA:  CLRF   x88
16AFC:  CLRF   x87
16AFE:  MOVLW  27
16B00:  MOVWF  x86
16B02:  MOVLW  10
16B04:  MOVWF  x85
16B06:  MOVLB  0
16B08:  RCALL  16A98
....................       if(RESET_bffr[0] == 0x8e) 
16B0A:  MOVF   x9E,W
16B0C:  SUBLW  8E
16B0E:  BNZ   16B16
....................       { 
....................          break; 
16B10:  MOVLB  3
16B12:  BRA    16B1C
16B14:  MOVLB  0
....................       } 
16B16:  MOVLB  3
16B18:  INCF   x84,F
16B1A:  BRA    16ADE
....................    } 
....................    return; 
16B1C:  MOVLB  0
16B1E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
*
16CFA:  MOVFF  D3,68
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
16CFE:  MOVFF  D4,6A
16D02:  MOVFF  D5,69
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
16D06:  MOVFF  D6,6B
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
16D0A:  MOVFF  D7,6D
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
16D0E:  MOVFF  D8,6C
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
16D12:  MOVFF  D9,6E
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
16D16:  MOVFF  DA,6F
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
16D1A:  MOVFF  DB,75
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
16D1E:  MOVFF  DC,76
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
16D22:  MOVFF  DD,77
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
16D26:  MOVFF  DE,78
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
16D2A:  MOVFF  DF,79
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
16D2E:  MOVFF  E0,7A
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
16D32:  MOVFF  E1,7B
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
16D36:  MOVFF  E2,7C
....................    if(PASSED_DAYS == 0xffff) 
16D3A:  INCFSZ x69,W
16D3C:  BRA    16D4C
16D3E:  INCFSZ x6A,W
16D40:  BRA    16D4C
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
16D42:  RCALL  16AD6
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
16D44:  MOVFF  A2,6A
16D48:  MOVFF  A3,69
....................    } 
....................    return; 
16D4C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
16D4E:  MOVLB  3
16D50:  CLRF   x2C
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
16D52:  MOVLB  0
16D54:  CALL   14C22
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
16D58:  MOVLB  3
16D5A:  CLRF   x2D
16D5C:  MOVF   x2D,W
16D5E:  SUBLW  0F
16D60:  BNC   16D7A
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
16D62:  CLRF   03
16D64:  MOVF   x2D,W
16D66:  ADDLW  D3
16D68:  MOVWF  FE9
16D6A:  MOVLW  00
16D6C:  ADDWFC 03,W
16D6E:  MOVWF  FEA
16D70:  INCFSZ FEF,W
16D72:  BRA    16D76
....................       { 
....................          checksum++; 
16D74:  INCF   x2C,F
....................       } 
16D76:  INCF   x2D,F
16D78:  BRA    16D5C
....................    }    
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
16D7A:  MOVLB  0
16D7C:  INCFSZ xD3,W
16D7E:  BRA    16D82
16D80:  BRA    16DBA
16D82:  INCFSZ xE2,W
16D84:  BRA    16D88
16D86:  BRA    16DBA
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
16D88:  MOVLB  3
16D8A:  CLRF   x2D
16D8C:  MOVF   x2D,W
16D8E:  SUBLW  0F
16D90:  BNC   16DB4
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
16D92:  CLRF   03
16D94:  MOVF   x2D,W
16D96:  ADDLW  D3
16D98:  MOVWF  FE9
16D9A:  MOVLW  00
16D9C:  ADDWFC 03,W
16D9E:  MOVWF  FEA
16DA0:  MOVFF  FEF,3A2
16DA4:  MOVLW  57
16DA6:  MOVWF  xA3
16DA8:  MOVLB  0
16DAA:  CALL   0734
16DAE:  MOVLB  3
16DB0:  INCF   x2D,F
16DB2:  BRA    16D8C
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
16DB4:  MOVLB  0
16DB6:  RCALL  16CFA
....................    }else{                                                                        //if nothing stored 
16DB8:  BRA    16DBE
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
16DBA:  CALL   14C82
....................    } 
....................    checksum = 0; 
16DBE:  MOVLB  3
16DC0:  CLRF   x2C
....................    return; 
16DC2:  MOVLB  0
16DC4:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... #ORG 0x00016800 
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
*
16EE2:  CALL   156C6
....................    RESET_DATA = 0; 
16EE6:  CLRF   x9D
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
16EE8:  RCALL  16AD6
....................    if(RESET_bffr[0] == 0x8e) 
16EEA:  MOVF   x9E,W
16EEC:  SUBLW  8E
16EEE:  BTFSS  FD8.2
16EF0:  BRA    1701C
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
16EF2:  MOVLW  DA
16EF4:  MOVLB  1
16EF6:  MOVWF  x37
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
16EF8:  MOVWF  x38
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
16EFA:  MOVFF  9F,139
....................       satellitelog[3] = RESET_bffr[2]; 
16EFE:  MOVFF  A0,13A
....................       satellitelog[4] = RESET_bffr[3]; 
16F02:  MOVFF  A1,13B
....................       satellitelog[5] = RESET_bffr[4]; 
16F06:  MOVFF  A2,13C
....................       satellitelog[6] = RESET_bffr[5]; 
16F0A:  MOVFF  A3,13D
....................        
....................       satellitelog[7] = data1; 
16F0E:  MOVFF  353,13E
....................       satellitelog[8] = data2; 
16F12:  MOVFF  354,13F
....................       satellitelog[9] = data3; 
16F16:  MOVFF  355,140
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
16F1A:  MOVLW  EF
16F1C:  MOVWF  x41
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
16F1E:  BCF    F92.5
16F20:  BCF    F89.5
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
16F22:  BCF    F94.4
16F24:  BCF    F8B.4
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
16F26:  MOVLB  3
16F28:  CLRF   x56
16F2A:  MOVF   x56,W
16F2C:  SUBLW  0A
16F2E:  BNC   16FFA
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
16F30:  MOVF   x56,W
16F32:  ADDWF  40,W
16F34:  MOVWF  x57
16F36:  MOVLW  00
16F38:  ADDWFC 41,W
16F3A:  MOVWF  x58
16F3C:  MOVLW  00
16F3E:  ADDWFC 42,W
16F40:  MOVWF  x59
16F42:  MOVLW  00
16F44:  ADDWFC 43,W
16F46:  MOVWF  x5A
16F48:  CLRF   03
16F4A:  MOVF   x56,W
16F4C:  ADDLW  37
16F4E:  MOVWF  FE9
16F50:  MOVLW  01
16F52:  ADDWFC 03,W
16F54:  MOVWF  FEA
16F56:  MOVFF  FEF,394
16F5A:  MOVFF  35A,393
16F5E:  MOVFF  359,392
16F62:  MOVFF  358,391
16F66:  MOVFF  357,390
16F6A:  MOVLB  0
16F6C:  CALL   119A4
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
16F70:  MOVLB  3
16F72:  MOVF   x56,W
16F74:  ADDWF  40,W
16F76:  MOVWF  x57
16F78:  MOVLW  00
16F7A:  ADDWFC 41,W
16F7C:  MOVWF  x58
16F7E:  MOVLW  00
16F80:  ADDWFC 42,W
16F82:  MOVWF  x59
16F84:  MOVLW  00
16F86:  ADDWFC 43,W
16F88:  MOVWF  x5A
16F8A:  CLRF   03
16F8C:  MOVF   x56,W
16F8E:  ADDLW  37
16F90:  MOVWF  FE9
16F92:  MOVLW  01
16F94:  ADDWFC 03,W
16F96:  MOVWF  FEA
16F98:  MOVFF  FEF,394
16F9C:  MOVFF  35A,393
16FA0:  MOVFF  359,392
16FA4:  MOVFF  358,391
16FA8:  MOVFF  357,390
16FAC:  MOVLB  0
16FAE:  CALL   11ACE
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
16FB2:  MOVLB  3
16FB4:  MOVF   x56,W
16FB6:  ADDWF  40,W
16FB8:  MOVWF  x57
16FBA:  MOVLW  00
16FBC:  ADDWFC 41,W
16FBE:  MOVWF  x58
16FC0:  MOVLW  00
16FC2:  ADDWFC 42,W
16FC4:  MOVWF  x59
16FC6:  MOVLW  00
16FC8:  ADDWFC 43,W
16FCA:  MOVWF  x5A
16FCC:  CLRF   03
16FCE:  MOVF   x56,W
16FD0:  ADDLW  37
16FD2:  MOVWF  FE9
16FD4:  MOVLW  01
16FD6:  ADDWFC 03,W
16FD8:  MOVWF  FEA
16FDA:  MOVFF  FEF,394
16FDE:  MOVFF  35A,393
16FE2:  MOVFF  359,392
16FE6:  MOVFF  358,391
16FEA:  MOVFF  357,390
16FEE:  MOVLB  0
16FF0:  CALL   11C04
16FF4:  MOVLB  3
16FF6:  INCF   x56,F
16FF8:  BRA    16F2A
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
16FFA:  BCF    F94.4
16FFC:  BSF    F8B.4
....................       SAT_LOG = SAT_LOG + logdata_size; 
16FFE:  MOVLW  0B
17000:  ADDWF  40,F
17002:  MOVLW  00
17004:  ADDWFC 41,F
17006:  ADDWFC 42,F
17008:  ADDWFC 43,F
....................       fprintf(PC,"LOG saving done\r\n"); 
1700A:  MOVLW  42
1700C:  MOVWF  FF6
1700E:  MOVLW  09
17010:  MOVWF  FF7
17012:  MOVLW  00
17014:  MOVWF  FF8
17016:  MOVLB  0
17018:  CALL   058C
....................    } 
....................     
....................    return; 
1701C:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<FLASH_OPERATION.c>                                                      //erase or transfer 
.................... #ifndef FLASH_OPERATION_C 
.................... #define FLASH_OPERATION_C 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
*
170D2:  MOVLW  54
170D4:  MOVWF  FF6
170D6:  MOVLW  09
170D8:  MOVWF  FF7
170DA:  MOVLW  00
170DC:  MOVWF  FF8
170DE:  MOVLW  09
170E0:  MOVLB  3
170E2:  MOVWF  xA2
170E4:  MOVLB  0
170E6:  CALL   0702
170EA:  MOVFF  347,3A2
170EE:  MOVLW  57
170F0:  MOVLB  3
170F2:  MOVWF  xA3
170F4:  MOVLB  0
170F6:  CALL   0734
170FA:  MOVFF  348,3A2
170FE:  MOVLW  57
17100:  MOVLB  3
17102:  MOVWF  xA3
17104:  MOVLB  0
17106:  CALL   0734
1710A:  MOVFF  349,3A2
1710E:  MOVLW  57
17110:  MOVLB  3
17112:  MOVWF  xA3
17114:  MOVLB  0
17116:  CALL   0734
1711A:  MOVFF  34A,3A2
1711E:  MOVLW  57
17120:  MOVLB  3
17122:  MOVWF  xA3
17124:  MOVLB  0
17126:  CALL   0734
1712A:  MOVLW  0D
1712C:  BTFSS  F9E.4
1712E:  BRA    1712C
17130:  MOVWF  FAD
17132:  MOVLW  0A
17134:  BTFSS  F9E.4
17136:  BRA    17134
17138:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
1713A:  MOVFF  347,34E
1713E:  MOVFF  348,34D
17142:  MOVFF  349,34C
17146:  MOVFF  34A,34B
....................    sector_erase_OF(address);                                                     //erase 1 sector 
1714A:  MOVFF  34E,38C
1714E:  MOVFF  34D,38B
17152:  MOVFF  34C,38A
17156:  MOVFF  34B,389
1715A:  CALL   12550
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
1715E:  MOVFF  34D,34F
17162:  MOVFF  34E,350
17166:  MOVFF  350,351
1716A:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe0, D1, D2);                                                   //0xE0+16bit sector info 
1716E:  MOVLW  E0
17170:  MOVLB  3
17172:  MOVWF  x53
17174:  MOVFF  351,354
17178:  MOVFF  352,355
1717C:  MOVLB  0
1717E:  RCALL  16EE2
....................     
....................    return; 
17180:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_SCF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17182:  MOVLW  68
17184:  MOVWF  FF6
17186:  MOVLW  09
17188:  MOVWF  FF7
1718A:  MOVLW  00
1718C:  MOVWF  FF8
1718E:  MOVLW  0A
17190:  MOVLB  3
17192:  MOVWF  xA2
17194:  MOVLB  0
17196:  CALL   0702
1719A:  MOVFF  347,3A2
1719E:  MOVLW  57
171A0:  MOVLB  3
171A2:  MOVWF  xA3
171A4:  MOVLB  0
171A6:  CALL   0734
171AA:  MOVFF  348,3A2
171AE:  MOVLW  57
171B0:  MOVLB  3
171B2:  MOVWF  xA3
171B4:  MOVLB  0
171B6:  CALL   0734
171BA:  MOVFF  349,3A2
171BE:  MOVLW  57
171C0:  MOVLB  3
171C2:  MOVWF  xA3
171C4:  MOVLB  0
171C6:  CALL   0734
171CA:  MOVFF  34A,3A2
171CE:  MOVLW  57
171D0:  MOVLB  3
171D2:  MOVWF  xA3
171D4:  MOVLB  0
171D6:  CALL   0734
171DA:  MOVLW  0D
171DC:  BTFSS  F9E.4
171DE:  BRA    171DC
171E0:  MOVWF  FAD
171E2:  MOVLW  0A
171E4:  BTFSS  F9E.4
171E6:  BRA    171E4
171E8:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
171EA:  MOVFF  347,34E
171EE:  MOVFF  348,34D
171F2:  MOVFF  349,34C
171F6:  MOVFF  34A,34B
....................    output_low(PIN_C4);                                                           //multiplexor OBC side 
171FA:  BCF    F94.4
171FC:  BCF    F8B.4
....................    sector_erase_SCF(address);                                                    //erase 1 sector 
171FE:  MOVFF  34E,38C
17202:  MOVFF  34D,38B
17206:  MOVFF  34C,38A
1720A:  MOVFF  34B,389
1720E:  CALL   125EE
....................    output_high(PIN_C4); 
17212:  BCF    F94.4
17214:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17216:  MOVFF  34D,34F
1721A:  MOVFF  34E,350
1721E:  MOVFF  350,351
17222:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe1, D1, D2);                                                   //0xE0+16bit sector info 
17226:  MOVLW  E1
17228:  MOVLB  3
1722A:  MOVWF  x53
1722C:  MOVFF  351,354
17230:  MOVFF  352,355
17234:  MOVLB  0
17236:  RCALL  16EE2
....................    return; 
17238:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void REFRESH_SECTOR_SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    fprintf(PC,"ERASE SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
*
1701E:  MOVLW  7E
17020:  MOVWF  FF6
17022:  MOVLW  09
17024:  MOVWF  FF7
17026:  MOVLW  00
17028:  MOVWF  FF8
1702A:  MOVLW  0A
1702C:  MOVLB  3
1702E:  MOVWF  xA2
17030:  MOVLB  0
17032:  CALL   0702
17036:  MOVFF  347,3A2
1703A:  MOVLW  57
1703C:  MOVLB  3
1703E:  MOVWF  xA3
17040:  MOVLB  0
17042:  CALL   0734
17046:  MOVFF  348,3A2
1704A:  MOVLW  57
1704C:  MOVLB  3
1704E:  MOVWF  xA3
17050:  MOVLB  0
17052:  CALL   0734
17056:  MOVFF  349,3A2
1705A:  MOVLW  57
1705C:  MOVLB  3
1705E:  MOVWF  xA3
17060:  MOVLB  0
17062:  CALL   0734
17066:  MOVFF  34A,3A2
1706A:  MOVLW  57
1706C:  MOVLB  3
1706E:  MOVWF  xA3
17070:  MOVLB  0
17072:  CALL   0734
17076:  MOVLW  0D
17078:  BTFSS  F9E.4
1707A:  BRA    17078
1707C:  MOVWF  FAD
1707E:  MOVLW  0A
17080:  BTFSS  F9E.4
17082:  BRA    17080
17084:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17086:  MOVFF  347,34E
1708A:  MOVFF  348,34D
1708E:  MOVFF  349,34C
17092:  MOVFF  34A,34B
....................    output_low(PIN_A5);                                                           //multiplexor OBC side 
17096:  BCF    F92.5
17098:  BCF    F89.5
....................    sector_erase_SMF(address);                                                    //erase 1 sector 
1709A:  MOVFF  34E,38C
1709E:  MOVFF  34D,38B
170A2:  MOVFF  34C,38A
170A6:  MOVFF  34B,389
170AA:  CALL   1268C
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector borrado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
170AE:  MOVFF  34D,34F
170B2:  MOVFF  34E,350
170B6:  MOVFF  350,351
170BA:  MOVFF  34F,352
....................     
....................    SAVE_SAT_LOG(0xe2, D1, D2);                                                   //0xE0+16bit sector info 
170BE:  MOVLW  E2
170C0:  MOVLB  3
170C2:  MOVWF  x53
170C4:  MOVFF  351,354
170C8:  MOVFF  352,355
170CC:  MOVLB  0
170CE:  RCALL  16EE2
....................    return; 
170D0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_OF2SCF(int8 data1,int8 data2,int8 data3,int8 data4)         //command 0x12 
.................... { 
....................    REFRESH_SECTOR_SCF(data1,data2,data3,data4);                                  //erase 1 sector SCF 
*
17468:  MOVFF  337,347
1746C:  MOVFF  338,348
17470:  MOVFF  339,349
17474:  MOVFF  33A,34A
17478:  RCALL  17182
....................    delay_ms(500); 
1747A:  MOVLW  02
1747C:  MOVLB  3
1747E:  MOVWF  x47
17480:  MOVLW  FA
17482:  MOVWF  x98
17484:  MOVLB  0
17486:  CALL   0526
1748A:  MOVLB  3
1748C:  DECFSZ x47,F
1748E:  BRA    17480
....................    fprintf(PC,"transfer OF2SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17490:  MOVLW  94
17492:  MOVWF  FF6
17494:  MOVLW  09
17496:  MOVWF  FF7
17498:  MOVLW  00
1749A:  MOVWF  FF8
1749C:  MOVLW  10
1749E:  MOVWF  xA2
174A0:  MOVLB  0
174A2:  CALL   0702
174A6:  MOVFF  337,3A2
174AA:  MOVLW  57
174AC:  MOVLB  3
174AE:  MOVWF  xA3
174B0:  MOVLB  0
174B2:  CALL   0734
174B6:  MOVFF  338,3A2
174BA:  MOVLW  57
174BC:  MOVLB  3
174BE:  MOVWF  xA3
174C0:  MOVLB  0
174C2:  CALL   0734
174C6:  MOVFF  339,3A2
174CA:  MOVLW  57
174CC:  MOVLB  3
174CE:  MOVWF  xA3
174D0:  MOVLB  0
174D2:  CALL   0734
174D6:  MOVFF  33A,3A2
174DA:  MOVLW  57
174DC:  MOVLB  3
174DE:  MOVWF  xA3
174E0:  MOVLB  0
174E2:  CALL   0734
174E6:  MOVLW  0D
174E8:  BTFSS  F9E.4
174EA:  BRA    174E8
174EC:  MOVWF  FAD
174EE:  MOVLW  0A
174F0:  BTFSS  F9E.4
174F2:  BRA    174F0
174F4:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
174F6:  MOVFF  337,33E
174FA:  MOVFF  338,33D
174FE:  MOVFF  339,33C
17502:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17506:  MOVLB  3
17508:  MOVFF  33B,00
1750C:  MOVFF  33C,01
17510:  CLRF   02
17512:  CLRF   03
17514:  MOVF   x3B,W
17516:  SUBWF  x3B,F
17518:  MOVF   x3C,W
1751A:  SUBWFB x3C,F
1751C:  MOVF   02,W
1751E:  SUBWFB x3D,F
17520:  MOVF   03,W
17522:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //OBC side 
17524:  BCF    F94.4
17526:  BCF    F8B.4
....................    for(int32 i = 0; i < SECT; i++) 
17528:  CLRF   x42
1752A:  CLRF   x41
1752C:  CLRF   x40
1752E:  CLRF   x3F
17530:  MOVF   x42,F
17532:  BNZ   175AE
17534:  MOVF   x41,W
17536:  SUBLW  00
17538:  BNC   175AE
....................    { 
....................       WRITE_DATA_BYTE_SCF(address + i, READ_DATA_BYTE_OF(address + i)); 
1753A:  MOVF   x3F,W
1753C:  ADDWF  x3B,W
1753E:  MOVWF  x47
17540:  MOVF   x40,W
17542:  ADDWFC x3C,W
17544:  MOVWF  x48
17546:  MOVF   x41,W
17548:  ADDWFC x3D,W
1754A:  MOVWF  x49
1754C:  MOVF   x42,W
1754E:  ADDWFC x3E,W
17550:  MOVWF  x4A
17552:  MOVF   x3F,W
17554:  ADDWF  x3B,W
17556:  MOVWF  x4B
17558:  MOVF   x40,W
1755A:  ADDWFC x3C,W
1755C:  MOVWF  x4C
1755E:  MOVF   x41,W
17560:  ADDWFC x3D,W
17562:  MOVWF  x4D
17564:  MOVF   x42,W
17566:  ADDWFC x3E,W
17568:  MOVWF  x4E
1756A:  MOVWF  xAB
1756C:  MOVFF  34D,3AA
17570:  MOVFF  34C,3A9
17574:  MOVFF  34B,3A8
17578:  MOVLB  0
1757A:  CALL   121C0
1757E:  MOVFF  01,34B
17582:  MOVFF  34A,393
17586:  MOVFF  349,392
1758A:  MOVFF  348,391
1758E:  MOVFF  347,390
17592:  MOVFF  01,394
17596:  CALL   11ACE
1759A:  MOVLW  01
1759C:  MOVLB  3
1759E:  ADDWF  x3F,F
175A0:  BTFSC  FD8.0
175A2:  INCF   x40,F
175A4:  BTFSC  FD8.2
175A6:  INCF   x41,F
175A8:  BTFSC  FD8.2
175AA:  INCF   x42,F
175AC:  BRA    17530
....................    } 
....................    delay_ms(100); 
175AE:  MOVLW  64
175B0:  MOVWF  x98
175B2:  MOVLB  0
175B4:  CALL   0526
....................    output_high(PIN_C4);                                                          //COM side 
175B8:  BCF    F94.4
175BA:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
175BC:  MOVFF  33D,343
175C0:  MOVFF  33E,344
175C4:  MOVFF  344,345
175C8:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x12, D1, D2);                                                   //0xE0+16bit sector info 
175CC:  MOVLW  12
175CE:  MOVLB  3
175D0:  MOVWF  x53
175D2:  MOVFF  345,354
175D6:  MOVFF  346,355
175DA:  MOVLB  0
175DC:  RCALL  16EE2
....................    return; 
175DE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_OF2SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_SMF(data1,data2,data3,data4);                                  //erase 1 sector SMF 
175E0:  MOVFF  337,347
175E4:  MOVFF  338,348
175E8:  MOVFF  339,349
175EC:  MOVFF  33A,34A
175F0:  RCALL  1701E
....................    delay_ms(500); 
175F2:  MOVLW  02
175F4:  MOVLB  3
175F6:  MOVWF  x47
175F8:  MOVLW  FA
175FA:  MOVWF  x98
175FC:  MOVLB  0
175FE:  CALL   0526
17602:  MOVLB  3
17604:  DECFSZ x47,F
17606:  BRA    175F8
....................    fprintf(PC,"transfer OF2SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17608:  MOVLW  B0
1760A:  MOVWF  FF6
1760C:  MOVLW  09
1760E:  MOVWF  FF7
17610:  MOVLW  00
17612:  MOVWF  FF8
17614:  MOVLW  10
17616:  MOVWF  xA2
17618:  MOVLB  0
1761A:  CALL   0702
1761E:  MOVFF  337,3A2
17622:  MOVLW  57
17624:  MOVLB  3
17626:  MOVWF  xA3
17628:  MOVLB  0
1762A:  CALL   0734
1762E:  MOVFF  338,3A2
17632:  MOVLW  57
17634:  MOVLB  3
17636:  MOVWF  xA3
17638:  MOVLB  0
1763A:  CALL   0734
1763E:  MOVFF  339,3A2
17642:  MOVLW  57
17644:  MOVLB  3
17646:  MOVWF  xA3
17648:  MOVLB  0
1764A:  CALL   0734
1764E:  MOVFF  33A,3A2
17652:  MOVLW  57
17654:  MOVLB  3
17656:  MOVWF  xA3
17658:  MOVLB  0
1765A:  CALL   0734
1765E:  MOVLW  0D
17660:  BTFSS  F9E.4
17662:  BRA    17660
17664:  MOVWF  FAD
17666:  MOVLW  0A
17668:  BTFSS  F9E.4
1766A:  BRA    17668
1766C:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
1766E:  MOVFF  337,33E
17672:  MOVFF  338,33D
17676:  MOVFF  339,33C
1767A:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
1767E:  MOVLB  3
17680:  MOVFF  33B,00
17684:  MOVFF  33C,01
17688:  CLRF   02
1768A:  CLRF   03
1768C:  MOVF   x3B,W
1768E:  SUBWF  x3B,F
17690:  MOVF   x3C,W
17692:  SUBWFB x3C,F
17694:  MOVF   02,W
17696:  SUBWFB x3D,F
17698:  MOVF   03,W
1769A:  SUBWFB x3E,F
....................    output_low(PIN_A5);                                                           //OBC side 
1769C:  BCF    F92.5
1769E:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
176A0:  CLRF   x42
176A2:  CLRF   x41
176A4:  CLRF   x40
176A6:  CLRF   x3F
176A8:  MOVF   x42,F
176AA:  BNZ   17726
176AC:  MOVF   x41,W
176AE:  SUBLW  00
176B0:  BNC   17726
....................    { 
....................       WRITE_DATA_BYTE_SMF(address + i, READ_DATA_BYTE_OF(address + i)); 
176B2:  MOVF   x3F,W
176B4:  ADDWF  x3B,W
176B6:  MOVWF  x47
176B8:  MOVF   x40,W
176BA:  ADDWFC x3C,W
176BC:  MOVWF  x48
176BE:  MOVF   x41,W
176C0:  ADDWFC x3D,W
176C2:  MOVWF  x49
176C4:  MOVF   x42,W
176C6:  ADDWFC x3E,W
176C8:  MOVWF  x4A
176CA:  MOVF   x3F,W
176CC:  ADDWF  x3B,W
176CE:  MOVWF  x4B
176D0:  MOVF   x40,W
176D2:  ADDWFC x3C,W
176D4:  MOVWF  x4C
176D6:  MOVF   x41,W
176D8:  ADDWFC x3D,W
176DA:  MOVWF  x4D
176DC:  MOVF   x42,W
176DE:  ADDWFC x3E,W
176E0:  MOVWF  x4E
176E2:  MOVWF  xAB
176E4:  MOVFF  34D,3AA
176E8:  MOVFF  34C,3A9
176EC:  MOVFF  34B,3A8
176F0:  MOVLB  0
176F2:  CALL   121C0
176F6:  MOVFF  01,34B
176FA:  MOVFF  34A,393
176FE:  MOVFF  349,392
17702:  MOVFF  348,391
17706:  MOVFF  347,390
1770A:  MOVFF  01,394
1770E:  CALL   11C04
17712:  MOVLW  01
17714:  MOVLB  3
17716:  ADDWF  x3F,F
17718:  BTFSC  FD8.0
1771A:  INCF   x40,F
1771C:  BTFSC  FD8.2
1771E:  INCF   x41,F
17720:  BTFSC  FD8.2
17722:  INCF   x42,F
17724:  BRA    176A8
....................    } 
....................    delay_ms(100); 
17726:  MOVLW  64
17728:  MOVWF  x98
1772A:  MOVLB  0
1772C:  CALL   0526
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17730:  MOVFF  33D,343
17734:  MOVFF  33E,344
17738:  MOVFF  344,345
1773C:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x13, D1, D2);                                                   //0xE0+16bit sector info 
17740:  MOVLW  13
17742:  MOVLB  3
17744:  MOVWF  x53
17746:  MOVFF  345,354
1774A:  MOVFF  346,355
1774E:  MOVLB  0
17750:  CALL   16EE2
....................     
....................    return; 
17754:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SCF2OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_OF(data1,data2,data3,data4);                                   //erase 1 sector OBC flash 
17756:  MOVFF  337,347
1775A:  MOVFF  338,348
1775E:  MOVFF  339,349
17762:  MOVFF  33A,34A
17766:  RCALL  170D2
....................    delay_ms(500); 
17768:  MOVLW  02
1776A:  MOVLB  3
1776C:  MOVWF  x47
1776E:  MOVLW  FA
17770:  MOVWF  x98
17772:  MOVLB  0
17774:  CALL   0526
17778:  MOVLB  3
1777A:  DECFSZ x47,F
1777C:  BRA    1776E
....................    fprintf(PC,"transfer SCF2OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
1777E:  MOVLW  CC
17780:  MOVWF  FF6
17782:  MOVLW  09
17784:  MOVWF  FF7
17786:  MOVLW  00
17788:  MOVWF  FF8
1778A:  MOVLW  10
1778C:  MOVWF  xA2
1778E:  MOVLB  0
17790:  CALL   0702
17794:  MOVFF  337,3A2
17798:  MOVLW  57
1779A:  MOVLB  3
1779C:  MOVWF  xA3
1779E:  MOVLB  0
177A0:  CALL   0734
177A4:  MOVFF  338,3A2
177A8:  MOVLW  57
177AA:  MOVLB  3
177AC:  MOVWF  xA3
177AE:  MOVLB  0
177B0:  CALL   0734
177B4:  MOVFF  339,3A2
177B8:  MOVLW  57
177BA:  MOVLB  3
177BC:  MOVWF  xA3
177BE:  MOVLB  0
177C0:  CALL   0734
177C4:  MOVFF  33A,3A2
177C8:  MOVLW  57
177CA:  MOVLB  3
177CC:  MOVWF  xA3
177CE:  MOVLB  0
177D0:  CALL   0734
177D4:  MOVLW  0D
177D6:  BTFSS  F9E.4
177D8:  BRA    177D6
177DA:  MOVWF  FAD
177DC:  MOVLW  0A
177DE:  BTFSS  F9E.4
177E0:  BRA    177DE
177E2:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
177E4:  MOVFF  337,33E
177E8:  MOVFF  338,33D
177EC:  MOVFF  339,33C
177F0:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
177F4:  MOVLB  3
177F6:  MOVFF  33B,00
177FA:  MOVFF  33C,01
177FE:  CLRF   02
17800:  CLRF   03
17802:  MOVF   x3B,W
17804:  SUBWF  x3B,F
17806:  MOVF   x3C,W
17808:  SUBWFB x3C,F
1780A:  MOVF   02,W
1780C:  SUBWFB x3D,F
1780E:  MOVF   03,W
17810:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
17812:  BCF    F94.4
17814:  BCF    F8B.4
....................    for(int32 i = 0; i < SECT; i++) 
17816:  CLRF   x42
17818:  CLRF   x41
1781A:  CLRF   x40
1781C:  CLRF   x3F
1781E:  MOVF   x42,F
17820:  BNZ   1789C
17822:  MOVF   x41,W
17824:  SUBLW  00
17826:  BNC   1789C
....................    { 
....................       WRITE_DATA_BYTE_OF(address + i, READ_DATA_BYTE_SCF(address + i)); 
17828:  MOVF   x3F,W
1782A:  ADDWF  x3B,W
1782C:  MOVWF  x47
1782E:  MOVF   x40,W
17830:  ADDWFC x3C,W
17832:  MOVWF  x48
17834:  MOVF   x41,W
17836:  ADDWFC x3D,W
17838:  MOVWF  x49
1783A:  MOVF   x42,W
1783C:  ADDWFC x3E,W
1783E:  MOVWF  x4A
17840:  MOVF   x3F,W
17842:  ADDWF  x3B,W
17844:  MOVWF  x4B
17846:  MOVF   x40,W
17848:  ADDWFC x3C,W
1784A:  MOVWF  x4C
1784C:  MOVF   x41,W
1784E:  ADDWFC x3D,W
17850:  MOVWF  x4D
17852:  MOVF   x42,W
17854:  ADDWFC x3E,W
17856:  MOVWF  x4E
17858:  MOVWF  x52
1785A:  MOVFF  34D,351
1785E:  MOVFF  34C,350
17862:  MOVFF  34B,34F
17866:  MOVLB  0
17868:  CALL   12984
1786C:  MOVFF  01,34B
17870:  MOVFF  34A,393
17874:  MOVFF  349,392
17878:  MOVFF  348,391
1787C:  MOVFF  347,390
17880:  MOVFF  01,394
17884:  CALL   119A4
17888:  MOVLW  01
1788A:  MOVLB  3
1788C:  ADDWF  x3F,F
1788E:  BTFSC  FD8.0
17890:  INCF   x40,F
17892:  BTFSC  FD8.2
17894:  INCF   x41,F
17896:  BTFSC  FD8.2
17898:  INCF   x42,F
1789A:  BRA    1781E
....................    } 
....................    delay_ms(100); 
1789C:  MOVLW  64
1789E:  MOVWF  x98
178A0:  MOVLB  0
178A2:  CALL   0526
....................    output_high(PIN_C4); 
178A6:  BCF    F94.4
178A8:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
178AA:  MOVFF  33D,343
178AE:  MOVFF  33E,344
178B2:  MOVFF  344,345
178B6:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x21, D1, D2);                                                   //0xE0+16bit sector info 
178BA:  MOVLW  21
178BC:  MOVLB  3
178BE:  MOVWF  x53
178C0:  MOVFF  345,354
178C4:  MOVFF  346,355
178C8:  MOVLB  0
178CA:  CALL   16EE2
....................     
....................    return; 
178CE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SCF2SMF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_SMF(data1,data2,data3,data4);                                  //erase 1 sector SMF 
178D0:  MOVFF  337,347
178D4:  MOVFF  338,348
178D8:  MOVFF  339,349
178DC:  MOVFF  33A,34A
178E0:  CALL   1701E
....................    delay_ms(500); 
178E4:  MOVLW  02
178E6:  MOVLB  3
178E8:  MOVWF  x47
178EA:  MOVLW  FA
178EC:  MOVWF  x98
178EE:  MOVLB  0
178F0:  CALL   0526
178F4:  MOVLB  3
178F6:  DECFSZ x47,F
178F8:  BRA    178EA
....................    fprintf(PC,"transfer SCF2SMF:%x%x%x%x\r\n",data1,data2,data3,data4); 
178FA:  MOVLW  E8
178FC:  MOVWF  FF6
178FE:  MOVLW  09
17900:  MOVWF  FF7
17902:  MOVLW  00
17904:  MOVWF  FF8
17906:  MOVLW  11
17908:  MOVWF  xA2
1790A:  MOVLB  0
1790C:  CALL   0702
17910:  MOVFF  337,3A2
17914:  MOVLW  57
17916:  MOVLB  3
17918:  MOVWF  xA3
1791A:  MOVLB  0
1791C:  CALL   0734
17920:  MOVFF  338,3A2
17924:  MOVLW  57
17926:  MOVLB  3
17928:  MOVWF  xA3
1792A:  MOVLB  0
1792C:  CALL   0734
17930:  MOVFF  339,3A2
17934:  MOVLW  57
17936:  MOVLB  3
17938:  MOVWF  xA3
1793A:  MOVLB  0
1793C:  CALL   0734
17940:  MOVFF  33A,3A2
17944:  MOVLW  57
17946:  MOVLB  3
17948:  MOVWF  xA3
1794A:  MOVLB  0
1794C:  CALL   0734
17950:  MOVLW  0D
17952:  BTFSS  F9E.4
17954:  BRA    17952
17956:  MOVWF  FAD
17958:  MOVLW  0A
1795A:  BTFSS  F9E.4
1795C:  BRA    1795A
1795E:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17960:  MOVFF  337,33E
17964:  MOVFF  338,33D
17968:  MOVFF  339,33C
1796C:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17970:  MOVLB  3
17972:  MOVFF  33B,00
17976:  MOVFF  33C,01
1797A:  CLRF   02
1797C:  CLRF   03
1797E:  MOVF   x3B,W
17980:  SUBWF  x3B,F
17982:  MOVF   x3C,W
17984:  SUBWFB x3C,F
17986:  MOVF   02,W
17988:  SUBWFB x3D,F
1798A:  MOVF   03,W
1798C:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
1798E:  BCF    F94.4
17990:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17992:  BCF    F92.5
17994:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17996:  CLRF   x42
17998:  CLRF   x41
1799A:  CLRF   x40
1799C:  CLRF   x3F
1799E:  MOVF   x42,F
179A0:  BNZ   17A1C
179A2:  MOVF   x41,W
179A4:  SUBLW  00
179A6:  BNC   17A1C
....................    { 
....................       WRITE_DATA_BYTE_SMF(address + i, READ_DATA_BYTE_SCF(address + i)); 
179A8:  MOVF   x3F,W
179AA:  ADDWF  x3B,W
179AC:  MOVWF  x47
179AE:  MOVF   x40,W
179B0:  ADDWFC x3C,W
179B2:  MOVWF  x48
179B4:  MOVF   x41,W
179B6:  ADDWFC x3D,W
179B8:  MOVWF  x49
179BA:  MOVF   x42,W
179BC:  ADDWFC x3E,W
179BE:  MOVWF  x4A
179C0:  MOVF   x3F,W
179C2:  ADDWF  x3B,W
179C4:  MOVWF  x4B
179C6:  MOVF   x40,W
179C8:  ADDWFC x3C,W
179CA:  MOVWF  x4C
179CC:  MOVF   x41,W
179CE:  ADDWFC x3D,W
179D0:  MOVWF  x4D
179D2:  MOVF   x42,W
179D4:  ADDWFC x3E,W
179D6:  MOVWF  x4E
179D8:  MOVWF  x52
179DA:  MOVFF  34D,351
179DE:  MOVFF  34C,350
179E2:  MOVFF  34B,34F
179E6:  MOVLB  0
179E8:  CALL   12984
179EC:  MOVFF  01,34B
179F0:  MOVFF  34A,393
179F4:  MOVFF  349,392
179F8:  MOVFF  348,391
179FC:  MOVFF  347,390
17A00:  MOVFF  01,394
17A04:  CALL   11C04
17A08:  MOVLW  01
17A0A:  MOVLB  3
17A0C:  ADDWF  x3F,F
17A0E:  BTFSC  FD8.0
17A10:  INCF   x40,F
17A12:  BTFSC  FD8.2
17A14:  INCF   x41,F
17A16:  BTFSC  FD8.2
17A18:  INCF   x42,F
17A1A:  BRA    1799E
....................    } 
....................    delay_ms(100); 
17A1C:  MOVLW  64
17A1E:  MOVWF  x98
17A20:  MOVLB  0
17A22:  CALL   0526
....................    output_high(PIN_C4); 
17A26:  BCF    F94.4
17A28:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17A2A:  MOVFF  33D,343
17A2E:  MOVFF  33E,344
17A32:  MOVFF  344,345
17A36:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x23, D1, D2);                                                   //0xE0+16bit sector info 
17A3A:  MOVLW  23
17A3C:  MOVLB  3
17A3E:  MOVWF  x53
17A40:  MOVFF  345,354
17A44:  MOVFF  346,355
17A48:  MOVLB  0
17A4A:  CALL   16EE2
....................     
....................    return; 
17A4E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SMF2OF(int8 data1,int8 data2,int8 data3,int8 data4) 
.................... { 
....................    REFRESH_SECTOR_OF(data1,data2,data3,data4);                                   //erase 1 sector OBC flash 
17A50:  MOVFF  337,347
17A54:  MOVFF  338,348
17A58:  MOVFF  339,349
17A5C:  MOVFF  33A,34A
17A60:  CALL   170D2
....................    delay_ms(500); 
17A64:  MOVLW  02
17A66:  MOVLB  3
17A68:  MOVWF  x47
17A6A:  MOVLW  FA
17A6C:  MOVWF  x98
17A6E:  MOVLB  0
17A70:  CALL   0526
17A74:  MOVLB  3
17A76:  DECFSZ x47,F
17A78:  BRA    17A6A
....................    fprintf(PC,"transfer SMF2OF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17A7A:  MOVLW  04
17A7C:  MOVWF  FF6
17A7E:  MOVLW  0A
17A80:  MOVWF  FF7
17A82:  MOVLW  00
17A84:  MOVWF  FF8
17A86:  MOVLW  10
17A88:  MOVWF  xA2
17A8A:  MOVLB  0
17A8C:  CALL   0702
17A90:  MOVFF  337,3A2
17A94:  MOVLW  57
17A96:  MOVLB  3
17A98:  MOVWF  xA3
17A9A:  MOVLB  0
17A9C:  CALL   0734
17AA0:  MOVFF  338,3A2
17AA4:  MOVLW  57
17AA6:  MOVLB  3
17AA8:  MOVWF  xA3
17AAA:  MOVLB  0
17AAC:  CALL   0734
17AB0:  MOVFF  339,3A2
17AB4:  MOVLW  57
17AB6:  MOVLB  3
17AB8:  MOVWF  xA3
17ABA:  MOVLB  0
17ABC:  CALL   0734
17AC0:  MOVFF  33A,3A2
17AC4:  MOVLW  57
17AC6:  MOVLB  3
17AC8:  MOVWF  xA3
17ACA:  MOVLB  0
17ACC:  CALL   0734
17AD0:  MOVLW  0D
17AD2:  BTFSS  F9E.4
17AD4:  BRA    17AD2
17AD6:  MOVWF  FAD
17AD8:  MOVLW  0A
17ADA:  BTFSS  F9E.4
17ADC:  BRA    17ADA
17ADE:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17AE0:  MOVFF  337,33E
17AE4:  MOVFF  338,33D
17AE8:  MOVFF  339,33C
17AEC:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17AF0:  MOVLB  3
17AF2:  MOVFF  33B,00
17AF6:  MOVFF  33C,01
17AFA:  CLRF   02
17AFC:  CLRF   03
17AFE:  MOVF   x3B,W
17B00:  SUBWF  x3B,F
17B02:  MOVF   x3C,W
17B04:  SUBWFB x3C,F
17B06:  MOVF   02,W
17B08:  SUBWFB x3D,F
17B0A:  MOVF   03,W
17B0C:  SUBWFB x3E,F
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17B0E:  BCF    F92.5
17B10:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17B12:  CLRF   x42
17B14:  CLRF   x41
17B16:  CLRF   x40
17B18:  CLRF   x3F
17B1A:  MOVF   x42,F
17B1C:  BNZ   17B98
17B1E:  MOVF   x41,W
17B20:  SUBLW  00
17B22:  BNC   17B98
....................    { 
....................       WRITE_DATA_BYTE_OF(address + i, READ_DATA_BYTE_SMF(address + i)); 
17B24:  MOVF   x3F,W
17B26:  ADDWF  x3B,W
17B28:  MOVWF  x47
17B2A:  MOVF   x40,W
17B2C:  ADDWFC x3C,W
17B2E:  MOVWF  x48
17B30:  MOVF   x41,W
17B32:  ADDWFC x3D,W
17B34:  MOVWF  x49
17B36:  MOVF   x42,W
17B38:  ADDWFC x3E,W
17B3A:  MOVWF  x4A
17B3C:  MOVF   x3F,W
17B3E:  ADDWF  x3B,W
17B40:  MOVWF  x4B
17B42:  MOVF   x40,W
17B44:  ADDWFC x3C,W
17B46:  MOVWF  x4C
17B48:  MOVF   x41,W
17B4A:  ADDWFC x3D,W
17B4C:  MOVWF  x4D
17B4E:  MOVF   x42,W
17B50:  ADDWFC x3E,W
17B52:  MOVWF  x4E
17B54:  MOVWF  x8C
17B56:  MOVFF  34D,38B
17B5A:  MOVFF  34C,38A
17B5E:  MOVFF  34B,389
17B62:  MOVLB  0
17B64:  CALL   11800
17B68:  MOVFF  01,34B
17B6C:  MOVFF  34A,393
17B70:  MOVFF  349,392
17B74:  MOVFF  348,391
17B78:  MOVFF  347,390
17B7C:  MOVFF  01,394
17B80:  CALL   119A4
17B84:  MOVLW  01
17B86:  MOVLB  3
17B88:  ADDWF  x3F,F
17B8A:  BTFSC  FD8.0
17B8C:  INCF   x40,F
17B8E:  BTFSC  FD8.2
17B90:  INCF   x41,F
17B92:  BTFSC  FD8.2
17B94:  INCF   x42,F
17B96:  BRA    17B1A
....................    } 
....................    delay_ms(100); 
17B98:  MOVLW  64
17B9A:  MOVWF  x98
17B9C:  MOVLB  0
17B9E:  CALL   0526
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17BA2:  MOVFF  33D,343
17BA6:  MOVFF  33E,344
17BAA:  MOVFF  344,345
17BAE:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x31, D1, D2);                                                   //0xE0+16bit sector info 
17BB2:  MOVLW  31
17BB4:  MOVLB  3
17BB6:  MOVWF  x53
17BB8:  MOVFF  345,354
17BBC:  MOVFF  346,355
17BC0:  MOVLB  0
17BC2:  CALL   16EE2
....................     
....................    return; 
17BC6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void TRANSFER_SECTOR_SMF2SCF(int8 data1,int8 data2,int8 data3,int8 data4)        //0x32 
.................... { 
....................    REFRESH_SECTOR_SCF(data1,data2,data3,data4);                                  //erase 1 sector SCF 
17BC8:  MOVFF  337,347
17BCC:  MOVFF  338,348
17BD0:  MOVFF  339,349
17BD4:  MOVFF  33A,34A
17BD8:  CALL   17182
....................    delay_ms(500); 
17BDC:  MOVLW  02
17BDE:  MOVLB  3
17BE0:  MOVWF  x47
17BE2:  MOVLW  FA
17BE4:  MOVWF  x98
17BE6:  MOVLB  0
17BE8:  CALL   0526
17BEC:  MOVLB  3
17BEE:  DECFSZ x47,F
17BF0:  BRA    17BE2
....................    fprintf(PC,"transfer SMF2SCF:%x%x%x%x\r\n",data1,data2,data3,data4); 
17BF2:  MOVLW  20
17BF4:  MOVWF  FF6
17BF6:  MOVLW  0A
17BF8:  MOVWF  FF7
17BFA:  MOVLW  00
17BFC:  MOVWF  FF8
17BFE:  MOVLW  11
17C00:  MOVWF  xA2
17C02:  MOVLB  0
17C04:  CALL   0702
17C08:  MOVFF  337,3A2
17C0C:  MOVLW  57
17C0E:  MOVLB  3
17C10:  MOVWF  xA3
17C12:  MOVLB  0
17C14:  CALL   0734
17C18:  MOVFF  338,3A2
17C1C:  MOVLW  57
17C1E:  MOVLB  3
17C20:  MOVWF  xA3
17C22:  MOVLB  0
17C24:  CALL   0734
17C28:  MOVFF  339,3A2
17C2C:  MOVLW  57
17C2E:  MOVLB  3
17C30:  MOVWF  xA3
17C32:  MOVLB  0
17C34:  CALL   0734
17C38:  MOVFF  33A,3A2
17C3C:  MOVLW  57
17C3E:  MOVLB  3
17C40:  MOVWF  xA3
17C42:  MOVLB  0
17C44:  CALL   0734
17C48:  MOVLW  0D
17C4A:  BTFSS  F9E.4
17C4C:  BRA    17C4A
17C4E:  MOVWF  FAD
17C50:  MOVLW  0A
17C52:  BTFSS  F9E.4
17C54:  BRA    17C52
17C56:  MOVWF  FAD
....................    int32 address = make32(data1,data2,data3,data4); 
17C58:  MOVFF  337,33E
17C5C:  MOVFF  338,33D
17C60:  MOVFF  339,33C
17C64:  MOVFF  33A,33B
....................    address = address - (address%SECT);                                           //si la direccion no es exacta la de un sector, transfiere desde la direccion donde comienza el sector 
17C68:  MOVLB  3
17C6A:  MOVFF  33B,00
17C6E:  MOVFF  33C,01
17C72:  CLRF   02
17C74:  CLRF   03
17C76:  MOVF   x3B,W
17C78:  SUBWF  x3B,F
17C7A:  MOVF   x3C,W
17C7C:  SUBWFB x3C,F
17C7E:  MOVF   02,W
17C80:  SUBWFB x3D,F
17C82:  MOVF   03,W
17C84:  SUBWFB x3E,F
....................    output_low(PIN_C4);                                                           //SCF OBC side 
17C86:  BCF    F94.4
17C88:  BCF    F8B.4
....................    output_low(PIN_A5);                                                           //SMF OBC side 
17C8A:  BCF    F92.5
17C8C:  BCF    F89.5
....................    for(int32 i = 0; i < SECT; i++) 
17C8E:  CLRF   x42
17C90:  CLRF   x41
17C92:  CLRF   x40
17C94:  CLRF   x3F
17C96:  MOVF   x42,F
17C98:  BNZ   17D14
17C9A:  MOVF   x41,W
17C9C:  SUBLW  00
17C9E:  BNC   17D14
....................    { 
....................       WRITE_DATA_BYTE_SCF(address + i, READ_DATA_BYTE_SMF(address + i)); 
17CA0:  MOVF   x3F,W
17CA2:  ADDWF  x3B,W
17CA4:  MOVWF  x47
17CA6:  MOVF   x40,W
17CA8:  ADDWFC x3C,W
17CAA:  MOVWF  x48
17CAC:  MOVF   x41,W
17CAE:  ADDWFC x3D,W
17CB0:  MOVWF  x49
17CB2:  MOVF   x42,W
17CB4:  ADDWFC x3E,W
17CB6:  MOVWF  x4A
17CB8:  MOVF   x3F,W
17CBA:  ADDWF  x3B,W
17CBC:  MOVWF  x4B
17CBE:  MOVF   x40,W
17CC0:  ADDWFC x3C,W
17CC2:  MOVWF  x4C
17CC4:  MOVF   x41,W
17CC6:  ADDWFC x3D,W
17CC8:  MOVWF  x4D
17CCA:  MOVF   x42,W
17CCC:  ADDWFC x3E,W
17CCE:  MOVWF  x4E
17CD0:  MOVWF  x8C
17CD2:  MOVFF  34D,38B
17CD6:  MOVFF  34C,38A
17CDA:  MOVFF  34B,389
17CDE:  MOVLB  0
17CE0:  CALL   11800
17CE4:  MOVFF  01,34B
17CE8:  MOVFF  34A,393
17CEC:  MOVFF  349,392
17CF0:  MOVFF  348,391
17CF4:  MOVFF  347,390
17CF8:  MOVFF  01,394
17CFC:  CALL   11ACE
17D00:  MOVLW  01
17D02:  MOVLB  3
17D04:  ADDWF  x3F,F
17D06:  BTFSC  FD8.0
17D08:  INCF   x40,F
17D0A:  BTFSC  FD8.2
17D0C:  INCF   x41,F
17D0E:  BTFSC  FD8.2
17D10:  INCF   x42,F
17D12:  BRA    17C96
....................    } 
....................    delay_ms(100); 
17D14:  MOVLW  64
17D16:  MOVWF  x98
17D18:  MOVLB  0
17D1A:  CALL   0526
....................    output_high(PIN_C4);                                                          //SCF COM side 
17D1E:  BCF    F94.4
17D20:  BSF    F8B.4
....................     
....................    int16 DATA = address/SECT;                                                    //maximum 2048, data almacena el nro de sector copiado 
....................    int8 D1 = DATA >> 8; 
....................    int8 D2 = DATA; 
17D22:  MOVFF  33D,343
17D26:  MOVFF  33E,344
17D2A:  MOVFF  344,345
17D2E:  MOVFF  343,346
....................     
....................    SAVE_SAT_LOG(0x32, D1, D2);                                                   //0xE0+16bit sector info 
17D32:  MOVLW  32
17D34:  MOVLB  3
17D36:  MOVWF  x53
17D38:  MOVFF  345,354
17D3C:  MOVFF  346,355
17D40:  MOVLB  0
17D42:  CALL   16EE2
....................    return; 
17D46:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<mainpic_function.c> 
.................... #ifndef MAINPIC_FUNCTION_C 
.................... #define MAINPIC_FUNCTION_C 
....................  
.................... /* 
.................... //caution 
.................... //port of kbhit in CAMTurn_OFF_BC Mission is PC-- 
.................... //TRANSFER_DATA_NBYTE_TOPC_SCF(65536,65536); is comment out-- 
.................... //adcs address test make32 function-- 
.................... // 
.................... //reset battery voltage 0x87, over 0x87 is nomal mode 
.................... //reset  
.................... */ 
....................  
.................... #include "mbp.c" 
.................... #ifndef MBP_C 
.................... #define MBP_C 
....................  
.................... #include "MEMORY_OPERATION.c" 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "SATELLITE_LOG.c" 
.................... #ifndef SATELLITE_LOG_C 
.................... #define SATELLITE_LOG_C 
....................  
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {}; 
.................... #ORG 0x00016800 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
....................    {} 
....................    return; 
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
.................... #ORG 0x00016800 
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
....................    { 
....................       reset_bffr[num] = 0; 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
....................    Save_RSV();                                                                   //save in flash memory reserve_table[] content 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
....................    fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
....................    fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
....................    fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
....................    for(int i = 0; i<100; i++) 
....................    { 
....................       fputc(0x27,reset);                                                      //send command for satellite reset 
....................       delay_ms(10); 
....................    } 
....................  
....................    RESET_DATA = 0; 
....................    fprintf(PC,"Ready for reset"); 
....................    delay_ms(1000); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
....................    RESET_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
....................    RESET_DATA = 0; 
....................    for(int m=0; m<10; m++) 
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
....................       delay_ms(10); 
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
....................       if(RESET_bffr[0] == 0x8e) 
....................       { 
....................          break; 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
....................    if(PASSED_DAYS == 0xffff) 
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00016800 
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    }    
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
....................    }else{                                                                        //if nothing stored 
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... #ORG 0x00016800 
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
....................    RESET_DATA = 0; 
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
....................       satellitelog[3] = RESET_bffr[2]; 
....................       satellitelog[4] = RESET_bffr[3]; 
....................       satellitelog[5] = RESET_bffr[4]; 
....................       satellitelog[6] = RESET_bffr[5]; 
....................        
....................       satellitelog[7] = data1; 
....................       satellitelog[8] = data2; 
....................       satellitelog[9] = data3; 
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
....................       SAT_LOG = SAT_LOG + logdata_size; 
....................       fprintf(PC,"LOG saving done\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... int8 MBP_DATA[83] = {}; 
.................... int8 DC_ACK = 0; 
....................  
.................... #ORG 0x00011800 
.................... void Turn_On_MBP() 
.................... { 
....................    output_high(PIN_F5); 
*
12A0C:  BCF    F97.5
12A0E:  BSF    F8E.5
....................    return; 
12A10:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Turn_Off_MBP() 
.................... { 
....................    output_low(PIN_F5); 
*
13A84:  BCF    F97.5
13A86:  BCF    F8E.5
....................    return; 
13A88:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void DELETE_MBP_DATA()                                                           //Clear MBP array to receive data 
.................... { 
....................    for(int8 i = 0; i < 81; i++) 
*
137AE:  MOVLB  3
137B0:  CLRF   x42
137B2:  MOVF   x42,W
137B4:  SUBLW  50
137B6:  BNC   137CC
....................    { 
....................       MBP_DATA[i] = 0; 
137B8:  CLRF   03
137BA:  MOVF   x42,W
137BC:  ADDLW  42
137BE:  MOVWF  FE9
137C0:  MOVLW  01
137C2:  ADDWFC 03,W
137C4:  MOVWF  FEA
137C6:  CLRF   FEF
137C8:  INCF   x42,F
137CA:  BRA    137B2
....................    } 
....................    return; 
137CC:  MOVLB  0
137CE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CHECK_ACK_FROM_DC_10k()                                                     //Wait ACK from DC for 10s 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
132DE:  MOVLB  3
132E0:  CLRF   x52
132E2:  CLRF   x51
132E4:  CLRF   x50
132E6:  CLRF   x4F
132E8:  MOVF   x52,F
132EA:  BNZ   13326
132EC:  MOVF   x51,W
132EE:  SUBLW  0F
132F0:  BNC   13326
132F2:  BNZ   13302
132F4:  MOVF   x50,W
132F6:  SUBLW  42
132F8:  BNC   13326
132FA:  BNZ   13302
132FC:  MOVF   x4F,W
132FE:  SUBLW  3F
13300:  BNC   13326
....................    { 
....................       if(kbhit(DC))                                                              //kbhit(PC) 
13302:  BTFSC  F86.1
13304:  BRA    13314
....................       { 
....................          DC_ACK = fgetc(DC);                                                     //PC    
13306:  MOVLB  0
13308:  CALL   1A5C
1330C:  MOVFF  01,195
....................          break; 
13310:  MOVLB  3
13312:  BRA    13326
....................       }                                                                          //delay_ms(1); 
13314:  MOVLW  01
13316:  ADDWF  x4F,F
13318:  BTFSC  FD8.0
1331A:  INCF   x50,F
1331C:  BTFSC  FD8.2
1331E:  INCF   x51,F
13320:  BTFSC  FD8.2
13322:  INCF   x52,F
13324:  BRA    132E8
....................    } 
....................    return; 
13326:  MOVLB  0
13328:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void GET_MBP_DATA(int16 transf_size) 
*
137D0:  MOVLB  3
137D2:  CLRF   x45
137D4:  CLRF   x44
137D6:  CLRF   x46
.................... { 
....................    int16 n = 0; 
....................    int8 input = 0; 
....................    for(int32 i = 0; i < 99000000; i++)                                            //1000000 
137D8:  CLRF   x4A
137DA:  CLRF   x49
137DC:  CLRF   x48
137DE:  CLRF   x47
137E0:  MOVF   x4A,W
137E2:  SUBLW  05
137E4:  BNC   13888
137E6:  BNZ   137FE
137E8:  MOVF   x49,W
137EA:  SUBLW  E6
137EC:  BNC   13888
137EE:  BNZ   137FE
137F0:  MOVF   x48,W
137F2:  SUBLW  9E
137F4:  BNC   13888
137F6:  BNZ   137FE
137F8:  MOVF   x47,W
137FA:  SUBLW  BF
137FC:  BNC   13888
....................    {                                                                              //99000000 es tiempo suficiente para transferir un sector 
....................       if(kbhit(DC)) 
137FE:  BTFSC  F86.1
13800:  BRA    13876
....................       { 
....................          input = fgetc(DC);                                                      //get data from MBP 
13802:  MOVLB  0
13804:  CALL   1A5C
13808:  MOVFF  01,346
....................          WRITE_DATA_BYTE_OF(DC_STATUS_ADDRESS,input);                            //Save data on OF, SCF, SMF 
1380C:  MOVFF  5B,393
13810:  MOVFF  5A,392
13814:  MOVFF  59,391
13818:  MOVFF  58,390
1381C:  MOVFF  346,394
13820:  CALL   119A4
....................          WRITE_DATA_BYTE_SCF(DC_STATUS_ADDRESS,input); 
13824:  MOVFF  5B,393
13828:  MOVFF  5A,392
1382C:  MOVFF  59,391
13830:  MOVFF  58,390
13834:  MOVFF  346,394
13838:  CALL   11ACE
....................          WRITE_DATA_BYTE_SMF(DC_STATUS_ADDRESS,input); 
1383C:  MOVFF  5B,393
13840:  MOVFF  5A,392
13844:  MOVFF  59,391
13848:  MOVFF  58,390
1384C:  MOVFF  346,394
13850:  CALL   11C04
....................          n++; 
13854:  MOVLB  3
13856:  INCF   x44,F
13858:  BTFSC  FD8.2
1385A:  INCF   x45,F
....................          DC_STATUS_ADDRESS = DC_STATUS_ADDRESS + 1; 
1385C:  MOVLW  01
1385E:  ADDWF  58,F
13860:  MOVLW  00
13862:  ADDWFC 59,F
13864:  ADDWFC 5A,F
13866:  ADDWFC 5B,F
....................          if(n==transf_size)                                                      //sale del for cuando se completa la cantidad de bytes 
13868:  MOVF   x42,W
1386A:  SUBWF  x44,W
1386C:  BNZ   13876
1386E:  MOVF   x43,W
13870:  SUBWF  x45,W
13872:  BNZ   13876
....................          { 
....................          break; 
13874:  BRA    13888
....................          } 
....................       } 
13876:  MOVLW  01
13878:  ADDWF  x47,F
1387A:  BTFSC  FD8.0
1387C:  INCF   x48,F
1387E:  BTFSC  FD8.2
13880:  INCF   x49,F
13882:  BTFSC  FD8.2
13884:  INCF   x4A,F
13886:  BRA    137E0
....................    } 
....................  
....................    DC_STATUS_ADDRESS=0x06660000; 
13888:  MOVLW  06
1388A:  MOVWF  5B
1388C:  MOVLW  66
1388E:  MOVWF  5A
13890:  CLRF   59
13892:  CLRF   58
....................    
....................    fprintf(PC,"Transferred %ld Bytes",n); 
13894:  MOVLW  3C
13896:  MOVWF  FF6
13898:  MOVLW  0A
1389A:  MOVWF  FF7
1389C:  MOVLW  00
1389E:  MOVWF  FF8
138A0:  MOVLW  0C
138A2:  MOVWF  xA2
138A4:  MOVLB  0
138A6:  CALL   0702
138AA:  MOVLW  10
138AC:  MOVWF  FE9
138AE:  MOVFF  345,34C
138B2:  MOVFF  344,34B
138B6:  GOTO   25C0
138BA:  MOVLW  4B
138BC:  MOVWF  FF6
138BE:  MOVLW  0A
138C0:  MOVWF  FF7
138C2:  MOVLW  00
138C4:  MOVWF  FF8
138C6:  MOVLW  06
138C8:  MOVLB  3
138CA:  MOVWF  xA2
138CC:  MOVLB  0
138CE:  CALL   0702
....................    n=0; 
138D2:  MOVLB  3
138D4:  CLRF   x45
138D6:  CLRF   x44
....................    output_high(PIN_C4);                                                          //COM_MUX COM side 
138D8:  BCF    F94.4
138DA:  BSF    F8B.4
....................    return; 
138DC:  MOVLB  0
138DE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void DATACOLLECTION_TEST_OPERATION(int8 cmd1,int8 cmd2,int8 cmd3,int8 cmd4,int8 cmd5,int8 cmd6,int8 cmd7) 
.................... { 
....................    DELETE_MBP_DATA();                                                            //Clear MBP array to receive data 
138E0:  RCALL  137AE
....................    // LOOP_DC_STATUS_ADDRESS();                                                   //realiza un loop verificando si se esta por alcanzar el limite de espacio asignado 
....................    REFRESH_SECTOR_OF(0x06,0x66,0x00,0x00);                                       //clear 1 sector OBC flash DC part 
138E2:  MOVLW  06
138E4:  MOVLB  3
138E6:  MOVWF  x47
138E8:  MOVLW  66
138EA:  MOVWF  x48
138EC:  CLRF   x49
138EE:  CLRF   x4A
138F0:  MOVLB  0
138F2:  CALL   170D2
....................    REFRESH_SECTOR_SCF(0x06,0x66,0x00,0x00);                                      //clear 1 sector COM flash DC part  
138F6:  MOVLW  06
138F8:  MOVLB  3
138FA:  MOVWF  x47
138FC:  MOVLW  66
138FE:  MOVWF  x48
13900:  CLRF   x49
13902:  CLRF   x4A
13904:  MOVLB  0
13906:  CALL   17182
....................    REFRESH_SECTOR_SMF(0x06,0x66,0x00,0x00);                                      //clear 1 sector MISSION flash DC part 
1390A:  MOVLW  06
1390C:  MOVLB  3
1390E:  MOVWF  x47
13910:  MOVLW  66
13912:  MOVWF  x48
13914:  CLRF   x49
13916:  CLRF   x4A
13918:  MOVLB  0
1391A:  CALL   1701E
....................     
....................    int16 data_pckts = make16(cmd6,cmd7); 
....................    int16 data_size = data_pckts*81; 
1391E:  MOVFF  33C,33F
13922:  MOVFF  33D,33E
13926:  MOVFF  33F,343
1392A:  MOVFF  33E,342
1392E:  MOVLB  3
13930:  CLRF   x45
13932:  MOVLW  51
13934:  MOVWF  x44
13936:  MOVLB  0
13938:  CALL   253A
1393C:  MOVFF  02,341
13940:  MOVFF  01,340
....................     
....................    fprintf(PC,"sending commands to MBP\r\n"); 
13944:  MOVLW  52
13946:  MOVWF  FF6
13948:  MOVLW  0A
1394A:  MOVWF  FF7
1394C:  MOVLW  00
1394E:  MOVWF  FF8
13950:  CALL   058C
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
13954:  CALL   12A0C
....................    delay_ms(30); 
13958:  MOVLW  1E
1395A:  MOVLB  3
1395C:  MOVWF  x98
1395E:  MOVLB  0
13960:  CALL   0526
....................  
....................    fputc(cmd1,DC); 
13964:  MOVFF  337,34F
13968:  CALL   1A16
....................    delay_ms(100); 
1396C:  MOVLW  64
1396E:  MOVLB  3
13970:  MOVWF  x98
13972:  MOVLB  0
13974:  CALL   0526
....................    fputc(cmd2,DC); 
13978:  MOVFF  338,34F
1397C:  CALL   1A16
....................    delay_ms(100); 
13980:  MOVLW  64
13982:  MOVLB  3
13984:  MOVWF  x98
13986:  MOVLB  0
13988:  CALL   0526
....................    fputc(cmd3,DC); 
1398C:  MOVFF  339,34F
13990:  CALL   1A16
....................    delay_ms(100); 
13994:  MOVLW  64
13996:  MOVLB  3
13998:  MOVWF  x98
1399A:  MOVLB  0
1399C:  CALL   0526
....................    fputc(cmd4,DC); 
139A0:  MOVFF  33A,34F
139A4:  CALL   1A16
....................    delay_ms(100); 
139A8:  MOVLW  64
139AA:  MOVLB  3
139AC:  MOVWF  x98
139AE:  MOVLB  0
139B0:  CALL   0526
....................    fputc(cmd5,DC); 
139B4:  MOVFF  33B,34F
139B8:  CALL   1A16
....................    delay_ms(100); 
139BC:  MOVLW  64
139BE:  MOVLB  3
139C0:  MOVWF  x98
139C2:  MOVLB  0
139C4:  CALL   0526
....................    fputc(cmd6,DC); 
139C8:  MOVFF  33C,34F
139CC:  CALL   1A16
....................    delay_ms(100); 
139D0:  MOVLW  64
139D2:  MOVLB  3
139D4:  MOVWF  x98
139D6:  MOVLB  0
139D8:  CALL   0526
....................    fputc(cmd7,DC); 
139DC:  MOVFF  33D,34F
139E0:  CALL   1A16
....................  
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from MBP for 10s 
139E4:  RCALL  132DE
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
139E6:  MOVLB  1
139E8:  MOVF   x95,W
139EA:  SUBLW  20
139EC:  BNZ   13A6A
....................    { 
....................       fprintf(PC,"Received ACK From MBP\r\n"); 
139EE:  MOVLW  6C
139F0:  MOVWF  FF6
139F2:  MOVLW  0A
139F4:  MOVWF  FF7
139F6:  MOVLW  00
139F8:  MOVWF  FF8
139FA:  MOVLB  0
139FC:  CALL   058C
....................       //delay_ms(1000); 
....................       DC_ACK = 0; 
13A00:  MOVLB  1
13A02:  CLRF   x95
....................       output_low(PIN_C4);                                                        //SCF main side 
13A04:  BCF    F94.4
13A06:  BCF    F8B.4
....................       output_low(PIN_A5);                                                        //SMF main side 
13A08:  BCF    F92.5
13A0A:  BCF    F89.5
....................       fprintf(PC,"TRANSFERRING %lx PACKETS\r\n",data_pckts); 
13A0C:  MOVLW  84
13A0E:  MOVWF  FF6
13A10:  MOVLW  0A
13A12:  MOVWF  FF7
13A14:  MOVLW  00
13A16:  MOVWF  FF8
13A18:  MOVLW  0D
13A1A:  MOVLB  3
13A1C:  MOVWF  xA2
13A1E:  MOVLB  0
13A20:  CALL   0702
13A24:  MOVFF  33F,3A2
13A28:  MOVLW  57
13A2A:  MOVLB  3
13A2C:  MOVWF  xA3
13A2E:  MOVLB  0
13A30:  CALL   0734
13A34:  MOVFF  33E,3A2
13A38:  MOVLW  57
13A3A:  MOVLB  3
13A3C:  MOVWF  xA3
13A3E:  MOVLB  0
13A40:  CALL   0734
13A44:  MOVLW  94
13A46:  MOVWF  FF6
13A48:  MOVLW  0A
13A4A:  MOVWF  FF7
13A4C:  MOVLW  00
13A4E:  MOVWF  FF8
13A50:  MOVLW  0A
13A52:  MOVLB  3
13A54:  MOVWF  xA2
13A56:  MOVLB  0
13A58:  CALL   0702
....................        
....................       GET_MBP_DATA(data_size); 
13A5C:  MOVFF  341,343
13A60:  MOVFF  340,342
13A64:  RCALL  137D0
....................  
....................    }else{ 
13A66:  BRA    13A7E
13A68:  MOVLB  1
....................       DC_ACK = 0; 
13A6A:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
13A6C:  MOVLW  A0
13A6E:  MOVWF  FF6
13A70:  MOVLW  0A
13A72:  MOVWF  FF7
13A74:  MOVLW  00
13A76:  MOVWF  FF8
13A78:  MOVLB  0
13A7A:  CALL   058C
....................    } 
....................  
....................    output_high(PIN_C4);                                                          //COM_MUX COM side 
13A7E:  BCF    F94.4
13A80:  BSF    F8B.4
....................     
....................    return; 
13A82:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void MISSION_TEST_OPERATION(int8 cmd1,int8 cmd2,int8 cmd3,int8 cmd4,int8 cmd5,int8 cmd6,int8 cmd7)                                                    //send array of commnands to MBP 
.................... { 
....................    fprintf(PC,"sending commands to MBP\r\n"); 
*
13A8A:  MOVLW  C0
13A8C:  MOVWF  FF6
13A8E:  MOVLW  0A
13A90:  MOVWF  FF7
13A92:  MOVLW  00
13A94:  MOVWF  FF8
13A96:  CALL   058C
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
13A9A:  CALL   12A0C
....................    delay_ms(30); 
13A9E:  MOVLW  1E
13AA0:  MOVLB  3
13AA2:  MOVWF  x98
13AA4:  MOVLB  0
13AA6:  CALL   0526
....................  
....................       fputc(cmd1,DC); 
13AAA:  MOVFF  337,34F
13AAE:  CALL   1A16
....................       delay_ms(100); 
13AB2:  MOVLW  64
13AB4:  MOVLB  3
13AB6:  MOVWF  x98
13AB8:  MOVLB  0
13ABA:  CALL   0526
....................       fputc(cmd2,DC); 
13ABE:  MOVFF  338,34F
13AC2:  CALL   1A16
....................       delay_ms(100); 
13AC6:  MOVLW  64
13AC8:  MOVLB  3
13ACA:  MOVWF  x98
13ACC:  MOVLB  0
13ACE:  CALL   0526
....................       fputc(cmd3,DC); 
13AD2:  MOVFF  339,34F
13AD6:  CALL   1A16
....................       delay_ms(100); 
13ADA:  MOVLW  64
13ADC:  MOVLB  3
13ADE:  MOVWF  x98
13AE0:  MOVLB  0
13AE2:  CALL   0526
....................       fputc(cmd4,DC); 
13AE6:  MOVFF  33A,34F
13AEA:  CALL   1A16
....................       delay_ms(100); 
13AEE:  MOVLW  64
13AF0:  MOVLB  3
13AF2:  MOVWF  x98
13AF4:  MOVLB  0
13AF6:  CALL   0526
....................       fputc(cmd5,DC); 
13AFA:  MOVFF  33B,34F
13AFE:  CALL   1A16
....................       delay_ms(100); 
13B02:  MOVLW  64
13B04:  MOVLB  3
13B06:  MOVWF  x98
13B08:  MOVLB  0
13B0A:  CALL   0526
....................       fputc(cmd6,DC); 
13B0E:  MOVFF  33C,34F
13B12:  CALL   1A16
....................       delay_ms(100); 
13B16:  MOVLW  64
13B18:  MOVLB  3
13B1A:  MOVWF  x98
13B1C:  MOVLB  0
13B1E:  CALL   0526
....................       fputc(cmd7,DC); 
13B22:  MOVFF  33D,34F
13B26:  CALL   1A16
....................  
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from DC for 10s 
13B2A:  CALL   132DE
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
13B2E:  MOVLB  1
13B30:  MOVF   x95,W
13B32:  SUBLW  20
13B34:  BNZ   13B4E
....................    { 
....................       fprintf(PC,"Received ACK From MBP\r\n"); 
13B36:  MOVLW  DA
13B38:  MOVWF  FF6
13B3A:  MOVLW  0A
13B3C:  MOVWF  FF7
13B3E:  MOVLW  00
13B40:  MOVWF  FF8
13B42:  MOVLB  0
13B44:  CALL   058C
....................       DC_ACK = 0; 
13B48:  MOVLB  1
13B4A:  CLRF   x95
....................        
....................    } 
13B4C:  BRA    13C2A
....................    else 
....................    { 
....................       DC_ACK = 0; 
13B4E:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
13B50:  MOVLW  F2
13B52:  MOVWF  FF6
13B54:  MOVLW  0A
13B56:  MOVWF  FF7
13B58:  MOVLW  00
13B5A:  MOVWF  FF8
13B5C:  MOVLB  0
13B5E:  CALL   058C
....................       fprintf(PC,"PWR cycle and sending commands again\r\n"); 
13B62:  MOVLW  12
13B64:  MOVWF  FF6
13B66:  MOVLW  0B
13B68:  MOVWF  FF7
13B6A:  MOVLW  00
13B6C:  MOVWF  FF8
13B6E:  CALL   058C
....................       Turn_Off_MBP(); 
13B72:  RCALL  13A84
....................       delay_ms(1000); 
13B74:  MOVLW  04
13B76:  MOVLB  3
13B78:  MOVWF  x3E
13B7A:  MOVLW  FA
13B7C:  MOVWF  x98
13B7E:  MOVLB  0
13B80:  CALL   0526
13B84:  MOVLB  3
13B86:  DECFSZ x3E,F
13B88:  BRA    13B7A
....................       Turn_On_MBP();                                                              //RF5=HIGH 
13B8A:  MOVLB  0
13B8C:  CALL   12A0C
....................       delay_ms(1000); 
13B90:  MOVLW  04
13B92:  MOVLB  3
13B94:  MOVWF  x3E
13B96:  MOVLW  FA
13B98:  MOVWF  x98
13B9A:  MOVLB  0
13B9C:  CALL   0526
13BA0:  MOVLB  3
13BA2:  DECFSZ x3E,F
13BA4:  BRA    13B96
....................  
....................       fputc(cmd1,DC); 
13BA6:  MOVFF  337,34F
13BAA:  MOVLB  0
13BAC:  CALL   1A16
....................       delay_ms(100); 
13BB0:  MOVLW  64
13BB2:  MOVLB  3
13BB4:  MOVWF  x98
13BB6:  MOVLB  0
13BB8:  CALL   0526
....................       fputc(cmd2,DC); 
13BBC:  MOVFF  338,34F
13BC0:  CALL   1A16
....................       delay_ms(100); 
13BC4:  MOVLW  64
13BC6:  MOVLB  3
13BC8:  MOVWF  x98
13BCA:  MOVLB  0
13BCC:  CALL   0526
....................       fputc(cmd3,DC); 
13BD0:  MOVFF  339,34F
13BD4:  CALL   1A16
....................       delay_ms(100); 
13BD8:  MOVLW  64
13BDA:  MOVLB  3
13BDC:  MOVWF  x98
13BDE:  MOVLB  0
13BE0:  CALL   0526
....................       fputc(cmd4,DC); 
13BE4:  MOVFF  33A,34F
13BE8:  CALL   1A16
....................       delay_ms(100); 
13BEC:  MOVLW  64
13BEE:  MOVLB  3
13BF0:  MOVWF  x98
13BF2:  MOVLB  0
13BF4:  CALL   0526
....................       fputc(cmd5,DC); 
13BF8:  MOVFF  33B,34F
13BFC:  CALL   1A16
....................       delay_ms(100); 
13C00:  MOVLW  64
13C02:  MOVLB  3
13C04:  MOVWF  x98
13C06:  MOVLB  0
13C08:  CALL   0526
....................       fputc(cmd6,DC); 
13C0C:  MOVFF  33C,34F
13C10:  CALL   1A16
....................       delay_ms(100); 
13C14:  MOVLW  64
13C16:  MOVLB  3
13C18:  MOVWF  x98
13C1A:  MOVLB  0
13C1C:  CALL   0526
....................       fputc(cmd7,DC);    
13C20:  MOVFF  33D,34F
13C24:  CALL   1A16
13C28:  MOVLB  1
....................    } 
....................    return; 
13C2A:  MOVLB  0
13C2C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void MBP_SYNC() 
.................... { 
....................    fprintf(PC,"\r\nsending SYNC time to MBP\r\n"); 
*
1332A:  MOVLW  3A
1332C:  MOVWF  FF6
1332E:  MOVLW  0B
13330:  MOVWF  FF7
13332:  MOVLW  00
13334:  MOVWF  FF8
13336:  CALL   058C
....................    Turn_On_MBP();                                                                 //RF5=HIGH 
1333A:  CALL   12A0C
....................    delay_ms(30); 
1333E:  MOVLW  1E
13340:  MOVLB  3
13342:  MOVWF  x98
13344:  MOVLB  0
13346:  CALL   0526
....................    COLLECT_RESET_DATA(); 
1334A:  CALL   16AD6
....................       if(RESET_bffr[0] == 0x8e) 
1334E:  MOVF   x9E,W
13350:  SUBLW  8E
13352:  BNZ   13366
....................    { 
....................       fprintf(PC,"Time received from RESET\r\n"); 
13354:  MOVLW  58
13356:  MOVWF  FF6
13358:  MOVLW  0B
1335A:  MOVWF  FF7
1335C:  MOVLW  00
1335E:  MOVWF  FF8
13360:  CALL   058C
....................  
....................    } 
13364:  BRA    13376
....................    else 
....................    { 
....................       fprintf(PC,"NO RESET time\r\n"); 
13366:  MOVLW  74
13368:  MOVWF  FF6
1336A:  MOVLW  0B
1336C:  MOVWF  FF7
1336E:  MOVLW  00
13370:  MOVWF  FF8
13372:  CALL   058C
....................    } 
....................        
....................       fputc(0XAA,DC); 
13376:  MOVLW  AA
13378:  MOVLB  3
1337A:  MOVWF  x4F
1337C:  MOVLB  0
1337E:  CALL   1A16
....................       delay_ms(100); 
13382:  MOVLW  64
13384:  MOVLB  3
13386:  MOVWF  x98
13388:  MOVLB  0
1338A:  CALL   0526
....................       fputc(reset_bffr[1],DC);                                                       //sec 
1338E:  MOVFF  9F,34F
13392:  CALL   1A16
....................       delay_ms(100); 
13396:  MOVLW  64
13398:  MOVLB  3
1339A:  MOVWF  x98
1339C:  MOVLB  0
1339E:  CALL   0526
....................       fputc(reset_bffr[2],DC);                                                       //minutes 
133A2:  MOVFF  A0,34F
133A6:  CALL   1A16
....................       delay_ms(100); 
133AA:  MOVLW  64
133AC:  MOVLB  3
133AE:  MOVWF  x98
133B0:  MOVLB  0
133B2:  CALL   0526
....................       fputc(reset_bffr[3],DC);                                                       //hours 
133B6:  MOVFF  A1,34F
133BA:  CALL   1A16
....................       delay_ms(100); 
133BE:  MOVLW  64
133C0:  MOVLB  3
133C2:  MOVWF  x98
133C4:  MOVLB  0
133C6:  CALL   0526
....................       fputc(reset_bffr[4],DC);                                                       //day_H 
133CA:  MOVFF  A2,34F
133CE:  CALL   1A16
....................       delay_ms(100); 
133D2:  MOVLW  64
133D4:  MOVLB  3
133D6:  MOVWF  x98
133D8:  MOVLB  0
133DA:  CALL   0526
....................       fputc(reset_bffr[5],DC);                                                       //day_L 
133DE:  MOVFF  A3,34F
133E2:  CALL   1A16
....................       delay_ms(100); 
133E6:  MOVLW  64
133E8:  MOVLB  3
133EA:  MOVWF  x98
133EC:  MOVLB  0
133EE:  CALL   0526
....................       fputc(0XBB,DC); 
133F2:  MOVLW  BB
133F4:  MOVLB  3
133F6:  MOVWF  x4F
133F8:  MOVLB  0
133FA:  CALL   1A16
....................    fprintf(PC,"%x:%x:%x,%x%x\r\n",reset_bffr[1], reset_bffr[2], reset_bffr[3], reset_bffr[4], reset_bffr[5]); 
133FE:  MOVFF  9F,3A2
13402:  MOVLW  57
13404:  MOVLB  3
13406:  MOVWF  xA3
13408:  MOVLB  0
1340A:  CALL   0734
1340E:  MOVLW  3A
13410:  BTFSS  F9E.4
13412:  BRA    13410
13414:  MOVWF  FAD
13416:  MOVFF  A0,3A2
1341A:  MOVLW  57
1341C:  MOVLB  3
1341E:  MOVWF  xA3
13420:  MOVLB  0
13422:  CALL   0734
13426:  MOVLW  3A
13428:  BTFSS  F9E.4
1342A:  BRA    13428
1342C:  MOVWF  FAD
1342E:  MOVFF  A1,3A2
13432:  MOVLW  57
13434:  MOVLB  3
13436:  MOVWF  xA3
13438:  MOVLB  0
1343A:  CALL   0734
1343E:  MOVLW  2C
13440:  BTFSS  F9E.4
13442:  BRA    13440
13444:  MOVWF  FAD
13446:  MOVFF  A2,3A2
1344A:  MOVLW  57
1344C:  MOVLB  3
1344E:  MOVWF  xA3
13450:  MOVLB  0
13452:  CALL   0734
13456:  MOVFF  A3,3A2
1345A:  MOVLW  57
1345C:  MOVLB  3
1345E:  MOVWF  xA3
13460:  MOVLB  0
13462:  CALL   0734
13466:  MOVLW  0D
13468:  BTFSS  F9E.4
1346A:  BRA    13468
1346C:  MOVWF  FAD
1346E:  MOVLW  0A
13470:  BTFSS  F9E.4
13472:  BRA    13470
13474:  MOVWF  FAD
....................    CHECK_ACK_FROM_DC_10k();                                                      //Wait ACK from DC for 10s 
13476:  RCALL  132DE
....................    if(DC_ACK == 0x20)                                                            //Success ACK 
13478:  MOVLB  1
1347A:  MOVF   x95,W
1347C:  SUBLW  20
1347E:  BNZ   13498
....................    { 
....................       fprintf(PC,"Time Received for MBP\r\n"); 
13480:  MOVLW  84
13482:  MOVWF  FF6
13484:  MOVLW  0B
13486:  MOVWF  FF7
13488:  MOVLW  00
1348A:  MOVWF  FF8
1348C:  MOVLB  0
1348E:  CALL   058C
....................       DC_ACK = 0; 
13492:  MOVLB  1
13494:  CLRF   x95
....................        
....................    } 
13496:  BRA    134AE
....................    else 
....................    { 
....................       DC_ACK = 0; 
13498:  CLRF   x95
....................       fprintf(PC,"FAILURED GETTING ACK From MBP\r\n"); 
1349A:  MOVLW  9C
1349C:  MOVWF  FF6
1349E:  MOVLW  0B
134A0:  MOVWF  FF7
134A2:  MOVLW  00
134A4:  MOVWF  FF8
134A6:  MOVLB  0
134A8:  CALL   058C
134AC:  MOVLB  1
....................    } 
....................    return; 
134AE:  MOVLB  0
134B0:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include "adcs_test.c" 
.................... #ifndef ADCS_TEST_C 
.................... #define ADCS_TEST_C 
....................  
.................... #include "adcs.c" 
.................... #ifndef ADCS_C 
.................... #define ADCS_C 
....................  
.................... #include "adcs.h" 
.................... #ifndef ADCS_H 
.................... #define ADCS_H 
....................  
.................... #define ADCS_SENSOR_SIZE 78                                                      //for testing additional 6byte for checking duty 
.................... #define TLE_size 77                                                              //TLE FORMAT ARRAY SIZE 
....................  
.................... unsigned int8 TLE[TLE_size] = {0xAA,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, //TLE data array 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00, 
....................                                0X00,0X00,0X00,0X00,0X00,0X00,0xBB}; 
....................                                   
.................... unsigned int8 ACK_for_COM[24] = {0xAA,0,0,0,0,0,0,0,0,0, 
....................                                  0,0,0,0,0,0,0,0,0,0, 
....................                                  0,0,0,0xBB}; 
....................                                   
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... static int16 currenttime = 0; 
....................  
.................... #endif 
....................  
.................... #include "MEMORY_OPERATION.c" 
.................... #ifndef MEMORY_OPERATION_C 
.................... #define MEMORY_OPERATION_C 
....................  
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... #ORG 0x00011800 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
....................  
....................  
....................  
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDERSS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
....................    //total programming memory size is 128KB 
....................    //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00014000 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM 
.................... {                                                                                //si no lo encuentra usa el valor inicial 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000                                                                       
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {  
....................    //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... #ORG 0x00014000 
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... #ORG 0x00014000 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
....................  
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... #ORG 0x00014000 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
.................... #ORG 0x00014000 
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00014000 
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "cw.c" 
.................... #ifndef CW_C 
.................... #define CW_C 
....................  
.................... #include "fab.h" 
.................... #ifndef FAB_h 
.................... #define FAB_h 
....................  
.................... #define HK_size 124                                                              //HK FORMAT ARRAY SIZE 
.................... #define CW_size 5                                                                //CW FORMAT ARRAY SIZE 
.................... #define HIGH_SAMP_HK_size 124                                                    //High Sampling HK FORMAT ARRAY SIZE 
.................... #define FAB_SENSOR_size 45                                                       //HK FAB Part 
.................... #define buffer_from_FAB  (in_bffr_main[0]==0x33) 
....................  
.................... static unsigned int8 CW_FORMAT[CW_size] = {}; 
.................... unsigned int8 in_HK[FAB_SENSOR_size] = {}; 
.................... unsigned int8 HKDATA[HK_size] ={}; 
.................... BYTE FAB_DATA = 0; 
.................... static int8 FAB_MEASUERING_FLAG= 0; 
.................... static int8 HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
.................... int32 FAB_FLAG = 0; 
.................... int8 CHECK_FAB_RESPONSE = 0; 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x0001E000 
.................... void REFLESH_CW_ACK_for_COM()                                                    //carga con 0x00 el array ACK_for_COM[7] 
.................... { 
....................    for(int i = 1; i < 7; i++) 
*
1E000:  MOVLW  01
1E002:  MOVLB  3
1E004:  MOVWF  x4F
1E006:  MOVF   x4F,W
1E008:  SUBLW  06
1E00A:  BNC   1E020
....................    { 
....................       ACK_for_COM[i] = 0x00; 
1E00C:  CLRF   03
1E00E:  MOVF   x4F,W
1E010:  ADDLW  E3
1E012:  MOVWF  FE9
1E014:  MOVLW  01
1E016:  ADDWFC 03,W
1E018:  MOVWF  FEA
1E01A:  CLRF   FEF
1E01C:  INCF   x4F,F
1E01E:  BRA    1E006
....................    } 
....................    return; 
1E020:  MOVLB  0
1E022:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void CW_RESPOND()                                                                //carga el array ACK_for_COM[] con el dato del array CW_FORMAT[] y envia a COM PIC 
.................... { 
....................    REFLESH_CW_ACK_for_COM();                                                     //carga con 0x00 el array ACK_for_COM[] desde la pos 1 a la 6 
1E024:  RCALL  1E000
....................    delay_ms(100); 
1E026:  MOVLW  64
1E028:  MOVLB  3
1E02A:  MOVWF  x98
1E02C:  MOVLB  0
1E02E:  CALL   0526
....................    ACK_for_COM[0] = 0xAA; 
1E032:  MOVLW  AA
1E034:  MOVLB  1
1E036:  MOVWF  xE3
....................    ACK_for_COM[1] = 0x50; 
1E038:  MOVLW  50
1E03A:  MOVWF  xE4
....................    ACK_for_COM[2] = CW_FORMAT[0]; 
1E03C:  MOVFF  24B,1E5
....................    ACK_for_COM[3] = CW_FORMAT[1]; 
1E040:  MOVFF  24C,1E6
....................    ACK_for_COM[4] = CW_FORMAT[2]; 
1E044:  MOVFF  24D,1E7
....................    ACK_for_COM[5] = CW_FORMAT[3]; 
1E048:  MOVFF  24E,1E8
....................    ACK_for_COM[6] = CW_FORMAT[4]; 
1E04C:  MOVFF  24F,1E9
....................    ACK_for_COM[23] = 0xBB; 
1E050:  MOVLW  BB
1E052:  MOVWF  xFA
....................    for(int a = 0; a < 24; a++)                                                   //send the latest CW data to COM PIC 
1E054:  MOVLB  3
1E056:  CLRF   x4D
1E058:  MOVF   x4D,W
1E05A:  SUBLW  17
1E05C:  BNC   1E07E
....................    { 
....................       fputc(ACK_for_COM[a],COM); 
1E05E:  CLRF   03
1E060:  MOVF   x4D,W
1E062:  ADDLW  E3
1E064:  MOVWF  FE9
1E066:  MOVLW  01
1E068:  ADDWFC 03,W
1E06A:  MOVWF  FEA
1E06C:  MOVFF  FEF,34F
1E070:  MOVF   x4F,W
1E072:  MOVLB  0
1E074:  CALL   1A0A
1E078:  MOVLB  3
1E07A:  INCF   x4D,F
1E07C:  BRA    1E058
....................    } 
....................    MBP_SYNC();                                                                   //Send time data to MBP for syncronization 
1E07E:  MOVLB  0
1E080:  CALL   1332A
....................    fprintf(PC,"\r\nCW ANS:"); 
1E084:  MOVLW  BC
1E086:  MOVWF  FF6
1E088:  MOVLW  0B
1E08A:  MOVWF  FF7
1E08C:  MOVLW  00
1E08E:  MOVWF  FF8
1E090:  CALL   058C
....................    for(a = 0; a < 23; a++)                                                       //send the latest CW data to PC 
1E094:  MOVLB  3
1E096:  CLRF   x4D
1E098:  MOVF   x4D,W
1E09A:  SUBLW  16
1E09C:  BNC   1E0C8
....................    { 
....................       fprintf(PC,"%x,",ACK_for_COM[a]); 
1E09E:  CLRF   03
1E0A0:  MOVF   x4D,W
1E0A2:  ADDLW  E3
1E0A4:  MOVWF  FE9
1E0A6:  MOVLW  01
1E0A8:  ADDWFC 03,W
1E0AA:  MOVWF  FEA
1E0AC:  MOVFF  FEF,3A2
1E0B0:  MOVLW  57
1E0B2:  MOVWF  xA3
1E0B4:  MOVLB  0
1E0B6:  CALL   0734
1E0BA:  MOVLW  2C
1E0BC:  BTFSS  F9E.4
1E0BE:  BRA    1E0BC
1E0C0:  MOVWF  FAD
1E0C2:  MOVLB  3
1E0C4:  INCF   x4D,F
1E0C6:  BRA    1E098
....................    } 
....................    fprintf(PC,"%x\r\n",ACK_for_COM[23]); 
1E0C8:  MOVFF  1FA,3A2
1E0CC:  MOVLW  57
1E0CE:  MOVWF  xA3
1E0D0:  MOVLB  0
1E0D2:  CALL   0734
1E0D6:  MOVLW  0D
1E0D8:  BTFSS  F9E.4
1E0DA:  BRA    1E0D8
1E0DC:  MOVWF  FAD
1E0DE:  MOVLW  0A
1E0E0:  BTFSS  F9E.4
1E0E2:  BRA    1E0E0
1E0E4:  MOVWF  FAD
....................     
....................    for(int k = 14; k < 23; k++)                                                   //clear RSV part 
1E0E6:  MOVLW  0E
1E0E8:  MOVLB  3
1E0EA:  MOVWF  x4E
1E0EC:  MOVF   x4E,W
1E0EE:  SUBLW  16
1E0F0:  BNC   1E106
....................    { 
....................       ACK_for_COM[k] = 0x00; 
1E0F2:  CLRF   03
1E0F4:  MOVF   x4E,W
1E0F6:  ADDLW  E3
1E0F8:  MOVWF  FE9
1E0FA:  MOVLW  01
1E0FC:  ADDWFC 03,W
1E0FE:  MOVWF  FEA
1E100:  CLRF   FEF
1E102:  INCF   x4E,F
1E104:  BRA    1E0EC
....................    } 
....................    return; 
1E106:  MOVLB  0
1E108:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00011800 
.................... void Turn_On_ADCS() 
.................... { 
....................    output_high(PIN_D6);                                                          //ADCS switch ON, RD6=1 
*
1277C:  BCF    F95.6
1277E:  BSF    F8C.6
....................    return; 
12780:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Turn_Off_ADCS() 
.................... { 
....................    output_low(PIN_D6);                                                           //ADCS switch OFF, RD6=0 
*
127CE:  BCF    F95.6
127D0:  BCF    F8C.6
....................    return; 
127D2:  RETURN 0
.................... } 
....................  
.................... /*void Send_Command_to_ADCS(int8 data)                                             //testing for EM integration 
.................... { 
....................    fputc(data,ADCS); 
....................    return; 
.................... }*/ 
....................  
.................... #ORG 0x00011800 
.................... void DELETE_ADCS_SENSOR() 
.................... { 
....................    for(int a = 0; a < ADCS_SENSOR_SIZE; a++) 
*
12750:  MOVLB  3
12752:  CLRF   x84
12754:  MOVF   x84,W
12756:  SUBLW  4D
12758:  BNC   1276E
....................    { 
....................       ADCS_SENSOR_DATA[a] = 0; 
1275A:  CLRF   03
1275C:  MOVF   x84,W
1275E:  ADDLW  FB
12760:  MOVWF  FE9
12762:  MOVLW  01
12764:  ADDWFC 03,W
12766:  MOVWF  FEA
12768:  CLRF   FEF
1276A:  INCF   x84,F
1276C:  BRA    12754
....................    } 
....................    return; 
1276E:  MOVLB  0
12770:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void Delete_Buffer()                                                             //delete com command buffer 
*
1272A:  MOVLB  3
1272C:  CLRF   x84
.................... { 
....................    int num = 0; 
....................    for(num = 0;num < 16; num++) 
1272E:  CLRF   x84
12730:  MOVF   x84,W
12732:  SUBLW  0F
12734:  BNC   1274A
....................    { 
....................     in_bffr_main[num] = 0x00; 
12736:  CLRF   03
12738:  MOVF   x84,W
1273A:  ADDLW  86
1273C:  MOVWF  FE9
1273E:  MOVLW  00
12740:  ADDWFC 03,W
12742:  MOVWF  FEA
12744:  CLRF   FEF
12746:  INCF   x84,F
12748:  BRA    12730
....................    } 
....................    COM_DATA = 0; 
1274A:  MOVLB  0
1274C:  CLRF   x96
....................    return; 
1274E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ADCS_SETTINGS()                                                             //initiallize 
.................... { 
....................    output_high(PIN_C4);                                                          //flash COM side 
*
12772:  BCF    F94.4
12774:  BSF    F8B.4
....................    Delete_Buffer();                                                              //delete in_bffr_main[] (com command buffer) 
12776:  RCALL  1272A
....................    DELETE_ADCS_SENSOR();                                                         //delet ADCS_SENSOR_DATA[] array 
12778:  RCALL  12750
....................    return; 
1277A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void CHECK_ACK_FROM_ADCS_10k()                                                     //Wait ACK from DC for 10s 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
12782:  MOVLB  3
12784:  CLRF   x87
12786:  CLRF   x86
12788:  CLRF   x85
1278A:  CLRF   x84
1278C:  MOVF   x87,F
1278E:  BNZ   127CA
12790:  MOVF   x86,W
12792:  SUBLW  0F
12794:  BNC   127CA
12796:  BNZ   127A6
12798:  MOVF   x85,W
1279A:  SUBLW  42
1279C:  BNC   127CA
1279E:  BNZ   127A6
127A0:  MOVF   x84,W
127A2:  SUBLW  3F
127A4:  BNC   127CA
....................    { 
....................       if(kbhit(ADCS))                                                              
127A6:  BTFSC  F85.6
127A8:  BRA    127B8
....................       { 
....................          ADCS_ACK = fgetc(ADCS);                                                    //PC    
127AA:  MOVLB  0
127AC:  CALL   1520
127B0:  MOVFF  01,9B
....................          break; 
127B4:  MOVLB  3
127B6:  BRA    127CA
....................       } 
127B8:  MOVLW  01
127BA:  ADDWF  x84,F
127BC:  BTFSC  FD8.0
127BE:  INCF   x85,F
127C0:  BTFSC  FD8.2
127C2:  INCF   x86,F
127C4:  BTFSC  FD8.2
127C6:  INCF   x87,F
127C8:  BRA    1278C
....................       //delay_ms(1); 
....................    } 
....................    return; 
127CA:  MOVLB  0
127CC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00011800 
.................... void ADCS_TLE_TRANSFER()                                                         //send TLE data to ADCS 
.................... { 
....................  
....................    fprintf(PC,"Turn On ADCS \r\n"); 
*
136C4:  MOVLW  C6
136C6:  MOVWF  FF6
136C8:  MOVLW  0B
136CA:  MOVWF  FF7
136CC:  MOVLW  00
136CE:  MOVWF  FF8
136D0:  CALL   058C
....................    Turn_On_ADCS();                                                               //Turn on ADCS 
136D4:  CALL   1277C
....................    /*delay_ms(8000);*/ 
....................    for(int c = 0; c < TLE_size; c++)                                           // Read TLE data from flash and put in TLE[] array 
136D8:  MOVLB  3
136DA:  CLRF   x37
136DC:  MOVF   x37,W
136DE:  SUBLW  4C
136E0:  BNC   13734
....................       { 
....................          TLE[c]=READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+c); 
136E2:  CLRF   03
136E4:  MOVF   x37,W
136E6:  ADDLW  96
136E8:  MOVWF  01
136EA:  MOVLW  01
136EC:  ADDWFC 03,F
136EE:  MOVFF  01,339
136F2:  MOVFF  03,33A
136F6:  MOVF   x37,W
136F8:  ADDWF  54,W
136FA:  MOVWF  x3B
136FC:  MOVLW  00
136FE:  ADDWFC 55,W
13700:  MOVWF  x3C
13702:  MOVLW  00
13704:  ADDWFC 56,W
13706:  MOVWF  x3D
13708:  MOVLW  00
1370A:  ADDWFC 57,W
1370C:  MOVWF  x3E
1370E:  MOVWF  xAB
13710:  MOVFF  33D,3AA
13714:  MOVFF  33C,3A9
13718:  MOVFF  33B,3A8
1371C:  MOVLB  0
1371E:  CALL   121C0
13722:  MOVFF  33A,FEA
13726:  MOVFF  339,FE9
1372A:  MOVFF  01,FEF
1372E:  MOVLB  3
13730:  INCF   x37,F
13732:  BRA    136DC
....................       } 
....................     
....................    fputc(0x21,ADCS);                                                             //ADCS hand shake 
13734:  MOVLW  21
13736:  MOVWF  x84
13738:  MOVLB  0
1373A:  CALL   14DA
....................  
....................    CHECK_ACK_FROM_ADCS_10k(); 
1373E:  CALL   12782
....................    if(ADCS_ACK == 0x55)                                                            //Success ACK 
13742:  MOVF   x9B,W
13744:  SUBLW  55
13746:  BNZ   13796
....................    { 
....................       fprintf(PC,"Received ACK From ADCS\r\n"); 
13748:  MOVLW  D6
1374A:  MOVWF  FF6
1374C:  MOVLW  0B
1374E:  MOVWF  FF7
13750:  MOVLW  00
13752:  MOVWF  FF8
13754:  CALL   058C
....................       //delay_ms(1000); 
....................       ADCS_ACK = 0;       
13758:  CLRF   x9B
....................       for(int t = 0; t < TLE_size; t++)                                           // Read TLE data from flash and put in TLE[] array 
1375A:  MOVLB  3
1375C:  CLRF   x38
1375E:  MOVF   x38,W
13760:  SUBLW  4C
13762:  BNC   13782
....................       { 
....................          fputc(TLE[t],ADCS); 
13764:  CLRF   03
13766:  MOVF   x38,W
13768:  ADDLW  96
1376A:  MOVWF  FE9
1376C:  MOVLW  01
1376E:  ADDWFC 03,W
13770:  MOVWF  FEA
13772:  MOVFF  FEF,384
13776:  MOVLB  0
13778:  CALL   14DA
1377C:  MOVLB  3
1377E:  INCF   x38,F
13780:  BRA    1375E
....................       } 
....................       fprintf(PC,"Sent TLE data to ADCS\r\n"); 
13782:  MOVLW  F0
13784:  MOVWF  FF6
13786:  MOVLW  0B
13788:  MOVWF  FF7
1378A:  MOVLW  00
1378C:  MOVWF  FF8
1378E:  MOVLB  0
13790:  CALL   058C
....................    }else{ 
13794:  BRA    137A8
....................       ADCS_ACK = 0; 
13796:  CLRF   x9B
....................       fprintf(PC,"FAILURED GETTING ACK From ADCS\r\n"); 
13798:  MOVLW  08
1379A:  MOVWF  FF6
1379C:  MOVLW  0C
1379E:  MOVWF  FF7
137A0:  MOVLW  00
137A2:  MOVWF  FF8
137A4:  CALL   058C
....................    } 
....................    CMD_FROM_PC[0] = 0;                                                           //prepare to get MAIN command 
137A8:  CLRF   x7E
....................    PC_DATA = 0;                                                                  //prepare to get MAIN command 
137AA:  CLRF   x99
....................    return; 
137AC:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include "adcs_test.h" 
.................... #ifndef ADCS_TEST_H 
.................... #define ADCS_TEST_H 
....................  
.................... int32 beginning_of_operation = 0; 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00011800 
.................... void ADCS_TEST_OPERATION(unsigned int16 duration, int8 OPERATION_MODE)           //Integration Testing With ADCS 
*
127D4:  MOVLB  3
127D6:  CLRF   x83
.................... { 
....................    int8 count = 0; 
....................    LOOP_ADCS_SENSOR_ADDRESS(); 
127D8:  MOVLB  0
127DA:  GOTO   1354
....................    ADCS_SETTINGS(); 
127DE:  RCALL  12772
....................    beginning_of_operation = ADCS_SENSOR_ADDRESS; 
127E0:  MOVFF  53,304
127E4:  MOVFF  52,303
127E8:  MOVFF  51,302
127EC:  MOVFF  50,301
....................     
....................    /*   GET_INITIAL_TIME(); */ 
....................    fprintf(PC,"Turn On ADCS \r\n"); 
127F0:  MOVLW  2A
127F2:  MOVWF  FF6
127F4:  MOVLW  0C
127F6:  MOVWF  FF7
127F8:  MOVLW  00
127FA:  MOVWF  FF8
127FC:  CALL   058C
....................    Turn_On_ADCS();                                                               //Turn on ADCS 
12800:  RCALL  1277C
....................    /*delay_ms(8000);*/ 
....................     
....................    fputc(0x21,ADCS);                                                             //ADCS hand shake 
12802:  MOVLW  21
12804:  MOVLB  3
12806:  MOVWF  x84
12808:  MOVLB  0
1280A:  CALL   14DA
....................  
....................    CHECK_ACK_FROM_ADCS_10k(); 
1280E:  RCALL  12782
....................    if(ADCS_ACK == 0x55)                                                            //Success ACK 
12810:  MOVF   x9B,W
12812:  SUBLW  55
12814:  BNZ   12842
....................    { 
....................       fprintf(PC,"Received ACK From ADCS\r\n"); 
12816:  MOVLW  3A
12818:  MOVWF  FF6
1281A:  MOVLW  0C
1281C:  MOVWF  FF7
1281E:  MOVLW  00
12820:  MOVWF  FF8
12822:  CALL   058C
....................       //delay_ms(1000); 
....................       ADCS_ACK = 0; 
12826:  CLRF   x9B
....................       fputc(OPERATION_MODE,adcs);                                                   //for execute stabilize mission 
12828:  MOVFF  382,384
1282C:  CALL   14DA
....................       fprintf(PC,"Sent OPERATION MODE to ADCS\r\n"); 
12830:  MOVLW  54
12832:  MOVWF  FF6
12834:  MOVLW  0C
12836:  MOVWF  FF7
12838:  MOVLW  00
1283A:  MOVWF  FF8
1283C:  CALL   058C
....................    }else{ 
12840:  BRA    12854
....................       ADCS_ACK = 0; 
12842:  CLRF   x9B
....................       fprintf(PC,"FAILURED GETTING ACK From ADCS\r\n"); 
12844:  MOVLW  72
12846:  MOVWF  FF6
12848:  MOVLW  0C
1284A:  MOVWF  FF7
1284C:  MOVLW  00
1284E:  MOVWF  FF8
12850:  CALL   058C
....................    } 
....................     
....................  
....................  
....................    CMD_FROM_PC[0] = 0;                                                           //prepare to get MAIN command 
12854:  CLRF   x7E
....................    PC_DATA = 0;                                                                  //prepare to get MAIN command 
12856:  CLRF   x99
....................    currenttime = 0;                                                              //prepare to measure the operation time 
12858:  MOVLB  2
1285A:  CLRF   x4A
1285C:  CLRF   x49
....................    while(true) 
....................    { 
....................       /*  for(int safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       if(currenttime > duration)                                                 //600-->600 seconds (10min) 
1285E:  MOVLB  3
12860:  MOVF   x81,W
12862:  MOVLB  2
12864:  SUBWF  x4A,W
12866:  BNC   12890
12868:  BNZ   1287A
1286A:  MOVF   x49,W
1286C:  MOVLB  3
1286E:  SUBWF  x80,W
12870:  BTFSS  FD8.0
12872:  BRA    12878
12874:  MOVLB  2
12876:  BRA    12890
12878:  MOVLB  2
....................       { 
....................          fprintf(PC,"done\r\n"); 
1287A:  MOVLW  94
1287C:  MOVWF  FF6
1287E:  MOVLW  0C
12880:  MOVWF  FF7
12882:  MOVLW  00
12884:  MOVWF  FF8
12886:  MOVLB  0
12888:  CALL   058C
....................          break; 
1288C:  BRA    128EA
1288E:  MOVLB  2
....................       } 
....................        /*  for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       if((currenttime%90)==0) 
12890:  MOVFF  24A,385
12894:  MOVFF  249,384
12898:  MOVLB  3
1289A:  CLRF   x87
1289C:  MOVLW  5A
1289E:  MOVWF  x86
128A0:  MOVLB  0
128A2:  CALL   156A
128A6:  MOVFF  00,384
128AA:  MOVLB  3
128AC:  MOVFF  03,385
128B0:  MOVF   x84,F
128B2:  BNZ   128C0
128B4:  MOVF   x85,F
128B6:  BNZ   128C0
....................       { 
....................          COLLECT_RESET_DATA(); 
128B8:  MOVLB  0
128BA:  CALL   16AD6
128BE:  MOVLB  3
....................       } 
....................        
....................       /* for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................        
....................       if(CMD_FROM_PC[0] == 0xab) 
128C0:  MOVLB  0
128C2:  MOVF   x7E,W
128C4:  SUBLW  AB
128C6:  BNZ   128E0
....................       { 
....................          CMD_FROM_PC[0] = 0; 
128C8:  CLRF   x7E
....................          PC_DATA = 0; 
128CA:  CLRF   x99
....................          Turn_off_ADCS(); 
128CC:  RCALL  127CE
....................          fprintf(PC,"Stop ADCS Mission\r\n"); 
128CE:  MOVLW  9C
128D0:  MOVWF  FF6
128D2:  MOVLW  0C
128D4:  MOVWF  FF7
128D6:  MOVLW  00
128D8:  MOVWF  FF8
128DA:  CALL   058C
....................          break; 
128DE:  BRA    128EA
....................       } 
....................       /* for(safe = 0; safe < 100; safe++) 
....................       { 
....................          GET_ADCS_MSN_DATA(); 
....................       }*/ 
....................       RESET_SATELLITE();                                                         //if reset pic send command for resetting the satellite, OBC will response soon 
128E0:  CALL   16CEE
128E4:  MOVLB  2
128E6:  BRA    1285E
128E8:  MOVLB  0
....................    }   
....................    Turn_OFF_ADCS();                                                              //turn off ADCS OCP 
128EA:  RCALL  127CE
....................    fprintf(PC,"\r\n\r\nTurned_OFF_ADCS\r\n\r\n\r\n");                                                        
128EC:  MOVLW  B0
128EE:  MOVWF  FF6
128F0:  MOVLW  0C
128F2:  MOVWF  FF7
128F4:  MOVLW  00
128F6:  MOVWF  FF8
128F8:  CALL   058C
....................    fprintf(PC,"%lx",beginning_of_operation); 
128FC:  MOVFF  304,3A2
12900:  MOVLW  57
12902:  MOVLB  3
12904:  MOVWF  xA3
12906:  MOVLB  0
12908:  CALL   0734
1290C:  MOVFF  303,3A2
12910:  MOVLW  57
12912:  MOVLB  3
12914:  MOVWF  xA3
12916:  MOVLB  0
12918:  CALL   0734
1291C:  MOVFF  302,3A2
12920:  MOVLW  57
12922:  MOVLB  3
12924:  MOVWF  xA3
12926:  MOVLB  0
12928:  CALL   0734
1292C:  MOVFF  301,3A2
12930:  MOVLW  57
12932:  MOVLB  3
12934:  MOVWF  xA3
12936:  MOVLB  0
12938:  CALL   0734
....................    delay_ms(1000); 
1293C:  MOVLW  04
1293E:  MOVLB  3
12940:  MOVWF  x84
12942:  MOVLW  FA
12944:  MOVWF  x98
12946:  MOVLB  0
12948:  CALL   0526
1294C:  MOVLB  3
1294E:  DECFSZ x84,F
12950:  BRA    12942
....................    Turn_On_ADCS(); 
12952:  MOVLB  0
12954:  RCALL  1277C
....................    fprintf(PC,"\r\n\r\nTurned_ON_ADCS\r\n\r\n\r\n"); 
12956:  MOVLW  CA
12958:  MOVWF  FF6
1295A:  MOVLW  0C
1295C:  MOVWF  FF7
1295E:  MOVLW  00
12960:  MOVWF  FF8
12962:  CALL   058C
....................    //ADCS debe estar siempre encendido 
....................    /*  SAVE_ADCS_INITIAL_and_FINAL(beginning_of_operation); 
....................    output_low(PIN_C4); 
....................    for(int32 num = 0; num < 81+90; num++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(beginning_of_operation + num)); 
....................    } 
....................    //TRANSFER_DATA_NBYTE_TOPC_SCF(ADCS_SENSOR_ADDRESS-ATTEMPT_TIME*100, ATTEMPT_TIME*100); 
....................    output_high(PIN_C4);*/ 
....................    RESET_SATELLITE();                                                            //if reset pic send command for resetting the satellite, OBC will response soon 
12966:  CALL   16CEE
....................    if(count > 89) 
1296A:  MOVLB  3
1296C:  MOVF   x83,W
1296E:  SUBLW  59
12970:  BC    1297E
....................    { 
....................       count = 0; 
12972:  CLRF   x83
....................       COLLECT_RESET_DATA(); 
12974:  MOVLB  0
12976:  CALL   16AD6
....................    }else{ 
1297A:  BRA    12982
1297C:  MOVLB  3
....................       count++; 
1297E:  INCF   x83,F
12980:  MOVLB  0
....................    }  
....................    return; 
12982:  RETURN 0
.................... } 
....................  
.................... void DISPLAY_ADCS_SENSOR_TO_PC()//for testing 
.................... { 
....................    for(int b = 0; b < ADCS_SENSOR_SIZE; b++)//for checking 
....................    { 
....................       fputc(ADCS_SENSOR_DATA[b],PC); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void CHECK_50_and_CW_RESPOND()                                                   //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
.................... { 
....................    if(in_bffr_main[4] == 0x50) 
*
01AA6:  MOVF   x8A,W
01AA8:  SUBLW  50
01AAA:  BNZ   1AB6
....................    { 
....................       CW_RESPOND();                                                              //carga el array ACK_for_COM[] con el dato del array CW_FORMAT[] y envia a COM PIC 
01AAC:  CALL   1E024
....................       Delete_Buffer();                                                           //delete in_bffr_main[] (com command buffer) 
01AB0:  CALL   1272A
....................       COM_DATA = 0;                                                              //flag to cero 
01AB4:  CLRF   x96
....................    } 
....................    return; 
01AB6:  RETURN 0
.................... } 
....................  
.................... void Get_ADCS_MISSION_Data() 
.................... { 
....................     
....................    Delete_ADCS_SENSOR(); //initialize 
....................    CHECK_50_and_CW_RESPOND(); 
....................    fputc(0x55,ADCS); 
....................    fputc(0x55,PC); 
....................    int i = 0; 
....................    for(int32 num = 0; num < 1000000 ;num++) 
....................    { 
....................       if(kbhit(ADCS) && fgetc(ADCS) == 0x67) 
....................       { 
....................          for(num = 0; num < 10000; num++) 
....................          { 
....................             if(Kbhit(ADCS)) 
....................             { 
....................                ADCS_SENSOR_DATA[i] = fgetc(ADCS); 
....................                i++; 
....................                if(i == 60) 
....................                { 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................          ADCS_ACK = 0x67; 
....................          break; 
....................       } 
....................    } 
....................    if(num == 1000000) 
....................    { 
....................       fprintf(PC,"NO DATA\r\n"); 
....................    } 
....................    CHECK_50_and_CW_RESPOND(); 
....................    return; 
.................... } 
....................  
.................... #ORG 0x00011800 
.................... int8 compare_before_after(int32 beginning, int32 end) 
.................... { 
....................    int8 data[12] = {}; 
*
12248:  MOVLB  3
1224A:  CLRF   x85
1224C:  CLRF   x86
1224E:  CLRF   x87
12250:  CLRF   x88
12252:  CLRF   x89
12254:  CLRF   x8A
12256:  CLRF   x8B
12258:  CLRF   x8C
1225A:  CLRF   x8D
1225C:  CLRF   x8E
1225E:  CLRF   x8F
12260:  CLRF   x90
....................    for(int i = 0; i < 6; i++) 
12262:  CLRF   x91
12264:  MOVF   x91,W
12266:  SUBLW  05
12268:  BNC   122D4
....................    { 
....................       data[i] = READ_DATA_BYTE_OF(beginning+222+10+i); 
1226A:  CLRF   03
1226C:  MOVF   x91,W
1226E:  ADDLW  85
12270:  MOVWF  01
12272:  MOVLW  03
12274:  ADDWFC 03,F
12276:  MOVFF  01,3A2
1227A:  MOVFF  03,3A3
1227E:  MOVLW  DE
12280:  ADDWF  x7D,W
12282:  MOVWF  xA4
12284:  MOVLW  00
12286:  ADDWFC x7E,W
12288:  MOVWF  xA5
1228A:  MOVLW  00
1228C:  ADDWFC x7F,W
1228E:  MOVWF  xA6
12290:  MOVLW  00
12292:  ADDWFC x80,W
12294:  MOVWF  xA7
12296:  MOVLW  0A
12298:  ADDWF  xA4,F
1229A:  MOVLW  00
1229C:  ADDWFC xA5,F
1229E:  ADDWFC xA6,F
122A0:  ADDWFC xA7,F
122A2:  MOVF   x91,W
122A4:  ADDWF  xA4,F
122A6:  MOVLW  00
122A8:  ADDWFC xA5,F
122AA:  ADDWFC xA6,F
122AC:  ADDWFC xA7,F
122AE:  MOVFF  3A7,3AB
122B2:  MOVFF  3A6,3AA
122B6:  MOVFF  3A5,3A9
122BA:  MOVFF  3A4,3A8
122BE:  MOVLB  0
122C0:  RCALL  121C0
122C2:  MOVFF  3A3,FEA
122C6:  MOVFF  3A2,FE9
122CA:  MOVFF  01,FEF
122CE:  MOVLB  3
122D0:  INCF   x91,F
122D2:  BRA    12264
....................    } 
....................    for(i = 0; i < 6; i++) 
122D4:  CLRF   x91
122D6:  MOVF   x91,W
122D8:  SUBLW  05
122DA:  BNC   1233C
....................    { 
....................       data[i+6] = READ_DATA_BYTE_OF(end-101+i); 
122DC:  MOVLW  06
122DE:  ADDWF  x91,W
122E0:  CLRF   03
122E2:  ADDLW  85
122E4:  MOVWF  01
122E6:  MOVLW  03
122E8:  ADDWFC 03,F
122EA:  MOVFF  01,3A2
122EE:  MOVFF  03,3A3
122F2:  MOVLW  65
122F4:  SUBWF  x81,W
122F6:  MOVWF  xA4
122F8:  MOVLW  00
122FA:  SUBWFB x82,W
122FC:  MOVWF  xA5
122FE:  MOVLW  00
12300:  SUBWFB x83,W
12302:  MOVWF  xA6
12304:  MOVLW  00
12306:  SUBWFB x84,W
12308:  MOVWF  xA7
1230A:  MOVF   x91,W
1230C:  ADDWF  xA4,F
1230E:  MOVLW  00
12310:  ADDWFC xA5,F
12312:  ADDWFC xA6,F
12314:  ADDWFC xA7,F
12316:  MOVFF  3A7,3AB
1231A:  MOVFF  3A6,3AA
1231E:  MOVFF  3A5,3A9
12322:  MOVFF  3A4,3A8
12326:  MOVLB  0
12328:  RCALL  121C0
1232A:  MOVFF  3A3,FEA
1232E:  MOVFF  3A2,FE9
12332:  MOVFF  01,FEF
12336:  MOVLB  3
12338:  INCF   x91,F
1233A:  BRA    122D6
....................    } 
....................    signed int16 Bx = make16(data[0],data[1]); 
....................    signed int16 By = make16(data[2],data[3]); 
....................    signed int16 Bz = make16(data[4],data[5]); 
....................     
....................    signed int16 Ax = make16(data[6],data[7]); 
....................    signed int16 Ay = make16(data[8],data[9]); 
....................    signed int16 Az = make16(data[10],data[11]); 
....................     
....................    signed int16 Total_B = Bx + By + Bz; 
....................    signed int16 Total_A = Ax + Ay + Az; 
1233C:  MOVFF  385,393
12340:  MOVFF  386,392
12344:  MOVFF  387,395
12348:  MOVFF  388,394
1234C:  MOVFF  389,397
12350:  MOVFF  38A,396
12354:  MOVFF  38B,399
12358:  MOVFF  38C,398
1235C:  MOVFF  38D,39B
12360:  MOVFF  38E,39A
12364:  MOVFF  38F,39D
12368:  MOVFF  390,39C
1236C:  MOVF   x94,W
1236E:  ADDWF  x92,W
12370:  MOVWF  xA2
12372:  MOVF   x95,W
12374:  ADDWFC x93,W
12376:  MOVWF  xA3
12378:  MOVF   x96,W
1237A:  ADDWF  xA2,W
1237C:  MOVWF  x9E
1237E:  MOVF   x97,W
12380:  ADDWFC xA3,W
12382:  MOVWF  x9F
12384:  MOVF   x9A,W
12386:  ADDWF  x98,W
12388:  MOVWF  xA2
1238A:  MOVF   x9B,W
1238C:  ADDWFC x99,W
1238E:  MOVWF  xA3
12390:  MOVF   x9C,W
12392:  ADDWF  xA2,W
12394:  MOVWF  xA0
12396:  MOVF   x9D,W
12398:  ADDWFC xA3,W
1239A:  MOVWF  xA1
....................    Total_B = abs(Total_B); 
1239C:  MOVFF  39F,03
123A0:  MOVF   x9E,W
123A2:  BTFSS  x9F.7
123A4:  BRA    123B6
123A6:  MOVLW  00
123A8:  BSF    FD8.0
123AA:  SUBFWB x9E,W
123AC:  MOVWF  00
123AE:  MOVLW  00
123B0:  SUBFWB x9F,W
123B2:  MOVWF  03
123B4:  MOVF   00,W
123B6:  MOVWF  x9E
123B8:  MOVFF  03,39F
....................    Total_A = abs(Total_A); 
123BC:  MOVFF  3A1,03
123C0:  MOVF   xA0,W
123C2:  BTFSS  xA1.7
123C4:  BRA    123D6
123C6:  MOVLW  00
123C8:  BSF    FD8.0
123CA:  SUBFWB xA0,W
123CC:  MOVWF  00
123CE:  MOVLW  00
123D0:  SUBFWB xA1,W
123D2:  MOVWF  03
123D4:  MOVF   00,W
123D6:  MOVWF  xA0
123D8:  MOVFF  03,3A1
....................    fprintf(PC,"%lx,%lx,%lx\r\n",Bx,By,Bz); 
123DC:  MOVFF  393,3A2
123E0:  MOVLW  57
123E2:  MOVWF  xA3
123E4:  MOVLB  0
123E6:  CALL   0734
123EA:  MOVFF  392,3A2
123EE:  MOVLW  57
123F0:  MOVLB  3
123F2:  MOVWF  xA3
123F4:  MOVLB  0
123F6:  CALL   0734
123FA:  MOVLW  2C
123FC:  BTFSS  F9E.4
123FE:  BRA    123FC
12400:  MOVWF  FAD
12402:  MOVFF  395,3A2
12406:  MOVLW  57
12408:  MOVLB  3
1240A:  MOVWF  xA3
1240C:  MOVLB  0
1240E:  CALL   0734
12412:  MOVFF  394,3A2
12416:  MOVLW  57
12418:  MOVLB  3
1241A:  MOVWF  xA3
1241C:  MOVLB  0
1241E:  CALL   0734
12422:  MOVLW  2C
12424:  BTFSS  F9E.4
12426:  BRA    12424
12428:  MOVWF  FAD
1242A:  MOVFF  397,3A2
1242E:  MOVLW  57
12430:  MOVLB  3
12432:  MOVWF  xA3
12434:  MOVLB  0
12436:  CALL   0734
1243A:  MOVFF  396,3A2
1243E:  MOVLW  57
12440:  MOVLB  3
12442:  MOVWF  xA3
12444:  MOVLB  0
12446:  CALL   0734
1244A:  MOVLW  0D
1244C:  BTFSS  F9E.4
1244E:  BRA    1244C
12450:  MOVWF  FAD
12452:  MOVLW  0A
12454:  BTFSS  F9E.4
12456:  BRA    12454
12458:  MOVWF  FAD
....................    fprintf(PC,"%lx,%lx,%lx\r\n",Ax,Ay,Az); 
1245A:  MOVFF  399,3A2
1245E:  MOVLW  57
12460:  MOVLB  3
12462:  MOVWF  xA3
12464:  MOVLB  0
12466:  CALL   0734
1246A:  MOVFF  398,3A2
1246E:  MOVLW  57
12470:  MOVLB  3
12472:  MOVWF  xA3
12474:  MOVLB  0
12476:  CALL   0734
1247A:  MOVLW  2C
1247C:  BTFSS  F9E.4
1247E:  BRA    1247C
12480:  MOVWF  FAD
12482:  MOVFF  39B,3A2
12486:  MOVLW  57
12488:  MOVLB  3
1248A:  MOVWF  xA3
1248C:  MOVLB  0
1248E:  CALL   0734
12492:  MOVFF  39A,3A2
12496:  MOVLW  57
12498:  MOVLB  3
1249A:  MOVWF  xA3
1249C:  MOVLB  0
1249E:  CALL   0734
124A2:  MOVLW  2C
124A4:  BTFSS  F9E.4
124A6:  BRA    124A4
124A8:  MOVWF  FAD
124AA:  MOVFF  39D,3A2
124AE:  MOVLW  57
124B0:  MOVLB  3
124B2:  MOVWF  xA3
124B4:  MOVLB  0
124B6:  CALL   0734
124BA:  MOVFF  39C,3A2
124BE:  MOVLW  57
124C0:  MOVLB  3
124C2:  MOVWF  xA3
124C4:  MOVLB  0
124C6:  CALL   0734
124CA:  MOVLW  0D
124CC:  BTFSS  F9E.4
124CE:  BRA    124CC
124D0:  MOVWF  FAD
124D2:  MOVLW  0A
124D4:  BTFSS  F9E.4
124D6:  BRA    124D4
124D8:  MOVWF  FAD
....................    fprintf(PC,"%lud,%lud\r\n",Total_B,Total_A); 
124DA:  MOVLW  10
124DC:  MOVWF  FE9
124DE:  MOVFF  39F,3A3
124E2:  MOVFF  39E,3A2
124E6:  CALL   0CEE
124EA:  MOVLW  64
124EC:  BTFSS  F9E.4
124EE:  BRA    124EC
124F0:  MOVWF  FAD
124F2:  MOVLW  2C
124F4:  BTFSS  F9E.4
124F6:  BRA    124F4
124F8:  MOVWF  FAD
124FA:  MOVLW  10
124FC:  MOVWF  FE9
124FE:  MOVFF  3A1,3A3
12502:  MOVFF  3A0,3A2
12506:  CALL   0CEE
1250A:  MOVLW  AA
1250C:  MOVWF  FF6
1250E:  MOVLW  0D
12510:  MOVWF  FF7
12512:  MOVLW  00
12514:  MOVWF  FF8
12516:  MOVLW  03
12518:  MOVLB  3
1251A:  MOVWF  xA2
1251C:  MOVLB  0
1251E:  CALL   0702
....................    if(Total_B >= Total_A) 
12522:  MOVLB  3
12524:  BTFSS  xA1.7
12526:  BRA    1252E
12528:  BTFSS  x9F.7
1252A:  BRA    12540
1252C:  BRA    12532
1252E:  BTFSC  x9F.7
12530:  BRA    12548
12532:  MOVF   xA1,W
12534:  SUBWF  x9F,W
12536:  BNC   12548
12538:  BNZ   12540
1253A:  MOVF   xA0,W
1253C:  SUBWF  x9E,W
1253E:  BNC   12548
....................    { 
....................       return 1;//declease --> continue 
12540:  MOVLW  01
12542:  MOVWF  01
12544:  BRA    1254C
....................    }else{ 
12546:  BRA    1254C
....................       return 0;//inclease --> stop 
12548:  MOVLW  00
1254A:  MOVWF  01
....................    } 
1254C:  MOVLB  0
1254E:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #ORG 0x00019000 
.................... void GIVE_ACCESS_SCF_Nsec(int8 min) 
.................... { 
....................    fprintf(PC,"giving access to COM for %d min\r\n", min); 
*
1B4E4:  MOVLW  AE
1B4E6:  MOVWF  FF6
1B4E8:  MOVLW  0D
1B4EA:  MOVWF  FF7
1B4EC:  MOVLW  00
1B4EE:  MOVWF  FF8
1B4F0:  MOVLW  19
1B4F2:  MOVLB  3
1B4F4:  MOVWF  xA2
1B4F6:  MOVLB  0
1B4F8:  CALL   0702
1B4FC:  MOVFF  337,33E
1B500:  MOVLW  18
1B502:  MOVLB  3
1B504:  MOVWF  x3F
1B506:  MOVLB  0
1B508:  CALL   2404
1B50C:  MOVLW  C9
1B50E:  MOVWF  FF6
1B510:  MOVLW  0D
1B512:  MOVWF  FF7
1B514:  MOVLW  00
1B516:  MOVWF  FF8
1B518:  MOVLW  06
1B51A:  MOVLB  3
1B51C:  MOVWF  xA2
1B51E:  MOVLB  0
1B520:  CALL   0702
....................    fputc(0x35,COM); 
1B524:  MOVLW  35
1B526:  CALL   1A0A
....................    output_high(PIN_C4); 
1B52A:  BCF    F94.4
1B52C:  BSF    F8B.4
....................    if(min > 5)                                                                   //for accidentaly send the long time delay, maximum should be 5 min 
1B52E:  MOVLB  3
1B530:  MOVF   x37,W
1B532:  SUBLW  05
1B534:  BC    1B53A
....................    { 
....................       min = 5; 
1B536:  MOVLW  05
1B538:  MOVWF  x37
....................    } 
....................    for(int16 i = 0; i < min * 60; i++) 
1B53A:  CLRF   x39
1B53C:  CLRF   x38
1B53E:  MOVF   x37,W
1B540:  MULLW  3C
1B542:  MOVF   FF3,W
1B544:  MOVF   x39,F
1B546:  BNZ   1B584
1B548:  SUBWF  x38,W
1B54A:  BC    1B584
....................    { 
....................       delay_ms(1000);                                                            //wait 1 sec 
1B54C:  MOVLW  04
1B54E:  MOVWF  x3A
1B550:  MOVLW  FA
1B552:  MOVWF  x98
1B554:  MOVLB  0
1B556:  CALL   0526
1B55A:  MOVLB  3
1B55C:  DECFSZ x3A,F
1B55E:  BRA    1B550
....................       if(in_bffr_main[4] == 0xab || CMD_FROM_PC[0] == 0xab) 
1B560:  MOVLB  0
1B562:  MOVF   x8A,W
1B564:  SUBLW  AB
1B566:  BZ    1B56E
1B568:  MOVF   x7E,W
1B56A:  SUBLW  AB
1B56C:  BNZ   1B57A
....................       { 
....................          CMD_FROM_PC[0] = 0; 
1B56E:  CLRF   x7E
....................          CMD_FROM_PC[1] = 0; 
1B570:  CLRF   x7F
....................          PC_DATA = 0; 
1B572:  CLRF   x99
....................          break; 
1B574:  MOVLB  3
1B576:  BRA    1B584
1B578:  MOVLB  0
....................       } 
1B57A:  MOVLB  3
1B57C:  INCF   x38,F
1B57E:  BTFSC  FD8.2
1B580:  INCF   x39,F
1B582:  BRA    1B53E
....................    } 
....................    fprintf(PC,"\r\nBack to Nomal Operation\r\n"); 
1B584:  MOVLW  D0
1B586:  MOVWF  FF6
1B588:  MOVLW  0D
1B58A:  MOVWF  FF7
1B58C:  MOVLW  00
1B58E:  MOVWF  FF8
1B590:  MOVLB  0
1B592:  CALL   058C
....................    return; 
1B596:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void DELETE_CMD_FROM_PC() 
.................... { 
....................    for(int num = 0; num < 8; num++) 
*
1B0BA:  MOVLB  3
1B0BC:  CLRF   x2C
1B0BE:  MOVF   x2C,W
1B0C0:  SUBLW  07
1B0C2:  BNC   1B0D8
....................    { 
....................       CMD_FROM_PC[num] = 0; 
1B0C4:  CLRF   03
1B0C6:  MOVF   x2C,W
1B0C8:  ADDLW  7E
1B0CA:  MOVWF  FE9
1B0CC:  MOVLW  00
1B0CE:  ADDWFC 03,W
1B0D0:  MOVWF  FEA
1B0D2:  CLRF   FEF
1B0D4:  INCF   x2C,F
1B0D6:  BRA    1B0BE
....................    } 
....................    return; 
1B0D8:  MOVLB  0
1B0DA:  RETURN 0
.................... } 
....................  
....................  
.................... //--------BC Function---------------------------------------------------------- 
....................  
.................... //unsigned int8 BC_temp_data[2] = {}; 
.................... unsigned int16 BC_temp_data_h = 0; 
.................... unsigned int16 BC_temp_data_l = 0; 
.................... unsigned int16 BC_TEMP = 0; 
.................... float  temp = 0; 
.................... float initial_temp = 0; 
.................... float MAXTEMP = 0; 
.................... int16 UNLEG2 = 0; 
....................  
.................... #ORG 0x00019000 
.................... void BC_SETUP()                                                                  //Analog read configuration (AN9) 
.................... { 
....................    ANCON2= 0x01;                                                                 // PIN RC2 Analog enable 
*
190A0:  MOVLW  01
190A2:  MOVLB  E
190A4:  MOVWF  x46
....................    ADCON1L = 0x00;                                                               // SAMP bit must be cleared by software to start conversion (ends sampling and starts converting) 
190A6:  CLRF   FC0
....................    ADCHS0L = 0x09;                                                               // Connect AN9 as S/H+ input 
190A8:  MOVLW  09
190AA:  MOVWF  x86
....................                                                                                  // AN9 is the input 
....................    ADCON2H = 0x00;                                                               //A/D control register 2H 
190AC:  CLRF   x8D
....................    ADRC = 1;                                                                     //RC Clock source 
190AE:  BSF    x8B.7
....................    ADCSS0L = 0;                                                                  //Sample select register 
190B0:  CLRF   x82
....................    ADCON3L = 0x02;                                                               // Conversion clock select bits, Tad = 3.2/Fosc    
190B2:  MOVLW  02
190B4:  MOVWF  x8A
....................    ADCON2L = 0;                                                                  //A/D control register 2L 
190B6:  CLRF   x8C
....................    return; 
190B8:  MOVLB  0
190BA:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void BC_READ_TO_PC() 
.................... { 
....................    ADON = 1; 
....................    SAMP = 1; 
....................    delay_ms(100); 
....................     
....................    SAMP = 0; // start converting 
....................    while (!DONE){}; 
....................    delay_ms(100); 
....................    //BC_temp_data[0] = ADCBUF0H;//read_adc(); 
....................    //BC_temp_data[1] = ADCBUF0L; 
....................     
....................    BC_temp_data_h = ADCBUF0H; 
....................    BC_temp_data_l = ADCBUF0L; 
....................    //temp = ((data_h << 8 ) | data_l); 
....................    fprintf(PC,"data_l:%x \r\n", BC_temp_data_l); 
....................    fprintf(PC,"data_h:%x \r\n", BC_temp_data_h); 
....................    BC_TEMP = BC_temp_data_h | BC_temp_data_l; 
....................    //fprintf(PC,"temp:%f\r\n",temp); 
....................    temp = BC_TEMP/1024*3.31*100-50;    //VDD: 3.31V(MEASURED) 
....................    //fprintf(PC,"%1.1f \r\n", temp); 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_BC_TEMP()                                                             //lee la temperatura del BC y lo guarda en MAXTEMP 
.................... { 
....................    BC_SETUP();                                                                   //Analog read configuration (AN9) 
*
19FC2:  CALL   190A0
....................    ADON = 1; 
19FC6:  BSF    FC1.7
....................    SAMP = 1; 
19FC8:  BSF    FC0.1
....................    delay_ms(10); 
19FCA:  MOVLW  0A
19FCC:  MOVLB  3
19FCE:  MOVWF  x98
19FD0:  MOVLB  0
19FD2:  CALL   0526
....................     
....................    SAMP = 0;                                                                     // start converting 
19FD6:  BCF    FC0.1
....................    while (!DONE){}; 
19FD8:  BTFSS  FC0.0
19FDA:  BRA    19FD8
....................    delay_ms(10); 
19FDC:  MOVLW  0A
19FDE:  MOVLB  3
19FE0:  MOVWF  x98
19FE2:  MOVLB  0
19FE4:  CALL   0526
....................    BC_temp_data_h = ADCBUF0H;                                                    //read_adc(); 
19FE8:  MOVLB  3
19FEA:  CLRF   x06
19FEC:  MOVFF  FC3,305
....................    BC_temp_data_l = ADCBUF0L; 
19FF0:  CLRF   x08
19FF2:  MOVFF  FC2,307
....................    //fprintf(PC,"%x%x\r\n",ADCBUF0H,BC_temp_data_l); 
....................    BC_temp = BC_temp_data_h<<8 | BC_temp_data_l;                                 //convierte en un int16 
19FF6:  CLRF   x41
19FF8:  MOVF   x41,W
19FFA:  IORWF  x07,W
19FFC:  MOVWF  x09
19FFE:  MOVF   x05,W
1A000:  IORWF  x08,W
1A002:  MOVWF  x0A
....................    //fprintf(PC,"HEX : %x%x\r\n",BC_temp>>8,BC_temp); 
....................  
....................    temp = BC_temp;                                                               //convierte a float 
1A004:  MOVFF  30A,342
1A008:  MOVFF  309,341
1A00C:  MOVLB  0
1A00E:  GOTO   1F36
1A012:  MOVFF  03,30E
1A016:  MOVFF  02,30D
1A01A:  MOVFF  01,30C
1A01E:  MOVFF  00,30B
....................    //temp = temp/1024*3.25*100-50; 
....................    temp = (temp*3.3/1023); 
1A022:  MOVFF  30E,351
1A026:  MOVFF  30D,350
1A02A:  MOVFF  30C,34F
1A02E:  MOVFF  30B,34E
1A032:  MOVLW  33
1A034:  MOVLB  3
1A036:  MOVWF  x55
1A038:  MOVWF  x54
1A03A:  MOVLW  53
1A03C:  MOVWF  x53
1A03E:  MOVLW  80
1A040:  MOVWF  x52
1A042:  MOVLB  0
1A044:  CALL   1B8C
1A048:  MOVFF  03,344
1A04C:  MOVFF  02,343
1A050:  MOVFF  01,342
1A054:  MOVFF  00,341
1A058:  MOVFF  03,348
1A05C:  MOVFF  02,347
1A060:  MOVFF  01,346
1A064:  MOVFF  00,345
1A068:  MOVLB  3
1A06A:  CLRF   x4C
1A06C:  MOVLW  C0
1A06E:  MOVWF  x4B
1A070:  MOVLW  7F
1A072:  MOVWF  x4A
1A074:  MOVLW  88
1A076:  MOVWF  x49
1A078:  MOVLB  0
1A07A:  GOTO   1F6E
1A07E:  MOVFF  03,30E
1A082:  MOVFF  02,30D
1A086:  MOVFF  01,30C
1A08A:  MOVFF  00,30B
....................    temp = temp*100-50; 
1A08E:  MOVFF  30E,351
1A092:  MOVFF  30D,350
1A096:  MOVFF  30C,34F
1A09A:  MOVFF  30B,34E
1A09E:  MOVLB  3
1A0A0:  CLRF   x55
1A0A2:  CLRF   x54
1A0A4:  MOVLW  48
1A0A6:  MOVWF  x53
1A0A8:  MOVLW  85
1A0AA:  MOVWF  x52
1A0AC:  MOVLB  0
1A0AE:  CALL   1B8C
1A0B2:  MOVFF  03,344
1A0B6:  MOVFF  02,343
1A0BA:  MOVFF  01,342
1A0BE:  MOVFF  00,341
1A0C2:  BSF    FD8.1
1A0C4:  MOVFF  03,34D
1A0C8:  MOVFF  02,34C
1A0CC:  MOVFF  01,34B
1A0D0:  MOVFF  00,34A
1A0D4:  MOVLB  3
1A0D6:  CLRF   x51
1A0D8:  CLRF   x50
1A0DA:  MOVLW  48
1A0DC:  MOVWF  x4F
1A0DE:  MOVLW  84
1A0E0:  MOVWF  x4E
1A0E2:  MOVLB  0
1A0E4:  CALL   1C82
1A0E8:  MOVFF  03,30E
1A0EC:  MOVFF  02,30D
1A0F0:  MOVFF  01,30C
1A0F4:  MOVFF  00,30B
....................    fprintf(PC,"Current Temp: %1.1f\r\n",temp); 
1A0F8:  MOVLW  EC
1A0FA:  MOVWF  FF6
1A0FC:  MOVLW  0D
1A0FE:  MOVWF  FF7
1A100:  MOVLW  00
1A102:  MOVWF  FF8
1A104:  MOVLW  0E
1A106:  MOVLB  3
1A108:  MOVWF  xA2
1A10A:  MOVLB  0
1A10C:  CALL   0702
1A110:  MOVLW  89
1A112:  MOVWF  FE9
1A114:  MOVFF  30E,344
1A118:  MOVFF  30D,343
1A11C:  MOVFF  30C,342
1A120:  MOVFF  30B,341
1A124:  MOVLW  01
1A126:  MOVLB  3
1A128:  MOVWF  x45
1A12A:  MOVLB  0
1A12C:  CALL   21A6
1A130:  MOVLW  0D
1A132:  BTFSS  F9E.4
1A134:  BRA    1A132
1A136:  MOVWF  FAD
1A138:  MOVLW  0A
1A13A:  BTFSS  F9E.4
1A13C:  BRA    1A13A
1A13E:  MOVWF  FAD
....................     
....................    if(MAXTEMP < temp) 
1A140:  MOVFF  316,348
1A144:  MOVFF  315,347
1A148:  MOVFF  314,346
1A14C:  MOVFF  313,345
1A150:  MOVFF  30E,34C
1A154:  MOVFF  30D,34B
1A158:  MOVFF  30C,34A
1A15C:  MOVFF  30B,349
1A160:  CALL   2344
1A164:  BNC   1A176
....................    { 
....................       MAXTEMP = temp; 
1A166:  MOVFF  30E,316
1A16A:  MOVFF  30D,315
1A16E:  MOVFF  30C,314
1A172:  MOVFF  30B,313
....................    } 
....................    fprintf(PC,"%f\r\n",temp); 
1A176:  MOVLW  89
1A178:  MOVWF  FE9
1A17A:  MOVFF  30E,344
1A17E:  MOVFF  30D,343
1A182:  MOVFF  30C,342
1A186:  MOVFF  30B,341
1A18A:  MOVLW  02
1A18C:  MOVLB  3
1A18E:  MOVWF  x45
1A190:  MOVLB  0
1A192:  CALL   21A6
1A196:  MOVLW  0D
1A198:  BTFSS  F9E.4
1A19A:  BRA    1A198
1A19C:  MOVWF  FAD
1A19E:  MOVLW  0A
1A1A0:  BTFSS  F9E.4
1A1A2:  BRA    1A1A0
1A1A4:  MOVWF  FAD
....................    return; 
1A1A6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MEASURE_BC_TEMP() 
.................... { 
....................    BC_SETUP();                                                                   //configuracion para lectura analogica 
*
1910C:  RCALL  190A0
....................    ADON = 1; 
1910E:  BSF    FC1.7
....................    SAMP = 1; 
19110:  BSF    FC0.1
....................    delay_ms(1); 
19112:  MOVLW  01
19114:  MOVLB  3
19116:  MOVWF  x98
19118:  MOVLB  0
1911A:  CALL   0526
....................     
....................    SAMP = 0;                                                                     // start converting 
1911E:  BCF    FC0.1
....................    while (!DONE){}; 
19120:  BTFSS  FC0.0
19122:  BRA    19120
....................    delay_ms(1); 
19124:  MOVLW  01
19126:  MOVLB  3
19128:  MOVWF  x98
1912A:  MOVLB  0
1912C:  CALL   0526
....................    BC_temp_data_h = ADCBUF0H;                                                    //read_adc(); 
19130:  MOVLB  3
19132:  CLRF   x06
19134:  MOVFF  FC3,305
....................    BC_temp_data_l = ADCBUF0L; 
19138:  CLRF   x08
1913A:  MOVFF  FC2,307
....................  
....................    return; 
1913E:  MOVLB  0
19140:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_ON_BC() 
.................... { 
....................    output_high(PIN_D5);                                                          //BC switch ON, RD5=1 
*
1A1A8:  BCF    F95.5
1A1AA:  BSF    F8C.5
....................    return; 
1A1AC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_OFF_BC() 
.................... { 
....................    output_low(PIN_D5);                                                           //BC switch OFF, RD5=0 
*
190C2:  BCF    F95.5
190C4:  BCF    F8C.5
....................    return; 
190C6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void BC_OPERATION()                                                              //Turn ON BC and read temperature 
.................... { 
....................    CHECK_BC_TEMP();                                                              //read BC temperature and save It in float MAXTEMP 
*
1A1AE:  RCALL  19FC2
....................    initial_temp = MAXTEMP;                                                       //save temperature in initial_temp before turn_ON BC 
1A1B0:  MOVFF  316,312
1A1B4:  MOVFF  315,311
1A1B8:  MOVFF  314,310
1A1BC:  MOVFF  313,30F
....................    //fprintf(PC,"INITIAL TEMPERATURE is %1.1f\r\n\r\n",initial_temp); 
....................    Turn_ON_BC();                                                                 //BC switch ON, RD5=1 
1A1C0:  RCALL  1A1A8
....................    fprintf(PC,"Turned ON BC\r\n"); 
1A1C2:  MOVLW  02
1A1C4:  MOVWF  FF6
1A1C6:  MOVLW  0E
1A1C8:  MOVWF  FF7
1A1CA:  MOVLW  00
1A1CC:  MOVWF  FF8
1A1CE:  CALL   058C
....................    currenttime = 0; 
1A1D2:  MOVLB  2
1A1D4:  CLRF   x4A
1A1D6:  CLRF   x49
....................    int8 counter = 0;    
1A1D8:  MOVLB  3
1A1DA:  CLRF   x3F
....................    while(currenttime < 30)                                                       //turn ON BC for 30 sec 
1A1DC:  MOVLB  2
1A1DE:  MOVF   x4A,F
1A1E0:  BNZ   1A284
1A1E2:  MOVF   x49,W
1A1E4:  SUBLW  1D
1A1E6:  BNC   1A284
....................    { 
....................       for(int i = 0; i < 10; i++) 
1A1E8:  MOVLB  3
1A1EA:  CLRF   x40
1A1EC:  MOVF   x40,W
1A1EE:  SUBLW  09
1A1F0:  BNC   1A25C
....................       { 
....................          COLLECT_RESET_DATA();                                                   //envia comando al reset PIC pidiendo RESET DATA 
1A1F2:  MOVLB  0
1A1F4:  CALL   16AD6
....................          if(reset_bffr[0] == 0x8e) 
1A1F8:  MOVF   x9E,W
1A1FA:  SUBLW  8E
1A1FC:  BNZ   1A256
....................          { 
....................             for(i = 0; i < 10; i++);                                             //muestra el array recibido 
1A1FE:  MOVLB  3
1A200:  CLRF   x40
1A202:  MOVF   x40,W
1A204:  SUBLW  09
1A206:  BNC   1A20C
1A208:  INCF   x40,F
1A20A:  BRA    1A202
....................             { 
....................                fprintf(PC,"%x,",reset_bffr[i]); 
1A20C:  CLRF   03
1A20E:  MOVF   x40,W
1A210:  ADDLW  9E
1A212:  MOVWF  FE9
1A214:  MOVLW  00
1A216:  ADDWFC 03,W
1A218:  MOVWF  FEA
1A21A:  MOVFF  FEF,3A2
1A21E:  MOVLW  57
1A220:  MOVWF  xA3
1A222:  MOVLB  0
1A224:  CALL   0734
1A228:  MOVLW  2C
1A22A:  BTFSS  F9E.4
1A22C:  BRA    1A22A
1A22E:  MOVWF  FAD
....................             } 
....................             fprintf(PC,"%x\r\n",reset_bffr[10]); 
1A230:  MOVFF  A8,3A2
1A234:  MOVLW  57
1A236:  MOVLB  3
1A238:  MOVWF  xA3
1A23A:  MOVLB  0
1A23C:  CALL   0734
1A240:  MOVLW  0D
1A242:  BTFSS  F9E.4
1A244:  BRA    1A242
1A246:  MOVWF  FAD
1A248:  MOVLW  0A
1A24A:  BTFSS  F9E.4
1A24C:  BRA    1A24A
1A24E:  MOVWF  FAD
....................             break; 
1A250:  MOVLB  3
1A252:  BRA    1A25C
1A254:  MOVLB  0
....................          } 
1A256:  MOVLB  3
1A258:  INCF   x40,F
1A25A:  BRA    1A1EC
....................       } 
....................       CHECK_BC_TEMP();                                                           //read BC temperature and save It in float MAXTEMP 
1A25C:  MOVLB  0
1A25E:  RCALL  19FC2
....................       UNLEG2 = UNLEG2 + RESET_bffr[10];                                          //add the unleg2 current every second 
1A260:  MOVF   xA8,W
1A262:  MOVLB  3
1A264:  ADDWF  x17,F
1A266:  MOVLW  00
1A268:  ADDWFC x18,F
....................       counter++; 
1A26A:  INCF   x3F,F
....................       delay_ms(900); 
1A26C:  MOVLW  04
1A26E:  MOVWF  x41
1A270:  MOVLW  E1
1A272:  MOVWF  x98
1A274:  MOVLB  0
1A276:  CALL   0526
1A27A:  MOVLB  3
1A27C:  DECFSZ x41,F
1A27E:  BRA    1A270
1A280:  BRA    1A1DC
1A282:  MOVLB  2
....................    } 
....................        
....................    Turn_OFF_BC();                                                                //BC switch OFF, RD5=0 
1A284:  MOVLB  0
1A286:  CALL   190C2
....................    fprintf(PC,"Turned OFF BC\r\n"); 
1A28A:  MOVLW  12
1A28C:  MOVWF  FF6
1A28E:  MOVLW  0E
1A290:  MOVWF  FF7
1A292:  MOVLW  00
1A294:  MOVWF  FF8
1A296:  CALL   058C
....................    delay_ms(500); 
1A29A:  MOVLW  02
1A29C:  MOVLB  3
1A29E:  MOVWF  x41
1A2A0:  MOVLW  FA
1A2A2:  MOVWF  x98
1A2A4:  MOVLB  0
1A2A6:  CALL   0526
1A2AA:  MOVLB  3
1A2AC:  DECFSZ x41,F
1A2AE:  BRA    1A2A0
....................    CHECK_BC_TEMP();                                                              //lee la temperatura del BC y lo guarda en float MAXTEMP 
1A2B0:  MOVLB  0
1A2B2:  RCALL  19FC2
....................    if(MAXTEMP-initial_temp > 5)                                                  //pone en HIGH bandera si hubo incremento de temperatura 
1A2B4:  BSF    FD8.1
1A2B6:  MOVFF  316,34D
1A2BA:  MOVFF  315,34C
1A2BE:  MOVFF  314,34B
1A2C2:  MOVFF  313,34A
1A2C6:  MOVFF  312,351
1A2CA:  MOVFF  311,350
1A2CE:  MOVFF  310,34F
1A2D2:  MOVFF  30F,34E
1A2D6:  CALL   1C82
1A2DA:  MOVFF  03,344
1A2DE:  MOVFF  02,343
1A2E2:  MOVFF  01,342
1A2E6:  MOVFF  00,341
1A2EA:  MOVLB  3
1A2EC:  CLRF   x48
1A2EE:  CLRF   x47
1A2F0:  MOVLW  20
1A2F2:  MOVWF  x46
1A2F4:  MOVLW  81
1A2F6:  MOVWF  x45
1A2F8:  MOVFF  03,34C
1A2FC:  MOVFF  02,34B
1A300:  MOVFF  01,34A
1A304:  MOVFF  00,349
1A308:  MOVLB  0
1A30A:  CALL   2344
1A30E:  BNC   1A314
....................    { 
....................       ANT_DEP_STATUS = 1; 
1A310:  MOVLW  01
1A312:  MOVWF  x7B
....................    } 
....................    fprintf(PC,"MAXIMUM TEMPERATURE is %1.1f\r\n\r\n",MAXTEMP); 
1A314:  MOVLW  22
1A316:  MOVWF  FF6
1A318:  MOVLW  0E
1A31A:  MOVWF  FF7
1A31C:  MOVLW  00
1A31E:  MOVWF  FF8
1A320:  MOVLW  17
1A322:  MOVLB  3
1A324:  MOVWF  xA2
1A326:  MOVLB  0
1A328:  CALL   0702
1A32C:  MOVLW  89
1A32E:  MOVWF  FE9
1A330:  MOVFF  316,344
1A334:  MOVFF  315,343
1A338:  MOVFF  314,342
1A33C:  MOVFF  313,341
1A340:  MOVLW  01
1A342:  MOVLB  3
1A344:  MOVWF  x45
1A346:  MOVLB  0
1A348:  CALL   21A6
1A34C:  MOVLW  3E
1A34E:  MOVWF  FF6
1A350:  MOVLW  0E
1A352:  MOVWF  FF7
1A354:  MOVLW  00
1A356:  MOVWF  FF8
1A358:  MOVLW  04
1A35A:  MOVLB  3
1A35C:  MOVWF  xA2
1A35E:  MOVLB  0
1A360:  CALL   0702
....................    MAXTEMP = 0; 
1A364:  MOVLB  3
1A366:  CLRF   x16
1A368:  CLRF   x15
1A36A:  CLRF   x14
1A36C:  CLRF   x13
....................    initial_temp = 0; 
1A36E:  CLRF   x12
1A370:  CLRF   x11
1A372:  CLRF   x10
1A374:  CLRF   x0F
....................    return; 
1A376:  MOVLB  0
1A378:  RETURN 0
.................... } 
....................  
....................  
.................... #ORG 0x00019000 
.................... void CLEAR_BC_FLAG() 
.................... { 
....................    BC_ATTEMPT_FLAG = 0; 
*
1B3D8:  CLRF   x68
....................    fprintf(PC,"\r\nBC Attempt Flag clear done\r\n"); 
1B3DA:  MOVLW  44
1B3DC:  MOVWF  FF6
1B3DE:  MOVLW  0E
1B3E0:  MOVWF  FF7
1B3E2:  MOVLW  00
1B3E4:  MOVWF  FF8
1B3E6:  CALL   058C
....................    return; 
1B3EA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_1() 
.................... { 
....................    BC_ATTEMPT_FLAG = 1; 
1B3EC:  MOVLW  01
1B3EE:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:1\r\n"); 
1B3F0:  MOVLW  64
1B3F2:  MOVWF  FF6
1B3F4:  MOVLW  0E
1B3F6:  MOVWF  FF7
1B3F8:  MOVLW  00
1B3FA:  MOVWF  FF8
1B3FC:  CALL   058C
....................    return; 
1B400:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_2() 
.................... { 
....................    BC_ATTEMPT_FLAG = 2; 
1B402:  MOVLW  02
1B404:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:2\r\n"); 
1B406:  MOVLW  7A
1B408:  MOVWF  FF6
1B40A:  MOVLW  0E
1B40C:  MOVWF  FF7
1B40E:  MOVLW  00
1B410:  MOVWF  FF8
1B412:  CALL   058C
....................    return; 
1B416:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_3() 
.................... { 
....................    BC_ATTEMPT_FLAG = 3; 
1B418:  MOVLW  03
1B41A:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:3\r\n"); 
1B41C:  MOVLW  90
1B41E:  MOVWF  FF6
1B420:  MOVLW  0E
1B422:  MOVWF  FF7
1B424:  MOVLW  00
1B426:  MOVWF  FF8
1B428:  CALL   058C
....................    return; 
1B42C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_BC_FLAG_4() 
.................... { 
....................    BC_ATTEMPT_FLAG = 4; 
1B42E:  MOVLW  04
1B430:  MOVWF  x68
....................    fprintf(PC,"\r\nBC Attempt Flag:4\r\n"); 
1B432:  MOVLW  A6
1B434:  MOVWF  FF6
1B436:  MOVLW  0E
1B438:  MOVWF  FF7
1B43A:  MOVLW  00
1B43C:  MOVWF  FF8
1B43E:  CALL   058C
....................    return; 
1B442:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Antenna_Deploy() 
.................... { 
....................    fprintf(PC,"Ant Dep Attempt No: %x\r\n",BC_ATTEMPT_FLAG); 
*
1A37A:  MOVLW  BC
1A37C:  MOVWF  FF6
1A37E:  MOVLW  0E
1A380:  MOVWF  FF7
1A382:  MOVLW  00
1A384:  MOVWF  FF8
1A386:  MOVLW  14
1A388:  MOVLB  3
1A38A:  MOVWF  xA2
1A38C:  MOVLB  0
1A38E:  CALL   0702
1A392:  MOVFF  68,3A2
1A396:  MOVLW  57
1A398:  MOVLB  3
1A39A:  MOVWF  xA3
1A39C:  MOVLB  0
1A39E:  CALL   0734
1A3A2:  MOVLW  0D
1A3A4:  BTFSS  F9E.4
1A3A6:  BRA    1A3A4
1A3A8:  MOVWF  FAD
1A3AA:  MOVLW  0A
1A3AC:  BTFSS  F9E.4
1A3AE:  BRA    1A3AC
1A3B0:  MOVWF  FAD
....................     
....................    if(BC_ATTEMPT_FLAG < 4 && BC_ATTEMPT_FLAG != 0)                               //SE REPETIRA 3 VECES MAS LUEGO DEL PRIMER DESPLIEGUE, SEA EXITOSO O NO 
1A3B2:  MOVF   x68,W
1A3B4:  SUBLW  03
1A3B6:  BNC   1A460
1A3B8:  MOVF   x68,F
1A3BA:  BZ    1A460
....................    { 
....................       //SAVE_SAT_LOG(0xBC,BC_ATTEMPT_FLAG,BC_ATTEMPT_FLAG); 
....................       fprintf(PC,"BC command sent to RESET PIC\r\n"); 
1A3BC:  MOVLW  D6
1A3BE:  MOVWF  FF6
1A3C0:  MOVLW  0E
1A3C2:  MOVWF  FF7
1A3C4:  MOVLW  00
1A3C6:  MOVWF  FF8
1A3C8:  CALL   058C
....................       for(int num = 0; num < 50; num++) 
1A3CC:  MOVLB  3
1A3CE:  CLRF   x2C
1A3D0:  MOVF   x2C,W
1A3D2:  SUBLW  31
1A3D4:  BNC   1A3F0
....................       { 
....................          fputc(0xBC,reset); 
1A3D6:  MOVLW  BC
1A3D8:  MOVLB  0
1A3DA:  CALL   15B0
....................          delay_ms(10); 
1A3DE:  MOVLW  0A
1A3E0:  MOVLB  3
1A3E2:  MOVWF  x98
1A3E4:  MOVLB  0
1A3E6:  CALL   0526
1A3EA:  MOVLB  3
1A3EC:  INCF   x2C,F
1A3EE:  BRA    1A3D0
....................       } 
....................       delay_ms(1000); 
1A3F0:  MOVLW  04
1A3F2:  MOVWF  x2D
1A3F4:  MOVLW  FA
1A3F6:  MOVWF  x98
1A3F8:  MOVLB  0
1A3FA:  CALL   0526
1A3FE:  MOVLB  3
1A400:  DECFSZ x2D,F
1A402:  BRA    1A3F4
....................       if(reset_bffr[0] == 0xCB)                                                  //check the headear of reset respond 
1A404:  MOVLB  0
1A406:  MOVF   x9E,W
1A408:  SUBLW  CB
1A40A:  BNZ   1A460
....................       { 
....................          RESET_DATA = 0; 
1A40C:  CLRF   x9D
....................          BC_OPERATION();                                                         //Turn ON BC for 30s and read temperature 
1A40E:  RCALL  1A1AE
....................          BC_ATTEMPT_FLAG++;                                                      //increase attempt Flag 
1A410:  INCF   x68,F
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1A412:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //guarda los flags en la EEPROM a partir de la direccion 0x18000 (75%) 
1A416:  CALL   11C84
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //guarda los datos de direcciones, en un nuevo sector si se cumple el ciclo de R/W 
1A41A:  CALL   144C8
....................          reset_bffr[0] = 0; 
1A41E:  CLRF   x9E
....................          CMD_FROM_PC[1] = 0; 
1A420:  CLRF   x7F
....................          RESET_DATA = 0; 
1A422:  CLRF   x9D
....................          delay_ms(1000); 
1A424:  MOVLW  04
1A426:  MOVLB  3
1A428:  MOVWF  x2D
1A42A:  MOVLW  FA
1A42C:  MOVWF  x98
1A42E:  MOVLB  0
1A430:  CALL   0526
1A434:  MOVLB  3
1A436:  DECFSZ x2D,F
1A438:  BRA    1A42A
....................          delay_ms(20000);                                                        //wait until RESET goes back to nomal loop 
1A43A:  MOVLW  50
1A43C:  MOVWF  x2D
1A43E:  MOVLW  FA
1A440:  MOVWF  x98
1A442:  MOVLB  0
1A444:  CALL   0526
1A448:  MOVLB  3
1A44A:  DECFSZ x2D,F
1A44C:  BRA    1A43E
....................          SAVE_SAT_LOG(0xBC,BC_ATTEMPT_FLAG,BC_ATTEMPT_FLAG); 
1A44E:  MOVLW  BC
1A450:  MOVWF  x53
1A452:  MOVFF  68,354
1A456:  MOVFF  68,355
1A45A:  MOVLB  0
1A45C:  CALL   16EE2
....................       } 
....................    } 
....................    return; 
1A460:  RETURN 0
.................... } 
....................  
.................... //--------FAB HK collection---------------------------------------------------- 
.................... #ORG 0x00019000 
.................... void REFLESH_MSN_ACK_for_COM()                                                   //clear array ACK_for_COM[i] from position 12 to 22 
.................... { 
....................    for(int i = 12; i < 23; i++) 
*
1AD70:  MOVLW  0C
1AD72:  MOVLB  3
1AD74:  MOVWF  x3A
1AD76:  MOVF   x3A,W
1AD78:  SUBLW  16
1AD7A:  BNC   1AD90
....................    { 
....................       ACK_for_COM[i] = 0x00; 
1AD7C:  CLRF   03
1AD7E:  MOVF   x3A,W
1AD80:  ADDLW  E3
1AD82:  MOVWF  FE9
1AD84:  MOVLW  01
1AD86:  ADDWFC 03,W
1AD88:  MOVWF  FEA
1AD8A:  CLRF   FEF
1AD8C:  INCF   x3A,F
1AD8E:  BRA    1AD76
....................    } 
....................    return; 
1AD90:  MOVLB  0
1AD92:  RETURN 0
.................... } 
....................  
.................... //--------ADCS MISSION--------------------------------------------------------- 
.................... ////////////////////////////////////////////////// 
.................... //ADCS MISSION ID: 0x45                         // 
.................... //ADCS MISSION DATA COLLECT: 55                 // 
.................... //ADCS SENSOR SAMPLING: 0x34                    //   
.................... //ADCS ACK: 0x55                                // 
.................... //ADCS Finish Storing: 0x67                     // 
.................... ////////////////////////////////////////////////// 
....................  
.................... #ORG 0x00019000 
.................... void GET_ADCS_SENSOR_DATA()                                                      //after that, method will changed (ADCS make format and just send to MAIN PIC) 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
*
19450:  CALL   1AA6
....................    fputc(0x34,adcs);                                                             //send command (just collect sensor) 
19454:  MOVLW  34
19456:  MOVLB  3
19458:  MOVWF  x84
1945A:  MOVLB  0
1945C:  CALL   14DA
....................    //delay_ms(700); 
....................    ADCS_ACK = 0; 
19460:  CLRF   x9B
....................    for(int32 num = 0; num < 1000000; num++) 
19462:  MOVLB  3
19464:  CLRF   x43
19466:  CLRF   x42
19468:  CLRF   x41
1946A:  CLRF   x40
1946C:  MOVF   x43,F
1946E:  BNZ   194AA
19470:  MOVF   x42,W
19472:  SUBLW  0F
19474:  BNC   194AA
19476:  BNZ   19486
19478:  MOVF   x41,W
1947A:  SUBLW  42
1947C:  BNC   194AA
1947E:  BNZ   19486
19480:  MOVF   x40,W
19482:  SUBLW  3F
19484:  BNC   194AA
....................    { 
....................       if(kbhit(ADCS)) 
19486:  BTFSC  F85.6
19488:  BRA    19498
....................       { 
....................          ADCS_ACK = fgetc(ADCS); 
1948A:  MOVLB  0
1948C:  CALL   1520
19490:  MOVFF  01,9B
....................          break; 
19494:  MOVLB  3
19496:  BRA    194AA
....................       } 
19498:  MOVLW  01
1949A:  ADDWF  x40,F
1949C:  BTFSC  FD8.0
1949E:  INCF   x41,F
194A0:  BTFSC  FD8.2
194A2:  INCF   x42,F
194A4:  BTFSC  FD8.2
194A6:  INCF   x43,F
194A8:  BRA    1946C
....................        
....................    } 
....................    int8 counter = 0; 
194AA:  CLRF   x44
....................    if(ADCS_ACK == 0x55)                                                          //acknowledge 
194AC:  MOVLB  0
194AE:  MOVF   x9B,W
194B0:  SUBLW  55
194B2:  BNZ   19524
....................    { 
....................       for(int32 num = 0; num < 1000000; num++) 
194B4:  MOVLB  3
194B6:  CLRF   x48
194B8:  CLRF   x47
194BA:  CLRF   x46
194BC:  CLRF   x45
194BE:  MOVF   x48,F
194C0:  BNZ   19522
194C2:  MOVF   x47,W
194C4:  SUBLW  0F
194C6:  BNC   19522
194C8:  BNZ   194D8
194CA:  MOVF   x46,W
194CC:  SUBLW  42
194CE:  BNC   19522
194D0:  BNZ   194D8
194D2:  MOVF   x45,W
194D4:  SUBLW  3F
194D6:  BNC   19522
....................       { 
....................          if(kbhit(ADCS)) 
194D8:  BTFSC  F85.6
194DA:  BRA    19510
....................          { 
....................             ADCS_SENSOR_DATA[counter] = fgetc(ADCS); 
194DC:  CLRF   03
194DE:  MOVF   x44,W
194E0:  ADDLW  FB
194E2:  MOVWF  FE9
194E4:  MOVLW  01
194E6:  ADDWFC 03,W
194E8:  MOVWF  FEA
194EA:  MOVFF  FEA,34C
194EE:  MOVFF  FE9,34B
194F2:  MOVLB  0
194F4:  CALL   1520
194F8:  MOVFF  34C,FEA
194FC:  MOVFF  34B,FE9
19500:  MOVFF  01,FEF
....................             counter++; 
19504:  MOVLB  3
19506:  INCF   x44,F
....................             if(counter == 61) 
19508:  MOVF   x44,W
1950A:  SUBLW  3D
1950C:  BNZ   19510
....................             { 
....................                break; 
1950E:  BRA    19522
....................             } 
....................          } 
19510:  MOVLW  01
19512:  ADDWF  x45,F
19514:  BTFSC  FD8.0
19516:  INCF   x46,F
19518:  BTFSC  FD8.2
1951A:  INCF   x47,F
1951C:  BTFSC  FD8.2
1951E:  INCF   x48,F
19520:  BRA    194BE
19522:  MOVLB  0
....................       } 
....................    } 
....................    CHECK_50_and_CW_RESPOND(); 
19524:  CALL   1AA6
....................    if(ADCS_SENSOR_DATA[0] == 0x57) 
19528:  MOVLB  1
1952A:  MOVF   xFB,W
1952C:  SUBLW  57
1952E:  BNZ   19546
....................    { 
....................       fprintf(PC,"\r\nADCS DATA received\r\n");    
19530:  MOVLW  F6
19532:  MOVWF  FF6
19534:  MOVLW  0E
19536:  MOVWF  FF7
19538:  MOVLW  00
1953A:  MOVWF  FF8
1953C:  MOVLB  0
1953E:  CALL   058C
....................    }else{ 
19542:  BRA    1955C
19544:  MOVLB  1
....................       fprintf(PC,"\r\nADCS DATA not received\r\n"); 
19546:  MOVLW  0E
19548:  MOVWF  FF6
1954A:  MOVLW  0F
1954C:  MOVWF  FF7
1954E:  MOVLW  00
19550:  MOVWF  FF8
19552:  MOVLB  0
19554:  CALL   058C
....................       ADCS_ACK_COMMING = 0; 
19558:  CLRF   x9C
....................       ADCS_ACK = 0; 
1955A:  CLRF   x9B
....................    } 
....................    return; 
1955C:  RETURN 0
.................... } 
....................  
.................... /////////TLE JOIN PART///////////// 
.................... #ORG 0x00019000 
.................... void ADCS_TLE_JOIN(int8 seq,int8 data1,int8 data2,int8 data3,int8 data4,int8 data5)  //join and save TLE data 
*
1B0DC:  MOVLB  3
1B0DE:  CLRF   x3D
.................... { 
....................    int pos=0;    
....................    switch(seq) 
1B0E0:  MOVLW  01
1B0E2:  SUBWF  x37,W
1B0E4:  ADDLW  F1
1B0E6:  BC    1B16A
1B0E8:  ADDLW  0F
1B0EA:  MOVLB  0
1B0EC:  GOTO   2582
....................    { 
....................       case 0x01: 
....................          pos=1;  
1B0F0:  MOVLW  01
1B0F2:  MOVLB  3
1B0F4:  MOVWF  x3D
....................          break; 
1B0F6:  BRA    1B16A
....................       case 0x02: 
....................          pos=6;  
1B0F8:  MOVLW  06
1B0FA:  MOVLB  3
1B0FC:  MOVWF  x3D
....................          break; 
1B0FE:  BRA    1B16A
....................       case 0x03: 
....................          pos=11;  
1B100:  MOVLW  0B
1B102:  MOVLB  3
1B104:  MOVWF  x3D
....................          break; 
1B106:  BRA    1B16A
....................       case 0x04: 
....................          pos=16;  
1B108:  MOVLW  10
1B10A:  MOVLB  3
1B10C:  MOVWF  x3D
....................          break; 
1B10E:  BRA    1B16A
....................       case 0x05: 
....................          pos=21;  
1B110:  MOVLW  15
1B112:  MOVLB  3
1B114:  MOVWF  x3D
....................          break; 
1B116:  BRA    1B16A
....................       case 0x06: 
....................          pos=26;  
1B118:  MOVLW  1A
1B11A:  MOVLB  3
1B11C:  MOVWF  x3D
....................          break; 
1B11E:  BRA    1B16A
....................       case 0x07: 
....................          pos=31;  
1B120:  MOVLW  1F
1B122:  MOVLB  3
1B124:  MOVWF  x3D
....................          break; 
1B126:  BRA    1B16A
....................       case 0x08: 
....................          pos=36;  
1B128:  MOVLW  24
1B12A:  MOVLB  3
1B12C:  MOVWF  x3D
....................          break; 
1B12E:  BRA    1B16A
....................       case 0x09: 
....................          pos=41;  
1B130:  MOVLW  29
1B132:  MOVLB  3
1B134:  MOVWF  x3D
....................          break; 
1B136:  BRA    1B16A
....................       case 0x0A: 
....................          pos=46;  
1B138:  MOVLW  2E
1B13A:  MOVLB  3
1B13C:  MOVWF  x3D
....................          break; 
1B13E:  BRA    1B16A
....................       case 0x0B: 
....................          pos=51;  
1B140:  MOVLW  33
1B142:  MOVLB  3
1B144:  MOVWF  x3D
....................          break; 
1B146:  BRA    1B16A
....................       case 0x0C: 
....................          pos=56;  
1B148:  MOVLW  38
1B14A:  MOVLB  3
1B14C:  MOVWF  x3D
....................          break; 
1B14E:  BRA    1B16A
....................       case 0x0D: 
....................          pos=61;  
1B150:  MOVLW  3D
1B152:  MOVLB  3
1B154:  MOVWF  x3D
....................          break; 
1B156:  BRA    1B16A
....................       case 0x0E: 
....................          pos=66;  
1B158:  MOVLW  42
1B15A:  MOVLB  3
1B15C:  MOVWF  x3D
....................          break; 
1B15E:  BRA    1B16A
....................       case 0x0F: 
....................          pos=71;  
1B160:  MOVLW  47
1B162:  MOVLB  3
1B164:  MOVWF  x3D
....................          break; 
1B166:  BRA    1B16A
1B168:  MOVLB  3
....................    } 
....................  
....................    output_low(PIN_C4); 
1B16A:  BCF    F94.4
1B16C:  BCF    F8B.4
....................    output_low(PIN_A5); 
1B16E:  BCF    F92.5
1B170:  BCF    F89.5
....................    delay_ms(100); 
1B172:  MOVLW  64
1B174:  MOVWF  x98
1B176:  MOVLB  0
1B178:  CALL   0526
....................    for(int c = 0; c < TLE_size; c++)                                           // Read TLE data from flash and put in TLE[] array 
1B17C:  MOVLB  3
1B17E:  CLRF   x3E
1B180:  MOVF   x3E,W
1B182:  SUBLW  4C
1B184:  BNC   1B1D8
....................       { 
....................          TLE[c]=READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+c); 
1B186:  CLRF   03
1B188:  MOVF   x3E,W
1B18A:  ADDLW  96
1B18C:  MOVWF  01
1B18E:  MOVLW  01
1B190:  ADDWFC 03,F
1B192:  MOVFF  01,341
1B196:  MOVFF  03,342
1B19A:  MOVF   x3E,W
1B19C:  ADDWF  54,W
1B19E:  MOVWF  x43
1B1A0:  MOVLW  00
1B1A2:  ADDWFC 55,W
1B1A4:  MOVWF  x44
1B1A6:  MOVLW  00
1B1A8:  ADDWFC 56,W
1B1AA:  MOVWF  x45
1B1AC:  MOVLW  00
1B1AE:  ADDWFC 57,W
1B1B0:  MOVWF  x46
1B1B2:  MOVWF  xAB
1B1B4:  MOVFF  345,3AA
1B1B8:  MOVFF  344,3A9
1B1BC:  MOVFF  343,3A8
1B1C0:  MOVLB  0
1B1C2:  CALL   121C0
1B1C6:  MOVFF  342,FEA
1B1CA:  MOVFF  341,FE9
1B1CE:  MOVFF  01,FEF
1B1D2:  MOVLB  3
1B1D4:  INCF   x3E,F
1B1D6:  BRA    1B180
....................       } 
....................       REFRESH_SECTOR_OF(0x06,0x65,0x00,0x00);                                    // Clear flash memory TO SAVE NEW DATA 
1B1D8:  MOVLW  06
1B1DA:  MOVWF  x47
1B1DC:  MOVLW  65
1B1DE:  MOVWF  x48
1B1E0:  CLRF   x49
1B1E2:  CLRF   x4A
1B1E4:  MOVLB  0
1B1E6:  CALL   170D2
....................       REFRESH_SECTOR_SCF(0x06,0x65,0x00,0x00); 
1B1EA:  MOVLW  06
1B1EC:  MOVLB  3
1B1EE:  MOVWF  x47
1B1F0:  MOVLW  65
1B1F2:  MOVWF  x48
1B1F4:  CLRF   x49
1B1F6:  CLRF   x4A
1B1F8:  MOVLB  0
1B1FA:  CALL   17182
....................       REFRESH_SECTOR_SMF(0x06,0x65,0x00,0x00); 
1B1FE:  MOVLW  06
1B200:  MOVLB  3
1B202:  MOVWF  x47
1B204:  MOVLW  65
1B206:  MOVWF  x48
1B208:  CLRF   x49
1B20A:  CLRF   x4A
1B20C:  MOVLB  0
1B20E:  CALL   1701E
....................        
....................       TLE[0] = 0xAA; 
1B212:  MOVLW  AA
1B214:  MOVLB  1
1B216:  MOVWF  x96
....................       TLE[pos] = data1;                                                          //update TLE[] array data 
1B218:  CLRF   03
1B21A:  MOVLB  3
1B21C:  MOVF   x3D,W
1B21E:  ADDLW  96
1B220:  MOVWF  FE9
1B222:  MOVLW  01
1B224:  ADDWFC 03,W
1B226:  MOVWF  FEA
1B228:  MOVFF  338,FEF
....................       TLE[pos+1] = data2;                                                       
1B22C:  MOVLW  01
1B22E:  ADDWF  x3D,W
1B230:  CLRF   03
1B232:  ADDLW  96
1B234:  MOVWF  FE9
1B236:  MOVLW  01
1B238:  ADDWFC 03,W
1B23A:  MOVWF  FEA
1B23C:  MOVFF  339,FEF
....................       TLE[pos+2] = data3;                                                       
1B240:  MOVLW  02
1B242:  ADDWF  x3D,W
1B244:  CLRF   03
1B246:  ADDLW  96
1B248:  MOVWF  FE9
1B24A:  MOVLW  01
1B24C:  ADDWFC 03,W
1B24E:  MOVWF  FEA
1B250:  MOVFF  33A,FEF
....................       TLE[pos+3] = data4;                                                       
1B254:  MOVLW  03
1B256:  ADDWF  x3D,W
1B258:  CLRF   03
1B25A:  ADDLW  96
1B25C:  MOVWF  FE9
1B25E:  MOVLW  01
1B260:  ADDWFC 03,W
1B262:  MOVWF  FEA
1B264:  MOVFF  33B,FEF
....................       TLE[pos+4] = data5; 
1B268:  MOVLW  04
1B26A:  ADDWF  x3D,W
1B26C:  CLRF   03
1B26E:  ADDLW  96
1B270:  MOVWF  FE9
1B272:  MOVLW  01
1B274:  ADDWFC 03,W
1B276:  MOVWF  FEA
1B278:  MOVFF  33C,FEF
....................       TLE[TLE_size] = 0xBB; 
1B27C:  MOVLW  BB
1B27E:  MOVLB  1
1B280:  MOVWF  xE3
....................        
....................    for(int i = 0; i < TLE_size; i++)                                             // save everything to flash memory 
1B282:  MOVLB  3
1B284:  CLRF   x3F
1B286:  MOVF   x3F,W
1B288:  SUBLW  4C
1B28A:  BNC   1B356
....................       { 
....................          WRITE_DATA_BYTE_OF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B28C:  MOVF   x3F,W
1B28E:  ADDWF  54,W
1B290:  MOVWF  x41
1B292:  MOVLW  00
1B294:  ADDWFC 55,W
1B296:  MOVWF  x42
1B298:  MOVLW  00
1B29A:  ADDWFC 56,W
1B29C:  MOVWF  x43
1B29E:  MOVLW  00
1B2A0:  ADDWFC 57,W
1B2A2:  MOVWF  x44
1B2A4:  CLRF   03
1B2A6:  MOVF   x3F,W
1B2A8:  ADDLW  96
1B2AA:  MOVWF  FE9
1B2AC:  MOVLW  01
1B2AE:  ADDWFC 03,W
1B2B0:  MOVWF  FEA
1B2B2:  MOVFF  FEF,394
1B2B6:  MOVFF  344,393
1B2BA:  MOVFF  343,392
1B2BE:  MOVFF  342,391
1B2C2:  MOVFF  341,390
1B2C6:  MOVLB  0
1B2C8:  CALL   119A4
....................          WRITE_DATA_BYTE_SCF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B2CC:  MOVLB  3
1B2CE:  MOVF   x3F,W
1B2D0:  ADDWF  54,W
1B2D2:  MOVWF  x41
1B2D4:  MOVLW  00
1B2D6:  ADDWFC 55,W
1B2D8:  MOVWF  x42
1B2DA:  MOVLW  00
1B2DC:  ADDWFC 56,W
1B2DE:  MOVWF  x43
1B2E0:  MOVLW  00
1B2E2:  ADDWFC 57,W
1B2E4:  MOVWF  x44
1B2E6:  CLRF   03
1B2E8:  MOVF   x3F,W
1B2EA:  ADDLW  96
1B2EC:  MOVWF  FE9
1B2EE:  MOVLW  01
1B2F0:  ADDWFC 03,W
1B2F2:  MOVWF  FEA
1B2F4:  MOVFF  FEF,394
1B2F8:  MOVFF  344,393
1B2FC:  MOVFF  343,392
1B300:  MOVFF  342,391
1B304:  MOVFF  341,390
1B308:  MOVLB  0
1B30A:  CALL   11ACE
....................          WRITE_DATA_BYTE_SMF(ADCS_TLE_ADDRESS + i,TLE[i]); 
1B30E:  MOVLB  3
1B310:  MOVF   x3F,W
1B312:  ADDWF  54,W
1B314:  MOVWF  x41
1B316:  MOVLW  00
1B318:  ADDWFC 55,W
1B31A:  MOVWF  x42
1B31C:  MOVLW  00
1B31E:  ADDWFC 56,W
1B320:  MOVWF  x43
1B322:  MOVLW  00
1B324:  ADDWFC 57,W
1B326:  MOVWF  x44
1B328:  CLRF   03
1B32A:  MOVF   x3F,W
1B32C:  ADDLW  96
1B32E:  MOVWF  FE9
1B330:  MOVLW  01
1B332:  ADDWFC 03,W
1B334:  MOVWF  FEA
1B336:  MOVFF  FEF,394
1B33A:  MOVFF  344,393
1B33E:  MOVFF  343,392
1B342:  MOVFF  342,391
1B346:  MOVFF  341,390
1B34A:  MOVLB  0
1B34C:  CALL   11C04
1B350:  MOVLB  3
1B352:  INCF   x3F,F
1B354:  BRA    1B286
....................       } 
....................  
....................    fprintf(PC,"\r\nTLE:\r\n"); 
1B356:  MOVLW  2A
1B358:  MOVWF  FF6
1B35A:  MOVLW  0F
1B35C:  MOVWF  FF7
1B35E:  MOVLW  00
1B360:  MOVWF  FF8
1B362:  MOVLB  0
1B364:  CALL   058C
....................    for(int p = 0; p < TLE_size; p++)                                                 // print TLE data 
1B368:  MOVLB  3
1B36A:  CLRF   x40
1B36C:  MOVF   x40,W
1B36E:  SUBLW  4C
1B370:  BNC   1B3C0
....................       { 
....................          fprintf(PC,"%x,",READ_DATA_BYTE_OF(ADCS_TLE_ADDRESS+p)); 
1B372:  MOVF   x40,W
1B374:  ADDWF  54,W
1B376:  MOVWF  x41
1B378:  MOVLW  00
1B37A:  ADDWFC 55,W
1B37C:  MOVWF  x42
1B37E:  MOVLW  00
1B380:  ADDWFC 56,W
1B382:  MOVWF  x43
1B384:  MOVLW  00
1B386:  ADDWFC 57,W
1B388:  MOVWF  x44
1B38A:  MOVWF  xAB
1B38C:  MOVFF  343,3AA
1B390:  MOVFF  342,3A9
1B394:  MOVFF  341,3A8
1B398:  MOVLB  0
1B39A:  CALL   121C0
1B39E:  MOVFF  01,341
1B3A2:  MOVFF  01,3A2
1B3A6:  MOVLW  57
1B3A8:  MOVLB  3
1B3AA:  MOVWF  xA3
1B3AC:  MOVLB  0
1B3AE:  CALL   0734
1B3B2:  MOVLW  2C
1B3B4:  BTFSS  F9E.4
1B3B6:  BRA    1B3B4
1B3B8:  MOVWF  FAD
1B3BA:  MOVLB  3
1B3BC:  INCF   x40,F
1B3BE:  BRA    1B36C
....................       } 
....................       fprintf(PC,"\r\n"); 
1B3C0:  MOVLW  0D
1B3C2:  BTFSS  F9E.4
1B3C4:  BRA    1B3C2
1B3C6:  MOVWF  FAD
1B3C8:  MOVLW  0A
1B3CA:  BTFSS  F9E.4
1B3CC:  BRA    1B3CA
1B3CE:  MOVWF  FAD
....................    output_high(PIN_C4); 
1B3D0:  BCF    F94.4
1B3D2:  BSF    F8B.4
....................    return; 
1B3D4:  MOVLB  0
1B3D6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Delete_in_HK()                                                              //Borra el array in_HK[118] 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
*
190C8:  MOVLB  3
190CA:  CLRF   x3E
190CC:  MOVF   x3E,W
190CE:  SUBLW  7B
190D0:  BNC   190E6
....................    { 
....................       in_HK[num] = 0; 
190D2:  CLRF   03
190D4:  MOVF   x3E,W
190D6:  ADDLW  50
190D8:  MOVWF  FE9
190DA:  MOVLW  02
190DC:  ADDWFC 03,W
190DE:  MOVWF  FEA
190E0:  CLRF   FEF
190E2:  INCF   x3E,F
190E4:  BRA    190CC
....................    } 
....................    return; 
190E6:  MOVLB  0
190E8:  RETURN 0
.................... } 
.................... ////////////////////////////////////// 
.................... #ORG 0x00019000 
.................... void Delete_HKDATA()                                                             //funcion que borra el array HKDATA[118] 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
190EA:  MOVLB  3
190EC:  CLRF   x4D
190EE:  MOVF   x4D,W
190F0:  SUBLW  7B
190F2:  BNC   19108
....................    { 
....................       HKDATA[num] = 0; 
190F4:  CLRF   03
190F6:  MOVF   x4D,W
190F8:  ADDLW  7D
190FA:  MOVWF  FE9
190FC:  MOVLW  02
190FE:  ADDWFC 03,W
19100:  MOVWF  FEA
19102:  CLRF   FEF
19104:  INCF   x4D,F
19106:  BRA    190EE
....................    } 
....................    return; 
19108:  MOVLB  0
1910A:  RETURN 0
.................... } 
.................... #ORG 0x00019000 
.................... void Delete_CWFORMAT()                                                           //borra el array CW_FORMAT[5] 
.................... { 
....................    for(int num = 0; num < CW_size; num++) 
*
195DC:  MOVLB  3
195DE:  CLRF   x3E
195E0:  MOVF   x3E,W
195E2:  SUBLW  04
195E4:  BNC   195FA
....................    { 
....................       CW_FORMAT[num] = 0; 
195E6:  CLRF   03
195E8:  MOVF   x3E,W
195EA:  ADDLW  4B
195EC:  MOVWF  FE9
195EE:  MOVLW  02
195F0:  ADDWFC 03,W
195F2:  MOVWF  FEA
195F4:  CLRF   FEF
195F6:  INCF   x3E,F
195F8:  BRA    195E0
....................    } 
....................    return; 
195FA:  MOVLB  0
195FC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CHECK_SUNSHINE(int8 current) 
.................... { 
....................    if(current > EX_PANEL_THRESHHOLD) 
*
19646:  MOVLB  3
19648:  MOVF   x3E,W
1964A:  SUBLW  14
1964C:  BC    19656
....................    { 
....................       return 1; 
1964E:  MOVLW  01
19650:  MOVWF  01
19652:  BRA    1965A
....................    }else{ 
19654:  BRA    1965A
....................       return 0; 
19656:  MOVLW  00
19658:  MOVWF  01
....................    } 
1965A:  MOVLB  0
1965C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_X(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for X 
*
19742:  MOVFF  33E,341
19746:  MOVFF  33F,340
1974A:  MOVFF  341,347
1974E:  MOVFF  340,346
19752:  CALL   1B3C
19756:  MOVFF  03,351
1975A:  MOVFF  02,350
1975E:  MOVFF  01,34F
19762:  MOVFF  00,34E
19766:  MOVLW  29
19768:  MOVLB  3
1976A:  MOVWF  x55
1976C:  MOVLW  5C
1976E:  MOVWF  x54
19770:  MOVLW  0F
19772:  MOVWF  x53
19774:  MOVLW  78
19776:  MOVWF  x52
19778:  MOVLB  0
1977A:  CALL   1B8C
1977E:  MOVFF  03,349
19782:  MOVFF  02,348
19786:  MOVFF  01,347
1978A:  MOVFF  00,346
1978E:  BSF    FD8.1
19790:  MOVFF  03,34D
19794:  MOVFF  02,34C
19798:  MOVFF  01,34B
1979C:  MOVFF  00,34A
197A0:  MOVLW  DB
197A2:  MOVLB  3
197A4:  MOVWF  x51
197A6:  MOVLW  BF
197A8:  MOVWF  x50
197AA:  MOVLW  72
197AC:  MOVWF  x4F
197AE:  MOVLW  7B
197B0:  MOVWF  x4E
197B2:  MOVLB  0
197B4:  CALL   1C82
197B8:  MOVFF  03,345
197BC:  MOVFF  02,344
197C0:  MOVFF  01,343
197C4:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.11853; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
197C8:  MOVFF  345,349
197CC:  MOVFF  344,348
197D0:  MOVFF  343,347
197D4:  MOVFF  342,346
197D8:  CALL   1EFA
197DC:  MOVF   01,W
197DE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_Y(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for Y 
197E0:  MOVFF  33E,341
197E4:  MOVFF  33F,340
197E8:  MOVFF  341,347
197EC:  MOVFF  340,346
197F0:  CALL   1B3C
197F4:  MOVFF  03,351
197F8:  MOVFF  02,350
197FC:  MOVFF  01,34F
19800:  MOVFF  00,34E
19804:  MOVLW  29
19806:  MOVLB  3
19808:  MOVWF  x55
1980A:  MOVLW  5C
1980C:  MOVWF  x54
1980E:  MOVLW  0F
19810:  MOVWF  x53
19812:  MOVLW  78
19814:  MOVWF  x52
19816:  MOVLB  0
19818:  CALL   1B8C
1981C:  MOVFF  03,349
19820:  MOVFF  02,348
19824:  MOVFF  01,347
19828:  MOVFF  00,346
1982C:  BSF    FD8.1
1982E:  MOVFF  03,34D
19832:  MOVFF  02,34C
19836:  MOVFF  01,34B
1983A:  MOVFF  00,34A
1983E:  MOVLW  98
19840:  MOVLB  3
19842:  MOVWF  x51
19844:  MOVLW  69
19846:  MOVWF  x50
19848:  MOVLW  7B
1984A:  MOVWF  x4F
1984C:  MOVLW  7C
1984E:  MOVWF  x4E
19850:  MOVLB  0
19852:  CALL   1C82
19856:  MOVFF  03,345
1985A:  MOVFF  02,344
1985E:  MOVFF  01,343
19862:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.24552; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
19866:  MOVFF  345,349
1986A:  MOVFF  344,348
1986E:  MOVFF  343,347
19872:  MOVFF  342,346
19876:  CALL   1EFA
1987A:  MOVF   01,W
1987C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 CONVERT_16bit_GYRO_to_8bit_Z(int8 HIGH_8bit, int8 LOW_8bit)//caribrated for Z 
1987E:  MOVFF  33E,341
19882:  MOVFF  33F,340
19886:  MOVFF  341,347
1988A:  MOVFF  340,346
1988E:  CALL   1B3C
19892:  MOVFF  03,351
19896:  MOVFF  02,350
1989A:  MOVFF  01,34F
1989E:  MOVFF  00,34E
198A2:  MOVLW  29
198A4:  MOVLB  3
198A6:  MOVWF  x55
198A8:  MOVLW  5C
198AA:  MOVWF  x54
198AC:  MOVLW  0F
198AE:  MOVWF  x53
198B0:  MOVLW  78
198B2:  MOVWF  x52
198B4:  MOVLB  0
198B6:  CALL   1B8C
198BA:  MOVFF  03,349
198BE:  MOVFF  02,348
198C2:  MOVFF  01,347
198C6:  MOVFF  00,346
198CA:  BSF    FD8.1
198CC:  MOVFF  03,34D
198D0:  MOVFF  02,34C
198D4:  MOVFF  01,34B
198D8:  MOVFF  00,34A
198DC:  MOVLW  CF
198DE:  MOVLB  3
198E0:  MOVWF  x51
198E2:  MOVLW  49
198E4:  MOVWF  x50
198E6:  MOVLW  4F
198E8:  MOVWF  x4F
198EA:  MOVLW  7D
198EC:  MOVWF  x4E
198EE:  MOVLB  0
198F0:  CALL   1C82
198F4:  MOVFF  03,345
198F8:  MOVFF  02,344
198FC:  MOVFF  01,343
19900:  MOVFF  00,342
.................... { 
....................    signed int16 row_data = make16(HIGH_8bit, LOW_8bit); 
....................    float ang_v = row_data*0.00875-0.40486; 
....................    /*fprintf(PC,"ang:%.4f\r\n",ang_v);*/ 
....................    return (int8)ang_v;  
19904:  MOVFF  345,349
19908:  MOVFF  344,348
1990C:  MOVFF  343,347
19910:  MOVFF  342,346
19914:  CALL   1EFA
19918:  MOVF   01,W
1991A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... int8 OPERATION_MODE_VALUE(int8 Bat_Vol) 
.................... { 
....................    //0x94HKDATA[116]  
....................    if(Bat_Vol > 0x94){//more than 3.8 
*
195FE:  MOVLB  3
19600:  MOVF   x3E,W
19602:  SUBLW  94
19604:  BC    19616
....................       OPERATION_MODE = 0x11; 
19606:  MOVLW  11
19608:  MOVLB  0
1960A:  MOVWF  x98
....................       return 96; 
1960C:  MOVLW  60
1960E:  MOVWF  01
19610:  BRA    19640
....................    }else if((Bat_Vol > 0x88) && (Bat_Vol <= 0x94)){//3.5 to 3.8 
19612:  BRA    19640
19614:  MOVLB  3
19616:  MOVF   x3E,W
19618:  SUBLW  88
1961A:  BC    19632
1961C:  MOVF   x3E,W
1961E:  SUBLW  94
19620:  BNC   19632
....................       OPERATION_MODE = 0x10; 
19622:  MOVLW  10
19624:  MOVLB  0
19626:  MOVWF  x98
....................       return 64; 
19628:  MOVLW  40
1962A:  MOVWF  01
1962C:  BRA    19640
....................    }else if(Bat_Vol <= 0x88){//less than 3.5 
1962E:  BRA    19640
19630:  MOVLB  3
19632:  MOVF   x3E,W
19634:  SUBLW  88
19636:  BNC   19642
....................       OPERATION_MODE = 0x00; 
19638:  MOVLB  0
1963A:  CLRF   x98
....................       return 16; 
1963C:  MOVLW  10
1963E:  MOVWF  01
19640:  MOVLB  3
....................    } 
19642:  MOVLB  0
19644:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW1_FORMAT()                                                            
.................... { 
....................    Delete_CWFORMAT();                                                            //borra el array CW_FORMAT[5] 
*
1965E:  RCALL  195DC
....................     
....................    CW_FORMAT[0] = HKDATA[44];                                                    //battery voltage 
19660:  MOVFF  2A9,24B
....................    CW_FORMAT[1] = HKDATA[45]<<4|HKDATA[46]>>4;                                   //battery current 
19664:  MOVLB  2
19666:  SWAPF  xAA,W
19668:  MOVLB  3
1966A:  MOVWF  x3E
1966C:  MOVLW  F0
1966E:  ANDWF  x3E,F
19670:  MOVLB  2
19672:  SWAPF  xAB,W
19674:  MOVWF  00
19676:  MOVLW  0F
19678:  ANDWF  00,F
1967A:  MOVF   00,W
1967C:  MOVLB  3
1967E:  IORWF  x3E,W
19680:  MOVLB  2
19682:  MOVWF  x4C
....................    CW_FORMAT[2] = HKDATA[47];                                                    //battery temp 
19684:  MOVFF  2AC,24D
....................     
....................    //   CW_FORMAT[3] = CW_FORMAT[3];//0:CW1 
....................    //   CW_FORMAT[3] = CW_FORMAT[3] + RESERVE_CHECK * 64; 
....................    CW_FORMAT[3] = CW_FORMAT[3] + OPERATION_MODE_VALUE(HKDATA[116]);              //96(=64+32-->0x01100000):nomal, 64(0x01000000):low, 16(0x00100000):safe 
19688:  MOVFF  2F1,33E
1968C:  MOVLB  0
1968E:  RCALL  195FE
19690:  MOVF   01,W
19692:  MOVLB  2
19694:  ADDWF  x4E,F
....................    KILL_FLAG_FAB = (HKDATA[49] & 0x10)>>4; 
19696:  MOVF   xAE,W
19698:  ANDLW  10
1969A:  MOVWF  00
1969C:  SWAPF  00,W
1969E:  MOVLB  0
196A0:  MOVWF  x76
196A2:  MOVLW  0F
196A4:  ANDWF  x76,F
....................    KILL_FLAG_MAIN = HKDATA[49] & 0x01; 
196A6:  MOVLB  2
196A8:  MOVF   xAE,W
196AA:  ANDLW  01
196AC:  MOVLB  0
196AE:  MOVWF  x75
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_MAIN * 16; 
196B0:  MOVF   x75,W
196B2:  MULLW  10
196B4:  MOVF   FF3,W
196B6:  MOVLB  2
196B8:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + KILL_FLAG_FAB * 8; 
196BA:  MOVLB  0
196BC:  MOVF   x76,W
196BE:  MULLW  08
196C0:  MOVF   FF3,W
196C2:  MOVLB  2
196C4:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + ANT_DEP_STATUS * 4; 
196C6:  MOVLB  0
196C8:  MOVF   x7B,W
196CA:  MULLW  04
196CC:  MOVF   FF3,W
196CE:  MOVLB  2
196D0:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + CHECK_SUNSHINE(HKDATA[34]) * 2;                 //+Y Panel (new axis definition) 
196D2:  MOVFF  29F,33E
196D6:  MOVLB  0
196D8:  RCALL  19646
196DA:  BCF    FD8.0
196DC:  RLCF   01,W
196DE:  MOVLB  2
196E0:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + CHECK_SUNSHINE(HKDATA[35]) * 1;                 //+X Panel (new axis definition) 
196E2:  MOVFF  2A0,33E
196E6:  MOVLB  0
196E8:  RCALL  19646
196EA:  MOVF   01,W
196EC:  MOVLB  2
196EE:  ADDWF  x4E,F
....................     
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[36]) * 128;               //-Z Panel (new axis definition) 
196F0:  MOVFF  2A1,33E
196F4:  MOVLB  0
196F6:  RCALL  19646
196F8:  MOVF   01,W
196FA:  MULLW  80
196FC:  MOVF   FF3,W
196FE:  MOVLB  2
19700:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[37]) * 64;                //-X Panel (new axis definition) 
19702:  MOVFF  2A2,33E
19706:  MOVLB  0
19708:  RCALL  19646
1970A:  MOVF   01,W
1970C:  MULLW  40
1970E:  MOVF   FF3,W
19710:  MOVLB  2
19712:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + CHECK_SUNSHINE(HKDATA[38]) * 32;                //+Z Panel (new axis definition) 
19714:  MOVFF  2A3,33E
19718:  MOVLB  0
1971A:  RCALL  19646
1971C:  MOVF   01,W
1971E:  MULLW  20
19720:  MOVF   FF3,W
19722:  MOVLB  2
19724:  ADDWF  x4F,F
....................    CW_FORMAT[4] = CW_FORMAT[4] + (HKDATA[4] & 0b00011111);                       //time data 
19726:  MOVF   x81,W
19728:  ANDLW  1F
1972A:  ADDWF  x4F,F
....................     
....................    CW_IDENTIFIER = 0; 
1972C:  MOVLB  0
1972E:  CLRF   x97
....................    CHECK_50_and_CW_RESPOND(); 
19730:  CALL   1AA6
....................    ACK_for_COM[0] = 0xAA;                                                        //for safety (this byte should be always 0) 
19734:  MOVLW  AA
19736:  MOVLB  1
19738:  MOVWF  xE3
....................    ACK_for_COM[23] = 0xBB;                                                       //for safety (this byte should be always 0) 
1973A:  MOVLW  BB
1973C:  MOVWF  xFA
....................    return; 
1973E:  MOVLB  0
19740:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW2_FORMAT() 
.................... { 
....................    Delete_CWFORMAT(); 
*
1991C:  RCALL  195DC
....................    //CHECK_50_and_CW_RESPOND(); 
....................    CW_FORMAT[0] = CONVERT_16bit_GYRO_to_8bit_X(HKDATA[59], HKDATA[60]);          //GYRO X axis 
1991E:  MOVFF  2B8,33E
19922:  MOVFF  2B9,33F
19926:  RCALL  19742
19928:  MOVFF  01,24B
....................    CW_FORMAT[1] = CONVERT_16bit_GYRO_to_8bit_Y(HKDATA[61], HKDATA[62]);          //GYRO Y axis 
1992C:  MOVFF  2BA,33E
19930:  MOVFF  2BB,33F
19934:  RCALL  197E0
19936:  MOVFF  01,24C
....................    CW_FORMAT[2] = CONVERT_16bit_GYRO_to_8bit_Z(HKDATA[63], HKDATA[64]);          //GYRO Z axis 
1993A:  MOVFF  2BC,33E
1993E:  MOVFF  2BD,33F
19942:  RCALL  1987E
19944:  MOVFF  01,24D
....................     
....................    CW_FORMAT[3] = CW_FORMAT[3] + 128;                                            //1:CW2 
19948:  MOVLW  80
1994A:  MOVLB  2
1994C:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + FIRST_HSSC_DONE * 64;                           //High Sampling Sensor Collection Flag 0:not done, 1:done 
1994E:  MOVLB  0
19950:  MOVF   x77,W
19952:  MULLW  40
19954:  MOVF   FF3,W
19956:  MOVLB  2
19958:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_CAM_DONE * 32;                             //AUTO CAM MISSION DONE 0:not done, 1:done 
1995A:  MOVLB  0
1995C:  MOVF   x78,W
1995E:  MULLW  20
19960:  MOVF   FF3,W
19962:  MOVLB  2
19964:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_MBP_DONE * 16;                             //AUTO MBP MISSION DONE 0:not done, 1:done 
19966:  MOVLB  0
19968:  MOVF   x79,W
1996A:  MULLW  10
1996C:  MOVF   FF3,W
1996E:  MOVLB  2
19970:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + AUTO_ADCS_DONE * 8;                             //AUTO ADCS MISSION DONE 0:not done, 1:done 
19972:  MOVLB  0
19974:  MOVF   x7A,W
19976:  MULLW  08
19978:  MOVF   FF3,W
1997A:  MOVLB  2
1997C:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + HKDATA[48] * 4;                                 //Heater 0:OFF, 1:ON 
1997E:  MOVF   xAD,W
19980:  MULLW  04
19982:  MOVF   FF3,W
19984:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + RESERVE_CHECK * 2;                              //RSV Flag 
19986:  BCF    FD8.0
19988:  MOVLB  0
1998A:  RLCF   x6B,W
1998C:  MOVLB  2
1998E:  ADDWF  x4E,F
....................    CW_FORMAT[3] = CW_FORMAT[3] + UPLINK_SUCCESS;                                 //UPLINK SUCCESS 
19990:  MOVLB  0
19992:  MOVF   x7C,W
19994:  MOVLB  2
19996:  ADDWF  x4E,F
....................     
....................    CW_FORMAT[4] = HKDATA[20]<<4|HKDATA[21]>>4;                                   //BPB_TEMP 
19998:  SWAPF  x91,W
1999A:  MOVLB  3
1999C:  MOVWF  x3E
1999E:  MOVLW  F0
199A0:  ANDWF  x3E,F
199A2:  MOVLB  2
199A4:  SWAPF  x92,W
199A6:  MOVWF  00
199A8:  MOVLW  0F
199AA:  ANDWF  00,F
199AC:  MOVF   00,W
199AE:  MOVLB  3
199B0:  IORWF  x3E,W
199B2:  MOVLB  2
199B4:  MOVWF  x4F
....................  
....................    CW_IDENTIFIER = 1; 
199B6:  MOVLW  01
199B8:  MOVLB  0
199BA:  MOVWF  x97
....................    CHECK_50_and_CW_RESPOND(); 
199BC:  CALL   1AA6
....................    ACK_for_COM[0] = 0xAA;                                                        //for safety (this byte should be always 0) 
199C0:  MOVLW  AA
199C2:  MOVLB  1
199C4:  MOVWF  xE3
....................    ACK_for_COM[23] = 0xBB;                                                       //for safety (this byte should be always 0) 
199C6:  MOVLW  BB
199C8:  MOVWF  xFA
....................     
....................    return; 
199CA:  MOVLB  0
199CC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_CW_FORMAT() 
.................... { 
....................    if(CW_IDENTIFIER) 
199CE:  MOVF   x97,F
199D0:  BZ    199D6
....................    { 
....................       MAKE_CW1_FORMAT(); 
199D2:  RCALL  1965E
....................    }else{ 
199D4:  BRA    199D8
....................       MAKE_CW2_FORMAT(); 
199D6:  RCALL  1991C
....................    } 
199D8:  RETURN 0
.................... } 
....................  
.................... void Send_COMMAND_TO_FAB(int8 cmd)                                               //funcion que envia comandos al FAB 
.................... { 
....................    fputc(cmd,FAB);                                                               //se indica el dato y el puerto 
*
01AC4:  MOVLB  3
01AC6:  MOVF   x4F,W
01AC8:  MOVLB  0
01ACA:  RCALL  1AB8
....................    return; 
01ACC:  RETURN 0
.................... } 
....................  
.................... void COMMAND_TO_FAB(int32 delaytime)                                             //envia comando al FAB para pedir datos 
.................... { 
....................    FAB_DATA = 0; 
01ACE:  MOVLB  2
01AD0:  CLRF   xF9
....................    enable_interrupts(INT_rda3);                                                  //Habilita interrupcion UART FAB para cargar el vector in_HK[] 
01AD2:  BSF    F61.5
....................    Send_Command_to_FAB(0x61);                                                    //send command to fab 
01AD4:  MOVLW  61
01AD6:  MOVLB  3
01AD8:  MOVWF  x4F
01ADA:  MOVLB  0
01ADC:  RCALL  1AC4
....................    /*fprintf(PC,"Command to FAB sent\r\n");*/  
....................    int32 a = 0; 
01ADE:  MOVLB  3
01AE0:  CLRF   x4E
01AE2:  CLRF   x4D
01AE4:  CLRF   x4C
01AE6:  CLRF   x4B
....................    while(FAB_DATA == 0){                                                         //Espera a que la bandera FAB_DATA se ponga en alto 
01AE8:  MOVLB  2
01AEA:  MOVF   xF9,F
01AEC:  BNZ   1B22
....................       a++;                                                                       //la bandera se pone en alto cuando se recibe un dato en el UART 
01AEE:  MOVLW  01
01AF0:  MOVLB  3
01AF2:  ADDWF  x4B,F
01AF4:  BTFSC  FD8.0
01AF6:  INCF   x4C,F
01AF8:  BTFSC  FD8.2
01AFA:  INCF   x4D,F
01AFC:  BTFSC  FD8.2
01AFE:  INCF   x4E,F
....................       if(a > 50000) 
01B00:  MOVF   x4E,F
01B02:  BNZ   1B18
01B04:  MOVF   x4D,F
01B06:  BNZ   1B18
01B08:  MOVF   x4C,W
01B0A:  SUBLW  C2
01B0C:  BC    1B1E
01B0E:  XORLW  FF
01B10:  BNZ   1B18
01B12:  MOVF   x4B,W
01B14:  SUBLW  50
01B16:  BC    1B1E
....................       { 
....................          break; 
01B18:  MOVLB  2
01B1A:  BRA    1B22
01B1C:  MOVLB  3
....................       } 
01B1E:  BRA    1AE8
01B20:  MOVLB  2
....................    } 
....................    waiting(delaytime);                                                           //funcion de espera 
01B22:  MOVFF  34A,388
01B26:  MOVFF  349,387
01B2A:  MOVFF  348,386
01B2E:  MOVFF  347,385
01B32:  MOVLB  0
01B34:  CALL   16A98
....................    disable_interrupts(INT_rda3);                                                 //desabilita interrupcion del UART FAB 
01B38:  BCF    F61.5
....................    return; 
01B3A:  RETURN 0
.................... } 
.................... /* 
.................... int8 ACK_FROM_FAB() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM); 
....................    return ack; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
*
19A5C:  BCF    F94.4
19A5E:  BCF    F8B.4
....................    for(int8 num = 0; num < HK_size; num++) 
19A60:  MOVLB  3
19A62:  CLRF   x46
19A64:  MOVF   x46,W
19A66:  SUBLW  7B
19A68:  BNC   19AB0
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress+num, HKDATA[num]); 
19A6A:  MOVF   x46,W
19A6C:  ADDWF  x42,W
19A6E:  MOVWF  x47
19A70:  MOVLW  00
19A72:  ADDWFC x43,W
19A74:  MOVWF  x48
19A76:  MOVLW  00
19A78:  ADDWFC x44,W
19A7A:  MOVWF  x49
19A7C:  MOVLW  00
19A7E:  ADDWFC x45,W
19A80:  MOVWF  x4A
19A82:  CLRF   03
19A84:  MOVF   x46,W
19A86:  ADDLW  7D
19A88:  MOVWF  FE9
19A8A:  MOVLW  02
19A8C:  ADDWFC 03,W
19A8E:  MOVWF  FEA
19A90:  MOVFF  FEF,394
19A94:  MOVFF  34A,393
19A98:  MOVFF  349,392
19A9C:  MOVFF  348,391
19AA0:  MOVFF  347,390
19AA4:  MOVLB  0
19AA6:  CALL   11ACE
19AAA:  MOVLB  3
19AAC:  INCF   x46,F
19AAE:  BRA    19A64
....................    } 
....................    output_high(PIN_C4); 
19AB0:  BCF    F94.4
19AB2:  BSF    F8B.4
....................    return; 
19AB4:  MOVLB  0
19AB6:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_SCF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_SCF(adress);  //save HK to COM PIC 
19AB8:  MOVFF  341,345
19ABC:  MOVFF  340,344
19AC0:  MOVFF  33F,343
19AC4:  MOVFF  33E,342
19AC8:  RCALL  19A5C
....................    CHECK_50_and_CW_RESPOND(); 
19ACA:  CALL   1AA6
....................    return; 
19ACE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_SMF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_A5); 
19AD0:  BCF    F92.5
19AD2:  BCF    F89.5
....................    for(int8 num = 0; num < HK_size; num++) 
19AD4:  MOVLB  3
19AD6:  CLRF   x46
19AD8:  MOVF   x46,W
19ADA:  SUBLW  7B
19ADC:  BNC   19B24
....................    { 
....................       WRITE_DATA_BYTE_SMF(Memory_Adress+num, HKDATA[num]); 
19ADE:  MOVF   x46,W
19AE0:  ADDWF  x42,W
19AE2:  MOVWF  x47
19AE4:  MOVLW  00
19AE6:  ADDWFC x43,W
19AE8:  MOVWF  x48
19AEA:  MOVLW  00
19AEC:  ADDWFC x44,W
19AEE:  MOVWF  x49
19AF0:  MOVLW  00
19AF2:  ADDWFC x45,W
19AF4:  MOVWF  x4A
19AF6:  CLRF   03
19AF8:  MOVF   x46,W
19AFA:  ADDLW  7D
19AFC:  MOVWF  FE9
19AFE:  MOVLW  02
19B00:  ADDWFC 03,W
19B02:  MOVWF  FEA
19B04:  MOVFF  FEF,394
19B08:  MOVFF  34A,393
19B0C:  MOVFF  349,392
19B10:  MOVFF  348,391
19B14:  MOVFF  347,390
19B18:  MOVLB  0
19B1A:  CALL   11C04
19B1E:  MOVLB  3
19B20:  INCF   x46,F
19B22:  BRA    19AD8
....................    } 
....................    return; 
19B24:  MOVLB  0
19B26:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_SMF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_SMF(adress);  //save HK to COM PIC 
19B28:  MOVFF  341,345
19B2C:  MOVFF  340,344
19B30:  MOVFF  33F,343
19B34:  MOVFF  33E,342
19B38:  RCALL  19AD0
....................    CHECK_50_and_CW_RESPOND(); 
19B3A:  CALL   1AA6
....................    return; 
19B3E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HKDATA_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    int num; 
....................    for(num = 0; num < HK_size; num++) 
19B40:  MOVLB  3
19B42:  CLRF   x46
19B44:  MOVF   x46,W
19B46:  SUBLW  7B
19B48:  BNC   19B90
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress+num, HKDATA[num]); 
19B4A:  MOVF   x46,W
19B4C:  ADDWF  x42,W
19B4E:  MOVWF  x47
19B50:  MOVLW  00
19B52:  ADDWFC x43,W
19B54:  MOVWF  x48
19B56:  MOVLW  00
19B58:  ADDWFC x44,W
19B5A:  MOVWF  x49
19B5C:  MOVLW  00
19B5E:  ADDWFC x45,W
19B60:  MOVWF  x4A
19B62:  CLRF   03
19B64:  MOVF   x46,W
19B66:  ADDLW  7D
19B68:  MOVWF  FE9
19B6A:  MOVLW  02
19B6C:  ADDWFC 03,W
19B6E:  MOVWF  FEA
19B70:  MOVFF  FEF,394
19B74:  MOVFF  34A,393
19B78:  MOVFF  349,392
19B7C:  MOVFF  348,391
19B80:  MOVFF  347,390
19B84:  MOVLB  0
19B86:  CALL   119A4
19B8A:  MOVLB  3
19B8C:  INCF   x46,F
19B8E:  BRA    19B44
....................    } 
....................    return; 
19B90:  MOVLB  0
19B92:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_HKDATA_to_OF(int32 adress) 
.................... { 
....................    Save_HKDATA_to_OF(adress);  //save HK to COM PIC 
19B94:  MOVFF  341,345
19B98:  MOVFF  340,344
19B9C:  MOVFF  33F,343
19BA0:  MOVFF  33E,342
19BA4:  RCALL  19B40
....................    CHECK_50_and_CW_RESPOND(); 
19BA6:  CALL   1AA6
....................    return; 
19BAA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_SCF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_C4); 
19BAC:  BCF    F94.4
19BAE:  BCF    F8B.4
....................    for(int8 num = 0; num < CW_size; num++) 
19BB0:  MOVLB  3
19BB2:  CLRF   x46
19BB4:  MOVF   x46,W
19BB6:  SUBLW  04
19BB8:  BNC   19C00
....................    { 
....................       WRITE_DATA_BYTE_SCF(Memory_Adress+num, CW_FORMAT[num]); 
19BBA:  MOVF   x46,W
19BBC:  ADDWF  x42,W
19BBE:  MOVWF  x47
19BC0:  MOVLW  00
19BC2:  ADDWFC x43,W
19BC4:  MOVWF  x48
19BC6:  MOVLW  00
19BC8:  ADDWFC x44,W
19BCA:  MOVWF  x49
19BCC:  MOVLW  00
19BCE:  ADDWFC x45,W
19BD0:  MOVWF  x4A
19BD2:  CLRF   03
19BD4:  MOVF   x46,W
19BD6:  ADDLW  4B
19BD8:  MOVWF  FE9
19BDA:  MOVLW  02
19BDC:  ADDWFC 03,W
19BDE:  MOVWF  FEA
19BE0:  MOVFF  FEF,394
19BE4:  MOVFF  34A,393
19BE8:  MOVFF  349,392
19BEC:  MOVFF  348,391
19BF0:  MOVFF  347,390
19BF4:  MOVLB  0
19BF6:  CALL   11ACE
19BFA:  MOVLB  3
19BFC:  INCF   x46,F
19BFE:  BRA    19BB4
....................    } 
....................    output_high(PIN_C4); 
19C00:  BCF    F94.4
19C02:  BSF    F8B.4
....................    return; 
19C04:  MOVLB  0
19C06:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_SCF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);                                                 //save HK to COM PIC 
19C08:  MOVFF  341,345
19C0C:  MOVFF  340,344
19C10:  MOVFF  33F,343
19C14:  MOVFF  33E,342
19C18:  RCALL  19BAC
....................    CHECK_50_and_CW_RESPOND(); 
19C1A:  CALL   1AA6
....................    return; 
19C1E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_SMF(unsigned int32 Memory_Adress) 
.................... { 
....................    output_low(PIN_A5); 
19C20:  BCF    F92.5
19C22:  BCF    F89.5
....................    for(int8 num = 0; num < CW_size; num++) 
19C24:  MOVLB  3
19C26:  CLRF   x46
19C28:  MOVF   x46,W
19C2A:  SUBLW  04
19C2C:  BNC   19C74
....................    { 
....................       WRITE_DATA_BYTE_SMF(Memory_Adress+num, CW_FORMAT[num]); 
19C2E:  MOVF   x46,W
19C30:  ADDWF  x42,W
19C32:  MOVWF  x47
19C34:  MOVLW  00
19C36:  ADDWFC x43,W
19C38:  MOVWF  x48
19C3A:  MOVLW  00
19C3C:  ADDWFC x44,W
19C3E:  MOVWF  x49
19C40:  MOVLW  00
19C42:  ADDWFC x45,W
19C44:  MOVWF  x4A
19C46:  CLRF   03
19C48:  MOVF   x46,W
19C4A:  ADDLW  4B
19C4C:  MOVWF  FE9
19C4E:  MOVLW  02
19C50:  ADDWFC 03,W
19C52:  MOVWF  FEA
19C54:  MOVFF  FEF,394
19C58:  MOVFF  34A,393
19C5C:  MOVFF  349,392
19C60:  MOVFF  348,391
19C64:  MOVFF  347,390
19C68:  MOVLB  0
19C6A:  CALL   11C04
19C6E:  MOVLB  3
19C70:  INCF   x46,F
19C72:  BRA    19C28
....................    } 
....................    return; 
19C74:  MOVLB  0
19C76:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_SMF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SMF(adress);  //save HK to COM PIC 
19C78:  MOVFF  341,345
19C7C:  MOVFF  340,344
19C80:  MOVFF  33F,343
19C84:  MOVFF  33E,342
19C88:  RCALL  19C20
....................    CHECK_50_and_CW_RESPOND(); 
19C8A:  CALL   1AA6
....................    fprintf(PC,"\r\nCW SAVED\r\n"); 
19C8E:  MOVLW  34
19C90:  MOVWF  FF6
19C92:  MOVLW  0F
19C94:  MOVWF  FF7
19C96:  MOVLW  00
19C98:  MOVWF  FF8
19C9A:  CALL   058C
....................    return; 
19C9E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_CWFORMAT_TO_OF(unsigned int32 Memory_Adress) 
.................... { 
....................    for(int8 num = 0; num < CW_size; num++) 
*
19000:  MOVLB  3
19002:  CLRF   x81
19004:  MOVF   x81,W
19006:  SUBLW  04
19008:  BNC   19050
....................    { 
....................       WRITE_DATA_BYTE_OF(Memory_Adress+num, CW_FORMAT[num]); 
1900A:  MOVF   x81,W
1900C:  ADDWF  x7D,W
1900E:  MOVWF  x82
19010:  MOVLW  00
19012:  ADDWFC x7E,W
19014:  MOVWF  x83
19016:  MOVLW  00
19018:  ADDWFC x7F,W
1901A:  MOVWF  x84
1901C:  MOVLW  00
1901E:  ADDWFC x80,W
19020:  MOVWF  x85
19022:  CLRF   03
19024:  MOVF   x81,W
19026:  ADDLW  4B
19028:  MOVWF  FE9
1902A:  MOVLW  02
1902C:  ADDWFC 03,W
1902E:  MOVWF  FEA
19030:  MOVFF  FEF,394
19034:  MOVFF  385,393
19038:  MOVFF  384,392
1903C:  MOVFF  383,391
19040:  MOVFF  382,390
19044:  MOVLB  0
19046:  CALL   119A4
1904A:  MOVLB  3
1904C:  INCF   x81,F
1904E:  BRA    19004
....................    } 
....................    return; 
19050:  MOVLB  0
19052:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SEND_CWFORMAT_TO_OF(int32 adress) 
.................... { 
....................    SAVE_CWFORMAT_TO_SCF(adress);                                                 //save HK to COM PIC 
*
19CA0:  MOVFF  341,345
19CA4:  MOVFF  340,344
19CA8:  MOVFF  33F,343
19CAC:  MOVFF  33E,342
19CB0:  RCALL  19BAC
....................    TRANSFER_DATA_NBYTE_TOPC_OF(adress,CW_size);                                  //for checking whether the data saved correctly 
19CB2:  MOVFF  341,345
19CB6:  MOVFF  340,344
19CBA:  MOVFF  33F,343
19CBE:  MOVFF  33E,342
19CC2:  MOVLB  3
19CC4:  CLRF   x49
19CC6:  CLRF   x48
19CC8:  CLRF   x47
19CCA:  MOVLW  05
19CCC:  MOVWF  x46
19CCE:  MOVLB  0
19CD0:  CALL   134B2
....................    CHECK_50_and_CW_RESPOND(); 
19CD4:  CALL   1AA6
....................    return; 
19CD8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_HKDATA(int8 in,int32 delaytime)                                       //funcion que carga el array HKDATA[] 
.................... { 
....................    fprintf(PC,"GET SENSOR DATA\r\n"); 
*
19142:  MOVLW  42
19144:  MOVWF  FF6
19146:  MOVLW  0F
19148:  MOVWF  FF7
1914A:  MOVLW  00
1914C:  MOVWF  FF8
1914E:  CALL   058C
....................    Delete_HKDATA();                                                              //borra el array HKDATA[] 
19152:  RCALL  190EA
....................    waiting(delaytime);                                                           //espera 
19154:  MOVFF  34B,388
19158:  MOVFF  34A,387
1915C:  MOVFF  349,386
19160:  MOVFF  348,385
19164:  CALL   16A98
....................    CHECK_50_and_CW_RESPOND(); 
19168:  CALL   1AA6
....................    for(int num = 1; num < 11 - in; num++)                                        //[FAB] +X,-Y,-Z,+Y,-Xtemp_high,low(array[10] to [17]) 
1916C:  MOVLW  01
1916E:  MOVLB  3
19170:  MOVWF  x4C
19172:  MOVLW  0B
19174:  BSF    FD8.0
19176:  SUBFWB x47,W
19178:  SUBWF  x4C,W
1917A:  BC    191E2
....................    { 
....................       HKDATA[num + 5+4] = in_HK[num + 2 - in];                                   //coloca los datos enviados por el FAB en el array HKDATA[] desde la posicion 10 al 17 
1917C:  MOVLW  05
1917E:  ADDWF  x4C,W
19180:  ADDLW  04
19182:  CLRF   03
19184:  ADDLW  7D
19186:  MOVWF  01
19188:  MOVLW  02
1918A:  ADDWFC 03,F
1918C:  MOVFF  03,34E
19190:  MOVLW  02
19192:  ADDWF  x4C,W
19194:  BSF    FD8.0
19196:  SUBFWB x47,W
19198:  CLRF   03
1919A:  ADDLW  50
1919C:  MOVWF  FE9
1919E:  MOVLW  02
191A0:  ADDWFC 03,W
191A2:  MOVWF  FEA
191A4:  MOVFF  FEF,34F
191A8:  MOVFF  34E,FEA
191AC:  MOVFF  01,FE9
191B0:  MOVFF  34F,FEF
....................      /* fputc(HKDATA[num + 5+4],PC); */                                              //imprime los datos desde la posicion 10 hasta 19 
....................       fprintf(PC,"%x,",HKDATA[num + 5+4]); 
191B4:  MOVLW  05
191B6:  ADDWF  x4C,W
191B8:  ADDLW  04
191BA:  CLRF   03
191BC:  ADDLW  7D
191BE:  MOVWF  FE9
191C0:  MOVLW  02
191C2:  ADDWFC 03,W
191C4:  MOVWF  FEA
191C6:  MOVFF  FEF,3A2
191CA:  MOVLW  57
191CC:  MOVWF  xA3
191CE:  MOVLB  0
191D0:  CALL   0734
191D4:  MOVLW  2C
191D6:  BTFSS  F9E.4
191D8:  BRA    191D6
191DA:  MOVWF  FAD
191DC:  MOVLB  3
191DE:  INCF   x4C,F
191E0:  BRA    19172
....................    } 
....................     
....................    MEASURE_BC_TEMP();                                                            //lectura analogica y carga de la variable BC_temp_data_h y BC_temp_data_l 
191E2:  MOVLB  0
191E4:  RCALL  1910C
....................    CHECK_50_and_CW_RESPOND();    
191E6:  CALL   1AA6
....................    HKDATA[14+4] = BC_temp_data_h;                                                //+X temp high[18] 
191EA:  MOVFF  305,28F
....................    HKDATA[15+4] = BC_temp_data_l;                                                //+X temp low[19] 
191EE:  MOVFF  307,290
....................     
....................    for(num = 9; num < FAB_SENSOR_size - 2; num++)                                //[FAB] from CPLD temp to Kill status(array[20] to [49]) 
191F2:  MOVLW  09
191F4:  MOVLB  3
191F6:  MOVWF  x4C
191F8:  MOVF   x4C,W
191FA:  SUBLW  2A
191FC:  BNC   19264
....................    { 
....................       HKDATA[num + 7+4] = in_HK[num + 2 - in]; 
191FE:  MOVLW  07
19200:  ADDWF  x4C,W
19202:  ADDLW  04
19204:  CLRF   03
19206:  ADDLW  7D
19208:  MOVWF  01
1920A:  MOVLW  02
1920C:  ADDWFC 03,F
1920E:  MOVFF  03,34E
19212:  MOVLW  02
19214:  ADDWF  x4C,W
19216:  BSF    FD8.0
19218:  SUBFWB x47,W
1921A:  CLRF   03
1921C:  ADDLW  50
1921E:  MOVWF  FE9
19220:  MOVLW  02
19222:  ADDWFC 03,W
19224:  MOVWF  FEA
19226:  MOVFF  FEF,34F
1922A:  MOVFF  34E,FEA
1922E:  MOVFF  01,FE9
19232:  MOVFF  34F,FEF
....................       /*fputc(HKDATA[num + 7+4],PC);*/                                           //imprime los datos desde la posicion 20 hasta 49 
....................       fprintf(PC,"%x,",HKDATA[num + 7+4]); 
19236:  MOVLW  07
19238:  ADDWF  x4C,W
1923A:  ADDLW  04
1923C:  CLRF   03
1923E:  ADDLW  7D
19240:  MOVWF  FE9
19242:  MOVLW  02
19244:  ADDWFC 03,W
19246:  MOVWF  FEA
19248:  MOVFF  FEF,3A2
1924C:  MOVLW  57
1924E:  MOVWF  xA3
19250:  MOVLB  0
19252:  CALL   0734
19256:  MOVLW  2C
19258:  BTFSS  F9E.4
1925A:  BRA    19258
1925C:  MOVWF  FAD
1925E:  MOVLB  3
19260:  INCF   x4C,F
19262:  BRA    191F8
....................    } 
....................    FAB_DATA = 0;                                                                 //pone a cero la bandera 
19264:  MOVLB  2
19266:  CLRF   xF9
....................    return; 
19268:  MOVLB  0
1926A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void VERIFY_FABDATA(int32 delaytime1,int32 delaytime2) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
1926C:  MOVLB  3
1926E:  CLRF   x46
19270:  MOVF   x46,W
19272:  SUBLW  02
19274:  BNC   19324
....................    { 
....................       COMMAND_TO_FAB(delaytime1);                                                //funcion que envia comando al FAB y carga el array in_HK[] 
19276:  MOVFF  341,34A
1927A:  MOVFF  340,349
1927E:  MOVFF  33F,348
19282:  MOVFF  33E,347
19286:  MOVLB  0
19288:  CALL   1ACE
....................       CHECK_50_and_CW_RESPOND(); 
1928C:  CALL   1AA6
....................       //FAB_DATA = 0; 
....................       if(in_HK[0] == 0x33)                                                       //gather sensor data by interrupt 
19290:  MOVLB  2
19292:  MOVF   x50,W
19294:  SUBLW  33
19296:  BNZ   192C2
....................       { 
....................          CHECK_HKDATA(2,delaytime2);                                             //funcion que carga el array HKDATA[118]  
19298:  MOVLW  02
1929A:  MOVLB  3
1929C:  MOVWF  x47
1929E:  MOVFF  345,34B
192A2:  MOVFF  344,34A
192A6:  MOVFF  343,349
192AA:  MOVFF  342,348
192AE:  MOVLB  0
192B0:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
192B2:  CALL   1AA6
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
192B6:  MOVLW  01
192B8:  MOVLB  3
192BA:  MOVWF  x00
....................          break; 
192BC:  BRA    19324
....................       }else if(in_HK[1] == 0x33){ 
192BE:  BRA    1931C
192C0:  MOVLB  2
192C2:  MOVF   x51,W
192C4:  SUBLW  33
192C6:  BNZ   192F2
....................          //delay_ms(200); 
....................          CHECK_HKDATA(1,delaytime2); 
192C8:  MOVLW  01
192CA:  MOVLB  3
192CC:  MOVWF  x47
192CE:  MOVFF  345,34B
192D2:  MOVFF  344,34A
192D6:  MOVFF  343,349
192DA:  MOVFF  342,348
192DE:  MOVLB  0
192E0:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
192E2:  CALL   1AA6
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
192E6:  MOVLW  01
192E8:  MOVLB  3
192EA:  MOVWF  x00
....................          break; 
192EC:  BRA    19324
....................       }else if(in_HK[2] == 0x33){ 
192EE:  BRA    1931C
192F0:  MOVLB  2
192F2:  MOVF   x52,W
192F4:  SUBLW  33
192F6:  BNZ   1931E
....................          //delay_ms(200); 
....................          CHECK_HKDATA(0,delaytime2); 
192F8:  MOVLB  3
192FA:  CLRF   x47
192FC:  MOVFF  345,34B
19300:  MOVFF  344,34A
19304:  MOVFF  343,349
19308:  MOVFF  342,348
1930C:  MOVLB  0
1930E:  RCALL  19142
....................          CHECK_50_and_CW_RESPOND(); 
19310:  CALL   1AA6
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
19314:  MOVLW  01
19316:  MOVLB  3
19318:  MOVWF  x00
....................          break; 
1931A:  BRA    19324
1931C:  MOVLB  2
....................       } 
1931E:  MOVLB  3
19320:  INCF   x46,F
19322:  BRA    19270
....................    } 
....................    return; 
19324:  MOVLB  0
19326:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void GET_RESET_DATA()                                                            //funcion que carga el array HKDATA con los datos del Reset PIC 
.................... { 
....................    RESET_DATA = 0; 
19328:  CLRF   x9D
....................    for(int i = 0; i < 6; i++) 
1932A:  MOVLB  3
1932C:  CLRF   x3E
1932E:  MOVF   x3E,W
19330:  SUBLW  05
19332:  BNC   1934C
....................    { 
....................       COLLECT_RESET_DATA(); 
19334:  MOVLB  0
19336:  CALL   16AD6
....................       if(reset_bffr[0] == 0x8e) 
1933A:  MOVF   x9E,W
1933C:  SUBLW  8E
1933E:  BNZ   19346
....................       { 
....................          break; 
19340:  MOVLB  3
19342:  BRA    1934C
19344:  MOVLB  0
....................       } 
19346:  MOVLB  3
19348:  INCF   x3E,F
1934A:  BRA    1932E
....................    }    
....................    CHECK_50_and_CW_RESPOND(); 
1934C:  MOVLB  0
1934E:  CALL   1AA6
....................    if(RESET_bffr[0] == 0x8e)                                                     //si el byte de cabecera es el correcto 
19352:  MOVF   x9E,W
19354:  SUBLW  8E
19356:  BNZ   1943A
....................    { 
....................       fprintf(PC,"\r\nRESET DATA OBTAINED\r\n"); 
19358:  MOVLW  54
1935A:  MOVWF  FF6
1935C:  MOVLW  0F
1935E:  MOVWF  FF7
19360:  MOVLW  00
19362:  MOVWF  FF8
19364:  CALL   058C
....................       for(int num = 0; num < 5; num++)                                           //carga el array HKDATA con timedata en las posiciones 2 al 6 
19368:  MOVLB  3
1936A:  CLRF   x3F
1936C:  MOVF   x3F,W
1936E:  SUBLW  04
19370:  BNC   193D0
....................       { 
....................          HKDATA[num + 2] = reset_bffr[num + 1]; 
19372:  MOVLW  02
19374:  ADDWF  x3F,W
19376:  CLRF   03
19378:  ADDLW  7D
1937A:  MOVWF  01
1937C:  MOVLW  02
1937E:  ADDWFC 03,F
19380:  MOVFF  03,341
19384:  MOVLW  01
19386:  ADDWF  x3F,W
19388:  CLRF   03
1938A:  ADDLW  9E
1938C:  MOVWF  FE9
1938E:  MOVLW  00
19390:  ADDWFC 03,W
19392:  MOVWF  FEA
19394:  MOVFF  FEF,342
19398:  MOVFF  341,FEA
1939C:  MOVFF  01,FE9
193A0:  MOVFF  342,FEF
....................          /* 
....................          fputc(HKDATA[num + 2],PC); 
....................          */ 
....................          fprintf(PC,"%x,",HKDATA[num + 2]);                                      //parte del test con serial monitor 
193A4:  MOVLW  02
193A6:  ADDWF  x3F,W
193A8:  CLRF   03
193AA:  ADDLW  7D
193AC:  MOVWF  FE9
193AE:  MOVLW  02
193B0:  ADDWFC 03,W
193B2:  MOVWF  FEA
193B4:  MOVFF  FEF,3A2
193B8:  MOVLW  57
193BA:  MOVWF  xA3
193BC:  MOVLB  0
193BE:  CALL   0734
193C2:  MOVLW  2C
193C4:  BTFSS  F9E.4
193C6:  BRA    193C4
193C8:  MOVWF  FAD
193CA:  MOVLB  3
193CC:  INCF   x3F,F
193CE:  BRA    1936C
....................       } 
....................     
....................       for(num = 0; num < 5; num++)                                               //carga el array HKDATA con reset sensor data en las posiciones 110 al 114 
193D0:  CLRF   x3F
193D2:  MOVF   x3F,W
193D4:  SUBLW  04
193D6:  BNC   19436
....................       { 
....................          HKDATA[num + 116] = reset_bffr[num + 6];                                //carga el HKDATA[] con los datos del reset[] 
193D8:  MOVLW  74
193DA:  ADDWF  x3F,W
193DC:  CLRF   03
193DE:  ADDLW  7D
193E0:  MOVWF  01
193E2:  MOVLW  02
193E4:  ADDWFC 03,F
193E6:  MOVFF  03,341
193EA:  MOVLW  06
193EC:  ADDWF  x3F,W
193EE:  CLRF   03
193F0:  ADDLW  9E
193F2:  MOVWF  FE9
193F4:  MOVLW  00
193F6:  ADDWFC 03,W
193F8:  MOVWF  FEA
193FA:  MOVFF  FEF,342
193FE:  MOVFF  341,FEA
19402:  MOVFF  01,FE9
19406:  MOVFF  342,FEF
....................          /* 
....................          fputc(HKDATA[num + 116],PC); 
....................          */ 
....................          fprintf(PC,"%x,",HKDATA[num + 116]);                                    //parte del test con serial monitor 
1940A:  MOVLW  74
1940C:  ADDWF  x3F,W
1940E:  CLRF   03
19410:  ADDLW  7D
19412:  MOVWF  FE9
19414:  MOVLW  02
19416:  ADDWFC 03,W
19418:  MOVWF  FEA
1941A:  MOVFF  FEF,3A2
1941E:  MOVLW  57
19420:  MOVWF  xA3
19422:  MOVLB  0
19424:  CALL   0734
19428:  MOVLW  2C
1942A:  BTFSS  F9E.4
1942C:  BRA    1942A
1942E:  MOVWF  FAD
19430:  MOVLB  3
19432:  INCF   x3F,F
19434:  BRA    193D2
....................       } 
....................    }else{ 
19436:  BRA    1944C
19438:  MOVLB  0
....................       fprintf(PC,"\r\nRESET DATA NO OBTAINED\r\n"); 
1943A:  MOVLW  6C
1943C:  MOVWF  FF6
1943E:  MOVLW  0F
19440:  MOVWF  FF7
19442:  MOVLW  00
19444:  MOVWF  FF8
19446:  CALL   058C
1944A:  MOVLB  3
....................    } 
....................    //Delete_Reset(); 
....................    return; 
1944C:  MOVLB  0
1944E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_ADCS_HKDATA()                                                          //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
.................... { 
....................    GET_ADCS_SENSOR_DATA();                                                       //funcion que carga el array ADCS_SENSOR_DATA[] con los datos del ADCS 
*
1955E:  RCALL  19450
....................    CHECK_50_and_CW_RESPOND();    
19560:  CALL   1AA6
....................    for(int num = 53; num < 113; num++)                                           //12byte(MAG6,GYRO6)+48byte(GPS) = 60 
19564:  MOVLW  35
19566:  MOVLB  3
19568:  MOVWF  x3E
1956A:  MOVF   x3E,W
1956C:  SUBLW  70
1956E:  BNC   195A4
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 52];                                  //ADCS[1] to ADCS[60] 
19570:  CLRF   03
19572:  MOVF   x3E,W
19574:  ADDLW  7D
19576:  MOVWF  01
19578:  MOVLW  02
1957A:  ADDWFC 03,F
1957C:  MOVFF  03,341
19580:  MOVLW  34
19582:  SUBWF  x3E,W
19584:  CLRF   03
19586:  ADDLW  FB
19588:  MOVWF  FE9
1958A:  MOVLW  01
1958C:  ADDWFC 03,W
1958E:  MOVWF  FEA
19590:  MOVFF  FEF,342
19594:  MOVFF  341,FEA
19598:  MOVFF  01,FE9
1959C:  MOVFF  342,FEF
195A0:  INCF   x3E,F
195A2:  BRA    1956A
....................    } 
....................    for(int n = 1; n < 61; n++)                                             // SHOW IN SERIAL MONITOR 12byte(MAG6,GYRO6)+48byte(GPS) = 60 
195A4:  MOVLW  01
195A6:  MOVWF  x3F
195A8:  MOVF   x3F,W
195AA:  SUBLW  3C
195AC:  BNC   195D8
....................    { 
....................       fprintf(PC,"%x,",ADCS_SENSOR_DATA[n]);                                    //ADCS[1] to ADCS[60] 
195AE:  CLRF   03
195B0:  MOVF   x3F,W
195B2:  ADDLW  FB
195B4:  MOVWF  FE9
195B6:  MOVLW  01
195B8:  ADDWFC 03,W
195BA:  MOVWF  FEA
195BC:  MOVFF  FEF,3A2
195C0:  MOVLW  57
195C2:  MOVWF  xA3
195C4:  MOVLB  0
195C6:  CALL   0734
195CA:  MOVLW  2C
195CC:  BTFSS  F9E.4
195CE:  BRA    195CC
195D0:  MOVWF  FAD
195D2:  MOVLB  3
195D4:  INCF   x3F,F
195D6:  BRA    195A8
....................                                  
....................    } 
....................     
....................    //!   for(num = 65; num < 107; num++)                                            //60byte(GPS) 
....................    //!   { 
....................    //!      HKDATA[num] = ADCS_SENSOR_DATA[num - 34];//HKDATA[54] = ADCS_SENSOR_DATA[21]-->ADCS[21] to ADCS[62] 
....................    //!   } 
....................    return; 
195D8:  MOVLB  0
195DA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void DISPLAY_CW()                                                                //funcion que imprime el array CW_FORMAT[] 
.................... { 
....................    fprintf(PC,"\r\nCW:\r\n"); 
*
19A08:  MOVLW  88
19A0A:  MOVWF  FF6
19A0C:  MOVLW  0F
19A0E:  MOVWF  FF7
19A10:  MOVLW  00
19A12:  MOVWF  FF8
19A14:  CALL   058C
....................    for(int8 i = 0; i < 5; i++) 
19A18:  MOVLB  3
19A1A:  CLRF   x2E
19A1C:  MOVF   x2E,W
19A1E:  SUBLW  04
19A20:  BNC   19A44
....................    { 
....................       fprintf(PC,"%x",CW_FORMAT[i]); 
19A22:  CLRF   03
19A24:  MOVF   x2E,W
19A26:  ADDLW  4B
19A28:  MOVWF  FE9
19A2A:  MOVLW  02
19A2C:  ADDWFC 03,W
19A2E:  MOVWF  FEA
19A30:  MOVFF  FEF,3A2
19A34:  MOVLW  57
19A36:  MOVWF  xA3
19A38:  MOVLB  0
19A3A:  CALL   0734
19A3E:  MOVLB  3
19A40:  INCF   x2E,F
19A42:  BRA    19A1C
....................    } 
....................    fprintf(PC,"\r\n"); 
19A44:  MOVLW  0D
19A46:  BTFSS  F9E.4
19A48:  BRA    19A46
19A4A:  MOVWF  FAD
19A4C:  MOVLW  0A
19A4E:  BTFSS  F9E.4
19A50:  BRA    19A4E
19A52:  MOVWF  FAD
....................    CHECK_50_and_CW_RESPOND();    
19A54:  MOVLB  0
19A56:  CALL   1AA6
....................    return; 
19A5A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void SET_IDENTIFIER() 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
*
199DA:  CALL   1AA6
....................    HKDATA[0] = 0x33; 
199DE:  MOVLW  33
199E0:  MOVLB  2
199E2:  MOVWF  x7D
....................    HKDATA[1] = 0x33; 
199E4:  MOVWF  x7E
....................    HKDATA[7] = 0xAA; 
199E6:  MOVLW  AA
199E8:  MOVWF  x84
....................    HKDATA[8] = 0xAA; 
199EA:  MOVWF  x85
....................    HKDATA[9] = 0xAA; 
199EC:  MOVWF  x86
....................    HKDATA[50] = 0xBB; 
199EE:  MOVLW  BB
199F0:  MOVWF  xAF
....................    HKDATA[51] = 0xBB; 
199F2:  MOVWF  xB0
....................    HKDATA[52] = 0xBB; 
199F4:  MOVWF  xB1
....................    HKDATA[113] = 0xCC; 
199F6:  MOVLW  CC
199F8:  MOVWF  xEE
....................    HKDATA[114] = 0xCC; 
199FA:  MOVWF  xEF
....................    HKDATA[115] = 0xCC; 
199FC:  MOVWF  xF0
....................    HKDATA[122] = 0x44; 
199FE:  MOVLW  44
19A00:  MOVWF  xF7
....................    HKDATA[123] = 0x44; 
19A02:  MOVWF  xF8
....................    return; 
19A04:  MOVLB  0
19A06:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void FAB_TEST_OPERATION() 
.................... { 
....................    Delete_in_HK();                                                               //Borra el array in_HK[124] 
*
19CDA:  CALL   190C8
....................    LOOP_FAB_HK_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
19CDE:  CALL   15736
....................    LOOP_FAB_CW_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CE2:  CALL   189E
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CE6:  CALL   1AA6
....................    LOOP_FAB_HK_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CEA:  CALL   15736
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CEE:  CALL   1AA6
....................    LOOP_FAB_CW_ADDRESS();                                                        //Rota las posiciones de guardado de los datos si llega al final del espacio asignado 
19CF2:  CALL   189E
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19CF6:  CALL   1AA6
....................    Turn_ON_ADCS();                                                               //turn ON ADCS, RD6 = HIGH                                                                
19CFA:  CALL   1277C
....................    //fprintf(PC,"FAB communication start\r\n"); 
....................    waiting(200000);                                                              //wait function, about 200.000=1s 
19CFE:  MOVLB  3
19D00:  CLRF   x88
19D02:  MOVLW  03
19D04:  MOVWF  x87
19D06:  MOVLW  0D
19D08:  MOVWF  x86
19D0A:  MOVLW  40
19D0C:  MOVWF  x85
19D0E:  MOVLB  0
19D10:  CALL   16A98
....................    FAB_MEASUERING_FLAG++;                                                        //count until 7(it means 10 min) 
19D14:  MOVLB  2
19D16:  INCF   xFA,F
....................    FAB_DATA = 0;                                                                 //for initialize 
19D18:  CLRF   xF9
....................     
....................    //   fprintf(PC,"SENDING COMMAND TO FAB\r\n"); 
....................    CHECK_50_and_CW_RESPOND();                                                    //verifica si llego comando 0x50 desde COM PIC y envia CW al COM 
19D1A:  MOVLB  0
19D1C:  CALL   1AA6
....................    VERIFY_FABDATA(130000,2000);//delaytime1 and delaytime2                       //envia comando al FAB y Carga el array in_HK[] con los datos del FAB 
19D20:  MOVLB  3
19D22:  CLRF   x41
19D24:  MOVLW  01
19D26:  MOVWF  x40
19D28:  MOVLW  FB
19D2A:  MOVWF  x3F
19D2C:  MOVLW  D0
19D2E:  MOVWF  x3E
19D30:  CLRF   x45
19D32:  CLRF   x44
19D34:  MOVLW  07
19D36:  MOVWF  x43
19D38:  MOVLW  D0
19D3A:  MOVWF  x42
19D3C:  MOVLB  0
19D3E:  CALL   1926C
....................    CHECK_50_and_CW_RESPOND(); 
19D42:  CALL   1AA6
....................     
....................    GET_RESET_DATA();                                                             //envia comando al reset PIC y Carga el array HKDATA[] con los datos del Reset PIC 
19D46:  CALL   19328
....................     
....................    MAKE_ADCS_HKDATA();                                                           //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
19D4A:  RCALL  1955E
....................     
....................    // Turn_OFF_ADCS();                                                              //ADCS switch OFF, RD6=0 
....................    CHECK_50_and_CW_RESPOND(); 
19D4C:  CALL   1AA6
....................    MAKE_CW_FORMAT();                                                             //make CW format 
19D50:  RCALL  199CE
....................    CHECK_50_and_CW_RESPOND();    
19D52:  CALL   1AA6
....................    SET_IDENTIFIER();                                                             //carga el HKDATA[] con los identificadores   
19D56:  RCALL  199DA
....................    if(CHECK_FAB_RESPONSE)                                                        //Si HKDATA[] se cargo con los datos del FAB y realizado el CW format 
19D58:  MOVLB  3
19D5A:  MOVF   x00,F
19D5C:  BTFSC  FD8.2
19D5E:  BRA    19EEC
....................    { 
....................       fprintf(PC,"\r\nCollecting HK and Making CWFormat Done\r\n"); 
19D60:  MOVLW  90
19D62:  MOVWF  FF6
19D64:  MOVLW  0F
19D66:  MOVWF  FF7
19D68:  MOVLW  00
19D6A:  MOVWF  FF8
19D6C:  MOVLB  0
19D6E:  CALL   058C
....................  
....................       fprintf(PC,"\r\nHK data:\r\n"); 
19D72:  MOVLW  BC
19D74:  MOVWF  FF6
19D76:  MOVLW  0F
19D78:  MOVWF  FF7
19D7A:  MOVLW  00
19D7C:  MOVWF  FF8
19D7E:  CALL   058C
....................  
....................       CHECK_50_and_CW_RESPOND(); 
19D82:  CALL   1AA6
....................        
....................       for(int num = 0; num < 65; num++)                                          //array[0] to [64](until gyro data) 
19D86:  MOVLB  3
19D88:  CLRF   x2C
19D8A:  MOVF   x2C,W
19D8C:  SUBLW  40
19D8E:  BNC   19DBA
....................       { 
....................          fprintf(PC,"%x,",HKDATA[num]); 
19D90:  CLRF   03
19D92:  MOVF   x2C,W
19D94:  ADDLW  7D
19D96:  MOVWF  FE9
19D98:  MOVLW  02
19D9A:  ADDWFC 03,W
19D9C:  MOVWF  FEA
19D9E:  MOVFF  FEF,3A2
19DA2:  MOVLW  57
19DA4:  MOVWF  xA3
19DA6:  MOVLB  0
19DA8:  CALL   0734
19DAC:  MOVLW  2C
19DAE:  BTFSS  F9E.4
19DB0:  BRA    19DAE
19DB2:  MOVWF  FAD
19DB4:  MOVLB  3
19DB6:  INCF   x2C,F
19DB8:  BRA    19D8A
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19DBA:  MOVLB  0
19DBC:  CALL   1AA6
....................       for(num = 65; num < 113; num++)                                            //GPS 60 byte should be shown as char type 
19DC0:  MOVLW  41
19DC2:  MOVLB  3
19DC4:  MOVWF  x2C
19DC6:  MOVF   x2C,W
19DC8:  SUBLW  70
19DCA:  BNC   19DF6
....................       { 
....................          //fputc(HKDATA[num],PC); 
....................          fprintf(PC,"%x,",HKDATA[num]);                                          //solo para test 
19DCC:  CLRF   03
19DCE:  MOVF   x2C,W
19DD0:  ADDLW  7D
19DD2:  MOVWF  FE9
19DD4:  MOVLW  02
19DD6:  ADDWFC 03,W
19DD8:  MOVWF  FEA
19DDA:  MOVFF  FEF,3A2
19DDE:  MOVLW  57
19DE0:  MOVWF  xA3
19DE2:  MOVLB  0
19DE4:  CALL   0734
19DE8:  MOVLW  2C
19DEA:  BTFSS  F9E.4
19DEC:  BRA    19DEA
19DEE:  MOVWF  FAD
19DF0:  MOVLB  3
19DF2:  INCF   x2C,F
19DF4:  BRA    19DC6
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19DF6:  MOVLB  0
19DF8:  CALL   1AA6
....................       for(num = 113; num < HK_Size; num++)                                       //array[113] to [124] 
19DFC:  MOVLW  71
19DFE:  MOVLB  3
19E00:  MOVWF  x2C
19E02:  MOVF   x2C,W
19E04:  SUBLW  7B
19E06:  BNC   19E36
....................       { 
....................          fprintf(PC,",%x",HKDATA[num]); 
19E08:  CLRF   03
19E0A:  MOVF   x2C,W
19E0C:  ADDLW  7D
19E0E:  MOVWF  FE9
19E10:  MOVLW  02
19E12:  ADDWFC 03,W
19E14:  MOVWF  FEA
19E16:  MOVFF  FEF,32E
19E1A:  MOVLW  2C
19E1C:  BTFSS  F9E.4
19E1E:  BRA    19E1C
19E20:  MOVWF  FAD
19E22:  MOVFF  32E,3A2
19E26:  MOVLW  57
19E28:  MOVWF  xA3
19E2A:  MOVLB  0
19E2C:  CALL   0734
19E30:  MOVLB  3
19E32:  INCF   x2C,F
19E34:  BRA    19E02
....................       }      
....................       CHECK_50_and_CW_RESPOND(); 
19E36:  MOVLB  0
19E38:  CALL   1AA6
....................        
....................       DISPLAY_CW();                                                              //funcion que imprime el array CW_FORMAT[] 
19E3C:  RCALL  19A08
....................       CHECK_FAB_RESPONSE = 0;                                                    //bandera FAB a cero      
19E3E:  MOVLB  3
19E40:  CLRF   x00
....................       output_low(PIN_C4);                                                        //COM Flash memory Main side 
19E42:  BCF    F94.4
19E44:  BCF    F8B.4
....................       output_low(PIN_A5); 
19E46:  BCF    F92.5
19E48:  BCF    F89.5
....................       //sector_erase_SCF(65536*50); 
....................       //sector_erase_SCF(65536*51); 
....................       SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                        //guarda en COM flash el array HKDATA[] 
19E4A:  MOVFF  4B,341
19E4E:  MOVFF  4A,340
19E52:  MOVFF  49,33F
19E56:  MOVFF  48,33E
19E5A:  MOVLB  0
19E5C:  RCALL  19AB8
....................       SEND_HKDATA_to_SMF(FAB_HK_ADDRESS); 
19E5E:  MOVFF  4B,341
19E62:  MOVFF  4A,340
19E66:  MOVFF  49,33F
19E6A:  MOVFF  48,33E
19E6E:  RCALL  19B28
....................       SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                         //guarda en Main flash el array HKDATA[] 
19E70:  MOVFF  4B,341
19E74:  MOVFF  4A,340
19E78:  MOVFF  49,33F
19E7C:  MOVFF  48,33E
19E80:  RCALL  19B94
....................       SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS);                                      //guarda en COM flash el array CWFORMAT[] 
19E82:  MOVFF  4F,341
19E86:  MOVFF  4E,340
19E8A:  MOVFF  4D,33F
19E8E:  MOVFF  4C,33E
19E92:  RCALL  19C08
....................       SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
19E94:  MOVFF  4F,341
19E98:  MOVFF  4E,340
19E9C:  MOVFF  4D,33F
19EA0:  MOVFF  4C,33E
19EA4:  RCALL  19C78
....................       SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS);                                       //guarda en Main flash el array CWFORMAT[] 
19EA6:  MOVFF  4F,341
19EAA:  MOVFF  4E,340
19EAE:  MOVFF  4D,33F
19EB2:  MOVFF  4C,33E
19EB6:  RCALL  19CA0
....................       FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                                 //prepare for next storing address 
19EB8:  MOVLW  7C
19EBA:  ADDWF  48,F
19EBC:  MOVLW  00
19EBE:  ADDWFC 49,F
19EC0:  ADDWFC 4A,F
19EC2:  ADDWFC 4B,F
....................       FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                                 //prepare for next storing address 
19EC4:  MOVLW  05
19EC6:  ADDWF  4C,F
19EC8:  MOVLW  00
19ECA:  ADDWFC 4D,F
19ECC:  ADDWFC 4E,F
19ECE:  ADDWFC 4F,F
....................       fprintf(PC,"\r\nSENSORS DATA SAVED ON FLASH\r\n"); 
19ED0:  MOVLW  CA
19ED2:  MOVWF  FF6
19ED4:  MOVLW  0F
19ED6:  MOVWF  FF7
19ED8:  MOVLW  00
19EDA:  MOVWF  FF8
19EDC:  CALL   058C
....................       output_high(PIN_C4);                                                       //COM Flash memory COM side 
19EE0:  BCF    F94.4
19EE2:  BSF    F8B.4
....................       CHECK_50_and_CW_RESPOND(); 
19EE4:  CALL   1AA6
....................    }else{ 
19EE8:  BRA    19FC0
19EEA:  MOVLB  3
....................       SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                        //guarda en COM flash el array HKDATA[] 
19EEC:  MOVFF  4B,341
19EF0:  MOVFF  4A,340
19EF4:  MOVFF  49,33F
19EF8:  MOVFF  48,33E
19EFC:  MOVLB  0
19EFE:  RCALL  19AB8
....................       SEND_HKDATA_to_SMF(FAB_HK_ADDRESS); 
19F00:  MOVFF  4B,341
19F04:  MOVFF  4A,340
19F08:  MOVFF  49,33F
19F0C:  MOVFF  48,33E
19F10:  RCALL  19B28
....................       SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                         //guarda en Main flash el array HKDATA[] 
19F12:  MOVFF  4B,341
19F16:  MOVFF  4A,340
19F1A:  MOVFF  49,33F
19F1E:  MOVFF  48,33E
19F22:  RCALL  19B94
....................       SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS);                                      //guarda en COM flash el array CWFORMAT[] 
19F24:  MOVFF  4F,341
19F28:  MOVFF  4E,340
19F2C:  MOVFF  4D,33F
19F30:  MOVFF  4C,33E
19F34:  RCALL  19C08
....................       SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
19F36:  MOVFF  4F,341
19F3A:  MOVFF  4E,340
19F3E:  MOVFF  4D,33F
19F42:  MOVFF  4C,33E
19F46:  RCALL  19C78
....................       SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS);                                       //guarda en Main flash el array CWFORMAT[] 
19F48:  MOVFF  4F,341
19F4C:  MOVFF  4E,340
19F50:  MOVFF  4D,33F
19F54:  MOVFF  4C,33E
19F58:  RCALL  19CA0
....................       FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                                 //prepare for next storing address 
19F5A:  MOVLW  7C
19F5C:  ADDWF  48,F
19F5E:  MOVLW  00
19F60:  ADDWFC 49,F
19F62:  ADDWFC 4A,F
19F64:  ADDWFC 4B,F
....................       FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                                 //prepare for next storing address 
19F66:  MOVLW  05
19F68:  ADDWF  4C,F
19F6A:  MOVLW  00
19F6C:  ADDWFC 4D,F
19F6E:  ADDWFC 4E,F
19F70:  ADDWFC 4F,F
....................       fprintf(PC,"NO RESPONSE FROM FAB\r\n\r\n");   
19F72:  MOVLW  EA
19F74:  MOVWF  FF6
19F76:  MOVLW  0F
19F78:  MOVWF  FF7
19F7A:  MOVLW  00
19F7C:  MOVWF  FF8
19F7E:  CALL   058C
....................       CHECK_50_and_CW_RESPOND(); 
19F82:  CALL   1AA6
....................       for(int num = 0; num < HK_size; num++) 
19F86:  MOVLB  3
19F88:  CLRF   x2D
19F8A:  MOVF   x2D,W
19F8C:  SUBLW  7B
19F8E:  BNC   19FBA
....................       { 
....................          fprintf(PC,"%x,",HKDATA[num]); 
19F90:  CLRF   03
19F92:  MOVF   x2D,W
19F94:  ADDLW  7D
19F96:  MOVWF  FE9
19F98:  MOVLW  02
19F9A:  ADDWFC 03,W
19F9C:  MOVWF  FEA
19F9E:  MOVFF  FEF,3A2
19FA2:  MOVLW  57
19FA4:  MOVWF  xA3
19FA6:  MOVLB  0
19FA8:  CALL   0734
19FAC:  MOVLW  2C
19FAE:  BTFSS  F9E.4
19FB0:  BRA    19FAE
19FB2:  MOVWF  FAD
19FB4:  MOVLB  3
19FB6:  INCF   x2D,F
19FB8:  BRA    19F8A
....................       } 
....................       CHECK_50_and_CW_RESPOND(); 
19FBA:  MOVLB  0
19FBC:  CALL   1AA6
....................     
....................    } 
....................     
....................    return; 
19FC0:  RETURN 0
.................... } 
.................... /* 
.................... void SAVE_ADCS_INITIAL_and_FINAL(int32 ADDRESS) 
.................... { 
....................    output_low(PIN_C4); 
....................    output_low(PIN_A5); 
....................    for(int i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................    for(i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................    for(i = 0; i < 90; i++)//put initial 90byte(9byte for time + 81byte for MSN) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADDRESS+i)); 
....................    } 
....................     
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 90; 
....................     
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    for(i = 0; i < 81; i++)//put final 81 byte 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+i,READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS-171+i)); 
....................    } 
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 81; 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void GET_INITIAL_TIME() 
.................... { 
....................    COLLECT_RESET_DATA(); 
....................     
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS,0xdd);//header 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(int i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................     
....................    output_low(PIN_C4);//COM_MUX MAINSIDE 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS,0xdd);//header 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................    output_high(PIN_C4); 
....................     
....................    output_low(PIN_A5);//CAM_MUX MAINSIDE 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS,0xdd);//heade 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 1,0xdd);//header 
....................    for(i = 1; i < 6; i++){ 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+1+i,reset_bffr[i]); 
....................    } 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 7,0xdd);//footer 
....................    WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 8,0xdd);//footer 
....................     
....................    ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + 9;//total 9byte for time info 
....................    //5 byte time info and 2 byte header and 2 byte footer 
....................    return; 
.................... } 
.................... */ 
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... /*void GET_ADCS_MSN_DATA() 
.................... { 
....................    int a = 1; 
....................    if(kbhit(ADCS)&&fgetc(ADCS) == 0x57) 
....................    { 
....................       for(int32 n= 0; n < 300000; n++) 
....................       { 
....................          if(kbhit(ADCS)) 
....................          { 
....................             ADCS_SENSOR_DATA[a] = fgetc(ADCS);//[1] to [72] 
....................             a++;//after input everything, a = 73 
....................          } 
....................          if(a == 73) 
....................          { 
....................             break; 
....................          } 
....................       } 
....................       for(int i = 76; i > 70 ; i--)//6 byte [76] to [70] --> Duty XYZ 
....................       { 
....................          ADCS_SENSOR_DATA[i] = ADCS_SENSOR_DATA[i-4];//ADCS_SENSOR_DATA[76] is ADCS_SENSOR_DATA[72] 
....................       } 
....................       for(i = 68; i > 20 ; i--)//48 byte [68] to [21] --> GPS 
....................       { 
....................          ADCS_SENSOR_DATA[i] = ADCS_SENSOR_DATA[i-2];//ADCS_SENSOR_DATA[68] is ADCS_SENSOR_DATA[66] 
....................       } 
....................           
....................       ADCS_SENSOR_DATA[0] = 0x57; 
....................       ADCS_SENSOR_DATA[19] = 0xee; 
....................       ADCS_SENSOR_DATA[20] = 0xee; 
....................       ADCS_SENSOR_DATA[69] = 0x58; 
....................       ADCS_SENSOR_DATA[70] = 0x58; 
....................       ADCS_SENSOR_DATA[77] = 0x59; 
....................              
....................       int8 a = (int8)(currenttime >> 8); 
....................       int8 b = (int8)(currenttime); 
....................       output_low(PIN_C4); 
....................       output_low(PIN_A5); 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS,0x56);//header 
....................              
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+2,b); 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS+2,b); 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+1,a); 
....................       WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS+2,b); 
....................       for(i = 0; i < ADCS_SENSOR_SIZE; i++)// save everything to frash memory 
....................       { 
....................          WRITE_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................          WRITE_DATA_BYTE_SCF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................          WRITE_DATA_BYTE_SMF(ADCS_SENSOR_ADDRESS + 3 + i,ADCS_SENSOR_DATA[i]); 
....................       } 
....................       output_high(PIN_C4); 
....................       fprintf(PC,"\r\n%ld,",currenttime); 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+3));//ack 
....................       fprintf(PC,","); 
....................              
....................       for(i = 4; i < 22; i++)// show the data-->Magnetometer XYZ, Gyro XYZ, Cur sensor XYZ 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          i++; 
....................          fprintf(PC,"%x,",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................              
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+22));//0xEE 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+23));//0xEE 
....................       fprintf(PC,","); 
....................              
....................       for(i = 24; i < 72; i++)// show the data(GPS)-->48byte 
....................       { 
....................          //fprintf(PC,"%c",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i)); 
....................          fputc(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i),PC); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................              
....................       fprintf(PC,","); 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+84));//0x58 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+85));//0x58 
....................       fprintf(PC,","); 
....................              
....................       for(i = 74; i < ADCS_SENSOR_SIZE+2; i++)// show the duty data-->6byte 
....................       { 
....................          fprintf(PC,"%x,",(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i))); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................          i++; 
....................          fprintf(PC,"%x,",(READ_DATA_BYTE_OF(ADCS_SENSOR_ADDRESS+i))); 
....................          ADCS_SENSOR_DATA[i] = 0; 
....................       } 
....................       ADCS_SENSOR_ADDRESS = ADCS_SENSOR_ADDRESS + ADCS_SENSOR_SIZE + 3; 
....................    } 
....................    return; 
.................... }*/ 
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
.................... //OPERATION_MODE 
.................... /*#define NOMAL_ADCS_MSN 0x22*/ 
.................... #define NOMAL_ADCS_MSN 0x78                                                      //comando esperado por hisatsugu 
.................... #define AUTO_ADCS_MSN 0x27 
....................  
.................... //--------HIGH SAMPLING HK collection------------------------------------------ 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_HIGH_SAMP_FABDATA(int8 in)                                            //FAB sensor data collect 
.................... { 
....................    fprintf(PC,"\r\nFAB DATA OBTAINED\r\n"); 
*
1A83E:  MOVLW  04
1A840:  MOVWF  FF6
1A842:  MOVLW  10
1A844:  MOVWF  FF7
1A846:  MOVLW  00
1A848:  MOVWF  FF8
1A84A:  CALL   058C
....................    Delete_HKDATA(); 
1A84E:  CALL   190EA
....................    for(int num = 1; num < 11; num++)                                             //Collect HK DATA 
1A852:  MOVLW  01
1A854:  MOVLB  3
1A856:  MOVWF  x44
1A858:  MOVF   x44,W
1A85A:  SUBLW  0A
1A85C:  BNC   1A8C0
....................    { 
....................       HKDATA[num + 5+4] = in_HK[num + 2 - in]; 
1A85E:  MOVLW  05
1A860:  ADDWF  x44,W
1A862:  ADDLW  04
1A864:  CLRF   03
1A866:  ADDLW  7D
1A868:  MOVWF  01
1A86A:  MOVLW  02
1A86C:  ADDWFC 03,F
1A86E:  MOVFF  03,346
1A872:  MOVLW  02
1A874:  ADDWF  x44,W
1A876:  BSF    FD8.0
1A878:  SUBFWB x43,W
1A87A:  CLRF   03
1A87C:  ADDLW  50
1A87E:  MOVWF  FE9
1A880:  MOVLW  02
1A882:  ADDWFC 03,W
1A884:  MOVWF  FEA
1A886:  MOVFF  FEF,347
1A88A:  MOVFF  346,FEA
1A88E:  MOVFF  01,FE9
1A892:  MOVFF  347,FEF
....................       fprintf(PC, "%x,", HKDATA[num]); 
1A896:  CLRF   03
1A898:  MOVF   x44,W
1A89A:  ADDLW  7D
1A89C:  MOVWF  FE9
1A89E:  MOVLW  02
1A8A0:  ADDWFC 03,W
1A8A2:  MOVWF  FEA
1A8A4:  MOVFF  FEF,3A2
1A8A8:  MOVLW  57
1A8AA:  MOVWF  xA3
1A8AC:  MOVLB  0
1A8AE:  CALL   0734
1A8B2:  MOVLW  2C
1A8B4:  BTFSS  F9E.4
1A8B6:  BRA    1A8B4
1A8B8:  MOVWF  FAD
1A8BA:  MOVLB  3
1A8BC:  INCF   x44,F
1A8BE:  BRA    1A858
....................    } 
....................    MEASURE_BC_TEMP(); 
1A8C0:  MOVLB  0
1A8C2:  CALL   1910C
....................    HKDATA[18] = BC_temp_data_h;                                                  //-X Panel Temp 
1A8C6:  MOVFF  305,28F
....................    HKDATA[19] = BC_temp_data_l;                                                  //-X Panel Temp 
1A8CA:  MOVFF  307,290
....................    for(num = 9; num < FAB_SENSOR_size - 2; num++)                                //[FAB] from CPLD temp to Kill status(array[20] to [49]) 
1A8CE:  MOVLW  09
1A8D0:  MOVLB  3
1A8D2:  MOVWF  x44
1A8D4:  MOVF   x44,W
1A8D6:  SUBLW  2A
1A8D8:  BNC   1A940
....................    { 
....................       HKDATA[num + 7+4] = in_HK[num + 2 - in]; 
1A8DA:  MOVLW  07
1A8DC:  ADDWF  x44,W
1A8DE:  ADDLW  04
1A8E0:  CLRF   03
1A8E2:  ADDLW  7D
1A8E4:  MOVWF  01
1A8E6:  MOVLW  02
1A8E8:  ADDWFC 03,F
1A8EA:  MOVFF  03,346
1A8EE:  MOVLW  02
1A8F0:  ADDWF  x44,W
1A8F2:  BSF    FD8.0
1A8F4:  SUBFWB x43,W
1A8F6:  CLRF   03
1A8F8:  ADDLW  50
1A8FA:  MOVWF  FE9
1A8FC:  MOVLW  02
1A8FE:  ADDWFC 03,W
1A900:  MOVWF  FEA
1A902:  MOVFF  FEF,347
1A906:  MOVFF  346,FEA
1A90A:  MOVFF  01,FE9
1A90E:  MOVFF  347,FEF
....................       fprintf(PC, "%x,", HKDATA[num + 7+4]); 
1A912:  MOVLW  07
1A914:  ADDWF  x44,W
1A916:  ADDLW  04
1A918:  CLRF   03
1A91A:  ADDLW  7D
1A91C:  MOVWF  FE9
1A91E:  MOVLW  02
1A920:  ADDWFC 03,W
1A922:  MOVWF  FEA
1A924:  MOVFF  FEF,3A2
1A928:  MOVLW  57
1A92A:  MOVWF  xA3
1A92C:  MOVLB  0
1A92E:  CALL   0734
1A932:  MOVLW  2C
1A934:  BTFSS  F9E.4
1A936:  BRA    1A934
1A938:  MOVWF  FAD
1A93A:  MOVLB  3
1A93C:  INCF   x44,F
1A93E:  BRA    1A8D4
....................    } 
....................    FAB_DATA = 0; 
1A940:  MOVLB  2
1A942:  CLRF   xF9
1A944:  MOVLB  0
1A946:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void VERIFY_HIGH_SAMP_FABDATA(int32 delaytime) 
.................... { 
....................    for(int8 num = 0; num < 3; num++) 
1A948:  MOVLB  3
1A94A:  CLRF   x42
1A94C:  MOVF   x42,W
1A94E:  SUBLW  02
1A950:  BNC   1A9C2
....................    { 
....................       COMMAND_TO_FAB(delaytime); 
1A952:  MOVFF  341,34A
1A956:  MOVFF  340,349
1A95A:  MOVFF  33F,348
1A95E:  MOVFF  33E,347
1A962:  MOVLB  0
1A964:  CALL   1ACE
....................       //FAB_DATA = 0; 
....................       //waiting(1000); 
....................       if(in_HK[0] == 0x33)                                                       //gather sensor data by interrupt 
1A968:  MOVLB  2
1A96A:  MOVF   x50,W
1A96C:  SUBLW  33
1A96E:  BNZ   1A986
....................       { 
....................          CHECK_HIGH_SAMP_FABDATA(2); 
1A970:  MOVLW  02
1A972:  MOVLB  3
1A974:  MOVWF  x43
1A976:  MOVLB  0
1A978:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A97A:  MOVLW  01
1A97C:  MOVLB  3
1A97E:  MOVWF  x00
....................          break; 
1A980:  BRA    1A9C2
....................       }else if(in_HK[1] == 0x33){ 
1A982:  BRA    1A9B8
1A984:  MOVLB  2
1A986:  MOVF   x51,W
1A988:  SUBLW  33
1A98A:  BNZ   1A9A2
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(1); 
1A98C:  MOVLW  01
1A98E:  MOVLB  3
1A990:  MOVWF  x43
1A992:  MOVLB  0
1A994:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A996:  MOVLW  01
1A998:  MOVLB  3
1A99A:  MOVWF  x00
....................          break; 
1A99C:  BRA    1A9C2
....................       }else if(in_HK[2] == 0x33){ 
1A99E:  BRA    1A9B8
1A9A0:  MOVLB  2
1A9A2:  MOVF   x52,W
1A9A4:  SUBLW  33
1A9A6:  BNZ   1A9BA
....................          //delay_ms(200); 
....................          CHECK_HIGH_SAMP_FABDATA(0); 
1A9A8:  MOVLB  3
1A9AA:  CLRF   x43
1A9AC:  MOVLB  0
1A9AE:  RCALL  1A83E
....................          CHECK_FAB_RESPONSE = 1;                                                 //1 is succeeded to get response from FAB 
1A9B0:  MOVLW  01
1A9B2:  MOVLB  3
1A9B4:  MOVWF  x00
....................          break; 
1A9B6:  BRA    1A9C2
1A9B8:  MOVLB  2
....................       } 
....................       FAB_DATA = 0; 
1A9BA:  CLRF   xF9
1A9BC:  MOVLB  3
1A9BE:  INCF   x42,F
1A9C0:  BRA    1A94C
....................    } 
....................    return; 
1A9C2:  MOVLB  0
1A9C4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void GET_HIGH_SAMP_RESET_DATA() 
.................... { 
....................    RESET_DATA = 0; 
1A9C6:  CLRF   x9D
....................    COLLECT_RESET_DATA(); 
1A9C8:  CALL   16AD6
....................    if(RESET_bffr[0] == 0x8e) 
1A9CC:  MOVF   x9E,W
1A9CE:  SUBLW  8E
1A9D0:  BNZ   1AAA0
....................    { 
....................       fprintf(PC,"GET RESET\r\n"); 
1A9D2:  MOVLW  1A
1A9D4:  MOVWF  FF6
1A9D6:  MOVLW  10
1A9D8:  MOVWF  FF7
1A9DA:  MOVLW  00
1A9DC:  MOVWF  FF8
1A9DE:  CALL   058C
....................       for(int num = 0; num < 5; num++)                                           //timedata 
1A9E2:  MOVLB  3
1A9E4:  CLRF   x3E
1A9E6:  MOVF   x3E,W
1A9E8:  SUBLW  04
1A9EA:  BNC   1AA40
....................       { 
....................          HKDATA[num + 2] = reset_bffr[num + 1]; 
1A9EC:  MOVLW  02
1A9EE:  ADDWF  x3E,W
1A9F0:  CLRF   03
1A9F2:  ADDLW  7D
1A9F4:  MOVWF  01
1A9F6:  MOVLW  02
1A9F8:  ADDWFC 03,F
1A9FA:  MOVFF  03,340
1A9FE:  MOVLW  01
1AA00:  ADDWF  x3E,W
1AA02:  CLRF   03
1AA04:  ADDLW  9E
1AA06:  MOVWF  FE9
1AA08:  MOVLW  00
1AA0A:  ADDWFC 03,W
1AA0C:  MOVWF  FEA
1AA0E:  MOVFF  FEF,341
1AA12:  MOVFF  340,FEA
1AA16:  MOVFF  01,FE9
1AA1A:  MOVFF  341,FEF
....................          fputc(HKDATA[num + 2],PC); 
1AA1E:  MOVLW  02
1AA20:  ADDWF  x3E,W
1AA22:  CLRF   03
1AA24:  ADDLW  7D
1AA26:  MOVWF  FE9
1AA28:  MOVLW  02
1AA2A:  ADDWFC 03,W
1AA2C:  MOVWF  FEA
1AA2E:  MOVFF  FEF,33F
1AA32:  MOVF   x3F,W
1AA34:  MOVLB  0
1AA36:  CALL   01D2
1AA3A:  MOVLB  3
1AA3C:  INCF   x3E,F
1AA3E:  BRA    1A9E6
....................       } 
....................     
....................       for(num = 0; num < 5; num++)                                               //reset sensor data 
1AA40:  CLRF   x3E
1AA42:  MOVF   x3E,W
1AA44:  SUBLW  04
1AA46:  BNC   1AA9C
....................       { 
....................          HKDATA[num + 116] = reset_bffr[num + 6];                                //HKDATA[116] = reset[6] 
1AA48:  MOVLW  74
1AA4A:  ADDWF  x3E,W
1AA4C:  CLRF   03
1AA4E:  ADDLW  7D
1AA50:  MOVWF  01
1AA52:  MOVLW  02
1AA54:  ADDWFC 03,F
1AA56:  MOVFF  03,340
1AA5A:  MOVLW  06
1AA5C:  ADDWF  x3E,W
1AA5E:  CLRF   03
1AA60:  ADDLW  9E
1AA62:  MOVWF  FE9
1AA64:  MOVLW  00
1AA66:  ADDWFC 03,W
1AA68:  MOVWF  FEA
1AA6A:  MOVFF  FEF,341
1AA6E:  MOVFF  340,FEA
1AA72:  MOVFF  01,FE9
1AA76:  MOVFF  341,FEF
....................          fputc(HKDATA[num + 116],PC); 
1AA7A:  MOVLW  74
1AA7C:  ADDWF  x3E,W
1AA7E:  CLRF   03
1AA80:  ADDLW  7D
1AA82:  MOVWF  FE9
1AA84:  MOVLW  02
1AA86:  ADDWFC 03,W
1AA88:  MOVWF  FEA
1AA8A:  MOVFF  FEF,33F
1AA8E:  MOVF   x3F,W
1AA90:  MOVLB  0
1AA92:  CALL   01D2
1AA96:  MOVLB  3
1AA98:  INCF   x3E,F
1AA9A:  BRA    1AA42
....................       } 
....................    }else{ 
1AA9C:  BRA    1AAB2
1AA9E:  MOVLB  0
....................       fprintf(PC,"NO RESET\r\n"); 
1AAA0:  MOVLW  26
1AAA2:  MOVWF  FF6
1AAA4:  MOVLW  10
1AAA6:  MOVWF  FF7
1AAA8:  MOVLW  00
1AAAA:  MOVWF  FF8
1AAAC:  CALL   058C
1AAB0:  MOVLB  3
....................    } 
1AAB2:  MOVLB  0
1AAB4:  RETURN 0
....................    //Delete_Reset(); 
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void MAKE_HIGH_SAMP_ADCS_FORMAT() 
.................... { 
....................    GET_ADCS_SENSOR_DATA(); 
1AAB6:  CALL   19450
....................    for(int num = 53; num < 113; num++)                                           //12byte+48byte = 60 byte 
1AABA:  MOVLW  35
1AABC:  MOVLB  3
1AABE:  MOVWF  x3E
1AAC0:  MOVF   x3E,W
1AAC2:  SUBLW  70
1AAC4:  BNC   1AAFA
....................    { 
....................       HKDATA[num] = ADCS_SENSOR_DATA[num - 52];                                  //ADCS[1] to ADCS[60] 
1AAC6:  CLRF   03
1AAC8:  MOVF   x3E,W
1AACA:  ADDLW  7D
1AACC:  MOVWF  01
1AACE:  MOVLW  02
1AAD0:  ADDWFC 03,F
1AAD2:  MOVFF  03,340
1AAD6:  MOVLW  34
1AAD8:  SUBWF  x3E,W
1AADA:  CLRF   03
1AADC:  ADDLW  FB
1AADE:  MOVWF  FE9
1AAE0:  MOVLW  01
1AAE2:  ADDWFC 03,W
1AAE4:  MOVWF  FEA
1AAE6:  MOVFF  FEF,341
1AAEA:  MOVFF  340,FEA
1AAEE:  MOVFF  01,FE9
1AAF2:  MOVFF  341,FEF
1AAF6:  INCF   x3E,F
1AAF8:  BRA    1AAC0
....................    } 
....................    //!   for(num = 65; num < 107; num++) 
....................    //!   { 
....................    //!      HKDATA[num] = ADCS_SENSOR_DATA[num - 34];//HKDATA[54] = ADCS_SENSOR_DATA[21] 
....................    //!   } 
....................    return; 
1AAFA:  MOVLB  0
1AAFC:  RETURN 0
.................... } 
.................... /* 
.................... void MAKE_HIGH_SAMPLING_FORMAT() 
.................... { 
....................    CHECK_50_and_CW_RESPOND(); 
....................    if(in_HK[0] == 0x33)//gather sensor data by interrupt 
....................    { 
....................       CHECK_HIGH_SAMP_FABDATA(2); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    }else if(in_HK[1] == 0x33){ 
....................       CHECK_HIGH_SAMP_FABDATA(1); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    }else if(in_HK[2] == 0x33){; 
....................       CHECK_HIGH_SAMP_FABDATA(0); 
....................       CHECK_FAB_RESPONSE = 1; //1 is succeeded to get response from FAB 
....................    } 
....................  
....................    CHECK_50_and_CW_RESPOND(); 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       for(int num = 0; num < 5; num++)//timedata 
....................       { 
....................          HKDATA[num] = reset_bffr[num + 1]; 
....................          //fputc(HKDATA[num],PC); 
....................       } 
....................     
....................       for(num = 0; num < 5; num++)//reset sensor data 
....................       { 
....................          HKDATA[num + 91] = reset_bffr[num + 6]; 
....................          //fputc(HKDATA[num + 91],PC); 
....................       } 
....................    } 
....................     
....................    CHECK_50_and_CW_RESPOND(); 
....................    for(int num = 0; num < 12; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 38] = ADCS_SENSOR_DATA[num]; 
....................    } 
....................    for(num = 0; num < 41; num++)//put into sensor array 
....................    { 
....................       HKDATA[num + 50] = ADCS_SENSOR_DATA[num + 21]; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY() 
.................... { 
....................    output_low(PIN_C4); 
*
1A71E:  BCF    F94.4
1A720:  BCF    F8B.4
....................    CHECK_50_and_CW_RESPOND(); 
1A722:  CALL   1AA6
....................    for(int i = 0; i < HIGH_SAMP_HK_size; i++) 
1A726:  MOVLB  3
1A728:  CLRF   x3E
1A72A:  MOVF   x3E,W
1A72C:  SUBLW  7B
1A72E:  BNC   1A776
....................    { 
....................       WRITE_DATA_BYTE_SCF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A730:  MOVF   x3E,W
1A732:  ADDWF  5C,W
1A734:  MOVWF  x3F
1A736:  MOVLW  00
1A738:  ADDWFC 5D,W
1A73A:  MOVWF  x40
1A73C:  MOVLW  00
1A73E:  ADDWFC 5E,W
1A740:  MOVWF  x41
1A742:  MOVLW  00
1A744:  ADDWFC 5F,W
1A746:  MOVWF  x42
1A748:  CLRF   03
1A74A:  MOVF   x3E,W
1A74C:  ADDLW  7D
1A74E:  MOVWF  FE9
1A750:  MOVLW  02
1A752:  ADDWFC 03,W
1A754:  MOVWF  FEA
1A756:  MOVFF  FEF,394
1A75A:  MOVFF  342,393
1A75E:  MOVFF  341,392
1A762:  MOVFF  340,391
1A766:  MOVFF  33F,390
1A76A:  MOVLB  0
1A76C:  CALL   11ACE
1A770:  MOVLB  3
1A772:  INCF   x3E,F
1A774:  BRA    1A72A
....................    } 
....................    output_high(PIN_C4);  
1A776:  BCF    F94.4
1A778:  BSF    F8B.4
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A77A:  MOVLB  0
1A77C:  CALL   1AA6
....................    for(i = 0; i < HIGH_SAMP_HK_size; i++) 
1A780:  MOVLB  3
1A782:  CLRF   x3E
1A784:  MOVF   x3E,W
1A786:  SUBLW  7B
1A788:  BNC   1A7D0
....................    { 
....................       WRITE_DATA_BYTE_OF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A78A:  MOVF   x3E,W
1A78C:  ADDWF  5C,W
1A78E:  MOVWF  x3F
1A790:  MOVLW  00
1A792:  ADDWFC 5D,W
1A794:  MOVWF  x40
1A796:  MOVLW  00
1A798:  ADDWFC 5E,W
1A79A:  MOVWF  x41
1A79C:  MOVLW  00
1A79E:  ADDWFC 5F,W
1A7A0:  MOVWF  x42
1A7A2:  CLRF   03
1A7A4:  MOVF   x3E,W
1A7A6:  ADDLW  7D
1A7A8:  MOVWF  FE9
1A7AA:  MOVLW  02
1A7AC:  ADDWFC 03,W
1A7AE:  MOVWF  FEA
1A7B0:  MOVFF  FEF,394
1A7B4:  MOVFF  342,393
1A7B8:  MOVFF  341,392
1A7BC:  MOVFF  340,391
1A7C0:  MOVFF  33F,390
1A7C4:  MOVLB  0
1A7C6:  CALL   119A4
1A7CA:  MOVLB  3
1A7CC:  INCF   x3E,F
1A7CE:  BRA    1A784
....................    } 
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A7D0:  MOVLB  0
1A7D2:  CALL   1AA6
....................    output_low(PIN_A5); 
1A7D6:  BCF    F92.5
1A7D8:  BCF    F89.5
....................    for(i = 0; i < HIGH_SAMP_HK_size; i++) 
1A7DA:  MOVLB  3
1A7DC:  CLRF   x3E
1A7DE:  MOVF   x3E,W
1A7E0:  SUBLW  7B
1A7E2:  BNC   1A82A
....................    { 
....................       WRITE_DATA_BYTE_SMF(HIGH_SAMP_HK_ADDRESS + i,HKDATA[i]); 
1A7E4:  MOVF   x3E,W
1A7E6:  ADDWF  5C,W
1A7E8:  MOVWF  x3F
1A7EA:  MOVLW  00
1A7EC:  ADDWFC 5D,W
1A7EE:  MOVWF  x40
1A7F0:  MOVLW  00
1A7F2:  ADDWFC 5E,W
1A7F4:  MOVWF  x41
1A7F6:  MOVLW  00
1A7F8:  ADDWFC 5F,W
1A7FA:  MOVWF  x42
1A7FC:  CLRF   03
1A7FE:  MOVF   x3E,W
1A800:  ADDLW  7D
1A802:  MOVWF  FE9
1A804:  MOVLW  02
1A806:  ADDWFC 03,W
1A808:  MOVWF  FEA
1A80A:  MOVFF  FEF,394
1A80E:  MOVFF  342,393
1A812:  MOVFF  341,392
1A816:  MOVFF  340,391
1A81A:  MOVFF  33F,390
1A81E:  MOVLB  0
1A820:  CALL   11C04
1A824:  MOVLB  3
1A826:  INCF   x3E,F
1A828:  BRA    1A7DE
....................    }   
....................     
....................    CHECK_50_and_CW_RESPOND(); 
1A82A:  MOVLB  0
1A82C:  CALL   1AA6
....................    HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS + HIGH_SAMP_HK_size;              //prepare for next storing address 
1A830:  MOVLW  7C
1A832:  ADDWF  5C,F
1A834:  MOVLW  00
1A836:  ADDWFC 5D,F
1A838:  ADDWFC 5E,F
1A83A:  ADDWFC 5F,F
....................     
....................    return; 
1A83C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void HIGH_SAMP_FAB_OPERATION() 
.................... { 
....................    Turn_ON_ADCS(); 
*
1AAFE:  CALL   1277C
....................    CHECK_50_and_CW_RESPOND(); 
1AB02:  CALL   1AA6
....................    HIGH_SAMP_FAB_MEASUERING_FLAG++;                                              //count until 90(it means 10 min) 
1AB06:  MOVLB  2
1AB08:  INCF   xFB,F
....................    //disable_interrupts(INT_rda2); 
....................    if(HIGH_SAMP_FAB_MEASUERING_FLAG > 17)                                        //HIGH_SAMP_FAB_MEASUERING_FLAG=18 --> 18*5 = 90 (sec) 
1AB0A:  MOVF   xFB,W
1AB0C:  SUBLW  11
1AB0E:  BTFSC  FD8.0
1AB10:  BRA    1AC3A
....................       { 
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1AB12:  MOVLB  0
1AB14:  CALL   1AA6
....................           
....................          fprintf(PC,"\r\n\90sec\r\n"); 
1AB18:  MOVLW  32
1AB1A:  MOVWF  FF6
1AB1C:  MOVLW  10
1AB1E:  MOVWF  FF7
1AB20:  MOVLW  00
1AB22:  MOVWF  FF8
1AB24:  CALL   058C
....................          Delete_in_HK();                                                         //delet HK array 
1AB28:  CALL   190C8
....................          VERIFY_FABDATA(10000,10);                                               //envia comando al FAB y Carga el array in_HK[] con los datos del FAB 
1AB2C:  MOVLB  3
1AB2E:  CLRF   x41
1AB30:  CLRF   x40
1AB32:  MOVLW  27
1AB34:  MOVWF  x3F
1AB36:  MOVLW  10
1AB38:  MOVWF  x3E
1AB3A:  CLRF   x45
1AB3C:  CLRF   x44
1AB3E:  CLRF   x43
1AB40:  MOVLW  0A
1AB42:  MOVWF  x42
1AB44:  MOVLB  0
1AB46:  CALL   1926C
....................          GET_RESET_DATA();                                                       //funcion que carga el array HKDATA con los datos del Reset PIC 
1AB4A:  CALL   19328
....................          MAKE_ADCS_HKDATA();                                                     //carga en el array HKDATA[] los datos del ADCS en las posiciones 53 al 106 
1AB4E:  CALL   1955E
....................          SET_IDENTIFIER(); 
1AB52:  CALL   199DA
....................          MAKE_CW_FORMAT(); 
1AB56:  CALL   199CE
....................          output_low(PIN_C4); 
1AB5A:  BCF    F94.4
1AB5C:  BCF    F8B.4
....................          output_low(PIN_A5); 
1AB5E:  BCF    F92.5
1AB60:  BCF    F89.5
....................           
....................          SEND_HKDATA_to_SCF(FAB_HK_ADDRESS);                                     //save HK in COM flash memory 
1AB62:  MOVFF  4B,341
1AB66:  MOVFF  4A,340
1AB6A:  MOVFF  49,33F
1AB6E:  MOVFF  48,33E
1AB72:  CALL   19AB8
....................          SEND_HKDATA_to_SMF(FAB_HK_ADDRESS);                                     //save HK in Mission flash memory 
1AB76:  MOVFF  4B,341
1AB7A:  MOVFF  4A,340
1AB7E:  MOVFF  49,33F
1AB82:  MOVFF  48,33E
1AB86:  CALL   19B28
....................          SEND_HKDATA_to_OF(FAB_HK_ADDRESS);                                      //save HK in OBC flash memory 
1AB8A:  MOVFF  4B,341
1AB8E:  MOVFF  4A,340
1AB92:  MOVFF  49,33F
1AB96:  MOVFF  48,33E
1AB9A:  CALL   19B94
....................          SEND_CWFORMAT_TO_SCF(FAB_CW_ADDRESS); 
1AB9E:  MOVFF  4F,341
1ABA2:  MOVFF  4E,340
1ABA6:  MOVFF  4D,33F
1ABAA:  MOVFF  4C,33E
1ABAE:  CALL   19C08
....................          SEND_CWFORMAT_TO_SMF(FAB_CW_ADDRESS); 
1ABB2:  MOVFF  4F,341
1ABB6:  MOVFF  4E,340
1ABBA:  MOVFF  4D,33F
1ABBE:  MOVFF  4C,33E
1ABC2:  CALL   19C78
....................          SEND_CWFORMAT_TO_OF(FAB_CW_ADDRESS); 
1ABC6:  MOVFF  4F,341
1ABCA:  MOVFF  4E,340
1ABCE:  MOVFF  4D,33F
1ABD2:  MOVFF  4C,33E
1ABD6:  CALL   19CA0
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1ABDA:  CALL   1AA6
....................          FAB_HK_ADDRESS = FAB_HK_ADDRESS + HK_size;                              //prepare for next storing address 
1ABDE:  MOVLW  7C
1ABE0:  ADDWF  48,F
1ABE2:  MOVLW  00
1ABE4:  ADDWFC 49,F
1ABE6:  ADDWFC 4A,F
1ABE8:  ADDWFC 4B,F
....................          FAB_CW_ADDRESS = FAB_CW_ADDRESS + CW_size;                              //prepare for next storing address 
1ABEA:  MOVLW  05
1ABEC:  ADDWF  4C,F
1ABEE:  MOVLW  00
1ABF0:  ADDWFC 4D,F
1ABF2:  ADDWFC 4E,F
1ABF4:  ADDWFC 4F,F
....................           
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
1ABF6:  RCALL  1A71E
....................           
....................          CHECK_50_and_CW_RESPOND(); 
1ABF8:  CALL   1AA6
....................           
....................          fprintf(PC,"\r\nCOUNT:%d\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
1ABFC:  MOVLW  3C
1ABFE:  MOVWF  FF6
1AC00:  MOVLW  10
1AC02:  MOVWF  FF7
1AC04:  MOVLW  00
1AC06:  MOVWF  FF8
1AC08:  MOVLW  08
1AC0A:  MOVLB  3
1AC0C:  MOVWF  xA2
1AC0E:  MOVLB  0
1AC10:  CALL   0702
1AC14:  MOVFF  2FB,33E
1AC18:  MOVLW  18
1AC1A:  MOVLB  3
1AC1C:  MOVWF  x3F
1AC1E:  MOVLB  0
1AC20:  CALL   2404
1AC24:  MOVLW  0D
1AC26:  BTFSS  F9E.4
1AC28:  BRA    1AC26
1AC2A:  MOVWF  FAD
1AC2C:  MOVLW  0A
1AC2E:  BTFSS  F9E.4
1AC30:  BRA    1AC2E
1AC32:  MOVWF  FAD
....................          HIGH_SAMP_FAB_MEASUERING_FLAG = 0; 
1AC34:  MOVLB  2
1AC36:  CLRF   xFB
....................           
....................       }else{ 
1AC38:  BRA    1AD66
....................          Delete_in_HK();                                                         //delet HK array 
1AC3A:  MOVLB  0
1AC3C:  CALL   190C8
....................          GET_RESET_DATA();                                                       //funcion que carga el array HKDATA con los datos del Reset PIC 
1AC40:  CALL   19328
....................          VERIFY_HIGH_SAMP_FABDATA(10000);                                        //get FAB data    
1AC44:  MOVLB  3
1AC46:  CLRF   x41
1AC48:  CLRF   x40
1AC4A:  MOVLW  27
1AC4C:  MOVWF  x3F
1AC4E:  MOVLW  10
1AC50:  MOVWF  x3E
1AC52:  MOVLB  0
1AC54:  RCALL  1A948
....................          GET_HIGH_SAMP_RESET_DATA();                                             //get reset data 
1AC56:  RCALL  1A9C6
....................          MAKE_HIGH_SAMP_ADCS_FORMAT();                                           //get ADCS data 
1AC58:  RCALL  1AAB6
....................          SET_IDENTIFIER(); 
1AC5A:  CALL   199DA
....................          //MAKE_CW_FORMAT(); 
....................                
....................          fprintf(PC,"\r\n"); 
1AC5E:  MOVLW  0D
1AC60:  BTFSS  F9E.4
1AC62:  BRA    1AC60
1AC64:  MOVWF  FAD
1AC66:  MOVLW  0A
1AC68:  BTFSS  F9E.4
1AC6A:  BRA    1AC68
1AC6C:  MOVWF  FAD
....................          for(int num = 0; num < 65; num++)                                       //array[0] to [64](until gyro data) 
1AC6E:  MOVLB  3
1AC70:  CLRF   x3D
1AC72:  MOVF   x3D,W
1AC74:  SUBLW  40
1AC76:  BNC   1ACA2
....................          { 
....................             fprintf(PC,"%x,",HKDATA[num]); 
1AC78:  CLRF   03
1AC7A:  MOVF   x3D,W
1AC7C:  ADDLW  7D
1AC7E:  MOVWF  FE9
1AC80:  MOVLW  02
1AC82:  ADDWFC 03,W
1AC84:  MOVWF  FEA
1AC86:  MOVFF  FEF,3A2
1AC8A:  MOVLW  57
1AC8C:  MOVWF  xA3
1AC8E:  MOVLB  0
1AC90:  CALL   0734
1AC94:  MOVLW  2C
1AC96:  BTFSS  F9E.4
1AC98:  BRA    1AC96
1AC9A:  MOVWF  FAD
1AC9C:  MOVLB  3
1AC9E:  INCF   x3D,F
1ACA0:  BRA    1AC72
....................          } 
....................          CHECK_50_and_CW_RESPOND(); 
1ACA2:  MOVLB  0
1ACA4:  CALL   1AA6
....................          for(num = 65; num < 113; num++) 
1ACA8:  MOVLW  41
1ACAA:  MOVLB  3
1ACAC:  MOVWF  x3D
1ACAE:  MOVF   x3D,W
1ACB0:  SUBLW  70
1ACB2:  BNC   1ACDE
....................          { 
....................           //fputc(HKDATA[num],PC); 
....................             fprintf(PC,"%x,",HKDATA[num]); 
1ACB4:  CLRF   03
1ACB6:  MOVF   x3D,W
1ACB8:  ADDLW  7D
1ACBA:  MOVWF  FE9
1ACBC:  MOVLW  02
1ACBE:  ADDWFC 03,W
1ACC0:  MOVWF  FEA
1ACC2:  MOVFF  FEF,3A2
1ACC6:  MOVLW  57
1ACC8:  MOVWF  xA3
1ACCA:  MOVLB  0
1ACCC:  CALL   0734
1ACD0:  MOVLW  2C
1ACD2:  BTFSS  F9E.4
1ACD4:  BRA    1ACD2
1ACD6:  MOVWF  FAD
1ACD8:  MOVLB  3
1ACDA:  INCF   x3D,F
1ACDC:  BRA    1ACAE
....................          } 
....................          CHECK_50_and_CW_RESPOND(); 
1ACDE:  MOVLB  0
1ACE0:  CALL   1AA6
....................          for(num = 113; num < HK_Size; num++) 
1ACE4:  MOVLW  71
1ACE6:  MOVLB  3
1ACE8:  MOVWF  x3D
1ACEA:  MOVF   x3D,W
1ACEC:  SUBLW  7B
1ACEE:  BNC   1AD1E
....................          { 
....................             fprintf(PC,",%x",HKDATA[num]); 
1ACF0:  CLRF   03
1ACF2:  MOVF   x3D,W
1ACF4:  ADDLW  7D
1ACF6:  MOVWF  FE9
1ACF8:  MOVLW  02
1ACFA:  ADDWFC 03,W
1ACFC:  MOVWF  FEA
1ACFE:  MOVFF  FEF,33E
1AD02:  MOVLW  2C
1AD04:  BTFSS  F9E.4
1AD06:  BRA    1AD04
1AD08:  MOVWF  FAD
1AD0A:  MOVFF  33E,3A2
1AD0E:  MOVLW  57
1AD10:  MOVWF  xA3
1AD12:  MOVLB  0
1AD14:  CALL   0734
1AD18:  MOVLB  3
1AD1A:  INCF   x3D,F
1AD1C:  BRA    1ACEA
....................          }  
....................          CHECK_50_and_CW_RESPOND(); 
1AD1E:  MOVLB  0
1AD20:  CALL   1AA6
....................           
....................          fprintf(PC,"\r\nCOUNT:%d\r\n",HIGH_SAMP_FAB_MEASUERING_FLAG); 
1AD24:  MOVLW  4A
1AD26:  MOVWF  FF6
1AD28:  MOVLW  10
1AD2A:  MOVWF  FF7
1AD2C:  MOVLW  00
1AD2E:  MOVWF  FF8
1AD30:  MOVLW  08
1AD32:  MOVLB  3
1AD34:  MOVWF  xA2
1AD36:  MOVLB  0
1AD38:  CALL   0702
1AD3C:  MOVFF  2FB,33E
1AD40:  MOVLW  18
1AD42:  MOVLB  3
1AD44:  MOVWF  x3F
1AD46:  MOVLB  0
1AD48:  CALL   2404
1AD4C:  MOVLW  0D
1AD4E:  BTFSS  F9E.4
1AD50:  BRA    1AD4E
1AD52:  MOVWF  FAD
1AD54:  MOVLW  0A
1AD56:  BTFSS  F9E.4
1AD58:  BRA    1AD56
1AD5A:  MOVWF  FAD
....................          CHECK_FAB_RESPONSE = 0; 
1AD5C:  MOVLB  3
1AD5E:  CLRF   x00
....................          SAVE_HIGH_SAMP_DATA_TO_EACH_MEMORY(); 
1AD60:  MOVLB  0
1AD62:  RCALL  1A71E
1AD64:  MOVLB  2
....................       }     
....................       //Delete_in_HK(); 
....................  
....................    FAB_DATA = 0; 
1AD66:  CLRF   xF9
....................    output_high(PIN_C4); 
1AD68:  BCF    F94.4
1AD6A:  BSF    F8B.4
....................  
....................    return; 
1AD6C:  MOVLB  0
1AD6E:  RETURN 0
.................... } 
....................  
....................  
.................... //--------CAM MISSION---------------------------------------------------------- 
.................... //#define STORE_TO_SING AA 
.................... ////////////////////////////////////////////////// 
.................... //CAM MISSION ID: 0x54                          // 
.................... //CAM ACK: 0x61                                 // 
.................... //CAM Finish Storing: 0x62                      // 
.................... ////////////////////////////////////////////////// 
....................  
.................... int8 CAM_ACK = 0; 
....................  
.................... #ORG 0x00019000 
.................... void Turn_On_CAM() 
.................... { 
....................    output_high(PIN_D7); 
*
1A462:  BCF    F95.7
1A464:  BSF    F8C.7
....................    return; 
1A466:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low(PIN_D7); 
*
190BC:  BCF    F95.7
190BE:  BCF    F8C.7
....................    return; 
190C0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Send_Command_to_CAM(int8 data)                                              //testing for EM integration 
.................... { 
....................    fputc(data,CAM); 
*
1A4CC:  MOVFF  338,339
1A4D0:  CALL   23BE
....................    fprintf(PC,"Command:%x\r\n",data); 
1A4D4:  MOVLW  58
1A4D6:  MOVWF  FF6
1A4D8:  MOVLW  10
1A4DA:  MOVWF  FF7
1A4DC:  MOVLW  00
1A4DE:  MOVWF  FF8
1A4E0:  MOVLW  08
1A4E2:  MOVLB  3
1A4E4:  MOVWF  xA2
1A4E6:  MOVLB  0
1A4E8:  CALL   0702
1A4EC:  MOVFF  338,3A2
1A4F0:  MOVLW  57
1A4F2:  MOVLB  3
1A4F4:  MOVWF  xA3
1A4F6:  MOVLB  0
1A4F8:  CALL   0734
1A4FC:  MOVLW  0D
1A4FE:  BTFSS  F9E.4
1A500:  BRA    1A4FE
1A502:  MOVWF  FAD
1A504:  MOVLW  0A
1A506:  BTFSS  F9E.4
1A508:  BRA    1A506
1A50A:  MOVWF  FAD
....................    return; 
1A50C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CAM_SETTINGS() 
.................... { 
....................    //disable_interrupts(INT_rda);                                                // Main to PC 
....................    fprintf(PC,"CAM Start operation\r\n"); 
*
1A468:  MOVLW  66
1A46A:  MOVWF  FF6
1A46C:  MOVLW  10
1A46E:  MOVWF  FF7
1A470:  MOVLW  00
1A472:  MOVWF  FF8
1A474:  CALL   058C
....................    COM_ONEBYTE_COMMAND = 0; 
1A478:  CLRF   x9A
....................    fprintf(PC,"Deleting 1 sector SMF Address 00080000\r\n"); 
1A47A:  MOVLW  7C
1A47C:  MOVWF  FF6
1A47E:  MOVLW  10
1A480:  MOVWF  FF7
1A482:  MOVLW  00
1A484:  MOVWF  FF8
1A486:  CALL   058C
....................    REFRESH_SECTOR_SMF(0x00,0x08,0x00,0x00);                                      //clear 1 sector MISSION flash CAM PART 
1A48A:  MOVLB  3
1A48C:  CLRF   x47
1A48E:  MOVLW  08
1A490:  MOVWF  x48
1A492:  CLRF   x49
1A494:  CLRF   x4A
1A496:  MOVLB  0
1A498:  CALL   1701E
....................    output_high(PIN_A5);                                                          //turn on MUX (give access to CAM) 
1A49C:  BCF    F92.5
1A49E:  BSF    F89.5
....................    delay_ms(100); 
1A4A0:  MOVLW  64
1A4A2:  MOVLB  3
1A4A4:  MOVWF  x98
1A4A6:  MOVLB  0
1A4A8:  CALL   0526
....................    Turn_On_CAM();                                                                //Turn on CAM 
1A4AC:  RCALL  1A462
....................    fprintf(PC,"Turned On CAM and MUX CAM side\r\n"); 
1A4AE:  MOVLW  A6
1A4B0:  MOVWF  FF6
1A4B2:  MOVLW  10
1A4B4:  MOVWF  FF7
1A4B6:  MOVLW  00
1A4B8:  MOVWF  FF8
1A4BA:  CALL   058C
....................    delay_ms(10); 
1A4BE:  MOVLW  0A
1A4C0:  MOVLB  3
1A4C2:  MOVWF  x98
1A4C4:  MOVLB  0
1A4C6:  CALL   0526
....................    return; 
1A4CA:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_10k()                                                    //check 10000 times (keep listening about 10 sec) 
.................... { 
....................    for(int32 num = 0; num < 1000000; num++)  
*
1A50E:  MOVLB  3
1A510:  CLRF   x3B
1A512:  CLRF   x3A
1A514:  CLRF   x39
1A516:  CLRF   x38
1A518:  MOVF   x3B,F
1A51A:  BNZ   1A556
1A51C:  MOVF   x3A,W
1A51E:  SUBLW  0F
1A520:  BNC   1A556
1A522:  BNZ   1A532
1A524:  MOVF   x39,W
1A526:  SUBLW  42
1A528:  BNC   1A556
1A52A:  BNZ   1A532
1A52C:  MOVF   x38,W
1A52E:  SUBLW  3F
1A530:  BNC   1A556
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
1A532:  BTFSC  F86.3
1A534:  BRA    1A544
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC    
1A536:  MOVLB  0
1A538:  CALL   10C8
1A53C:  MOVFF  01,319
....................          break; 
1A540:  MOVLB  3
1A542:  BRA    1A556
....................       } 
1A544:  MOVLW  01
1A546:  ADDWF  x38,F
1A548:  BTFSC  FD8.0
1A54A:  INCF   x39,F
1A54C:  BTFSC  FD8.2
1A54E:  INCF   x3A,F
1A550:  BTFSC  FD8.2
1A552:  INCF   x3B,F
1A554:  BRA    1A518
....................       //delay_ms(1); 
....................    } 
....................    return; 
1A556:  MOVLB  0
1A558:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_30k()                                                    //check 30000 times (keep listening about 30 sec) 
.................... { 
....................    for(int32 num = 0; num < 3000000; num++)  
*
19054:  MOVLB  3
19056:  CLRF   x80
19058:  CLRF   x7F
1905A:  CLRF   x7E
1905C:  CLRF   x7D
1905E:  MOVF   x80,F
19060:  BNZ   1909C
19062:  MOVF   x7F,W
19064:  SUBLW  2D
19066:  BNC   1909C
19068:  BNZ   19078
1906A:  MOVF   x7E,W
1906C:  SUBLW  C6
1906E:  BNC   1909C
19070:  BNZ   19078
19072:  MOVF   x7D,W
19074:  SUBLW  BF
19076:  BNC   1909C
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
19078:  BTFSC  F86.3
1907A:  BRA    1908A
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC    
1907C:  MOVLB  0
1907E:  CALL   10C8
19082:  MOVFF  01,319
....................          break; 
19086:  MOVLB  3
19088:  BRA    1909C
....................       } 
1908A:  MOVLW  01
1908C:  ADDWF  x7D,F
1908E:  BTFSC  FD8.0
19090:  INCF   x7E,F
19092:  BTFSC  FD8.2
19094:  INCF   x7F,F
19096:  BTFSC  FD8.2
19098:  INCF   x80,F
1909A:  BRA    1905E
....................       //delay_ms(1); 
....................    } 
....................    return; 
1909C:  MOVLB  0
1909E:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CHECK_ACK_FROM_CAM_200k()                                                   //check 200000 times(keep listening about 200 sec) 
.................... { 
....................    for(int32 num = 0; num < 40000000; num++)  
*
1A55A:  MOVLB  3
1A55C:  CLRF   x3B
1A55E:  CLRF   x3A
1A560:  CLRF   x39
1A562:  CLRF   x38
1A564:  MOVF   x3B,W
1A566:  SUBLW  02
1A568:  BNC   1A59E
1A56A:  BNZ   1A57A
1A56C:  MOVF   x3A,W
1A56E:  SUBLW  62
1A570:  BNC   1A59E
1A572:  BNZ   1A57A
1A574:  MOVF   x39,W
1A576:  SUBLW  59
1A578:  BNC   1A59E
....................    { 
....................       if(kbhit(CAM))                                                             //kbhit(PC) 
1A57A:  BTFSC  F86.3
1A57C:  BRA    1A58C
....................       { 
....................          CAM_ACK = fgetc(CAM);                                                   //PC 
1A57E:  MOVLB  0
1A580:  CALL   10C8
1A584:  MOVFF  01,319
....................          break; 
1A588:  MOVLB  3
1A58A:  BRA    1A59E
....................       } 
1A58C:  MOVLW  01
1A58E:  ADDWF  x38,F
1A590:  BTFSC  FD8.0
1A592:  INCF   x39,F
1A594:  BTFSC  FD8.2
1A596:  INCF   x3A,F
1A598:  BTFSC  FD8.2
1A59A:  INCF   x3B,F
1A59C:  BRA    1A564
....................       //delay_ms(1); 
....................    } 
....................    return; 
1A59E:  MOVLB  0
1A5A0:  RETURN 0
.................... } 
.................... /* 
.................... int8 ACK_from_CAM() 
.................... { 
....................    int8 ack; 
....................    ack = fgetc(CAM | PC); 
....................    return ack; 
.................... } 
....................  
.................... void Transfer_Photo() //transfer photo from Shared Mission Flash to Shared COM Flash 
.................... { 
....................    output_low(PIN_A5); 
....................    output_low(PIN_C4); 
....................    TRANSFER_DATA_NBYTE_SMFtoSCF(0,CAM_ADDRESS,65536); //from: sector0, to: sector1, datasize: 64kbyte(this value is for testing) 
....................    CAM_ADDRESS = CAM_ADDRESS + 65536; 
....................    return; 
.................... } 
.................... */ 
....................  
.................... #ORG 0x00019000 
.................... void CAM_TEST_OPERATION(int8 mode)                                               //Integration Testing With CAM 
.................... { 
....................    CAM_SETTINGS();                                                               //Turn ON CAM, delete 1 sector SCF address 00080000, MUX CAM side 
*
1AD94:  CALL   1A468
....................    delay_ms(5000);                                                               //Time is necessary for CAM to be ready 
1AD98:  MOVLW  14
1AD9A:  MOVLB  3
1AD9C:  MOVWF  x38
1AD9E:  MOVLW  FA
1ADA0:  MOVWF  x98
1ADA2:  MOVLB  0
1ADA4:  CALL   0526
1ADA8:  MOVLB  3
1ADAA:  DECFSZ x38,F
1ADAC:  BRA    1AD9E
....................  
....................  
....................    fprintf(PC,"Sending hand shake Command to CAM\r\n"); 
1ADAE:  MOVLW  12
1ADB0:  MOVWF  FF6
1ADB2:  MOVLW  11
1ADB4:  MOVWF  FF7
1ADB6:  MOVLW  00
1ADB8:  MOVWF  FF8
1ADBA:  MOVLB  0
1ADBC:  CALL   058C
....................    delay_ms(10); 
1ADC0:  MOVLW  0A
1ADC2:  MOVLB  3
1ADC4:  MOVWF  x98
1ADC6:  MOVLB  0
1ADC8:  CALL   0526
....................    Send_Command_to_CAM(0x54);                                                    //CAM MISSION ID 
1ADCC:  MOVLW  54
1ADCE:  MOVLB  3
1ADD0:  MOVWF  x38
1ADD2:  MOVLB  0
1ADD4:  CALL   1A4CC
....................    //fputc(0x54,PC); 
....................    CHECK_ACK_FROM_CAM_10k();                                                     //keep listening about 10 sec 
1ADD8:  CALL   1A50E
....................     
....................    if(CAM_ACK == 0x61)                                                           //CAM ACK 
1ADDC:  MOVLB  3
1ADDE:  MOVF   x19,W
1ADE0:  SUBLW  61
1ADE2:  BTFSS  FD8.2
1ADE4:  BRA    1B088
....................    { 
....................       CAM_ACK = 0; 
1ADE6:  CLRF   x19
....................       LOOP_CAM_ADDRESS();                                                        //hace un loop en las posiciones de memoria para almacenar CAM data 
1ADE8:  MOVLB  0
1ADEA:  CALL   1589A
....................       fprintf(PC,"ACK received from CAM\r\n\r\n"); 
1ADEE:  MOVLW  36
1ADF0:  MOVWF  FF6
1ADF2:  MOVLW  11
1ADF4:  MOVWF  FF7
1ADF6:  MOVLW  00
1ADF8:  MOVWF  FF8
1ADFA:  CALL   058C
....................       //delay_ms(1000); 
....................       fprintf(PC,"Sending CAM MODE data\r\n"); 
1ADFE:  MOVLW  50
1AE00:  MOVWF  FF6
1AE02:  MOVLW  11
1AE04:  MOVWF  FF7
1AE06:  MOVLW  00
1AE08:  MOVWF  FF8
1AE0A:  CALL   058C
....................       fputc(mode,CAM); 
1AE0E:  MOVFF  337,339
1AE12:  CALL   23BE
....................       CHECK_ACK_FROM_CAM_10k();                                                  //keep listening about 10 sec 
1AE16:  CALL   1A50E
....................       if(CAM_ACK == mode) 
1AE1A:  MOVLB  3
1AE1C:  MOVF   x37,W
1AE1E:  SUBWF  x19,W
1AE20:  BTFSS  FD8.2
1AE22:  BRA    1B086
....................       { 
....................             fprintf(PC,"Capturing and saving in SFM...\r\n\r\n"); 
1AE24:  MOVLW  68
1AE26:  MOVWF  FF6
1AE28:  MOVLW  11
1AE2A:  MOVWF  FF7
1AE2C:  MOVLW  00
1AE2E:  MOVWF  FF8
1AE30:  MOVLB  0
1AE32:  CALL   058C
....................           
....................          CHECK_ACK_FROM_CAM_200k();                                              //keep listening about 200 sec 
1AE36:  CALL   1A55A
....................           
....................          if(CAM_ACK == 0x62)                                                     //CAM Finish Storing 
1AE3A:  MOVLB  3
1AE3C:  MOVF   x19,W
1AE3E:  SUBLW  62
1AE40:  BTFSS  FD8.2
1AE42:  BRA    1B070
....................          { 
....................             CAM_ACK = 0; 
1AE44:  CLRF   x19
....................             fprintf(PC,"PHOTO SAVING DONE\r\n");    
1AE46:  MOVLW  8C
1AE48:  MOVWF  FF6
1AE4A:  MOVLW  11
1AE4C:  MOVWF  FF7
1AE4E:  MOVLW  00
1AE50:  MOVWF  FF8
1AE52:  MOVLB  0
1AE54:  CALL   058C
....................             output_low(PIN_A5);                                                  //Mission Flash MUX Main side 
1AE58:  BCF    F92.5
1AE5A:  BCF    F89.5
....................             delay_ms(10); 
1AE5C:  MOVLW  0A
1AE5E:  MOVLB  3
1AE60:  MOVWF  x98
1AE62:  MOVLB  0
1AE64:  CALL   0526
....................             //TRANSFER_DATA_NBYTE_TOPC_SMF(0x00000000,256);                      //for checking 
....................             output_low(PIN_C4);                                                  //COM Flash MUX Main side 
1AE68:  BCF    F94.4
1AE6A:  BCF    F8B.4
....................             delay_ms(10); 
1AE6C:  MOVLW  0A
1AE6E:  MOVLB  3
1AE70:  MOVWF  x98
1AE72:  MOVLB  0
1AE74:  CALL   0526
....................             fprintf(PC,"Read and Transfer data from SMF TO SCF and OF Start\r\n"); 
1AE78:  MOVLW  A0
1AE7A:  MOVWF  FF6
1AE7C:  MOVLW  11
1AE7E:  MOVWF  FF7
1AE80:  MOVLW  00
1AE82:  MOVWF  FF8
1AE84:  CALL   058C
....................             delay_ms(1000); 
1AE88:  MOVLW  04
1AE8A:  MOVLB  3
1AE8C:  MOVWF  x38
1AE8E:  MOVLW  FA
1AE90:  MOVWF  x98
1AE92:  MOVLB  0
1AE94:  CALL   0526
1AE98:  MOVLB  3
1AE9A:  DECFSZ x38,F
1AE9C:  BRA    1AE8E
....................              
....................             if(mode == 0xB0 || mode == 0xB1 || mode == 0xB2)                     //if CAM data size will be 2sectors 
1AE9E:  MOVF   x37,W
1AEA0:  SUBLW  B0
1AEA2:  BZ    1AEB0
1AEA4:  MOVF   x37,W
1AEA6:  SUBLW  B1
1AEA8:  BZ    1AEB0
1AEAA:  MOVF   x37,W
1AEAC:  SUBLW  B2
1AEAE:  BNZ   1AF8C
....................             { 
....................                sector_erase_SCF(CAM_ADDRESS);                                    //delete 1st sector 
1AEB0:  MOVFF  47,38C
1AEB4:  MOVFF  46,38B
1AEB8:  MOVFF  45,38A
1AEBC:  MOVFF  44,389
1AEC0:  MOVLB  0
1AEC2:  CALL   125EE
....................                sector_erase_SCF(CAM_ADDRESS + 65536);                            //delete 2nd sector 
1AEC6:  MOVFF  44,338
1AECA:  MOVLB  3
1AECC:  MOVFF  45,339
1AED0:  MOVLW  01
1AED2:  ADDWF  46,W
1AED4:  MOVWF  x3A
1AED6:  MOVLW  00
1AED8:  ADDWFC 47,W
1AEDA:  MOVWF  x3B
1AEDC:  MOVWF  x8C
1AEDE:  MOVFF  33A,38B
1AEE2:  MOVFF  45,38A
1AEE6:  MOVFF  44,389
1AEEA:  MOVLB  0
1AEEC:  CALL   125EE
....................                TRANSFER_DATA_NBYTE_SMFtoSCF(0x00080000,CAM_ADDRESS,80000);       //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AEF0:  MOVLB  3
1AEF2:  CLRF   x3B
1AEF4:  MOVLW  08
1AEF6:  MOVWF  x3A
1AEF8:  CLRF   x39
1AEFA:  CLRF   x38
1AEFC:  MOVFF  47,33F
1AF00:  MOVFF  46,33E
1AF04:  MOVFF  45,33D
1AF08:  MOVFF  44,33C
1AF0C:  CLRF   x43
1AF0E:  MOVLW  01
1AF10:  MOVWF  x42
1AF12:  MOVLW  38
1AF14:  MOVWF  x41
1AF16:  MOVLW  80
1AF18:  MOVWF  x40
1AF1A:  MOVLB  0
1AF1C:  CALL   13526
....................                TRANSFER_DATA_NBYTE_SMFtoOF(0x00080000,CAM_ADDRESS,80000);        //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AF20:  MOVLB  3
1AF22:  CLRF   x3B
1AF24:  MOVLW  08
1AF26:  MOVWF  x3A
1AF28:  CLRF   x39
1AF2A:  CLRF   x38
1AF2C:  MOVFF  47,33F
1AF30:  MOVFF  46,33E
1AF34:  MOVFF  45,33D
1AF38:  MOVFF  44,33C
1AF3C:  CLRF   x43
1AF3E:  MOVLW  01
1AF40:  MOVWF  x42
1AF42:  MOVLW  38
1AF44:  MOVWF  x41
1AF46:  MOVLW  80
1AF48:  MOVWF  x40
1AF4A:  MOVLB  0
1AF4C:  CALL   135B8
....................                TRANSFER_DATA_NBYTE_TOPC_SCF(CAM_ADDRESS,90000);                  //From(SCF): FROM CAM_ADDRESS To PC 
1AF50:  MOVFF  47,33B
1AF54:  MOVFF  46,33A
1AF58:  MOVFF  45,339
1AF5C:  MOVFF  44,338
1AF60:  MOVLB  3
1AF62:  CLRF   x3F
1AF64:  MOVLW  01
1AF66:  MOVWF  x3E
1AF68:  MOVLW  5F
1AF6A:  MOVWF  x3D
1AF6C:  MOVLW  90
1AF6E:  MOVWF  x3C
1AF70:  MOVLB  0
1AF72:  CALL   1364A
....................                CAM_ADDRESS = CAM_ADDRESS + 65536*2;                              //se ubica en la nueva posicion, dos sectores adelante 
1AF76:  MOVLW  02
1AF78:  ADDWF  46,F
1AF7A:  MOVLW  00
1AF7C:  ADDWFC 47,F
....................                delay_ms(10); 
1AF7E:  MOVLW  0A
1AF80:  MOVLB  3
1AF82:  MOVWF  x98
1AF84:  MOVLB  0
1AF86:  CALL   0526
1AF8A:  MOVLB  3
....................             } 
....................             if(mode == 0xA0 || mode == 0xA1 || mode == 0xA2) 
1AF8C:  MOVF   x37,W
1AF8E:  SUBLW  A0
1AF90:  BZ    1AF9E
1AF92:  MOVF   x37,W
1AF94:  SUBLW  A1
1AF96:  BZ    1AF9E
1AF98:  MOVF   x37,W
1AF9A:  SUBLW  A2
1AF9C:  BNZ   1B06E
....................             { 
....................                sector_erase_SCF(CAM_ADDRESS);                                    //delete 1st sector 
1AF9E:  MOVFF  47,38C
1AFA2:  MOVFF  46,38B
1AFA6:  MOVFF  45,38A
1AFAA:  MOVFF  44,389
1AFAE:  MOVLB  0
1AFB0:  CALL   125EE
....................                sector_erase_SCF(CAM_ADDRESS + 65536);                            //delete 2nd sector 
1AFB4:  MOVFF  44,338
1AFB8:  MOVLB  3
1AFBA:  MOVFF  45,339
1AFBE:  MOVLW  01
1AFC0:  ADDWF  46,W
1AFC2:  MOVWF  x3A
1AFC4:  MOVLW  00
1AFC6:  ADDWFC 47,W
1AFC8:  MOVWF  x3B
1AFCA:  MOVWF  x8C
1AFCC:  MOVFF  33A,38B
1AFD0:  MOVFF  45,38A
1AFD4:  MOVFF  44,389
1AFD8:  MOVLB  0
1AFDA:  CALL   125EE
....................                TRANSFER_DATA_NBYTE_SMFtoSCF(0x00080000,CAM_ADDRESS,65536);       //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1AFDE:  MOVLB  3
1AFE0:  CLRF   x3B
1AFE2:  MOVLW  08
1AFE4:  MOVWF  x3A
1AFE6:  CLRF   x39
1AFE8:  CLRF   x38
1AFEA:  MOVFF  47,33F
1AFEE:  MOVFF  46,33E
1AFF2:  MOVFF  45,33D
1AFF6:  MOVFF  44,33C
1AFFA:  CLRF   x43
1AFFC:  MOVLW  01
1AFFE:  MOVWF  x42
1B000:  CLRF   x41
1B002:  CLRF   x40
1B004:  MOVLB  0
1B006:  CALL   13526
....................                TRANSFER_DATA_NBYTE_SMFtoOF(0x00080000,CAM_ADDRESS,65536);        //From(SMF): sector8, To(SCF): sector indicated by CAM_ADDRESS 
1B00A:  MOVLB  3
1B00C:  CLRF   x3B
1B00E:  MOVLW  08
1B010:  MOVWF  x3A
1B012:  CLRF   x39
1B014:  CLRF   x38
1B016:  MOVFF  47,33F
1B01A:  MOVFF  46,33E
1B01E:  MOVFF  45,33D
1B022:  MOVFF  44,33C
1B026:  CLRF   x43
1B028:  MOVLW  01
1B02A:  MOVWF  x42
1B02C:  CLRF   x41
1B02E:  CLRF   x40
1B030:  MOVLB  0
1B032:  CALL   135B8
....................                TRANSFER_DATA_NBYTE_TOPC_SCF(CAM_ADDRESS,65536); 
1B036:  MOVFF  47,33B
1B03A:  MOVFF  46,33A
1B03E:  MOVFF  45,339
1B042:  MOVFF  44,338
1B046:  MOVLB  3
1B048:  CLRF   x3F
1B04A:  MOVLW  01
1B04C:  MOVWF  x3E
1B04E:  CLRF   x3D
1B050:  CLRF   x3C
1B052:  MOVLB  0
1B054:  CALL   1364A
....................                CAM_ADDRESS = CAM_ADDRESS + 65536; 
1B058:  MOVLW  01
1B05A:  ADDWF  46,F
1B05C:  MOVLW  00
1B05E:  ADDWFC 47,F
....................                delay_ms(10); 
1B060:  MOVLW  0A
1B062:  MOVLB  3
1B064:  MOVWF  x98
1B066:  MOVLB  0
1B068:  CALL   0526
1B06C:  MOVLB  3
....................             } 
....................              
....................          }else{ 
1B06E:  BRA    1B086
....................             CAM_ACK = 0; 
1B070:  CLRF   x19
....................             fprintf(PC,"CAM DATA SAVING FAILURED\r\n"); 
1B072:  MOVLW  D6
1B074:  MOVWF  FF6
1B076:  MOVLW  11
1B078:  MOVWF  FF7
1B07A:  MOVLW  00
1B07C:  MOVWF  FF8
1B07E:  MOVLB  0
1B080:  CALL   058C
1B084:  MOVLB  3
....................          }    
....................       }    
....................  
....................    }else{ 
1B086:  BRA    1B09E
....................       CAM_ACK = 0; 
1B088:  CLRF   x19
....................       fprintf(PC,"CAM ACK FAILURED\r\n"); 
1B08A:  MOVLW  F2
1B08C:  MOVWF  FF6
1B08E:  MOVLW  11
1B090:  MOVWF  FF7
1B092:  MOVLW  00
1B094:  MOVWF  FF8
1B096:  MOVLB  0
1B098:  CALL   058C
1B09C:  MOVLB  3
....................    } 
....................    
....................    Turn_Off_CAM(); 
1B09E:  MOVLB  0
1B0A0:  CALL   190BC
....................    fprintf(PC,"Turned OFF CAM\r\n"); 
1B0A4:  MOVLW  06
1B0A6:  MOVWF  FF6
1B0A8:  MOVLW  12
1B0AA:  MOVWF  FF7
1B0AC:  MOVLW  00
1B0AE:  MOVWF  FF8
1B0B0:  CALL   058C
....................    output_high(PIN_C4); //Give Access to COM PIC 
1B0B4:  BCF    F94.4
1B0B6:  BSF    F8B.4
....................    //fputc(0x69,COM);  
....................    //enable_interrupts(INT_rda);   // Main to PC 
....................    return; 
1B0B8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void CAM_DEPLOYMENT_OPERATION(int8 mode) 
.................... { 
....................    CAM_SETTINGS();                                                               //Turn ON CAM, delete 1 sector SCF address 00080000, MUX CAM side 
*
1A5A2:  RCALL  1A468
....................    delay_ms(5000);                                                               //Time is necessary for CAM to be ready 
1A5A4:  MOVLW  14
1A5A6:  MOVLB  3
1A5A8:  MOVWF  x2E
1A5AA:  MOVLW  FA
1A5AC:  MOVWF  x98
1A5AE:  MOVLB  0
1A5B0:  CALL   0526
1A5B4:  MOVLB  3
1A5B6:  DECFSZ x2E,F
1A5B8:  BRA    1A5AA
....................    fprintf(PC,"Sending hand shake Command to CAM\r\n"); 
1A5BA:  MOVLW  18
1A5BC:  MOVWF  FF6
1A5BE:  MOVLW  12
1A5C0:  MOVWF  FF7
1A5C2:  MOVLW  00
1A5C4:  MOVWF  FF8
1A5C6:  MOVLB  0
1A5C8:  CALL   058C
....................    delay_ms(10); 
1A5CC:  MOVLW  0A
1A5CE:  MOVLB  3
1A5D0:  MOVWF  x98
1A5D2:  MOVLB  0
1A5D4:  CALL   0526
....................    Send_Command_to_CAM(0x54);                                                    //CAM MISSION ID 
1A5D8:  MOVLW  54
1A5DA:  MOVLB  3
1A5DC:  MOVWF  x38
1A5DE:  MOVLB  0
1A5E0:  RCALL  1A4CC
....................    CHECK_ACK_FROM_CAM_10k();                                                     //keep listening about 10 sec 
1A5E2:  RCALL  1A50E
....................    if(CAM_ACK == 0x61)                                                           //CAM ACK 
1A5E4:  MOVLB  3
1A5E6:  MOVF   x19,W
1A5E8:  SUBLW  61
1A5EA:  BTFSS  FD8.2
1A5EC:  BRA    1A6E0
....................    { 
....................       fprintf(PC,"ACK received from CAM\r\n\r\n"); 
1A5EE:  MOVLW  3C
1A5F0:  MOVWF  FF6
1A5F2:  MOVLW  12
1A5F4:  MOVWF  FF7
1A5F6:  MOVLW  00
1A5F8:  MOVWF  FF8
1A5FA:  MOVLB  0
1A5FC:  CALL   058C
....................       CAM_ACK = 0;       
1A600:  MOVLB  3
1A602:  CLRF   x19
....................       for(int a = 0; a < 1; a++)                                               //deployment capture repetition 
1A604:  CLRF   x2D
1A606:  MOVF   x2D,F
1A608:  BNZ   1A6DE
....................       { 
....................          LOOP_CAM_ADDRESS();                                                    //hace un loop en las posiciones de memoria para almacenar CAM data 
1A60A:  MOVLB  0
1A60C:  CALL   1589A
....................          fprintf(PC,"Sending CAM MODE data\r\n"); 
1A610:  MOVLW  56
1A612:  MOVWF  FF6
1A614:  MOVLW  12
1A616:  MOVWF  FF7
1A618:  MOVLW  00
1A61A:  MOVWF  FF8
1A61C:  CALL   058C
....................          delay_ms(2000);                                                         //for CAM to go waiting for OBC cmnd 
1A620:  MOVLW  08
1A622:  MOVLB  3
1A624:  MOVWF  x2E
1A626:  MOVLW  FA
1A628:  MOVWF  x98
1A62A:  MOVLB  0
1A62C:  CALL   0526
1A630:  MOVLB  3
1A632:  DECFSZ x2E,F
1A634:  BRA    1A626
....................          fputc(mode,CAM); 
1A636:  MOVFF  32C,339
1A63A:  MOVLB  0
1A63C:  CALL   23BE
....................          CHECK_ACK_FROM_CAM_10k();                                              //keep listening about 10 sec 
1A640:  RCALL  1A50E
....................             if(CAM_ACK == mode) 
1A642:  MOVLB  3
1A644:  MOVF   x2C,W
1A646:  SUBWF  x19,W
1A648:  BNZ   1A6DA
....................             { 
....................                fprintf(PC,"Capturing and saving in SFM...\r\n\r\n"); 
1A64A:  MOVLW  6E
1A64C:  MOVWF  FF6
1A64E:  MOVLW  12
1A650:  MOVWF  FF7
1A652:  MOVLW  00
1A654:  MOVWF  FF8
1A656:  MOVLB  0
1A658:  CALL   058C
....................                CHECK_ACK_FROM_CAM_200k();                                       //keep listening about 200 sec 
1A65C:  RCALL  1A55A
....................                //CHECK_ACK_FROM_CAM_30k();                                         //keep listening about 30 sec 
....................                   if(CAM_ACK == 0x62)                                           //CAM Finish Storing 
1A65E:  MOVLB  3
1A660:  MOVF   x19,W
1A662:  SUBLW  62
1A664:  BNZ   1A6C4
....................                   { 
....................                      CAM_ACK = 0; 
1A666:  CLRF   x19
....................                      fprintf(PC,"PHOTO %d SAVING DONE\r\n",a+1);                     
1A668:  MOVLW  01
1A66A:  ADDWF  x2D,W
1A66C:  MOVWF  x2E
1A66E:  MOVLW  92
1A670:  MOVWF  FF6
1A672:  MOVLW  12
1A674:  MOVWF  FF7
1A676:  MOVLW  00
1A678:  MOVWF  FF8
1A67A:  MOVLW  06
1A67C:  MOVWF  xA2
1A67E:  MOVLB  0
1A680:  CALL   0702
1A684:  MOVFF  32E,33E
1A688:  MOVLW  18
1A68A:  MOVLB  3
1A68C:  MOVWF  x3F
1A68E:  MOVLB  0
1A690:  CALL   2404
1A694:  MOVLW  9A
1A696:  MOVWF  FF6
1A698:  MOVLW  12
1A69A:  MOVWF  FF7
1A69C:  MOVLW  00
1A69E:  MOVWF  FF8
1A6A0:  MOVLW  0E
1A6A2:  MOVLB  3
1A6A4:  MOVWF  xA2
1A6A6:  MOVLB  0
1A6A8:  CALL   0702
....................                      CAM_ADDRESS = CAM_ADDRESS + 65536;                          //se ubica en la nueva posicion, 10 sectores adelante 
1A6AC:  MOVLW  01
1A6AE:  ADDWF  46,F
1A6B0:  MOVLW  00
1A6B2:  ADDWFC 47,F
....................                      //sector_erase_SCF(CAM_ADDRESS); 
....................                      delay_ms(10); 
1A6B4:  MOVLW  0A
1A6B6:  MOVLB  3
1A6B8:  MOVWF  x98
1A6BA:  MOVLB  0
1A6BC:  CALL   0526
....................        
....................                   }else{ 
1A6C0:  BRA    1A6D8
1A6C2:  MOVLB  3
....................                      CAM_ACK = 0; 
1A6C4:  CLRF   x19
....................                      fprintf(PC,"CAM DATA SAVING FAILURED\r\n"); 
1A6C6:  MOVLW  AA
1A6C8:  MOVWF  FF6
1A6CA:  MOVLW  12
1A6CC:  MOVWF  FF7
1A6CE:  MOVLW  00
1A6D0:  MOVWF  FF8
1A6D2:  MOVLB  0
1A6D4:  CALL   058C
1A6D8:  MOVLB  3
....................                   }    
....................             }    
1A6DA:  INCF   x2D,F
1A6DC:  BRA    1A606
....................          } 
....................    }else{ 
1A6DE:  BRA    1A6F6
....................       CAM_ACK = 0; 
1A6E0:  CLRF   x19
....................       fprintf(PC,"CAM ACK FAILURED\r\n"); 
1A6E2:  MOVLW  C6
1A6E4:  MOVWF  FF6
1A6E6:  MOVLW  12
1A6E8:  MOVWF  FF7
1A6EA:  MOVLW  00
1A6EC:  MOVWF  FF8
1A6EE:  MOVLB  0
1A6F0:  CALL   058C
1A6F4:  MOVLB  3
....................    } 
....................    output_low(PIN_A5);                                                           //Mission Flash MUX Main side 
1A6F6:  BCF    F92.5
1A6F8:  BCF    F89.5
....................    delay_ms(10); 
1A6FA:  MOVLW  0A
1A6FC:  MOVWF  x98
1A6FE:  MOVLB  0
1A700:  CALL   0526
....................    Turn_Off_CAM(); 
1A704:  CALL   190BC
....................    fprintf(PC,"Turned OFF CAM\r\n"); 
1A708:  MOVLW  DA
1A70A:  MOVWF  FF6
1A70C:  MOVLW  12
1A70E:  MOVWF  FF7
1A710:  MOVLW  00
1A712:  MOVWF  FF8
1A714:  CALL   058C
....................    output_high(PIN_C4);                                                          //Give Access to COM PIC 
1A718:  BCF    F94.4
1A71A:  BSF    F8B.4
....................    return; 
1A71C:  RETURN 0
.................... } 
....................  
.................... //-------Kill Switch----------------------------------------------------------- 
.................... Static int8 KILL_COUNTER = 0; 
.................... #ORG 0x00019000 
.................... void Count_Kill_Flag() 
.................... { 
....................    KILL_COUNTER++; 
*
1B444:  MOVLB  3
1B446:  INCF   x1A,F
....................    if(Kill_COUNTER > 4) 
1B448:  MOVF   x1A,W
1B44A:  SUBLW  04
1B44C:  BC    1B460
....................    { 
....................       Kill_FLAG_MAIN = 1; 
1B44E:  MOVLW  01
1B450:  MOVLB  0
1B452:  MOVWF  x75
....................       output_high(PIN_A4);                                                       //Kill Switch ON 
1B454:  BCF    F92.4
1B456:  BSF    F89.4
....................       fputc(0x17,FAB); 
1B458:  MOVLW  17
1B45A:  CALL   1AB8
1B45E:  MOVLB  3
....................    } 
....................    fprintf(PC,"Kill counter: %x\r\n",KILL_COUNTER); 
1B460:  MOVLW  EC
1B462:  MOVWF  FF6
1B464:  MOVLW  12
1B466:  MOVWF  FF7
1B468:  MOVLW  00
1B46A:  MOVWF  FF8
1B46C:  MOVLW  0E
1B46E:  MOVWF  xA2
1B470:  MOVLB  0
1B472:  CALL   0702
1B476:  MOVFF  31A,3A2
1B47A:  MOVLW  57
1B47C:  MOVLB  3
1B47E:  MOVWF  xA3
1B480:  MOVLB  0
1B482:  CALL   0734
1B486:  MOVLW  0D
1B488:  BTFSS  F9E.4
1B48A:  BRA    1B488
1B48C:  MOVWF  FAD
1B48E:  MOVLW  0A
1B490:  BTFSS  F9E.4
1B492:  BRA    1B490
1B494:  MOVWF  FAD
....................    return; 
1B496:  RETURN 0
.................... } 
....................  
.................... #ORG 0x00019000 
.................... void Disable_Kill() 
.................... { 
....................    KILL_COUNTER = 0; 
1B498:  MOVLB  3
1B49A:  CLRF   x1A
....................     
....................    Kill_FLAG_MAIN = 0; 
1B49C:  MOVLB  0
1B49E:  CLRF   x75
....................    output_low(PIN_A4);                                                           //Kill Switch OFF 
1B4A0:  BCF    F92.4
1B4A2:  BCF    F89.4
....................    fputc(0x18,FAB); 
1B4A4:  MOVLW  18
1B4A6:  CALL   1AB8
....................     
....................    fprintf(PC,"Kill counter: %x\r\n",KILL_COUNTER); 
1B4AA:  MOVLW  00
1B4AC:  MOVWF  FF6
1B4AE:  MOVLW  13
1B4B0:  MOVWF  FF7
1B4B2:  MOVLW  00
1B4B4:  MOVWF  FF8
1B4B6:  MOVLW  0E
1B4B8:  MOVLB  3
1B4BA:  MOVWF  xA2
1B4BC:  MOVLB  0
1B4BE:  CALL   0702
1B4C2:  MOVFF  31A,3A2
1B4C6:  MOVLW  57
1B4C8:  MOVLB  3
1B4CA:  MOVWF  xA3
1B4CC:  MOVLB  0
1B4CE:  CALL   0734
1B4D2:  MOVLW  0D
1B4D4:  BTFSS  F9E.4
1B4D6:  BRA    1B4D4
1B4D8:  MOVWF  FAD
1B4DA:  MOVLW  0A
1B4DC:  BTFSS  F9E.4
1B4DE:  BRA    1B4DC
1B4E0:  MOVWF  FAD
....................    return; 
1B4E2:  RETURN 0
.................... } 
....................  
.................... //-------Reset Function-------------------------------------------------------- 
.................... #ORG 0x0001B800 
.................... void BC_ON_30min() 
.................... { 
....................    if(currenttime > 1805 && BC_ATTEMPT_FLAG == 0)                                //if first attempt and 30 min(1800sec) passed 
*
1B9DC:  MOVLB  2
1B9DE:  MOVF   x4A,W
1B9E0:  SUBLW  06
1B9E2:  BC    1BAB2
1B9E4:  XORLW  FF
1B9E6:  BNZ   1B9EE
1B9E8:  MOVF   x49,W
1B9EA:  SUBLW  0D
1B9EC:  BC    1BAB2
1B9EE:  MOVLB  0
1B9F0:  MOVF   x68,F
1B9F2:  BTFSC  FD8.2
1B9F4:  BRA    1B9FA
1B9F6:  MOVLB  2
1B9F8:  BRA    1BAB2
....................    { 
....................       fprintf(PC,"sending BC command to RESET PIC\r\n"); 
1B9FA:  MOVLW  14
1B9FC:  MOVWF  FF6
1B9FE:  MOVLW  13
1BA00:  MOVWF  FF7
1BA02:  MOVLW  00
1BA04:  MOVWF  FF8
1BA06:  CALL   058C
....................       for(int16 num = 0; num < 200; num++) 
1BA0A:  MOVLB  3
1BA0C:  CLRF   x3E
1BA0E:  CLRF   x3D
1BA10:  MOVF   x3E,F
1BA12:  BNZ   1BA44
1BA14:  MOVF   x3D,W
1BA16:  SUBLW  C7
1BA18:  BNC   1BA44
....................       { 
....................          fputc(0xBC,reset); 
1BA1A:  MOVLW  BC
1BA1C:  MOVLB  0
1BA1E:  CALL   15B0
....................          delay_ms(100); 
1BA22:  MOVLW  64
1BA24:  MOVLB  3
1BA26:  MOVWF  x98
1BA28:  MOVLB  0
1BA2A:  CALL   0526
....................          if(reset_bffr[0] == 0xCB)                                               //condicion para que deje de enviar al recibir el ACK 
1BA2E:  MOVF   x9E,W
1BA30:  SUBLW  CB
1BA32:  BNZ   1BA3A
....................          { 
....................          break; 
1BA34:  MOVLB  3
1BA36:  BRA    1BA44
1BA38:  MOVLB  0
....................          } 
1BA3A:  MOVLB  3
1BA3C:  INCF   x3D,F
1BA3E:  BTFSC  FD8.2
1BA40:  INCF   x3E,F
1BA42:  BRA    1BA10
....................       } 
....................       delay_ms(1000);                                                             
1BA44:  MOVLW  04
1BA46:  MOVWF  x3F
1BA48:  MOVLW  FA
1BA4A:  MOVWF  x98
1BA4C:  MOVLB  0
1BA4E:  CALL   0526
1BA52:  MOVLB  3
1BA54:  DECFSZ x3F,F
1BA56:  BRA    1BA48
....................       if(reset_bffr[0] == 0xCB) 
1BA58:  MOVLB  0
1BA5A:  MOVF   x9E,W
1BA5C:  SUBLW  CB
1BA5E:  BNZ   1BAB0
....................       { 
....................          BC_OPERATION(); 
1BA60:  CALL   1A1AE
....................          BC_ATTEMPT_FLAG++; 
1BA64:  INCF   x68,F
....................          WRITE_FLAG_to_EEPROM(); 
1BA66:  CALL   11C84
....................          STORE_FLAG_INFO(); 
1BA6A:  CALL   14000
....................          STORE_ADRESS_DATA_TO_FLASH(); 
1BA6E:  CALL   144C8
....................          reset_bffr[0] = 0; 
1BA72:  CLRF   x9E
....................          RESET_DATA = 0; 
1BA74:  CLRF   x9D
....................          delay_ms(1000); 
1BA76:  MOVLW  04
1BA78:  MOVLB  3
1BA7A:  MOVWF  x3F
1BA7C:  MOVLW  FA
1BA7E:  MOVWF  x98
1BA80:  MOVLB  0
1BA82:  CALL   0526
1BA86:  MOVLB  3
1BA88:  DECFSZ x3F,F
1BA8A:  BRA    1BA7C
....................          delay_ms(20000);                                                        //wait until RESET goes back to nomal loop 
1BA8C:  MOVLW  50
1BA8E:  MOVWF  x3F
1BA90:  MOVLW  FA
1BA92:  MOVWF  x98
1BA94:  MOVLB  0
1BA96:  CALL   0526
1BA9A:  MOVLB  3
1BA9C:  DECFSZ x3F,F
1BA9E:  BRA    1BA90
....................          SAVE_SAT_LOG(0xBC,0x30,0x30);                                           //first 30 min antenna deployment 
1BAA0:  MOVLW  BC
1BAA2:  MOVWF  x53
1BAA4:  MOVLW  30
1BAA6:  MOVWF  x54
1BAA8:  MOVWF  x55
1BAAA:  MOVLB  0
1BAAC:  CALL   16EE2
1BAB0:  MOVLB  2
....................       } 
....................    } 
....................    return; 
1BAB2:  MOVLB  0
1BAB4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void HIGHSAMP_SENSOR_COLLECTION(int16 times) 
.................... { 
....................    LOOP_HIGH_SAMP_HK_ADDRESS();                                                  //loop in memory to save data, keep first 3 sectors forever 
1BAB6:  CALL   158F6
....................    int32 num = 0; 
1BABA:  MOVLB  3
1BABC:  CLRF   x3C
1BABE:  CLRF   x3B
1BAC0:  CLRF   x3A
1BAC2:  CLRF   x39
....................  
....................    while(num < times) 
1BAC4:  MOVF   x3C,F
1BAC6:  BTFSS  FD8.2
1BAC8:  BRA    1BB92
1BACA:  MOVF   x3B,F
1BACC:  BTFSS  FD8.2
1BACE:  BRA    1BB92
1BAD0:  MOVF   x3A,W
1BAD2:  SUBWF  x38,W
1BAD4:  BNC   1BB92
1BAD6:  BNZ   1BADE
1BAD8:  MOVF   x37,W
1BADA:  SUBWF  x39,W
1BADC:  BC    1BB92
....................    { 
....................       CHECK_50_and_CW_RESPOND();                                                 //check cw cmd from COM PIC 
1BADE:  MOVLB  0
1BAE0:  CALL   1AA6
....................       if(FAB_FLAG > 4) 
1BAE4:  MOVLB  2
1BAE6:  MOVF   xFF,F
1BAE8:  BNZ   1BAF8
1BAEA:  MOVF   xFE,F
1BAEC:  BNZ   1BAF8
1BAEE:  MOVF   xFD,F
1BAF0:  BNZ   1BAF8
1BAF2:  MOVF   xFC,W
1BAF4:  SUBLW  04
1BAF6:  BC    1BB6E
....................       { 
....................          FAB_FLAG = 0; 
1BAF8:  CLRF   xFF
1BAFA:  CLRF   xFE
1BAFC:  CLRF   xFD
1BAFE:  CLRF   xFC
....................          HIGH_SAMP_FAB_OPERATION();                                              //collect FAB, RESET and ADCS data 
1BB00:  MOVLB  0
1BB02:  CALL   1AAFE
....................           
....................          num++; 
1BB06:  MOVLW  01
1BB08:  MOVLB  3
1BB0A:  ADDWF  x39,F
1BB0C:  BTFSC  FD8.0
1BB0E:  INCF   x3A,F
1BB10:  BTFSC  FD8.2
1BB12:  INCF   x3B,F
1BB14:  BTFSC  FD8.2
1BB16:  INCF   x3C,F
....................          if((num % 20) == 0)                                                     //once in the 20 times(every 100sec save the address to the flash) 
1BB18:  BSF    FD8.1
1BB1A:  MOVLW  03
1BB1C:  MOVWF  FEA
1BB1E:  MOVLW  3D
1BB20:  MOVWF  FE9
1BB22:  MOVFF  33C,351
1BB26:  MOVFF  33B,350
1BB2A:  MOVFF  33A,34F
1BB2E:  MOVFF  339,34E
1BB32:  CLRF   x55
1BB34:  CLRF   x54
1BB36:  CLRF   x53
1BB38:  MOVLW  14
1BB3A:  MOVWF  x52
1BB3C:  MOVLB  0
1BB3E:  CALL   2112
1BB42:  MOVFF  340,344
1BB46:  MOVFF  33F,343
1BB4A:  MOVFF  33E,342
1BB4E:  MOVFF  33D,341
1BB52:  MOVLB  3
1BB54:  MOVF   x41,F
1BB56:  BNZ   1BB6C
1BB58:  MOVF   x42,F
1BB5A:  BNZ   1BB6C
1BB5C:  MOVF   x43,F
1BB5E:  BNZ   1BB6C
1BB60:  MOVF   x44,F
1BB62:  BNZ   1BB6C
....................          { 
....................             STORE_ADRESS_DATA_TO_FLASH();                                        //for store the flag 
1BB64:  MOVLB  0
1BB66:  CALL   144C8
1BB6A:  MOVLB  3
1BB6C:  MOVLB  2
....................          }  
....................       } 
....................  
....................       BC_ON_30min();                                                             //check if first attempt and 30 min(1800sec) passed 
1BB6E:  MOVLB  0
1BB70:  RCALL  1B9DC
....................       if((CMD_FROM_PC[0] == 0xAB)||(in_bffr_main[4] == 0xAB))                    //forced termination function 
1BB72:  MOVF   x7E,W
1BB74:  SUBLW  AB
1BB76:  BZ    1BB7E
1BB78:  MOVF   x8A,W
1BB7A:  SUBLW  AB
1BB7C:  BNZ   1BB88
....................       { 
....................          Delete_Buffer(); 
1BB7E:  CALL   1272A
....................          break; 
1BB82:  MOVLB  3
1BB84:  BRA    1BB92
1BB86:  MOVLB  0
....................       } 
....................       PC_DATA = 0; 
1BB88:  CLRF   x99
....................       RESET_SATELLITE();                                                         //check reset command from RESET PIC 
1BB8A:  CALL   16CEE
1BB8E:  MOVLB  3
1BB90:  BRA    1BAC4
....................    } 
....................    fprintf(PC,"HSSC DONE\r\n"); 
1BB92:  MOVLW  36
1BB94:  MOVWF  FF6
1BB96:  MOVLW  13
1BB98:  MOVWF  FF7
1BB9A:  MOVLW  00
1BB9C:  MOVWF  FF8
1BB9E:  MOVLB  0
1BBA0:  CALL   058C
....................    return; 
1BBA4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void REPLY_TO_COM(int8 data1,int8 data2) 
.................... { 
....................    if(ACK_for_COM[12] == 0x66 && ACK_for_COM[14] == 0x77) 
*
1D84A:  MOVLB  1
1D84C:  MOVF   xEF,W
1D84E:  SUBLW  66
1D850:  BNZ   1D8CA
1D852:  MOVF   xF1,W
1D854:  SUBLW  77
1D856:  BNZ   1D8CA
....................    { 
....................       for(int n = 0; n < 24; n++)                                                //send back the acknowledge 
1D858:  MOVLB  3
1D85A:  CLRF   x39
1D85C:  MOVF   x39,W
1D85E:  SUBLW  17
1D860:  BNC   1D882
....................       { 
....................          fputc(ACK_for_COM[n],COM); 
1D862:  CLRF   03
1D864:  MOVF   x39,W
1D866:  ADDLW  E3
1D868:  MOVWF  FE9
1D86A:  MOVLW  01
1D86C:  ADDWFC 03,W
1D86E:  MOVWF  FEA
1D870:  MOVFF  FEF,33B
1D874:  MOVF   x3B,W
1D876:  MOVLB  0
1D878:  CALL   1A0A
1D87C:  MOVLB  3
1D87E:  INCF   x39,F
1D880:  BRA    1D85C
....................       } 
....................       for(n = 0; n < 24; n++)                                                    //send back the acknowledge 
1D882:  CLRF   x39
1D884:  MOVF   x39,W
1D886:  SUBLW  17
1D888:  BNC   1D8B4
....................       { 
....................          fprintf(PC,"%x,",ACK_for_COM[n]); 
1D88A:  CLRF   03
1D88C:  MOVF   x39,W
1D88E:  ADDLW  E3
1D890:  MOVWF  FE9
1D892:  MOVLW  01
1D894:  ADDWFC 03,W
1D896:  MOVWF  FEA
1D898:  MOVFF  FEF,3A2
1D89C:  MOVLW  57
1D89E:  MOVWF  xA3
1D8A0:  MOVLB  0
1D8A2:  CALL   0734
1D8A6:  MOVLW  2C
1D8A8:  BTFSS  F9E.4
1D8AA:  BRA    1D8A8
1D8AC:  MOVWF  FAD
1D8AE:  MOVLB  3
1D8B0:  INCF   x39,F
1D8B2:  BRA    1D884
....................       } 
....................       fprintf(PC,",AUTO\r\n"); 
1D8B4:  MOVLW  42
1D8B6:  MOVWF  FF6
1D8B8:  MOVLW  13
1D8BA:  MOVWF  FF7
1D8BC:  MOVLW  00
1D8BE:  MOVWF  FF8
1D8C0:  MOVLB  0
1D8C2:  CALL   058C
....................    } 
1D8C6:  BRA    1D948
1D8C8:  MOVLB  1
....................    else{ 
....................       //REFLESH_MSN_ACK_for_COM(); 
....................       //!      for(int n = 7; n < 24; n++)//send back the acknowledge 
....................       //!      { 
....................       //!         ACK_for_COM[n] = 0xff; 
....................       //!      } 
....................       ACK_for_COM[0] = 0xAA; 
1D8CA:  MOVLW  AA
1D8CC:  MOVWF  xE3
....................       ACK_for_COM[12] = data1; 
1D8CE:  MOVFF  337,1EF
....................       ACK_for_COM[13] = data2; 
1D8D2:  MOVFF  338,1F0
....................       ACK_for_COM[23] = 0xBB; 
1D8D6:  MOVLW  BB
1D8D8:  MOVWF  xFA
....................       for(int n = 0; n < 24; n++)                                                //send back the acknowledge 
1D8DA:  MOVLB  3
1D8DC:  CLRF   x3A
1D8DE:  MOVF   x3A,W
1D8E0:  SUBLW  17
1D8E2:  BNC   1D904
....................       { 
....................          fputc(ACK_for_COM[n],COM); 
1D8E4:  CLRF   03
1D8E6:  MOVF   x3A,W
1D8E8:  ADDLW  E3
1D8EA:  MOVWF  FE9
1D8EC:  MOVLW  01
1D8EE:  ADDWFC 03,W
1D8F0:  MOVWF  FEA
1D8F2:  MOVFF  FEF,33B
1D8F6:  MOVF   x3B,W
1D8F8:  MOVLB  0
1D8FA:  CALL   1A0A
1D8FE:  MOVLB  3
1D900:  INCF   x3A,F
1D902:  BRA    1D8DE
....................       } 
....................       for(n = 0; n < 24; n++)                                                    //send back the acknowledge 
1D904:  CLRF   x3A
1D906:  MOVF   x3A,W
1D908:  SUBLW  17
1D90A:  BNC   1D936
....................       { 
....................          fprintf(PC,"%x,",ACK_for_COM[n]); 
1D90C:  CLRF   03
1D90E:  MOVF   x3A,W
1D910:  ADDLW  E3
1D912:  MOVWF  FE9
1D914:  MOVLW  01
1D916:  ADDWFC 03,W
1D918:  MOVWF  FEA
1D91A:  MOVFF  FEF,3A2
1D91E:  MOVLW  57
1D920:  MOVWF  xA3
1D922:  MOVLB  0
1D924:  CALL   0734
1D928:  MOVLW  2C
1D92A:  BTFSS  F9E.4
1D92C:  BRA    1D92A
1D92E:  MOVWF  FAD
1D930:  MOVLB  3
1D932:  INCF   x3A,F
1D934:  BRA    1D906
....................       } 
....................       fprintf(PC,",NORMAL\r\n"); 
1D936:  MOVLW  4A
1D938:  MOVWF  FF6
1D93A:  MOVLW  13
1D93C:  MOVWF  FF7
1D93E:  MOVLW  00
1D940:  MOVWF  FF8
1D942:  MOVLB  0
1D944:  CALL   058C
....................    } 
1D948:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void UPDATE_ACK_for_COM(int8 data1,int8 data2,int32 address, int16 size)         //send data to COM for automatical mission 
.................... { 
....................    REFLESH_MSN_ACK_for_COM();                                                    //clear array ACK_for_COM[i] from position 12 to 22 
*
1BBA6:  CALL   1AD70
....................    ACK_for_COM[15] = address >> 24; 
1BBAA:  MOVFF  336,1F2
....................    ACK_for_COM[16] = address >> 16; 
1BBAE:  MOVFF  335,1F3
....................    ACK_for_COM[17] = address >> 8; 
1BBB2:  MOVFF  334,1F4
....................    ACK_for_COM[18] = address; 
1BBB6:  MOVFF  333,1F5
....................     
....................    ACK_for_COM[19] = size >> 24; 
1BBBA:  MOVLB  1
1BBBC:  CLRF   xF6
....................    ACK_for_COM[20] = size >> 16; 
1BBBE:  CLRF   xF7
....................    ACK_for_COM[21] = size >> 8; 
1BBC0:  MOVFF  338,1F8
....................    ACK_for_COM[22] = size; 
1BBC4:  MOVFF  337,1F9
....................     
....................    ACK_for_COM[0] = 0xAA;                                                        //header 
1BBC8:  MOVLW  AA
1BBCA:  MOVWF  xE3
....................    ACK_for_COM[12] = data1;                                                      //success ack indicator 0x66 
1BBCC:  MOVFF  331,1EF
....................    ACK_for_COM[14] = data2;                                                      //auto indicator 0x77 
1BBD0:  MOVFF  332,1F1
....................    ACK_for_COM[23] = 0xBB;                                                       //footer 
1BBD4:  MOVLW  BB
1BBD6:  MOVWF  xFA
....................    for(int n = 0; n < 24; n++)                                                   //send back the acknowledge 
1BBD8:  MOVLB  3
1BBDA:  CLRF   x39
1BBDC:  MOVF   x39,W
1BBDE:  SUBLW  17
1BBE0:  BNC   1BC02
....................    { 
....................       fputc(ACK_for_COM[n],COM); 
1BBE2:  CLRF   03
1BBE4:  MOVF   x39,W
1BBE6:  ADDLW  E3
1BBE8:  MOVWF  FE9
1BBEA:  MOVLW  01
1BBEC:  ADDWFC 03,W
1BBEE:  MOVWF  FEA
1BBF0:  MOVFF  FEF,33A
1BBF4:  MOVF   x3A,W
1BBF6:  MOVLB  0
1BBF8:  CALL   1A0A
1BBFC:  MOVLB  3
1BBFE:  INCF   x39,F
1BC00:  BRA    1BBDC
....................    } 
1BC02:  MOVLB  0
1BC04:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void call_ADCS_TEST_OPERATION(unsigned int16 duration, int8 OPERATION_MODE) 
.................... { 
....................    ADCS_TEST_OPERATION(duration, OPERATION_MODE); 
*
1B800:  MOVFF  37E,381
1B804:  MOVFF  37D,380
1B808:  MOVFF  37F,382
1B80C:  CALL   127D4
1B810:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<AUTO_MSN.c> 
.................... #ifndef AUTO_MSN_C 
.................... #define AUTO_MSN_C 
....................  
.................... #define loop_day 70 
.................... int16 AD = 0;                                                                    //DATE DATA 
.................... int16 D = 0;                                                                     //everyday change the DL address. nomally, increase 5 packet for each day 
....................                                                                                   
.................... int8 ADH = 0;                                                                    //for satellite log(int16 date high) 
.................... int8 ADL = 0;                                                                    //for satellite log(int16 date low) 
.................... int32 DL_AD = 0;                                                                 //Data size to increase when day changed 
....................  
.................... //@@@@@@@@@@@ HIGH SAMPLING@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY0()                                                                      //2 hour high sampling sensor 
.................... { 
....................    SAVE_SAT_LOG(0xFA,0x11,0x11);                                                 //11,11: automatical mission 
*
1BC06:  MOVLW  FA
1BC08:  MOVLB  3
1BC0A:  MOVWF  x53
1BC0C:  MOVLW  11
1BC0E:  MOVWF  x54
1BC10:  MOVWF  x55
1BC12:  MOVLB  0
1BC14:  CALL   16EE2
....................    FIRST_HSSC_DONE = 1;                                                          //flag in HIGH 
1BC18:  MOVLW  01
1BC1A:  MOVWF  x77
....................    STORE_FLAG_INFO();                                                            //save passed days 
1BC1C:  CALL   14000
....................    WRITE_FLAG_to_EEPROM(); 
1BC20:  CALL   11C84
....................    HIGHSAMP_SENSOR_COLLECTION(1440);                                             //execute HSSC mission for 2 hours 
1BC24:  MOVLW  05
1BC26:  MOVLB  3
1BC28:  MOVWF  x38
1BC2A:  MOVLW  A0
1BC2C:  MOVWF  x37
1BC2E:  MOVLB  0
1BC30:  RCALL  1BAB6
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 // save all address data in FLASH memories 
1BC32:  CALL   144C8
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BC36:  MOVFF  6A,385
1BC3A:  MOVFF  69,384
1BC3E:  MOVLB  3
1BC40:  CLRF   x87
1BC42:  MOVLW  46
1BC44:  MOVWF  x86
1BC46:  MOVLB  0
1BC48:  CALL   156A
1BC4C:  MOVFF  00,31B
1BC50:  MOVLB  3
1BC52:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BC56:  CLRF   x1F
....................    ADL = AD; 
1BC58:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1BC5C:  MOVLW  FD
1BC5E:  MOVWF  x53
1BC60:  MOVFF  31F,354
1BC64:  MOVFF  320,355
1BC68:  MOVLB  0
1BC6A:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639,405);                                  //send data1,data2,address,size to COM for automatical mission) 
1BC6E:  MOVLW  66
1BC70:  MOVLB  3
1BC72:  MOVWF  x31
1BC74:  MOVLW  77
1BC76:  MOVWF  x32
1BC78:  MOVLW  06
1BC7A:  MOVWF  x36
1BC7C:  MOVLW  67
1BC7E:  MOVWF  x35
1BC80:  CLRF   x34
1BC82:  CLRF   x33
1BC84:  MOVLW  01
1BC86:  MOVWF  x38
1BC88:  MOVLW  95
1BC8A:  MOVWF  x37
1BC8C:  MOVLB  0
1BC8E:  RCALL  1BBA6
....................                                                                                  //118byte*3600*2/5 (about 2.59sector) 65536*1639 
....................    return;                                                                        
1BC90:  RETURN 0
.................... } 
.................... #ORG 0x0001B800 
.................... void DAY1to4()                                                                   //HIGH SAMPLING Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BC92:  MOVFF  6A,385
1BC96:  MOVFF  69,384
1BC9A:  MOVLB  3
1BC9C:  CLRF   x87
1BC9E:  MOVLW  46
1BCA0:  MOVWF  x86
1BCA2:  MOVLB  0
1BCA4:  CALL   156A
1BCA8:  MOVFF  00,31B
1BCAC:  MOVLB  3
1BCAE:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BCB2:  CLRF   x1F
....................    ADL = AD; 
1BCB4:  MOVFF  31B,320
....................    D = AD; 
1BCB8:  MOVFF  31C,31E
1BCBC:  MOVFF  31B,31D
....................     
....................    DL_AD = 220*D;                                                                //skip 220 packets each day 
1BCC0:  CLRF   x43
1BCC2:  MOVLW  DC
1BCC4:  MOVWF  x42
1BCC6:  MOVFF  31E,345
1BCCA:  MOVFF  31D,344
1BCCE:  MOVLB  0
1BCD0:  CALL   253A
1BCD4:  MOVLB  3
1BCD6:  CLRF   x24
1BCD8:  CLRF   x23
1BCDA:  MOVFF  02,322
1BCDE:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //address from where will be downloaded 
1BCE2:  MOVFF  324,337
1BCE6:  MOVFF  323,336
1BCEA:  MOVFF  322,335
1BCEE:  MOVFF  321,334
1BCF2:  CLRF   x3B
1BCF4:  CLRF   x3A
1BCF6:  CLRF   x39
1BCF8:  MOVLW  51
1BCFA:  MOVWF  x38
1BCFC:  MOVLB  0
1BCFE:  CALL   24DE
1BD02:  MOVFF  03,324
1BD06:  MOVFF  02,323
1BD0A:  MOVFF  01,322
1BD0E:  MOVFF  00,321
....................    /*//////////////PACKET///////////////// 
....................    //220-224, 440-444, 660-664, 880-884 
....................    /////////////////////////////////////*/ 
....................     
....................     
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1BD12:  MOVLW  FD
1BD14:  MOVLB  3
1BD16:  MOVWF  x53
1BD18:  MOVFF  31F,354
1BD1C:  MOVFF  320,355
1BD20:  MOVLB  0
1BD22:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*1639 
1BD26:  MOVLB  3
1BD28:  MOVFF  321,32D
1BD2C:  MOVFF  322,32E
1BD30:  MOVLW  67
1BD32:  ADDWF  x23,W
1BD34:  MOVWF  x2F
1BD36:  MOVLW  06
1BD38:  ADDWFC x24,W
1BD3A:  MOVWF  x30
1BD3C:  MOVLW  66
1BD3E:  MOVWF  x31
1BD40:  MOVLW  77
1BD42:  MOVWF  x32
1BD44:  MOVFF  330,336
1BD48:  MOVFF  32F,335
1BD4C:  MOVFF  322,334
1BD50:  MOVFF  321,333
1BD54:  MOVLW  01
1BD56:  MOVWF  x38
1BD58:  MOVLW  95
1BD5A:  MOVWF  x37
1BD5C:  MOVLB  0
1BD5E:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1BD60:  MOVLB  3
1BD62:  CLRF   x1F
1BD64:  CLRF   x20
1BD66:  CLRF   x24
1BD68:  CLRF   x23
1BD6A:  CLRF   x22
1BD6C:  CLRF   x21
1BD6E:  CLRF   x1E
1BD70:  CLRF   x1D
....................    return; 
1BD72:  MOVLB  0
1BD74:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY1to4_ADDRESS()                                                           //HIGH SAMPLING DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
*
1CB74:  MOVFF  6A,385
1CB78:  MOVFF  69,384
1CB7C:  MOVLB  3
1CB7E:  CLRF   x87
1CB80:  MOVLW  46
1CB82:  MOVWF  x86
1CB84:  MOVLB  0
1CB86:  CALL   156A
1CB8A:  MOVFF  00,31B
1CB8E:  MOVLB  3
1CB90:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CB94:  CLRF   x1F
....................    ADL = AD; 
1CB96:  MOVFF  31B,320
....................    D = AD; 
1CB9A:  MOVFF  31C,31E
1CB9E:  MOVFF  31B,31D
....................     
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1CBA2:  CLRF   x43
1CBA4:  MOVLW  DC
1CBA6:  MOVWF  x42
1CBA8:  MOVFF  31E,345
1CBAC:  MOVFF  31D,344
1CBB0:  MOVLB  0
1CBB2:  CALL   253A
1CBB6:  MOVLB  3
1CBB8:  CLRF   x24
1CBBA:  CLRF   x23
1CBBC:  MOVFF  02,322
1CBC0:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CBC4:  MOVFF  324,337
1CBC8:  MOVFF  323,336
1CBCC:  MOVFF  322,335
1CBD0:  MOVFF  321,334
1CBD4:  CLRF   x3B
1CBD6:  CLRF   x3A
1CBD8:  CLRF   x39
1CBDA:  MOVLW  51
1CBDC:  MOVWF  x38
1CBDE:  MOVLB  0
1CBE0:  CALL   24DE
1CBE4:  MOVFF  03,324
1CBE8:  MOVFF  02,323
1CBEC:  MOVFF  01,322
1CBF0:  MOVFF  00,321
....................    /*//////////////PACKET///////////////// 
....................    //220-224, 440-444, 660-664, 880-884 
....................    /////////////////////////////////////*/ 
....................     
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1CBF4:  MOVLB  3
1CBF6:  MOVFF  321,32D
1CBFA:  MOVFF  322,32E
1CBFE:  MOVLW  67
1CC00:  ADDWF  x23,W
1CC02:  MOVWF  x2F
1CC04:  MOVLW  06
1CC06:  ADDWFC x24,W
1CC08:  MOVWF  x30
1CC0A:  MOVLW  66
1CC0C:  MOVWF  x31
1CC0E:  MOVLW  77
1CC10:  MOVWF  x32
1CC12:  MOVFF  330,336
1CC16:  MOVFF  32F,335
1CC1A:  MOVFF  322,334
1CC1E:  MOVFF  321,333
1CC22:  MOVLW  01
1CC24:  MOVWF  x38
1CC26:  MOVLW  95
1CC28:  MOVWF  x37
1CC2A:  MOVLB  0
1CC2C:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CC30:  MOVLB  3
1CC32:  CLRF   x1F
1CC34:  CLRF   x20
1CC36:  CLRF   x24
1CC38:  CLRF   x23
1CC3A:  CLRF   x22
1CC3C:  CLRF   x21
1CC3E:  CLRF   x1E
1CC40:  CLRF   x1D
....................    return; 
1CC42:  MOVLB  0
1CC44:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY20to25()                                                                 //20-25day 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //20,21,22,23,24,25 
*
1C23C:  MOVFF  6A,385
1C240:  MOVFF  69,384
1C244:  MOVLB  3
1C246:  CLRF   x87
1C248:  MOVLW  46
1C24A:  MOVWF  x86
1C24C:  MOVLB  0
1C24E:  CALL   156A
1C252:  MOVFF  00,31B
1C256:  MOVLB  3
1C258:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C25C:  CLRF   x1F
....................    ADL = AD; 
1C25E:  MOVFF  31B,320
....................     
....................    D = AD - 15;                                                                  //5,6,7,8,9,10 
1C262:  MOVLW  0F
1C264:  SUBWF  x1B,W
1C266:  MOVWF  x1D
1C268:  MOVLW  00
1C26A:  SUBWFB x1C,W
1C26C:  MOVWF  x1E
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1C26E:  CLRF   x43
1C270:  MOVLW  DC
1C272:  MOVWF  x42
1C274:  MOVFF  31E,345
1C278:  MOVFF  31D,344
1C27C:  MOVLB  0
1C27E:  CALL   253A
1C282:  MOVLB  3
1C284:  CLRF   x24
1C286:  CLRF   x23
1C288:  MOVFF  02,322
1C28C:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C290:  MOVFF  324,337
1C294:  MOVFF  323,336
1C298:  MOVFF  322,335
1C29C:  MOVFF  321,334
1C2A0:  CLRF   x3B
1C2A2:  CLRF   x3A
1C2A4:  CLRF   x39
1C2A6:  MOVLW  51
1C2A8:  MOVWF  x38
1C2AA:  MOVLB  0
1C2AC:  CALL   24DE
1C2B0:  MOVFF  03,324
1C2B4:  MOVFF  02,323
1C2B8:  MOVFF  01,322
1C2BC:  MOVFF  00,321
....................    /*/////////////////////////////PACKET//////////////////////////////// 
....................    //1100-1104, 1320-1324, 1540-1544, 1760-1764, 1980,1984, 2200-2204 
....................    ///////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xFD,ADH,ADL);                                                   //11,11: automatical mission 
1C2C0:  MOVLW  FD
1C2C2:  MOVLB  3
1C2C4:  MOVWF  x53
1C2C6:  MOVFF  31F,354
1C2CA:  MOVFF  320,355
1C2CE:  MOVLB  0
1C2D0:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C2D4:  MOVLB  3
1C2D6:  MOVFF  321,32D
1C2DA:  MOVFF  322,32E
1C2DE:  MOVLW  67
1C2E0:  ADDWF  x23,W
1C2E2:  MOVWF  x2F
1C2E4:  MOVLW  06
1C2E6:  ADDWFC x24,W
1C2E8:  MOVWF  x30
1C2EA:  MOVLW  66
1C2EC:  MOVWF  x31
1C2EE:  MOVLW  77
1C2F0:  MOVWF  x32
1C2F2:  MOVFF  330,336
1C2F6:  MOVFF  32F,335
1C2FA:  MOVFF  322,334
1C2FE:  MOVFF  321,333
1C302:  MOVLW  01
1C304:  MOVWF  x38
1C306:  MOVLW  95
1C308:  MOVWF  x37
1C30A:  MOVLB  0
1C30C:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C30E:  MOVLB  3
1C310:  CLRF   x1F
1C312:  CLRF   x20
1C314:  CLRF   x24
1C316:  CLRF   x23
1C318:  CLRF   x22
1C31A:  CLRF   x21
1C31C:  CLRF   x1E
1C31E:  CLRF   x1D
....................    return; 
1C320:  MOVLB  0
1C322:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY20to25_ADDRESS()                                                         //20-25day 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //20,21,22,23,24,25 
*
1CE3C:  MOVFF  6A,385
1CE40:  MOVFF  69,384
1CE44:  MOVLB  3
1CE46:  CLRF   x87
1CE48:  MOVLW  46
1CE4A:  MOVWF  x86
1CE4C:  MOVLB  0
1CE4E:  CALL   156A
1CE52:  MOVFF  00,31B
1CE56:  MOVLB  3
1CE58:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CE5C:  CLRF   x1F
....................    ADL = AD; 
1CE5E:  MOVFF  31B,320
....................     
....................    D = AD - 15;                                                                  //5,6,7,8,9,10 
1CE62:  MOVLW  0F
1CE64:  SUBWF  x1B,W
1CE66:  MOVWF  x1D
1CE68:  MOVLW  00
1CE6A:  SUBWFB x1C,W
1CE6C:  MOVWF  x1E
....................    DL_AD = 220*D;                                                                //realiza saltos de 220 paquetes 
1CE6E:  CLRF   x43
1CE70:  MOVLW  DC
1CE72:  MOVWF  x42
1CE74:  MOVFF  31E,345
1CE78:  MOVFF  31D,344
1CE7C:  MOVLB  0
1CE7E:  CALL   253A
1CE82:  MOVLB  3
1CE84:  CLRF   x24
1CE86:  CLRF   x23
1CE88:  MOVFF  02,322
1CE8C:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CE90:  MOVFF  324,337
1CE94:  MOVFF  323,336
1CE98:  MOVFF  322,335
1CE9C:  MOVFF  321,334
1CEA0:  CLRF   x3B
1CEA2:  CLRF   x3A
1CEA4:  CLRF   x39
1CEA6:  MOVLW  51
1CEA8:  MOVWF  x38
1CEAA:  MOVLB  0
1CEAC:  CALL   24DE
1CEB0:  MOVFF  03,324
1CEB4:  MOVFF  02,323
1CEB8:  MOVFF  01,322
1CEBC:  MOVFF  00,321
....................    /*/////////////////////////////PACKET//////////////////////////////// 
....................    //1100-1104, 1320-1324, 1540-1544, 1760-1764, 1980,1984, 2200-2204 
....................    ///////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);//65536*8 
1CEC0:  MOVLB  3
1CEC2:  MOVFF  321,32D
1CEC6:  MOVFF  322,32E
1CECA:  MOVLW  67
1CECC:  ADDWF  x23,W
1CECE:  MOVWF  x2F
1CED0:  MOVLW  06
1CED2:  ADDWFC x24,W
1CED4:  MOVWF  x30
1CED6:  MOVLW  66
1CED8:  MOVWF  x31
1CEDA:  MOVLW  77
1CEDC:  MOVWF  x32
1CEDE:  MOVFF  330,336
1CEE2:  MOVFF  32F,335
1CEE6:  MOVFF  322,334
1CEEA:  MOVFF  321,333
1CEEE:  MOVLW  01
1CEF0:  MOVWF  x38
1CEF2:  MOVLW  95
1CEF4:  MOVWF  x37
1CEF6:  MOVLB  0
1CEF8:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CEFC:  MOVLB  3
1CEFE:  CLRF   x1F
1CF00:  CLRF   x20
1CF02:  CLRF   x24
1CF04:  CLRF   x23
1CF06:  CLRF   x22
1CF08:  CLRF   x21
1CF0A:  CLRF   x1E
1CF0C:  CLRF   x1D
....................    return; 
1CF0E:  MOVLB  0
1CF10:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ CAM MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY5()                                                                      //CAM MSN 
.................... { 
....................    SAVE_SAT_LOG(0xC0,0x11,0x11);                                                 //11,11: automatical mission 
*
1BD76:  MOVLW  C0
1BD78:  MOVLB  3
1BD7A:  MOVWF  x53
1BD7C:  MOVLW  11
1BD7E:  MOVWF  x54
1BD80:  MOVWF  x55
1BD82:  MOVLB  0
1BD84:  CALL   16EE2
....................    AUTO_CAM_DONE = 1; 
1BD88:  MOVLW  01
1BD8A:  MOVWF  x78
....................    STORE_FLAG_INFO();                                                            //save flag 
1BD8C:  CALL   14000
....................    WRITE_FLAG_to_EEPROM(); 
1BD90:  CALL   11C84
....................    CAM_TEST_OPERATION(0xA0);                                                     //cam mission 320x240 low quality 
1BD94:  MOVLW  A0
1BD96:  MOVLB  3
1BD98:  MOVWF  x37
1BD9A:  MOVLB  0
1BD9C:  CALL   1AD94
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //save passed days 
1BDA0:  CALL   144C8
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //1,2,3,4 
1BDA4:  MOVFF  6A,385
1BDA8:  MOVFF  69,384
1BDAC:  MOVLB  3
1BDAE:  CLRF   x87
1BDB0:  MOVLW  46
1BDB2:  MOVWF  x86
1BDB4:  MOVLB  0
1BDB6:  CALL   156A
1BDBA:  MOVFF  00,31B
1BDBE:  MOVLB  3
1BDC0:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BDC4:  CLRF   x1F
....................    ADL = AD; 
1BDC6:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1BDCA:  MOVLW  CD
1BDCC:  MOVWF  x53
1BDCE:  MOVFF  31F,354
1BDD2:  MOVFF  320,355
1BDD6:  MOVLB  0
1BDD8:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8,405);                                     //65536*8 
1BDDC:  MOVLW  66
1BDDE:  MOVLB  3
1BDE0:  MOVWF  x31
1BDE2:  MOVLW  77
1BDE4:  MOVWF  x32
1BDE6:  CLRF   x36
1BDE8:  MOVLW  08
1BDEA:  MOVWF  x35
1BDEC:  CLRF   x34
1BDEE:  CLRF   x33
1BDF0:  MOVLW  01
1BDF2:  MOVWF  x38
1BDF4:  MOVLW  95
1BDF6:  MOVWF  x37
1BDF8:  MOVLB  0
1BDFA:  RCALL  1BBA6
....................    return; 
1BDFC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY6to9()                                                                   //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //6,7,8,9 
1BDFE:  MOVFF  6A,385
1BE02:  MOVFF  69,384
1BE06:  MOVLB  3
1BE08:  CLRF   x87
1BE0A:  MOVLW  46
1BE0C:  MOVWF  x86
1BE0E:  MOVLB  0
1BE10:  CALL   156A
1BE14:  MOVFF  00,31B
1BE18:  MOVLB  3
1BE1A:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BE1E:  CLRF   x1F
....................    ADL = AD; 
1BE20:  MOVFF  31B,320
....................     
....................    D = AD - 5;                                                                   //1,2,3,4 
1BE24:  MOVLW  05
1BE26:  SUBWF  x1B,W
1BE28:  MOVWF  x1D
1BE2A:  MOVLW  00
1BE2C:  SUBWFB x1C,W
1BE2E:  MOVWF  x1E
....................    DL_AD = D*5;                                                                   
1BE30:  MOVFF  31E,343
1BE34:  MOVFF  31D,342
1BE38:  CLRF   x45
1BE3A:  MOVLW  05
1BE3C:  MOVWF  x44
1BE3E:  MOVLB  0
1BE40:  CALL   253A
1BE44:  MOVLB  3
1BE46:  CLRF   x24
1BE48:  CLRF   x23
1BE4A:  MOVFF  02,322
1BE4E:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //download address 
1BE52:  MOVFF  324,337
1BE56:  MOVFF  323,336
1BE5A:  MOVFF  322,335
1BE5E:  MOVFF  321,334
1BE62:  CLRF   x3B
1BE64:  CLRF   x3A
1BE66:  CLRF   x39
1BE68:  MOVLW  51
1BE6A:  MOVWF  x38
1BE6C:  MOVLB  0
1BE6E:  CALL   24DE
1BE72:  MOVFF  03,324
1BE76:  MOVFF  02,323
1BE7A:  MOVFF  01,322
1BE7E:  MOVFF  00,321
....................    /*/////////PACKET//////////// 
....................    //5-9, 10-14, 15-19, 20-24 
....................    ///////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1BE82:  MOVLW  CD
1BE84:  MOVLB  3
1BE86:  MOVWF  x53
1BE88:  MOVFF  31F,354
1BE8C:  MOVFF  320,355
1BE90:  MOVLB  0
1BE92:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1BE96:  MOVLB  3
1BE98:  MOVFF  321,32D
1BE9C:  MOVFF  322,32E
1BEA0:  MOVLW  08
1BEA2:  ADDWF  x23,W
1BEA4:  MOVWF  x2F
1BEA6:  MOVLW  00
1BEA8:  ADDWFC x24,W
1BEAA:  MOVWF  x30
1BEAC:  MOVLW  66
1BEAE:  MOVWF  x31
1BEB0:  MOVLW  77
1BEB2:  MOVWF  x32
1BEB4:  MOVFF  330,336
1BEB8:  MOVFF  32F,335
1BEBC:  MOVFF  322,334
1BEC0:  MOVFF  321,333
1BEC4:  MOVLW  01
1BEC6:  MOVWF  x38
1BEC8:  MOVLW  95
1BECA:  MOVWF  x37
1BECC:  MOVLB  0
1BECE:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1BED0:  MOVLB  3
1BED2:  CLRF   x1F
1BED4:  CLRF   x20
1BED6:  CLRF   x24
1BED8:  CLRF   x23
1BEDA:  CLRF   x22
1BEDC:  CLRF   x21
1BEDE:  CLRF   x1E
1BEE0:  CLRF   x1D
....................    return; 
1BEE2:  MOVLB  0
1BEE4:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY6to9_ADDRESS()                                                           //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //6,7,8,9 
*
1CC46:  MOVFF  6A,385
1CC4A:  MOVFF  69,384
1CC4E:  MOVLB  3
1CC50:  CLRF   x87
1CC52:  MOVLW  46
1CC54:  MOVWF  x86
1CC56:  MOVLB  0
1CC58:  CALL   156A
1CC5C:  MOVFF  00,31B
1CC60:  MOVLB  3
1CC62:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CC66:  CLRF   x1F
....................    ADL = AD; 
1CC68:  MOVFF  31B,320
....................     
....................    D = AD - 5;                                                                   //1,2,3,4 
1CC6C:  MOVLW  05
1CC6E:  SUBWF  x1B,W
1CC70:  MOVWF  x1D
1CC72:  MOVLW  00
1CC74:  SUBWFB x1C,W
1CC76:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //saltos de 5 paquetes 
1CC78:  MOVFF  31E,343
1CC7C:  MOVFF  31D,342
1CC80:  CLRF   x45
1CC82:  MOVLW  05
1CC84:  MOVWF  x44
1CC86:  MOVLB  0
1CC88:  CALL   253A
1CC8C:  MOVLB  3
1CC8E:  CLRF   x24
1CC90:  CLRF   x23
1CC92:  MOVFF  02,322
1CC96:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CC9A:  MOVFF  324,337
1CC9E:  MOVFF  323,336
1CCA2:  MOVFF  322,335
1CCA6:  MOVFF  321,334
1CCAA:  CLRF   x3B
1CCAC:  CLRF   x3A
1CCAE:  CLRF   x39
1CCB0:  MOVLW  51
1CCB2:  MOVWF  x38
1CCB4:  MOVLB  0
1CCB6:  CALL   24DE
1CCBA:  MOVFF  03,324
1CCBE:  MOVFF  02,323
1CCC2:  MOVFF  01,322
1CCC6:  MOVFF  00,321
....................    /*/////////PACKET//////////// 
....................    //5-9, 10-14, 15-19, 20-24 
....................    ///////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1CCCA:  MOVLB  3
1CCCC:  MOVFF  321,32D
1CCD0:  MOVFF  322,32E
1CCD4:  MOVLW  08
1CCD6:  ADDWF  x23,W
1CCD8:  MOVWF  x2F
1CCDA:  MOVLW  00
1CCDC:  ADDWFC x24,W
1CCDE:  MOVWF  x30
1CCE0:  MOVLW  66
1CCE2:  MOVWF  x31
1CCE4:  MOVLW  77
1CCE6:  MOVWF  x32
1CCE8:  MOVFF  330,336
1CCEC:  MOVFF  32F,335
1CCF0:  MOVFF  322,334
1CCF4:  MOVFF  321,333
1CCF8:  MOVLW  01
1CCFA:  MOVWF  x38
1CCFC:  MOVLW  95
1CCFE:  MOVWF  x37
1CD00:  MOVLB  0
1CD02:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CD06:  MOVLB  3
1CD08:  CLRF   x1F
1CD0A:  CLRF   x20
1CD0C:  CLRF   x24
1CD0E:  CLRF   x23
1CD10:  CLRF   x22
1CD12:  CLRF   x21
1CD14:  CLRF   x1E
1CD16:  CLRF   x1D
....................    return; 
1CD18:  MOVLB  0
1CD1A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY26to46()                                                                 //CAM Download 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46 
*
1C324:  MOVFF  6A,385
1C328:  MOVFF  69,384
1C32C:  MOVLB  3
1C32E:  CLRF   x87
1C330:  MOVLW  46
1C332:  MOVWF  x86
1C334:  MOVLB  0
1C336:  CALL   156A
1C33A:  MOVFF  00,31B
1C33E:  MOVLB  3
1C340:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C344:  CLRF   x1F
....................    ADL = AD; 
1C346:  MOVFF  31B,320
....................     
....................    D = AD - 21;                                                                  //se le descuenta 21 para continuar con la descarga desde el paquete 25  
1C34A:  MOVLW  15
1C34C:  SUBWF  x1B,W
1C34E:  MOVWF  x1D
1C350:  MOVLW  00
1C352:  SUBWFB x1C,W
1C354:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //los primeros 25 se descarga en los primeros 5 dias 
1C356:  MOVFF  31E,343
1C35A:  MOVFF  31D,342
1C35E:  CLRF   x45
1C360:  MOVLW  05
1C362:  MOVWF  x44
1C364:  MOVLB  0
1C366:  CALL   253A
1C36A:  MOVLB  3
1C36C:  CLRF   x24
1C36E:  CLRF   x23
1C370:  MOVFF  02,322
1C374:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C378:  MOVFF  324,337
1C37C:  MOVFF  323,336
1C380:  MOVFF  322,335
1C384:  MOVFF  321,334
1C388:  CLRF   x3B
1C38A:  CLRF   x3A
1C38C:  CLRF   x39
1C38E:  MOVLW  51
1C390:  MOVWF  x38
1C392:  MOVLB  0
1C394:  CALL   24DE
1C398:  MOVFF  03,324
1C39C:  MOVFF  02,323
1C3A0:  MOVFF  01,322
1C3A4:  MOVFF  00,321
....................    /*//////////////////////PACKET///////////////////////// 
....................    //25-29,   30-34,   35-39,   40-44,   45-49 
....................    //50-54,   55-59,   60-64,   65-69,   70-74 
....................    //75-79,   80-84,   85-89,   90-94,   95-99 
....................    //100-104, 105-109, 110-114, 115-119, 120-124 
....................    //125-129 
....................    //---------------------------------------------------- 
....................    //total is 129 packet 
....................    ////////////////////////////////////////////////////// 
....................     
....................    /////////////////////////////BYTE///////////////////////// 
....................    //2025-2429, 2430-2834, 2835-3239, 3240-3644, 3645-4049 
....................    //4050-4454, 4455-4859, 4860-5264, 5265-5669, 5670-6074 
....................    //6075-6479, 6480-6884, 6885-7289, 7290-7694, 7695-8099 
....................    //8100-8504, 8505-8909, 8910-9314, 9315-9719, 9720-10124 
....................    //10125-10530 
....................    //-------------------------------------------------------- 
....................    //total is about 10kB 
....................    /////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xCD,ADH,ADL);                                                   //11,11: automatical mission 
1C3A8:  MOVLW  CD
1C3AA:  MOVLB  3
1C3AC:  MOVWF  x53
1C3AE:  MOVFF  31F,354
1C3B2:  MOVFF  320,355
1C3B6:  MOVLB  0
1C3B8:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1C3BC:  MOVLB  3
1C3BE:  MOVFF  321,32D
1C3C2:  MOVFF  322,32E
1C3C6:  MOVLW  08
1C3C8:  ADDWF  x23,W
1C3CA:  MOVWF  x2F
1C3CC:  MOVLW  00
1C3CE:  ADDWFC x24,W
1C3D0:  MOVWF  x30
1C3D2:  MOVLW  66
1C3D4:  MOVWF  x31
1C3D6:  MOVLW  77
1C3D8:  MOVWF  x32
1C3DA:  MOVFF  330,336
1C3DE:  MOVFF  32F,335
1C3E2:  MOVFF  322,334
1C3E6:  MOVFF  321,333
1C3EA:  MOVLW  01
1C3EC:  MOVWF  x38
1C3EE:  MOVLW  95
1C3F0:  MOVWF  x37
1C3F2:  MOVLB  0
1C3F4:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C3F8:  MOVLB  3
1C3FA:  CLRF   x1F
1C3FC:  CLRF   x20
1C3FE:  CLRF   x24
1C400:  CLRF   x23
1C402:  CLRF   x22
1C404:  CLRF   x21
1C406:  CLRF   x1E
1C408:  CLRF   x1D
....................    return; 
1C40A:  MOVLB  0
1C40C:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY26to46_ADDRESS()                                                         //CAM DL 1 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46 
*
1CF12:  MOVFF  6A,385
1CF16:  MOVFF  69,384
1CF1A:  MOVLB  3
1CF1C:  CLRF   x87
1CF1E:  MOVLW  46
1CF20:  MOVWF  x86
1CF22:  MOVLB  0
1CF24:  CALL   156A
1CF28:  MOVFF  00,31B
1CF2C:  MOVLB  3
1CF2E:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CF32:  CLRF   x1F
....................    ADL = AD; 
1CF34:  MOVFF  31B,320
....................     
....................    D = AD - 21; 
1CF38:  MOVLW  15
1CF3A:  SUBWF  x1B,W
1CF3C:  MOVWF  x1D
1CF3E:  MOVLW  00
1CF40:  SUBWFB x1C,W
1CF42:  MOVWF  x1E
....................    DL_AD = D*5;                                                                  //saltos de 5 paquetes 
1CF44:  MOVFF  31E,343
1CF48:  MOVFF  31D,342
1CF4C:  CLRF   x45
1CF4E:  MOVLW  05
1CF50:  MOVWF  x44
1CF52:  MOVLB  0
1CF54:  CALL   253A
1CF58:  MOVLB  3
1CF5A:  CLRF   x24
1CF5C:  CLRF   x23
1CF5E:  MOVFF  02,322
1CF62:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1CF66:  MOVFF  324,337
1CF6A:  MOVFF  323,336
1CF6E:  MOVFF  322,335
1CF72:  MOVFF  321,334
1CF76:  CLRF   x3B
1CF78:  CLRF   x3A
1CF7A:  CLRF   x39
1CF7C:  MOVLW  51
1CF7E:  MOVWF  x38
1CF80:  MOVLB  0
1CF82:  CALL   24DE
1CF86:  MOVFF  03,324
1CF8A:  MOVFF  02,323
1CF8E:  MOVFF  01,322
1CF92:  MOVFF  00,321
....................    /*//////////////////////PACKET///////////////////////// 
....................    //25-29,   40-34,   35-39,   40-44,   45-49 
....................    //50-54,   55-59,   60-64,   65-69,   70-74 
....................    //75-79,   80-84,   85-89,   90-94,   95-99 
....................    //100-104, 105-109, 110-114, 115-119, 120-124 
....................    //125-129 
....................    //---------------------------------------------------- 
....................    //total is 129 packet 
....................    ////////////////////////////////////////////////////// 
....................     
....................    /////////////////////////////BYTE///////////////////////// 
....................    //2025-2429, 2430-2834, 2835-3239, 3240-3644, 3645-4049 
....................    //4050-4454, 4455-4859, 4860-5264, 5265-5669, 5670-6074 
....................    //6075-6479, 6480-6884, 6885-7289, 7290-7694, 7695-8099 
....................    //8100-8504, 8505-8909, 8910-9314, 9315-9719, 9720-10124 
....................    //10125-10530 
....................    //-------------------------------------------------------- 
....................    //total is about 10kB 
....................    /////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*8+DL_AD,405);                               //65536*8 
1CF96:  MOVLB  3
1CF98:  MOVFF  321,32D
1CF9C:  MOVFF  322,32E
1CFA0:  MOVLW  08
1CFA2:  ADDWF  x23,W
1CFA4:  MOVWF  x2F
1CFA6:  MOVLW  00
1CFA8:  ADDWFC x24,W
1CFAA:  MOVWF  x30
1CFAC:  MOVLW  66
1CFAE:  MOVWF  x31
1CFB0:  MOVLW  77
1CFB2:  MOVWF  x32
1CFB4:  MOVFF  330,336
1CFB8:  MOVFF  32F,335
1CFBC:  MOVFF  322,334
1CFC0:  MOVFF  321,333
1CFC4:  MOVLW  01
1CFC6:  MOVWF  x38
1CFC8:  MOVLW  95
1CFCA:  MOVWF  x37
1CFCC:  MOVLB  0
1CFCE:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CFD2:  MOVLB  3
1CFD4:  CLRF   x1F
1CFD6:  CLRF   x20
1CFD8:  CLRF   x24
1CFDA:  CLRF   x23
1CFDC:  CLRF   x22
1CFDE:  CLRF   x21
1CFE0:  CLRF   x1E
1CFE2:  CLRF   x1D
....................    return; 
1CFE4:  MOVLB  0
1CFE6:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@@@@@@@@@@@@@@@@ MBP MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY10()                                                                     //MBP mission 
.................... { 
....................    AUTO_MBP_DONE = 1; 
*
1BEE6:  MOVLW  01
1BEE8:  MOVWF  x79
....................    STORE_FLAG_INFO();                                                            //save flag 
1BEEA:  CALL   14000
....................    WRITE_FLAG_to_EEPROM(); 
1BEEE:  CALL   11C84
....................     
....................    SAVE_SAT_LOG(0xD0,0x11,0x11);                                                 //11,11: automatical mission 
1BEF2:  MOVLW  D0
1BEF4:  MOVLB  3
1BEF6:  MOVWF  x53
1BEF8:  MOVLW  11
1BEFA:  MOVWF  x54
1BEFC:  MOVWF  x55
1BEFE:  MOVLB  0
1BF00:  CALL   16EE2
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //1 execution of the mission 
....................    delay_ms(3000); 
1BF04:  MOVLW  0C
1BF06:  MOVLB  3
1BF08:  MOVWF  x2D
1BF0A:  MOVLW  FA
1BF0C:  MOVWF  x98
1BF0E:  MOVLB  0
1BF10:  CALL   0526
1BF14:  MOVLB  3
1BF16:  DECFSZ x2D,F
1BF18:  BRA    1BF0A
....................    SAVE_SAT_LOG(0xD0,0x22,0x22);                                                 //01,01: automatical mission 
1BF1A:  MOVLW  D0
1BF1C:  MOVWF  x53
1BF1E:  MOVLW  22
1BF20:  MOVWF  x54
1BF22:  MOVWF  x55
1BF24:  MOVLB  0
1BF26:  CALL   16EE2
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //2 execution of the mission 
....................    delay_ms(3000); 
1BF2A:  MOVLW  0C
1BF2C:  MOVLB  3
1BF2E:  MOVWF  x2D
1BF30:  MOVLW  FA
1BF32:  MOVWF  x98
1BF34:  MOVLB  0
1BF36:  CALL   0526
1BF3A:  MOVLB  3
1BF3C:  DECFSZ x2D,F
1BF3E:  BRA    1BF30
....................    SAVE_SAT_LOG(0xD0,0x33,0x33);                                                 //01,01: automatical mission 
1BF40:  MOVLW  D0
1BF42:  MOVWF  x53
1BF44:  MOVLW  33
1BF46:  MOVWF  x54
1BF48:  MOVWF  x55
1BF4A:  MOVLB  0
1BF4C:  CALL   16EE2
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //3 execution of the mission 
....................    delay_ms(3000); 
1BF50:  MOVLW  0C
1BF52:  MOVLB  3
1BF54:  MOVWF  x2D
1BF56:  MOVLW  FA
1BF58:  MOVWF  x98
1BF5A:  MOVLB  0
1BF5C:  CALL   0526
1BF60:  MOVLB  3
1BF62:  DECFSZ x2D,F
1BF64:  BRA    1BF56
....................    SAVE_SAT_LOG(0xD0,0x44,0x44);                                                 //01,01: automatical mission 
1BF66:  MOVLW  D0
1BF68:  MOVWF  x53
1BF6A:  MOVLW  44
1BF6C:  MOVWF  x54
1BF6E:  MOVWF  x55
1BF70:  MOVLB  0
1BF72:  CALL   16EE2
....................    //   DATACOLLECTION_TEST_OPERATION();                                              //4 execution of the mission 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1BF76:  CALL   144C8
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //10 
1BF7A:  MOVFF  6A,385
1BF7E:  MOVFF  69,384
1BF82:  MOVLB  3
1BF84:  CLRF   x87
1BF86:  MOVLW  46
1BF88:  MOVWF  x86
1BF8A:  MOVLB  0
1BF8C:  CALL   156A
1BF90:  MOVFF  00,31B
1BF94:  MOVLB  3
1BF96:  MOVFF  03,31C
....................    ADH = AD << 8; 
1BF9A:  CLRF   x1F
....................    ADL = AD; 
1BF9C:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xDD,ADH,ADL);                                                   //11,11: automatical mission 
1BFA0:  MOVLW  DD
1BFA2:  MOVWF  x53
1BFA4:  MOVFF  31F,354
1BFA8:  MOVFF  320,355
1BFAC:  MOVLB  0
1BFAE:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);                      //65536*162, 332 corresponde a 4 paquetes de 83 recibidos de la ejecucion de DC 
1BFB2:  MOVLW  4C
1BFB4:  SUBWF  58,W
1BFB6:  MOVLB  3
1BFB8:  MOVWF  x2D
1BFBA:  MOVLW  01
1BFBC:  SUBWFB 59,W
1BFBE:  MOVWF  x2E
1BFC0:  MOVLW  00
1BFC2:  SUBWFB 5A,W
1BFC4:  MOVWF  x2F
1BFC6:  MOVLW  00
1BFC8:  SUBWFB 5B,W
1BFCA:  MOVWF  x30
1BFCC:  MOVLW  66
1BFCE:  MOVWF  x31
1BFD0:  MOVLW  77
1BFD2:  MOVWF  x32
1BFD4:  MOVFF  330,336
1BFD8:  MOVFF  32F,335
1BFDC:  MOVFF  32E,334
1BFE0:  MOVFF  32D,333
1BFE4:  MOVLW  01
1BFE6:  MOVWF  x38
1BFE8:  MOVLW  4C
1BFEA:  MOVWF  x37
1BFEC:  MOVLB  0
1BFEE:  RCALL  1BBA6
....................    return; 
1BFF0:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY11to14()                                                                 //MBP Data download 
.................... { 
....................    SAVE_SAT_LOG(0xD0,0x11,0x11);                                                 //01,01: automatical mission 
1BFF2:  MOVLW  D0
1BFF4:  MOVLB  3
1BFF6:  MOVWF  x53
1BFF8:  MOVLW  11
1BFFA:  MOVWF  x54
1BFFC:  MOVWF  x55
1BFFE:  MOVLB  0
1C000:  CALL   16EE2
....................    /* 
....................    DATACOLLECTION_TEST_OPERATION();                                               1 execution of the mission 
....................    */ 
....................    delay_ms(3000); 
1C004:  MOVLW  0C
1C006:  MOVLB  3
1C008:  MOVWF  x2D
1C00A:  MOVLW  FA
1C00C:  MOVWF  x98
1C00E:  MOVLB  0
1C010:  CALL   0526
1C014:  MOVLB  3
1C016:  DECFSZ x2D,F
1C018:  BRA    1C00A
....................    SAVE_SAT_LOG(0xD0,0x22,0x22);                                                 //01,01: automatical mission 
1C01A:  MOVLW  D0
1C01C:  MOVWF  x53
1C01E:  MOVLW  22
1C020:  MOVWF  x54
1C022:  MOVWF  x55
1C024:  MOVLB  0
1C026:  CALL   16EE2
....................  
....................    delay_ms(3000); 
1C02A:  MOVLW  0C
1C02C:  MOVLB  3
1C02E:  MOVWF  x2D
1C030:  MOVLW  FA
1C032:  MOVWF  x98
1C034:  MOVLB  0
1C036:  CALL   0526
1C03A:  MOVLB  3
1C03C:  DECFSZ x2D,F
1C03E:  BRA    1C030
....................    SAVE_SAT_LOG(0xD0,0x33,0x33);                                                 //01,01: automatical mission 
1C040:  MOVLW  D0
1C042:  MOVWF  x53
1C044:  MOVLW  33
1C046:  MOVWF  x54
1C048:  MOVWF  x55
1C04A:  MOVLB  0
1C04C:  CALL   16EE2
....................  
....................    delay_ms(3000); 
1C050:  MOVLW  0C
1C052:  MOVLB  3
1C054:  MOVWF  x2D
1C056:  MOVLW  FA
1C058:  MOVWF  x98
1C05A:  MOVLB  0
1C05C:  CALL   0526
1C060:  MOVLB  3
1C062:  DECFSZ x2D,F
1C064:  BRA    1C056
....................    SAVE_SAT_LOG(0xD4,0x44,0x44);                                                 //01,01: automatical mission 
1C066:  MOVLW  D4
1C068:  MOVWF  x53
1C06A:  MOVLW  44
1C06C:  MOVWF  x54
1C06E:  MOVWF  x55
1C070:  MOVLB  0
1C072:  CALL   16EE2
....................  
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1C076:  CALL   144C8
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //11,12,13,14 
1C07A:  MOVFF  6A,385
1C07E:  MOVFF  69,384
1C082:  MOVLB  3
1C084:  CLRF   x87
1C086:  MOVLW  46
1C088:  MOVWF  x86
1C08A:  MOVLB  0
1C08C:  CALL   156A
1C090:  MOVFF  00,31B
1C094:  MOVLB  3
1C096:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C09A:  CLRF   x1F
....................    ADL = AD; 
1C09C:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xDD,ADH,ADL); 
1C0A0:  MOVLW  DD
1C0A2:  MOVWF  x53
1C0A4:  MOVFF  31F,354
1C0A8:  MOVFF  320,355
1C0AC:  MOVLB  0
1C0AE:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);                      //65536*8 
1C0B2:  MOVLW  4C
1C0B4:  SUBWF  58,W
1C0B6:  MOVLB  3
1C0B8:  MOVWF  x2D
1C0BA:  MOVLW  01
1C0BC:  SUBWFB 59,W
1C0BE:  MOVWF  x2E
1C0C0:  MOVLW  00
1C0C2:  SUBWFB 5A,W
1C0C4:  MOVWF  x2F
1C0C6:  MOVLW  00
1C0C8:  SUBWFB 5B,W
1C0CA:  MOVWF  x30
1C0CC:  MOVLW  66
1C0CE:  MOVWF  x31
1C0D0:  MOVLW  77
1C0D2:  MOVWF  x32
1C0D4:  MOVFF  330,336
1C0D8:  MOVFF  32F,335
1C0DC:  MOVFF  32E,334
1C0E0:  MOVFF  32D,333
1C0E4:  MOVLW  01
1C0E6:  MOVWF  x38
1C0E8:  MOVLW  4C
1C0EA:  MOVWF  x37
1C0EC:  MOVLB  0
1C0EE:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C0F0:  MOVLB  3
1C0F2:  CLRF   x1F
1C0F4:  CLRF   x20
1C0F6:  CLRF   x24
1C0F8:  CLRF   x23
1C0FA:  CLRF   x22
1C0FC:  CLRF   x21
1C0FE:  CLRF   x1E
1C100:  CLRF   x1D
....................    return; 
1C102:  MOVLB  0
1C104:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY11to14_ADDRESS()                                                         //MBP Data download 
.................... {    
....................    AD = PASSED_DAYS % loop_day;                                                  //11,12,13,14 
*
1CD1C:  MOVFF  6A,385
1CD20:  MOVFF  69,384
1CD24:  MOVLB  3
1CD26:  CLRF   x87
1CD28:  MOVLW  46
1CD2A:  MOVWF  x86
1CD2C:  MOVLB  0
1CD2E:  CALL   156A
1CD32:  MOVFF  00,31B
1CD36:  MOVLB  3
1CD38:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CD3C:  CLRF   x1F
....................    ADL = AD; 
1CD3E:  MOVFF  31B,320
....................    UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);//65536*8 
1CD42:  MOVLW  4C
1CD44:  SUBWF  58,W
1CD46:  MOVWF  x2D
1CD48:  MOVLW  01
1CD4A:  SUBWFB 59,W
1CD4C:  MOVWF  x2E
1CD4E:  MOVLW  00
1CD50:  SUBWFB 5A,W
1CD52:  MOVWF  x2F
1CD54:  MOVLW  00
1CD56:  SUBWFB 5B,W
1CD58:  MOVWF  x30
1CD5A:  MOVLW  66
1CD5C:  MOVWF  x31
1CD5E:  MOVLW  77
1CD60:  MOVWF  x32
1CD62:  MOVFF  330,336
1CD66:  MOVFF  32F,335
1CD6A:  MOVFF  32E,334
1CD6E:  MOVFF  32D,333
1CD72:  MOVLW  01
1CD74:  MOVWF  x38
1CD76:  MOVLW  4C
1CD78:  MOVWF  x37
1CD7A:  MOVLB  0
1CD7C:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CD80:  MOVLB  3
1CD82:  CLRF   x1F
1CD84:  CLRF   x20
1CD86:  CLRF   x24
1CD88:  CLRF   x23
1CD8A:  CLRF   x22
1CD8C:  CLRF   x21
1CD8E:  CLRF   x1E
1CD90:  CLRF   x1D
....................    return; 
1CD92:  MOVLB  0
1CD94:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ ADCS MISSION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY15()                                                                     //ADCS MSN 
.................... { 
....................    SAVE_SAT_LOG(0xA0,0x11,0x11);                                                 //01,01: automatical mission 
*
1C106:  MOVLW  A0
1C108:  MOVLB  3
1C10A:  MOVWF  x53
1C10C:  MOVLW  11
1C10E:  MOVWF  x54
1C110:  MOVWF  x55
1C112:  MOVLB  0
1C114:  CALL   16EE2
....................    AUTO_ADCS_DONE = 1; 
1C118:  MOVLW  01
1C11A:  MOVWF  x7A
....................    STORE_FLAG_INFO();                                                            //save flag 
1C11C:  CALL   14000
....................    WRITE_FLAG_to_EEPROM();  
1C120:  CALL   11C84
....................    STORE_ADRESS_DATA_TO_FLASH(); 
1C124:  CALL   144C8
....................     
....................    AD = PASSED_DAYS % loop_day;                                                  //15 
1C128:  MOVFF  6A,385
1C12C:  MOVFF  69,384
1C130:  MOVLB  3
1C132:  CLRF   x87
1C134:  MOVLW  46
1C136:  MOVWF  x86
1C138:  MOVLB  0
1C13A:  CALL   156A
1C13E:  MOVFF  00,31B
1C142:  MOVLB  3
1C144:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C148:  CLRF   x1F
....................    ADL = AD; 
1C14A:  MOVFF  31B,320
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C14E:  MOVLW  AD
1C150:  MOVWF  x53
1C152:  MOVFF  31F,354
1C156:  MOVFF  320,355
1C15A:  MOVLB  0
1C15C:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66, 0x77, SECT*1138, 405);                               //(9byte) + (initial 81byte) + (end 81byte) 
1C160:  MOVLW  66
1C162:  MOVLB  3
1C164:  MOVWF  x31
1C166:  MOVLW  77
1C168:  MOVWF  x32
1C16A:  MOVLW  04
1C16C:  MOVWF  x36
1C16E:  MOVLW  72
1C170:  MOVWF  x35
1C172:  CLRF   x34
1C174:  CLRF   x33
1C176:  MOVLW  01
1C178:  MOVWF  x38
1C17A:  MOVLW  95
1C17C:  MOVWF  x37
1C17E:  MOVLB  0
1C180:  RCALL  1BBA6
....................    return; 
1C182:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY16to19()                                                                 //ADCS Data download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //16,17,18,19 
1C184:  MOVFF  6A,385
1C188:  MOVFF  69,384
1C18C:  MOVLB  3
1C18E:  CLRF   x87
1C190:  MOVLW  46
1C192:  MOVWF  x86
1C194:  MOVLB  0
1C196:  CALL   156A
1C19A:  MOVFF  00,31B
1C19E:  MOVLB  3
1C1A0:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C1A4:  CLRF   x1F
....................    ADL = AD; 
1C1A6:  MOVFF  31B,320
....................    D = AD - 15; 
1C1AA:  MOVLW  0F
1C1AC:  SUBWF  x1B,W
1C1AE:  MOVWF  x1D
1C1B0:  MOVLW  00
1C1B2:  SUBWFB x1C,W
1C1B4:  MOVWF  x1E
....................    DL_AD = 360*D; 
1C1B6:  MOVLW  01
1C1B8:  MOVWF  x43
1C1BA:  MOVLW  68
1C1BC:  MOVWF  x42
1C1BE:  MOVFF  31E,345
1C1C2:  MOVFF  31D,344
1C1C6:  MOVLB  0
1C1C8:  CALL   253A
1C1CC:  MOVLB  3
1C1CE:  CLRF   x24
1C1D0:  CLRF   x23
1C1D2:  MOVFF  02,322
1C1D6:  MOVFF  01,321
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C1DA:  MOVLW  AD
1C1DC:  MOVWF  x53
1C1DE:  MOVFF  31F,354
1C1E2:  MOVFF  320,355
1C1E6:  MOVLB  0
1C1E8:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C1EC:  MOVLB  3
1C1EE:  MOVFF  321,32D
1C1F2:  MOVFF  322,32E
1C1F6:  MOVLW  67
1C1F8:  ADDWF  x23,W
1C1FA:  MOVWF  x2F
1C1FC:  MOVLW  06
1C1FE:  ADDWFC x24,W
1C200:  MOVWF  x30
1C202:  MOVLW  66
1C204:  MOVWF  x31
1C206:  MOVLW  77
1C208:  MOVWF  x32
1C20A:  MOVFF  330,336
1C20E:  MOVFF  32F,335
1C212:  MOVFF  322,334
1C216:  MOVFF  321,333
1C21A:  MOVLW  01
1C21C:  MOVWF  x38
1C21E:  MOVLW  95
1C220:  MOVWF  x37
1C222:  MOVLB  0
1C224:  RCALL  1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C226:  MOVLB  3
1C228:  CLRF   x1F
1C22A:  CLRF   x20
1C22C:  CLRF   x24
1C22E:  CLRF   x23
1C230:  CLRF   x22
1C232:  CLRF   x21
1C234:  CLRF   x1E
1C236:  CLRF   x1D
....................    return; 
1C238:  MOVLB  0
1C23A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY16to19_ADDRESS()                                                         //ADCS DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //16,17,18,19 
*
1CD96:  MOVFF  6A,385
1CD9A:  MOVFF  69,384
1CD9E:  MOVLB  3
1CDA0:  CLRF   x87
1CDA2:  MOVLW  46
1CDA4:  MOVWF  x86
1CDA6:  MOVLB  0
1CDA8:  CALL   156A
1CDAC:  MOVFF  00,31B
1CDB0:  MOVLB  3
1CDB2:  MOVFF  03,31C
....................    ADH = AD << 8; 
1CDB6:  CLRF   x1F
....................    ADL = AD; 
1CDB8:  MOVFF  31B,320
....................    D = AD - 15; 
1CDBC:  MOVLW  0F
1CDBE:  SUBWF  x1B,W
1CDC0:  MOVWF  x1D
1CDC2:  MOVLW  00
1CDC4:  SUBWFB x1C,W
1CDC6:  MOVWF  x1E
....................    DL_AD = 360*D;                                                                //saltos de 360 paquetes 
1CDC8:  MOVLW  01
1CDCA:  MOVWF  x43
1CDCC:  MOVLW  68
1CDCE:  MOVWF  x42
1CDD0:  MOVFF  31E,345
1CDD4:  MOVFF  31D,344
1CDD8:  MOVLB  0
1CDDA:  CALL   253A
1CDDE:  MOVLB  3
1CDE0:  CLRF   x24
1CDE2:  CLRF   x23
1CDE4:  MOVFF  02,322
1CDE8:  MOVFF  01,321
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1CDEC:  MOVFF  321,32D
1CDF0:  MOVFF  322,32E
1CDF4:  MOVLW  67
1CDF6:  ADDWF  x23,W
1CDF8:  MOVWF  x2F
1CDFA:  MOVLW  06
1CDFC:  ADDWFC x24,W
1CDFE:  MOVWF  x30
1CE00:  MOVLW  66
1CE02:  MOVWF  x31
1CE04:  MOVLW  77
1CE06:  MOVWF  x32
1CE08:  MOVFF  330,336
1CE0C:  MOVFF  32F,335
1CE10:  MOVFF  322,334
1CE14:  MOVFF  321,333
1CE18:  MOVLW  01
1CE1A:  MOVWF  x38
1CE1C:  MOVLW  95
1CE1E:  MOVWF  x37
1CE20:  MOVLB  0
1CE22:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1CE26:  MOVLB  3
1CE28:  CLRF   x1F
1CE2A:  CLRF   x20
1CE2C:  CLRF   x24
1CE2E:  CLRF   x23
1CE30:  CLRF   x22
1CE32:  CLRF   x21
1CE34:  CLRF   x1E
1CE36:  CLRF   x1D
....................    return; 
1CE38:  MOVLB  0
1CE3A:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY47to52()                                                                 //ADCS Datadownload 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //47,48,49,50,51,52 
*
1C40E:  MOVFF  6A,385
1C412:  MOVFF  69,384
1C416:  MOVLB  3
1C418:  CLRF   x87
1C41A:  MOVLW  46
1C41C:  MOVWF  x86
1C41E:  MOVLB  0
1C420:  CALL   156A
1C424:  MOVFF  00,31B
1C428:  MOVLB  3
1C42A:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C42E:  CLRF   x1F
....................    ADL = AD; 
1C430:  MOVFF  31B,320
....................    D = AD - 42;                                                                  //5,6,7,8,9,10 
1C434:  MOVLW  2A
1C436:  SUBWF  x1B,W
1C438:  MOVWF  x1D
1C43A:  MOVLW  00
1C43C:  SUBWFB x1C,W
1C43E:  MOVWF  x1E
....................     
....................    DL_AD = 360*D;                                                                //realiza saltos de 360 
1C440:  MOVLW  01
1C442:  MOVWF  x43
1C444:  MOVLW  68
1C446:  MOVWF  x42
1C448:  MOVFF  31E,345
1C44C:  MOVFF  31D,344
1C450:  MOVLB  0
1C452:  CALL   253A
1C456:  MOVLB  3
1C458:  CLRF   x24
1C45A:  CLRF   x23
1C45C:  MOVFF  02,322
1C460:  MOVFF  01,321
....................    DL_AD = DL_AD * 81;                                                           //download address 
1C464:  MOVFF  324,337
1C468:  MOVFF  323,336
1C46C:  MOVFF  322,335
1C470:  MOVFF  321,334
1C474:  CLRF   x3B
1C476:  CLRF   x3A
1C478:  CLRF   x39
1C47A:  MOVLW  51
1C47C:  MOVWF  x38
1C47E:  MOVLB  0
1C480:  CALL   24DE
1C484:  MOVFF  03,324
1C488:  MOVFF  02,323
1C48C:  MOVFF  01,322
1C490:  MOVFF  00,321
....................    /*////////////////////////////PACKET//////////////////////////////// 
....................    //1800-1804, 2160-2164, 2520-2524, 2880-2884, 3240-3244, 3600-3604 
....................    //////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C494:  MOVLW  AD
1C496:  MOVLB  3
1C498:  MOVWF  x53
1C49A:  MOVFF  31F,354
1C49E:  MOVFF  320,355
1C4A2:  MOVLB  0
1C4A4:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1C4A8:  MOVLB  3
1C4AA:  MOVFF  321,32D
1C4AE:  MOVFF  322,32E
1C4B2:  MOVLW  67
1C4B4:  ADDWF  x23,W
1C4B6:  MOVWF  x2F
1C4B8:  MOVLW  06
1C4BA:  ADDWFC x24,W
1C4BC:  MOVWF  x30
1C4BE:  MOVLW  66
1C4C0:  MOVWF  x31
1C4C2:  MOVLW  77
1C4C4:  MOVWF  x32
1C4C6:  MOVFF  330,336
1C4CA:  MOVFF  32F,335
1C4CE:  MOVFF  322,334
1C4D2:  MOVFF  321,333
1C4D6:  MOVLW  01
1C4D8:  MOVWF  x38
1C4DA:  MOVLW  95
1C4DC:  MOVWF  x37
1C4DE:  MOVLB  0
1C4E0:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C4E4:  MOVLB  3
1C4E6:  CLRF   x1F
1C4E8:  CLRF   x20
1C4EA:  CLRF   x24
1C4EC:  CLRF   x23
1C4EE:  CLRF   x22
1C4F0:  CLRF   x21
1C4F2:  CLRF   x1E
1C4F4:  CLRF   x1D
....................    return; 
1C4F6:  MOVLB  0
1C4F8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY47to52_ADDRESS()                                                         //ADCS DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //47,48,49,50,51,52 
*
1CFE8:  MOVFF  6A,385
1CFEC:  MOVFF  69,384
1CFF0:  MOVLB  3
1CFF2:  CLRF   x87
1CFF4:  MOVLW  46
1CFF6:  MOVWF  x86
1CFF8:  MOVLB  0
1CFFA:  CALL   156A
1CFFE:  MOVFF  00,31B
1D002:  MOVLB  3
1D004:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D008:  CLRF   x1F
....................    ADL = AD; 
1D00A:  MOVFF  31B,320
....................    D = AD - 42;                                                                  //5,6,7,8,9,10 
1D00E:  MOVLW  2A
1D010:  SUBWF  x1B,W
1D012:  MOVWF  x1D
1D014:  MOVLW  00
1D016:  SUBWFB x1C,W
1D018:  MOVWF  x1E
....................     
....................    DL_AD = 360*D;                                                                //saltos de 360 paquetes 
1D01A:  MOVLW  01
1D01C:  MOVWF  x43
1D01E:  MOVLW  68
1D020:  MOVWF  x42
1D022:  MOVFF  31E,345
1D026:  MOVFF  31D,344
1D02A:  MOVLB  0
1D02C:  CALL   253A
1D030:  MOVLB  3
1D032:  CLRF   x24
1D034:  CLRF   x23
1D036:  MOVFF  02,322
1D03A:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1D03E:  MOVFF  324,337
1D042:  MOVFF  323,336
1D046:  MOVFF  322,335
1D04A:  MOVFF  321,334
1D04E:  CLRF   x3B
1D050:  CLRF   x3A
1D052:  CLRF   x39
1D054:  MOVLW  51
1D056:  MOVWF  x38
1D058:  MOVLB  0
1D05A:  CALL   24DE
1D05E:  MOVFF  03,324
1D062:  MOVFF  02,323
1D066:  MOVFF  01,322
1D06A:  MOVFF  00,321
....................    /*////////////////////////////PACKET//////////////////////////////// 
....................    //1800-1804, 2160-2164, 2520-2524, 2880-2884, 3240-3244, 3600-3604 
....................    //////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*1639+DL_AD,405);                            //65536*8 
1D06E:  MOVLB  3
1D070:  MOVFF  321,32D
1D074:  MOVFF  322,32E
1D078:  MOVLW  67
1D07A:  ADDWF  x23,W
1D07C:  MOVWF  x2F
1D07E:  MOVLW  06
1D080:  ADDWFC x24,W
1D082:  MOVWF  x30
1D084:  MOVLW  66
1D086:  MOVWF  x31
1D088:  MOVLW  77
1D08A:  MOVWF  x32
1D08C:  MOVFF  330,336
1D090:  MOVFF  32F,335
1D094:  MOVFF  322,334
1D098:  MOVFF  321,333
1D09C:  MOVLW  01
1D09E:  MOVWF  x38
1D0A0:  MOVLW  95
1D0A2:  MOVWF  x37
1D0A4:  MOVLB  0
1D0A6:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D0AA:  MOVLB  3
1D0AC:  CLRF   x1F
1D0AE:  CLRF   x20
1D0B0:  CLRF   x24
1D0B2:  CLRF   x23
1D0B4:  CLRF   x22
1D0B6:  CLRF   x21
1D0B8:  CLRF   x1E
1D0BA:  CLRF   x1D
....................    return; 
1D0BC:  MOVLB  0
1D0BE:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ SAT_LOG @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY53to59()                                                                 //LOG DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //53,54,55,56,57,58,59 
*
1C4FA:  MOVFF  6A,385
1C4FE:  MOVFF  69,384
1C502:  MOVLB  3
1C504:  CLRF   x87
1C506:  MOVLW  46
1C508:  MOVWF  x86
1C50A:  MOVLB  0
1C50C:  CALL   156A
1C510:  MOVFF  00,31B
1C514:  MOVLB  3
1C516:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C51A:  CLRF   x1F
....................    ADL = AD; 
1C51C:  MOVFF  31B,320
....................    D = AD - 53;                                                                  //0,1,2,3,4,5,6 
1C520:  MOVLW  35
1C522:  SUBWF  x1B,W
1C524:  MOVWF  x1D
1C526:  MOVLW  00
1C528:  SUBWFB x1C,W
1C52A:  MOVWF  x1E
....................     
....................    DL_AD = D; 
1C52C:  CLRF   x24
1C52E:  CLRF   x23
1C530:  MOVFF  31E,322
1C534:  MOVFF  31D,321
....................    DL_AD = DL_AD * 81; 
1C538:  MOVFF  324,337
1C53C:  MOVFF  323,336
1C540:  MOVFF  322,335
1C544:  MOVFF  321,334
1C548:  CLRF   x3B
1C54A:  CLRF   x3A
1C54C:  CLRF   x39
1C54E:  MOVLW  51
1C550:  MOVWF  x38
1C552:  MOVLB  0
1C554:  CALL   24DE
1C558:  MOVFF  03,324
1C55C:  MOVFF  02,323
1C560:  MOVFF  01,322
1C564:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //0-4, 5-10, 10-14, 15-19, 20-24, 25-29, 30-34 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C568:  MOVLW  AD
1C56A:  MOVLB  3
1C56C:  MOVWF  x53
1C56E:  MOVFF  31F,354
1C572:  MOVFF  320,355
1C576:  MOVLB  0
1C578:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*6+DL_AD,405);                               //65536*8 
1C57C:  MOVLB  3
1C57E:  MOVFF  321,32D
1C582:  MOVFF  322,32E
1C586:  MOVLW  06
1C588:  ADDWF  x23,W
1C58A:  MOVWF  x2F
1C58C:  MOVLW  00
1C58E:  ADDWFC x24,W
1C590:  MOVWF  x30
1C592:  MOVLW  66
1C594:  MOVWF  x31
1C596:  MOVLW  77
1C598:  MOVWF  x32
1C59A:  MOVFF  330,336
1C59E:  MOVFF  32F,335
1C5A2:  MOVFF  322,334
1C5A6:  MOVFF  321,333
1C5AA:  MOVLW  01
1C5AC:  MOVWF  x38
1C5AE:  MOVLW  95
1C5B0:  MOVWF  x37
1C5B2:  MOVLB  0
1C5B4:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C5B8:  MOVLB  3
1C5BA:  CLRF   x1F
1C5BC:  CLRF   x20
1C5BE:  CLRF   x24
1C5C0:  CLRF   x23
1C5C2:  CLRF   x22
1C5C4:  CLRF   x21
1C5C6:  CLRF   x1E
1C5C8:  CLRF   x1D
....................    return; 
1C5CA:  MOVLB  0
1C5CC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY53to59_ADDRESS()                                                         //LOG DL 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //53,54,55,56,57,58,59 
*
1D0C0:  MOVFF  6A,385
1D0C4:  MOVFF  69,384
1D0C8:  MOVLB  3
1D0CA:  CLRF   x87
1D0CC:  MOVLW  46
1D0CE:  MOVWF  x86
1D0D0:  MOVLB  0
1D0D2:  CALL   156A
1D0D6:  MOVFF  00,31B
1D0DA:  MOVLB  3
1D0DC:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D0E0:  CLRF   x1F
....................    ADL = AD; 
1D0E2:  MOVFF  31B,320
....................    D = AD - 53;                                                                  //0,1,2,3,4,5,6 
1D0E6:  MOVLW  35
1D0E8:  SUBWF  x1B,W
1D0EA:  MOVWF  x1D
1D0EC:  MOVLW  00
1D0EE:  SUBWFB x1C,W
1D0F0:  MOVWF  x1E
....................     
....................    DL_AD = D; 
1D0F2:  CLRF   x24
1D0F4:  CLRF   x23
1D0F6:  MOVFF  31E,322
1D0FA:  MOVFF  31D,321
....................    DL_AD = DL_AD * 81; 
1D0FE:  MOVFF  324,337
1D102:  MOVFF  323,336
1D106:  MOVFF  322,335
1D10A:  MOVFF  321,334
1D10E:  CLRF   x3B
1D110:  CLRF   x3A
1D112:  CLRF   x39
1D114:  MOVLW  51
1D116:  MOVWF  x38
1D118:  MOVLB  0
1D11A:  CALL   24DE
1D11E:  MOVFF  03,324
1D122:  MOVFF  02,323
1D126:  MOVFF  01,322
1D12A:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //0-4, 5-10, 10-14, 15-19, 20-24, 25-29, 30-34 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*6+DL_AD,405);                               //65536*8 
1D12E:  MOVLB  3
1D130:  MOVFF  321,32D
1D134:  MOVFF  322,32E
1D138:  MOVLW  06
1D13A:  ADDWF  x23,W
1D13C:  MOVWF  x2F
1D13E:  MOVLW  00
1D140:  ADDWFC x24,W
1D142:  MOVWF  x30
1D144:  MOVLW  66
1D146:  MOVWF  x31
1D148:  MOVLW  77
1D14A:  MOVWF  x32
1D14C:  MOVFF  330,336
1D150:  MOVFF  32F,335
1D154:  MOVFF  322,334
1D158:  MOVFF  321,333
1D15C:  MOVLW  01
1D15E:  MOVWF  x38
1D160:  MOVLW  95
1D162:  MOVWF  x37
1D164:  MOVLB  0
1D166:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D16A:  MOVLB  3
1D16C:  CLRF   x1F
1D16E:  CLRF   x20
1D170:  CLRF   x24
1D172:  CLRF   x23
1D174:  CLRF   x22
1D176:  CLRF   x21
1D178:  CLRF   x1E
1D17A:  CLRF   x1D
....................    return; 
1D17C:  MOVLB  0
1D17E:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ NOMAL SAMPLING HK @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void DAY60to69()                                                                 //HK Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //60,61,62,63,64,65,66,67,68,69 
*
1C5CE:  MOVFF  6A,385
1C5D2:  MOVFF  69,384
1C5D6:  MOVLB  3
1C5D8:  CLRF   x87
1C5DA:  MOVLW  46
1C5DC:  MOVWF  x86
1C5DE:  MOVLB  0
1C5E0:  CALL   156A
1C5E4:  MOVFF  00,31B
1C5E8:  MOVLB  3
1C5EA:  MOVFF  03,31C
....................    ADH = AD << 8; 
1C5EE:  CLRF   x1F
....................    ADL = AD; 
1C5F0:  MOVFF  31B,320
....................    //D = AD - 53;                                                                //0,1,2,3,4,5,6,7,8,9 (deberia ser AD-53?) 
....................    D = AD - 60; 
1C5F4:  MOVLW  3C
1C5F6:  SUBWF  x1B,W
1C5F8:  MOVWF  x1D
1C5FA:  MOVLW  00
1C5FC:  SUBWFB x1C,W
1C5FE:  MOVWF  x1E
....................    DL_AD = 9798*D;                                                               //realiza un salto de 9798 paquetes 
1C600:  MOVLW  26
1C602:  MOVWF  x43
1C604:  MOVLW  46
1C606:  MOVWF  x42
1C608:  MOVFF  31E,345
1C60C:  MOVFF  31D,344
1C610:  MOVLB  0
1C612:  CALL   253A
1C616:  MOVLB  3
1C618:  CLRF   x24
1C61A:  CLRF   x23
1C61C:  MOVFF  02,322
1C620:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1C624:  MOVFF  324,337
1C628:  MOVFF  323,336
1C62C:  MOVFF  322,335
1C630:  MOVFF  321,334
1C634:  CLRF   x3B
1C636:  CLRF   x3A
1C638:  CLRF   x39
1C63A:  MOVLW  51
1C63C:  MOVWF  x38
1C63E:  MOVLB  0
1C640:  CALL   24DE
1C644:  MOVFF  03,324
1C648:  MOVFF  02,323
1C64C:  MOVFF  01,322
1C650:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //    0-4,      9798-9802,  19596-19600, 29394-29398, 39192-39196 
....................    //48990-48994, 58788-58792, 68586-68590, 78384-78388, 88182-88186 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    SAVE_SAT_LOG(0xAD,ADH,ADL);                                                   //11,11: automatical mission 
1C654:  MOVLW  AD
1C656:  MOVLB  3
1C658:  MOVWF  x53
1C65A:  MOVFF  31F,354
1C65E:  MOVFF  320,355
1C662:  MOVLB  0
1C664:  CALL   16EE2
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*98+DL_AD,405);                              //65536*8 
1C668:  MOVLB  3
1C66A:  MOVFF  321,32D
1C66E:  MOVFF  322,32E
1C672:  MOVLW  62
1C674:  ADDWF  x23,W
1C676:  MOVWF  x2F
1C678:  MOVLW  00
1C67A:  ADDWFC x24,W
1C67C:  MOVWF  x30
1C67E:  MOVLW  66
1C680:  MOVWF  x31
1C682:  MOVLW  77
1C684:  MOVWF  x32
1C686:  MOVFF  330,336
1C68A:  MOVFF  32F,335
1C68E:  MOVFF  322,334
1C692:  MOVFF  321,333
1C696:  MOVLW  01
1C698:  MOVWF  x38
1C69A:  MOVLW  95
1C69C:  MOVWF  x37
1C69E:  MOVLB  0
1C6A0:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1C6A4:  MOVLB  3
1C6A6:  CLRF   x1F
1C6A8:  CLRF   x20
1C6AA:  CLRF   x24
1C6AC:  CLRF   x23
1C6AE:  CLRF   x22
1C6B0:  CLRF   x21
1C6B2:  CLRF   x1E
1C6B4:  CLRF   x1D
....................    return; 
1C6B6:  MOVLB  0
1C6B8:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void DAY60to69_ADDRESS()                                                         //HK Download 
.................... { 
....................    AD = PASSED_DAYS % loop_day;                                                  //60,61,62,63,64,65,66,67,68,69 
*
1D180:  MOVFF  6A,385
1D184:  MOVFF  69,384
1D188:  MOVLB  3
1D18A:  CLRF   x87
1D18C:  MOVLW  46
1D18E:  MOVWF  x86
1D190:  MOVLB  0
1D192:  CALL   156A
1D196:  MOVFF  00,31B
1D19A:  MOVLB  3
1D19C:  MOVFF  03,31C
....................    ADH = AD << 8; 
1D1A0:  CLRF   x1F
....................    ADL = AD; 
1D1A2:  MOVFF  31B,320
....................    //D = AD - 53;                                                                  //0,1,2,3,4,5,6,7,8,9 (deberia ser AD-53?) 
....................    D = AD - 60; 
1D1A6:  MOVLW  3C
1D1A8:  SUBWF  x1B,W
1D1AA:  MOVWF  x1D
1D1AC:  MOVLW  00
1D1AE:  SUBWFB x1C,W
1D1B0:  MOVWF  x1E
....................    DL_AD = 9798*D;                                                               //realiza saltos de 9798 paquetes 
1D1B2:  MOVLW  26
1D1B4:  MOVWF  x43
1D1B6:  MOVLW  46
1D1B8:  MOVWF  x42
1D1BA:  MOVFF  31E,345
1D1BE:  MOVFF  31D,344
1D1C2:  MOVLB  0
1D1C4:  CALL   253A
1D1C8:  MOVLB  3
1D1CA:  CLRF   x24
1D1CC:  CLRF   x23
1D1CE:  MOVFF  02,322
1D1D2:  MOVFF  01,321
....................    DL_AD = DL_AD * 81; 
1D1D6:  MOVFF  324,337
1D1DA:  MOVFF  323,336
1D1DE:  MOVFF  322,335
1D1E2:  MOVFF  321,334
1D1E6:  CLRF   x3B
1D1E8:  CLRF   x3A
1D1EA:  CLRF   x39
1D1EC:  MOVLW  51
1D1EE:  MOVWF  x38
1D1F0:  MOVLB  0
1D1F2:  CALL   24DE
1D1F6:  MOVFF  03,324
1D1FA:  MOVFF  02,323
1D1FE:  MOVFF  01,322
1D202:  MOVFF  00,321
....................    /*////////////////////////////PACKET////////////////////////////// 
....................    //    0-4,      9798-9802,  19596-19600, 29394-29398, 39192-39196 
....................    //48990-48994, 58788-58792, 68586-68590, 78384-78388, 88182-88186 
....................    ////////////////////////////////////////////////////////////////*/ 
....................     
....................    UPDATE_ACK_for_COM(0x66,0x77,SECT*98+DL_AD,405);                              //65536*8 
1D206:  MOVLB  3
1D208:  MOVFF  321,32D
1D20C:  MOVFF  322,32E
1D210:  MOVLW  62
1D212:  ADDWF  x23,W
1D214:  MOVWF  x2F
1D216:  MOVLW  00
1D218:  ADDWFC x24,W
1D21A:  MOVWF  x30
1D21C:  MOVLW  66
1D21E:  MOVWF  x31
1D220:  MOVLW  77
1D222:  MOVWF  x32
1D224:  MOVFF  330,336
1D228:  MOVFF  32F,335
1D22C:  MOVFF  322,334
1D230:  MOVFF  321,333
1D234:  MOVLW  01
1D236:  MOVWF  x38
1D238:  MOVLW  95
1D23A:  MOVWF  x37
1D23C:  MOVLB  0
1D23E:  CALL   1BBA6
....................    ADH=0; ADL=0; DL_AD=0; D=0; 
1D242:  MOVLB  3
1D244:  CLRF   x1F
1D246:  CLRF   x20
1D248:  CLRF   x24
1D24A:  CLRF   x23
1D24C:  CLRF   x22
1D24E:  CLRF   x21
1D250:  CLRF   x1E
1D252:  CLRF   x1D
....................    return; 
1D254:  MOVLB  0
1D256:  RETURN 0
.................... } 
....................  
.................... //@@@@@@@@@@@ ADDRESS CHANGE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTO_MSN_AD_CHANGE()                                                        //update address for a new cycle 
*
1B812:  MOVFF  6A,385
1B816:  MOVFF  69,384
1B81A:  MOVLB  3
1B81C:  CLRF   x87
1B81E:  MOVLW  46
1B820:  MOVWF  x86
1B822:  MOVLB  0
1B824:  CALL   156A
1B828:  MOVFF  02,32E
1B82C:  MOVFF  01,32D
1B830:  MOVFF  32D,32F
.................... { 
....................    unsigned int16 D = PASSED_DAYS/loop_day; 
....................    int8 UPDATE_TIME = (int8)D; 
....................    SAVE_SAT_LOG(0xF9,UPDATE_TIME,UPDATE_TIME); 
1B834:  MOVLW  F9
1B836:  MOVLB  3
1B838:  MOVWF  x53
1B83A:  MOVFF  32F,354
1B83E:  MOVFF  32F,355
1B842:  MOVLB  0
1B844:  CALL   16EE2
....................    int32 DATA = 8192*D;                                                          //11byte*500 < 5500 (enough), SAT_LOG data sent in one cycle 
1B848:  MOVLB  3
1B84A:  SWAPF  x2D,W
1B84C:  MOVWF  x31
1B84E:  CLRF   x30
1B850:  RLCF   x31,F
1B852:  MOVLW  E0
1B854:  ANDWF  x31,F
....................    SAT_LOG = SECT*6 + DATA;                                                      //2sector 
1B856:  MOVFF  330,40
1B85A:  MOVFF  331,41
1B85E:  MOVLW  06
1B860:  ADDWF  x32,W
1B862:  MOVWF  42
1B864:  MOVLW  00
1B866:  ADDWFC x33,W
1B868:  MOVWF  43
....................     
....................    DATA = SECT*D;                                                                //1sector, CAM data sent in one cycle 
1B86A:  MOVFF  32E,333
1B86E:  MOVFF  32D,332
1B872:  CLRF   x30
1B874:  CLRF   x31
....................    CAM_ADDRESS = SECT*8 + DATA; 
1B876:  MOVFF  330,44
1B87A:  MOVFF  331,45
1B87E:  MOVLW  08
1B880:  ADDWF  x32,W
1B882:  MOVWF  46
1B884:  MOVLW  00
1B886:  ADDWFC x33,W
1B888:  MOVWF  47
....................     
....................    DATA = SECT*130;                                                              //124*3600*24*70/90 < 128sector, HK data sent in one cycle 
1B88A:  CLRF   x33
1B88C:  MOVLW  82
1B88E:  MOVWF  x32
1B890:  CLRF   x31
1B892:  CLRF   x30
....................    DATA = DATA*D; 
1B894:  MOVFF  333,337
1B898:  MOVFF  332,336
1B89C:  MOVFF  331,335
1B8A0:  MOVFF  330,334
1B8A4:  CLRF   x3B
1B8A6:  CLRF   x3A
1B8A8:  MOVFF  32E,339
1B8AC:  MOVFF  32D,338
1B8B0:  MOVLB  0
1B8B2:  CALL   24DE
1B8B6:  MOVFF  03,333
1B8BA:  MOVFF  02,332
1B8BE:  MOVFF  01,331
1B8C2:  MOVFF  00,330
....................    FAB_HK_ADDRESS = SECT*98 + DATA;                                              //1000sector 
1B8C6:  MOVLB  3
1B8C8:  MOVFF  330,48
1B8CC:  MOVFF  331,49
1B8D0:  MOVLW  62
1B8D2:  ADDWF  x32,W
1B8D4:  MOVWF  4A
1B8D6:  MOVLW  00
1B8D8:  ADDWFC x33,W
1B8DA:  MOVWF  4B
....................     
....................    DATA = SECT*5;                                                                //81*5400/1.5 < 5sector, ADCS data sent in one cycle 
1B8DC:  CLRF   x33
1B8DE:  MOVLW  05
1B8E0:  MOVWF  x32
1B8E2:  CLRF   x31
1B8E4:  CLRF   x30
....................    DATA = DATA*D; 
1B8E6:  MOVFF  333,337
1B8EA:  MOVFF  332,336
1B8EE:  MOVFF  331,335
1B8F2:  MOVFF  330,334
1B8F6:  CLRF   x3B
1B8F8:  CLRF   x3A
1B8FA:  MOVFF  32E,339
1B8FE:  MOVFF  32D,338
1B902:  MOVLB  0
1B904:  CALL   24DE
1B908:  MOVFF  03,333
1B90C:  MOVFF  02,332
1B910:  MOVFF  01,331
1B914:  MOVFF  00,330
....................    ADCS_SENSOR_ADDRESS = SECT*1138 + DATA;                                       //500sector 
1B918:  MOVLB  3
1B91A:  MOVFF  330,50
1B91E:  MOVFF  331,51
1B922:  MOVLW  72
1B924:  ADDWF  x32,W
1B926:  MOVWF  52
1B928:  MOVLW  04
1B92A:  ADDWFC x33,W
1B92C:  MOVWF  53
....................     
....................    DATA = 405*5;                                                                 //5packet*5, DC data sent in one cycle 
1B92E:  CLRF   x33
1B930:  CLRF   x32
1B932:  MOVLW  07
1B934:  MOVWF  x31
1B936:  MOVLW  E9
1B938:  MOVWF  x30
....................    DATA = DATA*D; 
1B93A:  MOVFF  333,337
1B93E:  MOVFF  332,336
1B942:  MOVFF  331,335
1B946:  MOVFF  330,334
1B94A:  CLRF   x3B
1B94C:  CLRF   x3A
1B94E:  MOVFF  32E,339
1B952:  MOVFF  32D,338
1B956:  MOVLB  0
1B958:  CALL   24DE
1B95C:  MOVFF  03,333
1B960:  MOVFF  02,332
1B964:  MOVFF  01,331
1B968:  MOVFF  00,330
....................    DC_STATUS_ADDRESS = SECT*1638 + DATA;                                         //1sector 
1B96C:  MOVLB  3
1B96E:  MOVFF  330,58
1B972:  MOVFF  331,59
1B976:  MOVLW  66
1B978:  ADDWF  x32,W
1B97A:  MOVWF  5A
1B97C:  MOVLW  06
1B97E:  ADDWFC x33,W
1B980:  MOVWF  5B
....................     
....................    DATA = SECT*3;                                                                //124*3600*2/5 < 3sector, HSSC data sent in one cycle 
1B982:  CLRF   x33
1B984:  MOVLW  03
1B986:  MOVWF  x32
1B988:  CLRF   x31
1B98A:  CLRF   x30
....................    DATA = DATA*D; 
1B98C:  MOVFF  333,337
1B990:  MOVFF  332,336
1B994:  MOVFF  331,335
1B998:  MOVFF  330,334
1B99C:  CLRF   x3B
1B99E:  CLRF   x3A
1B9A0:  MOVFF  32E,339
1B9A4:  MOVFF  32D,338
1B9A8:  MOVLB  0
1B9AA:  CALL   24DE
1B9AE:  MOVFF  03,333
1B9B2:  MOVFF  02,332
1B9B6:  MOVFF  01,331
1B9BA:  MOVFF  00,330
....................    HIGH_SAMP_HK_ADDRESS = SECT*1639 + DATA;                                      //409sector 
1B9BE:  MOVLB  3
1B9C0:  MOVFF  330,5C
1B9C4:  MOVFF  331,5D
1B9C8:  MOVLW  67
1B9CA:  ADDWF  x32,W
1B9CC:  MOVWF  5E
1B9CE:  MOVLW  06
1B9D0:  ADDWFC x33,W
1B9D2:  MOVWF  5F
....................     
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //update 
1B9D4:  MOVLB  0
1B9D6:  CALL   144C8
....................     
....................    return; 
1B9DA:  RETURN 0
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@ AUTO MISSION EXECUTING FUNCTION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTOMATICAL_MSN_EXE() 
.................... { 
....................     
....................    if(((PASSED_DAYS%loop_day) >= 0 && UPLINK_SUCCESS == 0) && FIRST_HSSC_DONE == 0)                      //automated high samp mission condition 
*
1C6BA:  MOVFF  6A,385
1C6BE:  MOVFF  69,384
1C6C2:  MOVLB  3
1C6C4:  CLRF   x87
1C6C6:  MOVLW  46
1C6C8:  MOVWF  x86
1C6CA:  MOVLB  0
1C6CC:  CALL   156A
1C6D0:  MOVFF  00,32D
1C6D4:  MOVFF  03,32E
1C6D8:  MOVLB  0
1C6DA:  MOVF   x7C,F
1C6DC:  BNZ   1C6E8
1C6DE:  MOVF   x77,F
1C6E0:  BNZ   1C6E8
....................    { 
....................       DAY0(); 
1C6E2:  CALL   1BC06
....................    }else if(PASSED_DAYS < make16(reset_bffr[4],reset_bffr[5]))                                           //if the date changed (next day) 
1C6E6:  BRA    1CB5A
1C6E8:  MOVFF  A2,03
1C6EC:  MOVFF  A3,01
1C6F0:  MOVF   x6A,W
1C6F2:  SUBWF  xA2,W
1C6F4:  BTFSS  FD8.0
1C6F6:  BRA    1CB5A
1C6F8:  BNZ   1C702
1C6FA:  MOVF   01,W
1C6FC:  SUBWF  x69,W
1C6FE:  BTFSC  FD8.0
1C700:  BRA    1CB5A
....................    { 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]);                                                 //update passed days 
1C702:  MOVFF  A2,6A
1C706:  MOVFF  A3,69
....................       STORE_FLAG_INFO();                                                                                 //save passed days 
1C70A:  CALL   14000
....................       WRITE_FLAG_to_EEPROM(); 
1C70E:  CALL   11C84
....................        
....................       if(((PASSED_DAYS%loop_day) >= 1 && (PASSED_DAYS%loop_day) <= 4) && UPLINK_SUCCESS == 0){           //1-4th day high samp mission download  
1C712:  MOVFF  6A,385
1C716:  MOVFF  69,384
1C71A:  MOVLB  3
1C71C:  CLRF   x87
1C71E:  MOVLW  46
1C720:  MOVWF  x86
1C722:  MOVLB  0
1C724:  CALL   156A
1C728:  MOVFF  00,32D
1C72C:  MOVLB  3
1C72E:  MOVFF  03,32E
1C732:  MOVF   x2E,F
1C734:  BNZ   1C73C
1C736:  MOVF   x2D,W
1C738:  SUBLW  00
1C73A:  BC    1C778
1C73C:  MOVFF  6A,385
1C740:  MOVFF  69,384
1C744:  CLRF   x87
1C746:  MOVLW  46
1C748:  MOVWF  x86
1C74A:  MOVLB  0
1C74C:  CALL   156A
1C750:  MOVFF  00,32D
1C754:  MOVLB  3
1C756:  MOVFF  03,32E
1C75A:  MOVF   x2E,F
1C75C:  BNZ   1C778
1C75E:  MOVF   x2D,W
1C760:  SUBLW  04
1C762:  BNC   1C778
1C764:  MOVLB  0
1C766:  MOVF   x7C,F
1C768:  BTFSC  FD8.2
1C76A:  BRA    1C770
1C76C:  MOVLB  3
1C76E:  BRA    1C778
....................          DAY1to4(); 
1C770:  CALL   1BC92
....................       }else if(((PASSED_DAYS%loop_day) >= 5 && UPLINK_SUCCESS == 0) && AUTO_CAM_DONE == 0){              //5th day (CAM MSN) 
1C774:  BRA    1CB5A
1C776:  MOVLB  3
1C778:  MOVFF  6A,385
1C77C:  MOVFF  69,384
1C780:  CLRF   x87
1C782:  MOVLW  46
1C784:  MOVWF  x86
1C786:  MOVLB  0
1C788:  CALL   156A
1C78C:  MOVFF  00,32D
1C790:  MOVLB  3
1C792:  MOVFF  03,32E
1C796:  MOVF   x2E,F
1C798:  BNZ   1C7A0
1C79A:  MOVF   x2D,W
1C79C:  SUBLW  04
1C79E:  BC    1C7BE
1C7A0:  MOVLB  0
1C7A2:  MOVF   x7C,F
1C7A4:  BTFSC  FD8.2
1C7A6:  BRA    1C7AC
1C7A8:  MOVLB  3
1C7AA:  BRA    1C7BE
1C7AC:  MOVF   x78,F
1C7AE:  BTFSC  FD8.2
1C7B0:  BRA    1C7B6
1C7B2:  MOVLB  3
1C7B4:  BRA    1C7BE
....................          DAY5(); 
1C7B6:  CALL   1BD76
....................       }else if(((PASSED_DAYS%loop_day) >= 6 && (PASSED_DAYS%loop_day) <= 9) && UPLINK_SUCCESS == 0){     //download cam data 
1C7BA:  BRA    1CB5A
1C7BC:  MOVLB  3
1C7BE:  MOVFF  6A,385
1C7C2:  MOVFF  69,384
1C7C6:  CLRF   x87
1C7C8:  MOVLW  46
1C7CA:  MOVWF  x86
1C7CC:  MOVLB  0
1C7CE:  CALL   156A
1C7D2:  MOVFF  00,32D
1C7D6:  MOVLB  3
1C7D8:  MOVFF  03,32E
1C7DC:  MOVF   x2E,F
1C7DE:  BNZ   1C7E6
1C7E0:  MOVF   x2D,W
1C7E2:  SUBLW  05
1C7E4:  BC    1C822
1C7E6:  MOVFF  6A,385
1C7EA:  MOVFF  69,384
1C7EE:  CLRF   x87
1C7F0:  MOVLW  46
1C7F2:  MOVWF  x86
1C7F4:  MOVLB  0
1C7F6:  CALL   156A
1C7FA:  MOVFF  00,32D
1C7FE:  MOVLB  3
1C800:  MOVFF  03,32E
1C804:  MOVF   x2E,F
1C806:  BNZ   1C822
1C808:  MOVF   x2D,W
1C80A:  SUBLW  09
1C80C:  BNC   1C822
1C80E:  MOVLB  0
1C810:  MOVF   x7C,F
1C812:  BTFSC  FD8.2
1C814:  BRA    1C81A
1C816:  MOVLB  3
1C818:  BRA    1C822
....................          DAY6to9(); 
1C81A:  CALL   1BDFE
....................       }else if(((PASSED_DAYS%loop_day) >= 10 && UPLINK_SUCCESS == 0) && AUTO_MBP_DONE == 0){             //MBP and download 
1C81E:  BRA    1CB5A
1C820:  MOVLB  3
1C822:  MOVFF  6A,385
1C826:  MOVFF  69,384
1C82A:  CLRF   x87
1C82C:  MOVLW  46
1C82E:  MOVWF  x86
1C830:  MOVLB  0
1C832:  CALL   156A
1C836:  MOVFF  00,32D
1C83A:  MOVLB  3
1C83C:  MOVFF  03,32E
1C840:  MOVF   x2E,F
1C842:  BNZ   1C84A
1C844:  MOVF   x2D,W
1C846:  SUBLW  09
1C848:  BC    1C868
1C84A:  MOVLB  0
1C84C:  MOVF   x7C,F
1C84E:  BTFSC  FD8.2
1C850:  BRA    1C856
1C852:  MOVLB  3
1C854:  BRA    1C868
1C856:  MOVF   x79,F
1C858:  BTFSC  FD8.2
1C85A:  BRA    1C860
1C85C:  MOVLB  3
1C85E:  BRA    1C868
....................          DAY10(); 
1C860:  CALL   1BEE6
....................       }else if(((PASSED_DAYS%loop_day) >= 11 && (PASSED_DAYS%loop_day) <= 14) && UPLINK_SUCCESS == 0){   //MBP and download 
1C864:  BRA    1CB5A
1C866:  MOVLB  3
1C868:  MOVFF  6A,385
1C86C:  MOVFF  69,384
1C870:  CLRF   x87
1C872:  MOVLW  46
1C874:  MOVWF  x86
1C876:  MOVLB  0
1C878:  CALL   156A
1C87C:  MOVFF  00,32D
1C880:  MOVLB  3
1C882:  MOVFF  03,32E
1C886:  MOVF   x2E,F
1C888:  BNZ   1C890
1C88A:  MOVF   x2D,W
1C88C:  SUBLW  0A
1C88E:  BC    1C8CC
1C890:  MOVFF  6A,385
1C894:  MOVFF  69,384
1C898:  CLRF   x87
1C89A:  MOVLW  46
1C89C:  MOVWF  x86
1C89E:  MOVLB  0
1C8A0:  CALL   156A
1C8A4:  MOVFF  00,32D
1C8A8:  MOVLB  3
1C8AA:  MOVFF  03,32E
1C8AE:  MOVF   x2E,F
1C8B0:  BNZ   1C8CC
1C8B2:  MOVF   x2D,W
1C8B4:  SUBLW  0E
1C8B6:  BNC   1C8CC
1C8B8:  MOVLB  0
1C8BA:  MOVF   x7C,F
1C8BC:  BTFSC  FD8.2
1C8BE:  BRA    1C8C4
1C8C0:  MOVLB  3
1C8C2:  BRA    1C8CC
....................          DAY11to14(); 
1C8C4:  CALL   1BFF2
....................       }else if(((PASSED_DAYS%loop_day) >= 15 && UPLINK_SUCCESS == 0) && AUTO_ADCS_DONE == 0){            //ADCS Mission and Download 
1C8C8:  BRA    1CB5A
1C8CA:  MOVLB  3
1C8CC:  MOVFF  6A,385
1C8D0:  MOVFF  69,384
1C8D4:  CLRF   x87
1C8D6:  MOVLW  46
1C8D8:  MOVWF  x86
1C8DA:  MOVLB  0
1C8DC:  CALL   156A
1C8E0:  MOVFF  00,32D
1C8E4:  MOVLB  3
1C8E6:  MOVFF  03,32E
1C8EA:  MOVF   x2E,F
1C8EC:  BNZ   1C8F4
1C8EE:  MOVF   x2D,W
1C8F0:  SUBLW  0E
1C8F2:  BC    1C912
1C8F4:  MOVLB  0
1C8F6:  MOVF   x7C,F
1C8F8:  BTFSC  FD8.2
1C8FA:  BRA    1C900
1C8FC:  MOVLB  3
1C8FE:  BRA    1C912
1C900:  MOVF   x7A,F
1C902:  BTFSC  FD8.2
1C904:  BRA    1C90A
1C906:  MOVLB  3
1C908:  BRA    1C912
....................          DAY15(); 
1C90A:  CALL   1C106
....................       }else if(((PASSED_DAYS%loop_day) >= 16 && (PASSED_DAYS%loop_day) <= 19) && UPLINK_SUCCESS == 0){   //ADCS Download 
1C90E:  BRA    1CB5A
1C910:  MOVLB  3
1C912:  MOVFF  6A,385
1C916:  MOVFF  69,384
1C91A:  CLRF   x87
1C91C:  MOVLW  46
1C91E:  MOVWF  x86
1C920:  MOVLB  0
1C922:  CALL   156A
1C926:  MOVFF  00,32D
1C92A:  MOVLB  3
1C92C:  MOVFF  03,32E
1C930:  MOVF   x2E,F
1C932:  BNZ   1C93A
1C934:  MOVF   x2D,W
1C936:  SUBLW  0F
1C938:  BC    1C974
1C93A:  MOVFF  6A,385
1C93E:  MOVFF  69,384
1C942:  CLRF   x87
1C944:  MOVLW  46
1C946:  MOVWF  x86
1C948:  MOVLB  0
1C94A:  CALL   156A
1C94E:  MOVFF  00,32D
1C952:  MOVLB  3
1C954:  MOVFF  03,32E
1C958:  MOVF   x2E,F
1C95A:  BNZ   1C974
1C95C:  MOVF   x2D,W
1C95E:  SUBLW  13
1C960:  BNC   1C974
1C962:  MOVLB  0
1C964:  MOVF   x7C,F
1C966:  BTFSC  FD8.2
1C968:  BRA    1C96E
1C96A:  MOVLB  3
1C96C:  BRA    1C974
....................          DAY16to19(); 
1C96E:  RCALL  1C184
....................       }else if(((PASSED_DAYS%loop_day) >= 20 && (PASSED_DAYS%loop_day) <= 25) && UPLINK_SUCCESS == 0){   //High sampling sensor collecting mission download 
1C970:  BRA    1CB5A
1C972:  MOVLB  3
1C974:  MOVFF  6A,385
1C978:  MOVFF  69,384
1C97C:  CLRF   x87
1C97E:  MOVLW  46
1C980:  MOVWF  x86
1C982:  MOVLB  0
1C984:  CALL   156A
1C988:  MOVFF  00,32D
1C98C:  MOVLB  3
1C98E:  MOVFF  03,32E
1C992:  MOVF   x2E,F
1C994:  BNZ   1C99C
1C996:  MOVF   x2D,W
1C998:  SUBLW  13
1C99A:  BC    1C9D6
1C99C:  MOVFF  6A,385
1C9A0:  MOVFF  69,384
1C9A4:  CLRF   x87
1C9A6:  MOVLW  46
1C9A8:  MOVWF  x86
1C9AA:  MOVLB  0
1C9AC:  CALL   156A
1C9B0:  MOVFF  00,32D
1C9B4:  MOVLB  3
1C9B6:  MOVFF  03,32E
1C9BA:  MOVF   x2E,F
1C9BC:  BNZ   1C9D6
1C9BE:  MOVF   x2D,W
1C9C0:  SUBLW  19
1C9C2:  BNC   1C9D6
1C9C4:  MOVLB  0
1C9C6:  MOVF   x7C,F
1C9C8:  BTFSC  FD8.2
1C9CA:  BRA    1C9D0
1C9CC:  MOVLB  3
1C9CE:  BRA    1C9D6
....................          DAY20to25(); 
1C9D0:  RCALL  1C23C
....................       }else if(((PASSED_DAYS%loop_day) >= 26 && (PASSED_DAYS%loop_day) <= 46) && UPLINK_SUCCESS == 0){   //CAM Mission Download 
1C9D2:  BRA    1CB5A
1C9D4:  MOVLB  3
1C9D6:  MOVFF  6A,385
1C9DA:  MOVFF  69,384
1C9DE:  CLRF   x87
1C9E0:  MOVLW  46
1C9E2:  MOVWF  x86
1C9E4:  MOVLB  0
1C9E6:  CALL   156A
1C9EA:  MOVFF  00,32D
1C9EE:  MOVLB  3
1C9F0:  MOVFF  03,32E
1C9F4:  MOVF   x2E,F
1C9F6:  BNZ   1C9FE
1C9F8:  MOVF   x2D,W
1C9FA:  SUBLW  19
1C9FC:  BC    1CA38
1C9FE:  MOVFF  6A,385
1CA02:  MOVFF  69,384
1CA06:  CLRF   x87
1CA08:  MOVLW  46
1CA0A:  MOVWF  x86
1CA0C:  MOVLB  0
1CA0E:  CALL   156A
1CA12:  MOVFF  00,32D
1CA16:  MOVLB  3
1CA18:  MOVFF  03,32E
1CA1C:  MOVF   x2E,F
1CA1E:  BNZ   1CA38
1CA20:  MOVF   x2D,W
1CA22:  SUBLW  2E
1CA24:  BNC   1CA38
1CA26:  MOVLB  0
1CA28:  MOVF   x7C,F
1CA2A:  BTFSC  FD8.2
1CA2C:  BRA    1CA32
1CA2E:  MOVLB  3
1CA30:  BRA    1CA38
....................          DAY26to46(); 
1CA32:  RCALL  1C324
....................       }else if(((PASSED_DAYS%loop_day) >= 47 && (PASSED_DAYS%loop_day) <= 52) && UPLINK_SUCCESS == 0){   //ADCS Mission Data Download 
1CA34:  BRA    1CB5A
1CA36:  MOVLB  3
1CA38:  MOVFF  6A,385
1CA3C:  MOVFF  69,384
1CA40:  CLRF   x87
1CA42:  MOVLW  46
1CA44:  MOVWF  x86
1CA46:  MOVLB  0
1CA48:  CALL   156A
1CA4C:  MOVFF  00,32D
1CA50:  MOVLB  3
1CA52:  MOVFF  03,32E
1CA56:  MOVF   x2E,F
1CA58:  BNZ   1CA60
1CA5A:  MOVF   x2D,W
1CA5C:  SUBLW  2E
1CA5E:  BC    1CA9A
1CA60:  MOVFF  6A,385
1CA64:  MOVFF  69,384
1CA68:  CLRF   x87
1CA6A:  MOVLW  46
1CA6C:  MOVWF  x86
1CA6E:  MOVLB  0
1CA70:  CALL   156A
1CA74:  MOVFF  00,32D
1CA78:  MOVLB  3
1CA7A:  MOVFF  03,32E
1CA7E:  MOVF   x2E,F
1CA80:  BNZ   1CA9A
1CA82:  MOVF   x2D,W
1CA84:  SUBLW  34
1CA86:  BNC   1CA9A
1CA88:  MOVLB  0
1CA8A:  MOVF   x7C,F
1CA8C:  BTFSC  FD8.2
1CA8E:  BRA    1CA94
1CA90:  MOVLB  3
1CA92:  BRA    1CA9A
....................          DAY47to52(); 
1CA94:  RCALL  1C40E
....................       }else if(((PASSED_DAYS%loop_day) >= 53 && (PASSED_DAYS%loop_day) <= 59) && UPLINK_SUCCESS == 0){   //Satellite LOG Download 
1CA96:  BRA    1CB5A
1CA98:  MOVLB  3
1CA9A:  MOVFF  6A,385
1CA9E:  MOVFF  69,384
1CAA2:  CLRF   x87
1CAA4:  MOVLW  46
1CAA6:  MOVWF  x86
1CAA8:  MOVLB  0
1CAAA:  CALL   156A
1CAAE:  MOVFF  00,32D
1CAB2:  MOVLB  3
1CAB4:  MOVFF  03,32E
1CAB8:  MOVF   x2E,F
1CABA:  BNZ   1CAC2
1CABC:  MOVF   x2D,W
1CABE:  SUBLW  34
1CAC0:  BC    1CAFC
1CAC2:  MOVFF  6A,385
1CAC6:  MOVFF  69,384
1CACA:  CLRF   x87
1CACC:  MOVLW  46
1CACE:  MOVWF  x86
1CAD0:  MOVLB  0
1CAD2:  CALL   156A
1CAD6:  MOVFF  00,32D
1CADA:  MOVLB  3
1CADC:  MOVFF  03,32E
1CAE0:  MOVF   x2E,F
1CAE2:  BNZ   1CAFC
1CAE4:  MOVF   x2D,W
1CAE6:  SUBLW  3B
1CAE8:  BNC   1CAFC
1CAEA:  MOVLB  0
1CAEC:  MOVF   x7C,F
1CAEE:  BTFSC  FD8.2
1CAF0:  BRA    1CAF6
1CAF2:  MOVLB  3
1CAF4:  BRA    1CAFC
....................          DAY53to59(); 
1CAF6:  RCALL  1C4FA
....................       }else if(((PASSED_DAYS%loop_day) >= 60 && (PASSED_DAYS%loop_day) <= 69) && UPLINK_SUCCESS == 0){   //Normal HK Download 
1CAF8:  BRA    1CB5A
1CAFA:  MOVLB  3
1CAFC:  MOVFF  6A,385
1CB00:  MOVFF  69,384
1CB04:  CLRF   x87
1CB06:  MOVLW  46
1CB08:  MOVWF  x86
1CB0A:  MOVLB  0
1CB0C:  CALL   156A
1CB10:  MOVFF  00,32D
1CB14:  MOVLB  3
1CB16:  MOVFF  03,32E
1CB1A:  MOVF   x2E,F
1CB1C:  BNZ   1CB24
1CB1E:  MOVF   x2D,W
1CB20:  SUBLW  3B
1CB22:  BC    1CB5C
1CB24:  MOVFF  6A,385
1CB28:  MOVFF  69,384
1CB2C:  CLRF   x87
1CB2E:  MOVLW  46
1CB30:  MOVWF  x86
1CB32:  MOVLB  0
1CB34:  CALL   156A
1CB38:  MOVFF  00,32D
1CB3C:  MOVLB  3
1CB3E:  MOVFF  03,32E
1CB42:  MOVF   x2E,F
1CB44:  BNZ   1CB5C
1CB46:  MOVF   x2D,W
1CB48:  SUBLW  45
1CB4A:  BNC   1CB5C
1CB4C:  MOVLB  0
1CB4E:  MOVF   x7C,F
1CB50:  BTFSC  FD8.2
1CB52:  BRA    1CB58
1CB54:  MOVLB  3
1CB56:  BRA    1CB5C
....................          DAY60to69(); 
1CB58:  RCALL  1C5CE
1CB5A:  MOVLB  3
....................       } 
....................    } 
....................    if(BC_ATTEMPT_FLAG == 0)                                                      //at this moment, this flag should be over 1 
1CB5C:  MOVLB  0
1CB5E:  MOVF   x68,F
1CB60:  BNZ   1CB66
....................    { 
....................       BC_ON_30min(); 
1CB62:  CALL   1B9DC
....................    } 
....................     
....................    FAB_FLAG = 0; 
1CB66:  MOVLB  2
1CB68:  CLRF   xFF
1CB6A:  CLRF   xFE
1CB6C:  CLRF   xFD
1CB6E:  CLRF   xFC
....................    return; 
1CB70:  MOVLB  0
1CB72:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001B800 
.................... void PREPARE_AUTOMATICAL_MSN_ADDRESS() 
.................... { 
....................    if((PASSED_DAYS%loop_day) == 0 && UPLINK_SUCCESS == 0){                                               //0th day high samp mission download 
*
1D258:  MOVFF  6A,385
1D25C:  MOVFF  69,384
1D260:  MOVLB  3
1D262:  CLRF   x87
1D264:  MOVLW  46
1D266:  MOVWF  x86
1D268:  MOVLB  0
1D26A:  CALL   156A
1D26E:  MOVFF  00,32D
1D272:  MOVLB  3
1D274:  MOVFF  03,32E
1D278:  MOVF   x2D,F
1D27A:  BNZ   1D2B4
1D27C:  MOVF   x2E,F
1D27E:  BNZ   1D2B4
1D280:  MOVLB  0
1D282:  MOVF   x7C,F
1D284:  BTFSC  FD8.2
1D286:  BRA    1D28C
1D288:  MOVLB  3
1D28A:  BRA    1D2B4
....................       UPDATE_ACK_for_COM(0x66,0x77,SECT*1639,405); 
1D28C:  MOVLW  66
1D28E:  MOVLB  3
1D290:  MOVWF  x31
1D292:  MOVLW  77
1D294:  MOVWF  x32
1D296:  MOVLW  06
1D298:  MOVWF  x36
1D29A:  MOVLW  67
1D29C:  MOVWF  x35
1D29E:  CLRF   x34
1D2A0:  CLRF   x33
1D2A2:  MOVLW  01
1D2A4:  MOVWF  x38
1D2A6:  MOVLW  95
1D2A8:  MOVWF  x37
1D2AA:  MOVLB  0
1D2AC:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 1 && (PASSED_DAYS%loop_day) <= 4) && UPLINK_SUCCESS == 0){        //1-4th day high samp mission download  
1D2B0:  BRA    1D76E
1D2B2:  MOVLB  3
1D2B4:  MOVFF  6A,385
1D2B8:  MOVFF  69,384
1D2BC:  CLRF   x87
1D2BE:  MOVLW  46
1D2C0:  MOVWF  x86
1D2C2:  MOVLB  0
1D2C4:  CALL   156A
1D2C8:  MOVFF  00,32D
1D2CC:  MOVLB  3
1D2CE:  MOVFF  03,32E
1D2D2:  MOVF   x2E,F
1D2D4:  BNZ   1D2DC
1D2D6:  MOVF   x2D,W
1D2D8:  SUBLW  00
1D2DA:  BC    1D316
1D2DC:  MOVFF  6A,385
1D2E0:  MOVFF  69,384
1D2E4:  CLRF   x87
1D2E6:  MOVLW  46
1D2E8:  MOVWF  x86
1D2EA:  MOVLB  0
1D2EC:  CALL   156A
1D2F0:  MOVFF  00,32D
1D2F4:  MOVLB  3
1D2F6:  MOVFF  03,32E
1D2FA:  MOVF   x2E,F
1D2FC:  BNZ   1D316
1D2FE:  MOVF   x2D,W
1D300:  SUBLW  04
1D302:  BNC   1D316
1D304:  MOVLB  0
1D306:  MOVF   x7C,F
1D308:  BTFSC  FD8.2
1D30A:  BRA    1D310
1D30C:  MOVLB  3
1D30E:  BRA    1D316
....................       DAY1to4_ADDRESS(); 
1D310:  RCALL  1CB74
....................    }else if(((PASSED_DAYS%loop_day) >= 5 && UPLINK_SUCCESS == 0) && AUTO_CAM_DONE == 0){                 //5th day (CAM MSN) 
1D312:  BRA    1D76E
1D314:  MOVLB  3
1D316:  MOVFF  6A,385
1D31A:  MOVFF  69,384
1D31E:  CLRF   x87
1D320:  MOVLW  46
1D322:  MOVWF  x86
1D324:  MOVLB  0
1D326:  CALL   156A
1D32A:  MOVFF  00,32D
1D32E:  MOVLB  3
1D330:  MOVFF  03,32E
1D334:  MOVF   x2E,F
1D336:  BNZ   1D33E
1D338:  MOVF   x2D,W
1D33A:  SUBLW  04
1D33C:  BC    1D37A
1D33E:  MOVLB  0
1D340:  MOVF   x7C,F
1D342:  BTFSC  FD8.2
1D344:  BRA    1D34A
1D346:  MOVLB  3
1D348:  BRA    1D37A
1D34A:  MOVF   x78,F
1D34C:  BTFSC  FD8.2
1D34E:  BRA    1D354
1D350:  MOVLB  3
1D352:  BRA    1D37A
....................       UPDATE_ACK_for_COM(0x66,0x77,SECT*8,405);//65536*8; 
1D354:  MOVLW  66
1D356:  MOVLB  3
1D358:  MOVWF  x31
1D35A:  MOVLW  77
1D35C:  MOVWF  x32
1D35E:  CLRF   x36
1D360:  MOVLW  08
1D362:  MOVWF  x35
1D364:  CLRF   x34
1D366:  CLRF   x33
1D368:  MOVLW  01
1D36A:  MOVWF  x38
1D36C:  MOVLW  95
1D36E:  MOVWF  x37
1D370:  MOVLB  0
1D372:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 6 && (PASSED_DAYS%loop_day) <= 9) && UPLINK_SUCCESS == 0){        //download cam data 
1D376:  BRA    1D76E
1D378:  MOVLB  3
1D37A:  MOVFF  6A,385
1D37E:  MOVFF  69,384
1D382:  CLRF   x87
1D384:  MOVLW  46
1D386:  MOVWF  x86
1D388:  MOVLB  0
1D38A:  CALL   156A
1D38E:  MOVFF  00,32D
1D392:  MOVLB  3
1D394:  MOVFF  03,32E
1D398:  MOVF   x2E,F
1D39A:  BNZ   1D3A2
1D39C:  MOVF   x2D,W
1D39E:  SUBLW  05
1D3A0:  BC    1D3DC
1D3A2:  MOVFF  6A,385
1D3A6:  MOVFF  69,384
1D3AA:  CLRF   x87
1D3AC:  MOVLW  46
1D3AE:  MOVWF  x86
1D3B0:  MOVLB  0
1D3B2:  CALL   156A
1D3B6:  MOVFF  00,32D
1D3BA:  MOVLB  3
1D3BC:  MOVFF  03,32E
1D3C0:  MOVF   x2E,F
1D3C2:  BNZ   1D3DC
1D3C4:  MOVF   x2D,W
1D3C6:  SUBLW  09
1D3C8:  BNC   1D3DC
1D3CA:  MOVLB  0
1D3CC:  MOVF   x7C,F
1D3CE:  BTFSC  FD8.2
1D3D0:  BRA    1D3D6
1D3D2:  MOVLB  3
1D3D4:  BRA    1D3DC
....................       DAY6to9_ADDRESS(); 
1D3D6:  RCALL  1CC46
....................    }else if(((PASSED_DAYS%loop_day) >= 10 && UPLINK_SUCCESS == 0) && AUTO_MBP_DONE == 0){                //MBP and download 
1D3D8:  BRA    1D76E
1D3DA:  MOVLB  3
1D3DC:  MOVFF  6A,385
1D3E0:  MOVFF  69,384
1D3E4:  CLRF   x87
1D3E6:  MOVLW  46
1D3E8:  MOVWF  x86
1D3EA:  MOVLB  0
1D3EC:  CALL   156A
1D3F0:  MOVFF  00,32D
1D3F4:  MOVLB  3
1D3F6:  MOVFF  03,32E
1D3FA:  MOVF   x2E,F
1D3FC:  BNZ   1D404
1D3FE:  MOVF   x2D,W
1D400:  SUBLW  09
1D402:  BC    1D45E
1D404:  MOVLB  0
1D406:  MOVF   x7C,F
1D408:  BTFSC  FD8.2
1D40A:  BRA    1D410
1D40C:  MOVLB  3
1D40E:  BRA    1D45E
1D410:  MOVF   x79,F
1D412:  BTFSC  FD8.2
1D414:  BRA    1D41A
1D416:  MOVLB  3
1D418:  BRA    1D45E
....................       UPDATE_ACK_for_COM(0x66,0x77,DC_STATUS_ADDRESS-332,332);//65536*162; 
1D41A:  MOVLW  4C
1D41C:  SUBWF  58,W
1D41E:  MOVLB  3
1D420:  MOVWF  x2D
1D422:  MOVLW  01
1D424:  SUBWFB 59,W
1D426:  MOVWF  x2E
1D428:  MOVLW  00
1D42A:  SUBWFB 5A,W
1D42C:  MOVWF  x2F
1D42E:  MOVLW  00
1D430:  SUBWFB 5B,W
1D432:  MOVWF  x30
1D434:  MOVLW  66
1D436:  MOVWF  x31
1D438:  MOVLW  77
1D43A:  MOVWF  x32
1D43C:  MOVFF  330,336
1D440:  MOVFF  32F,335
1D444:  MOVFF  32E,334
1D448:  MOVFF  32D,333
1D44C:  MOVLW  01
1D44E:  MOVWF  x38
1D450:  MOVLW  4C
1D452:  MOVWF  x37
1D454:  MOVLB  0
1D456:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 11 && (PASSED_DAYS%loop_day) <= 14) && UPLINK_SUCCESS == 0){      //MBP and download 
1D45A:  BRA    1D76E
1D45C:  MOVLB  3
1D45E:  MOVFF  6A,385
1D462:  MOVFF  69,384
1D466:  CLRF   x87
1D468:  MOVLW  46
1D46A:  MOVWF  x86
1D46C:  MOVLB  0
1D46E:  CALL   156A
1D472:  MOVFF  00,32D
1D476:  MOVLB  3
1D478:  MOVFF  03,32E
1D47C:  MOVF   x2E,F
1D47E:  BNZ   1D486
1D480:  MOVF   x2D,W
1D482:  SUBLW  0A
1D484:  BC    1D4C0
1D486:  MOVFF  6A,385
1D48A:  MOVFF  69,384
1D48E:  CLRF   x87
1D490:  MOVLW  46
1D492:  MOVWF  x86
1D494:  MOVLB  0
1D496:  CALL   156A
1D49A:  MOVFF  00,32D
1D49E:  MOVLB  3
1D4A0:  MOVFF  03,32E
1D4A4:  MOVF   x2E,F
1D4A6:  BNZ   1D4C0
1D4A8:  MOVF   x2D,W
1D4AA:  SUBLW  0E
1D4AC:  BNC   1D4C0
1D4AE:  MOVLB  0
1D4B0:  MOVF   x7C,F
1D4B2:  BTFSC  FD8.2
1D4B4:  BRA    1D4BA
1D4B6:  MOVLB  3
1D4B8:  BRA    1D4C0
....................       DAY11to14_ADDRESS(); 
1D4BA:  RCALL  1CD1C
....................    }else if(((PASSED_DAYS%loop_day) >= 15 && UPLINK_SUCCESS == 0) && AUTO_ADCS_DONE == 0){               //ADCS Mission and Download 
1D4BC:  BRA    1D76E
1D4BE:  MOVLB  3
1D4C0:  MOVFF  6A,385
1D4C4:  MOVFF  69,384
1D4C8:  CLRF   x87
1D4CA:  MOVLW  46
1D4CC:  MOVWF  x86
1D4CE:  MOVLB  0
1D4D0:  CALL   156A
1D4D4:  MOVFF  00,32D
1D4D8:  MOVLB  3
1D4DA:  MOVFF  03,32E
1D4DE:  MOVF   x2E,F
1D4E0:  BNZ   1D4E8
1D4E2:  MOVF   x2D,W
1D4E4:  SUBLW  0E
1D4E6:  BC    1D526
1D4E8:  MOVLB  0
1D4EA:  MOVF   x7C,F
1D4EC:  BTFSC  FD8.2
1D4EE:  BRA    1D4F4
1D4F0:  MOVLB  3
1D4F2:  BRA    1D526
1D4F4:  MOVF   x7A,F
1D4F6:  BTFSC  FD8.2
1D4F8:  BRA    1D4FE
1D4FA:  MOVLB  3
1D4FC:  BRA    1D526
....................       UPDATE_ACK_for_COM(0x66, 0x77, SECT*1138, 405);                                                    //ADCS 
1D4FE:  MOVLW  66
1D500:  MOVLB  3
1D502:  MOVWF  x31
1D504:  MOVLW  77
1D506:  MOVWF  x32
1D508:  MOVLW  04
1D50A:  MOVWF  x36
1D50C:  MOVLW  72
1D50E:  MOVWF  x35
1D510:  CLRF   x34
1D512:  CLRF   x33
1D514:  MOVLW  01
1D516:  MOVWF  x38
1D518:  MOVLW  95
1D51A:  MOVWF  x37
1D51C:  MOVLB  0
1D51E:  CALL   1BBA6
....................    }else if(((PASSED_DAYS%loop_day) >= 16 && (PASSED_DAYS%loop_day) <= 19) && UPLINK_SUCCESS == 0){      //ADCS Download 
1D522:  BRA    1D76E
1D524:  MOVLB  3
1D526:  MOVFF  6A,385
1D52A:  MOVFF  69,384
1D52E:  CLRF   x87
1D530:  MOVLW  46
1D532:  MOVWF  x86
1D534:  MOVLB  0
1D536:  CALL   156A
1D53A:  MOVFF  00,32D
1D53E:  MOVLB  3
1D540:  MOVFF  03,32E
1D544:  MOVF   x2E,F
1D546:  BNZ   1D54E
1D548:  MOVF   x2D,W
1D54A:  SUBLW  0F
1D54C:  BC    1D588
1D54E:  MOVFF  6A,385
1D552:  MOVFF  69,384
1D556:  CLRF   x87
1D558:  MOVLW  46
1D55A:  MOVWF  x86
1D55C:  MOVLB  0
1D55E:  CALL   156A
1D562:  MOVFF  00,32D
1D566:  MOVLB  3
1D568:  MOVFF  03,32E
1D56C:  MOVF   x2E,F
1D56E:  BNZ   1D588
1D570:  MOVF   x2D,W
1D572:  SUBLW  13
1D574:  BNC   1D588
1D576:  MOVLB  0
1D578:  MOVF   x7C,F
1D57A:  BTFSC  FD8.2
1D57C:  BRA    1D582
1D57E:  MOVLB  3
1D580:  BRA    1D588
....................       DAY16to19_ADDRESS();                                                                               //ADCS DL 
1D582:  RCALL  1CD96
....................    }else if(((PASSED_DAYS%loop_day) >= 20 && (PASSED_DAYS%loop_day) <= 25) && UPLINK_SUCCESS == 0){      //High sampling sensor collecting mission download 
1D584:  BRA    1D76E
1D586:  MOVLB  3
1D588:  MOVFF  6A,385
1D58C:  MOVFF  69,384
1D590:  CLRF   x87
1D592:  MOVLW  46
1D594:  MOVWF  x86
1D596:  MOVLB  0
1D598:  CALL   156A
1D59C:  MOVFF  00,32D
1D5A0:  MOVLB  3
1D5A2:  MOVFF  03,32E
1D5A6:  MOVF   x2E,F
1D5A8:  BNZ   1D5B0
1D5AA:  MOVF   x2D,W
1D5AC:  SUBLW  13
1D5AE:  BC    1D5EA
1D5B0:  MOVFF  6A,385
1D5B4:  MOVFF  69,384
1D5B8:  CLRF   x87
1D5BA:  MOVLW  46
1D5BC:  MOVWF  x86
1D5BE:  MOVLB  0
1D5C0:  CALL   156A
1D5C4:  MOVFF  00,32D
1D5C8:  MOVLB  3
1D5CA:  MOVFF  03,32E
1D5CE:  MOVF   x2E,F
1D5D0:  BNZ   1D5EA
1D5D2:  MOVF   x2D,W
1D5D4:  SUBLW  19
1D5D6:  BNC   1D5EA
1D5D8:  MOVLB  0
1D5DA:  MOVF   x7C,F
1D5DC:  BTFSC  FD8.2
1D5DE:  BRA    1D5E4
1D5E0:  MOVLB  3
1D5E2:  BRA    1D5EA
....................       DAY20to25_ADDRESS(); 
1D5E4:  RCALL  1CE3C
....................    }else if(((PASSED_DAYS%loop_day) >= 26 && (PASSED_DAYS%loop_day) <= 46) && UPLINK_SUCCESS == 0){      //CAM Mission Download 
1D5E6:  BRA    1D76E
1D5E8:  MOVLB  3
1D5EA:  MOVFF  6A,385
1D5EE:  MOVFF  69,384
1D5F2:  CLRF   x87
1D5F4:  MOVLW  46
1D5F6:  MOVWF  x86
1D5F8:  MOVLB  0
1D5FA:  CALL   156A
1D5FE:  MOVFF  00,32D
1D602:  MOVLB  3
1D604:  MOVFF  03,32E
1D608:  MOVF   x2E,F
1D60A:  BNZ   1D612
1D60C:  MOVF   x2D,W
1D60E:  SUBLW  19
1D610:  BC    1D64C
1D612:  MOVFF  6A,385
1D616:  MOVFF  69,384
1D61A:  CLRF   x87
1D61C:  MOVLW  46
1D61E:  MOVWF  x86
1D620:  MOVLB  0
1D622:  CALL   156A
1D626:  MOVFF  00,32D
1D62A:  MOVLB  3
1D62C:  MOVFF  03,32E
1D630:  MOVF   x2E,F
1D632:  BNZ   1D64C
1D634:  MOVF   x2D,W
1D636:  SUBLW  2E
1D638:  BNC   1D64C
1D63A:  MOVLB  0
1D63C:  MOVF   x7C,F
1D63E:  BTFSC  FD8.2
1D640:  BRA    1D646
1D642:  MOVLB  3
1D644:  BRA    1D64C
....................       DAY26to46_ADDRESS(); 
1D646:  RCALL  1CF12
....................    }else if(((PASSED_DAYS%loop_day) >= 47 && (PASSED_DAYS%loop_day) <= 52) && UPLINK_SUCCESS == 0){      //ADCS Mission Data Download 
1D648:  BRA    1D76E
1D64A:  MOVLB  3
1D64C:  MOVFF  6A,385
1D650:  MOVFF  69,384
1D654:  CLRF   x87
1D656:  MOVLW  46
1D658:  MOVWF  x86
1D65A:  MOVLB  0
1D65C:  CALL   156A
1D660:  MOVFF  00,32D
1D664:  MOVLB  3
1D666:  MOVFF  03,32E
1D66A:  MOVF   x2E,F
1D66C:  BNZ   1D674
1D66E:  MOVF   x2D,W
1D670:  SUBLW  2E
1D672:  BC    1D6AE
1D674:  MOVFF  6A,385
1D678:  MOVFF  69,384
1D67C:  CLRF   x87
1D67E:  MOVLW  46
1D680:  MOVWF  x86
1D682:  MOVLB  0
1D684:  CALL   156A
1D688:  MOVFF  00,32D
1D68C:  MOVLB  3
1D68E:  MOVFF  03,32E
1D692:  MOVF   x2E,F
1D694:  BNZ   1D6AE
1D696:  MOVF   x2D,W
1D698:  SUBLW  34
1D69A:  BNC   1D6AE
1D69C:  MOVLB  0
1D69E:  MOVF   x7C,F
1D6A0:  BTFSC  FD8.2
1D6A2:  BRA    1D6A8
1D6A4:  MOVLB  3
1D6A6:  BRA    1D6AE
....................       DAY47to52_ADDRESS(); 
1D6A8:  RCALL  1CFE8
....................    }else if(((PASSED_DAYS%loop_day) >= 53 && (PASSED_DAYS%loop_day) <= 59) && UPLINK_SUCCESS == 0){      //Satellite LOG Download 
1D6AA:  BRA    1D76E
1D6AC:  MOVLB  3
1D6AE:  MOVFF  6A,385
1D6B2:  MOVFF  69,384
1D6B6:  CLRF   x87
1D6B8:  MOVLW  46
1D6BA:  MOVWF  x86
1D6BC:  MOVLB  0
1D6BE:  CALL   156A
1D6C2:  MOVFF  00,32D
1D6C6:  MOVLB  3
1D6C8:  MOVFF  03,32E
1D6CC:  MOVF   x2E,F
1D6CE:  BNZ   1D6D6
1D6D0:  MOVF   x2D,W
1D6D2:  SUBLW  34
1D6D4:  BC    1D710
1D6D6:  MOVFF  6A,385
1D6DA:  MOVFF  69,384
1D6DE:  CLRF   x87
1D6E0:  MOVLW  46
1D6E2:  MOVWF  x86
1D6E4:  MOVLB  0
1D6E6:  CALL   156A
1D6EA:  MOVFF  00,32D
1D6EE:  MOVLB  3
1D6F0:  MOVFF  03,32E
1D6F4:  MOVF   x2E,F
1D6F6:  BNZ   1D710
1D6F8:  MOVF   x2D,W
1D6FA:  SUBLW  3B
1D6FC:  BNC   1D710
1D6FE:  MOVLB  0
1D700:  MOVF   x7C,F
1D702:  BTFSC  FD8.2
1D704:  BRA    1D70A
1D706:  MOVLB  3
1D708:  BRA    1D710
....................       DAY53to59_ADDRESS(); 
1D70A:  RCALL  1D0C0
....................    }else if(((PASSED_DAYS%loop_day) >= 60 && (PASSED_DAYS%loop_day) <= 69) && UPLINK_SUCCESS == 0){      //Normal HK Download 
1D70C:  BRA    1D76E
1D70E:  MOVLB  3
1D710:  MOVFF  6A,385
1D714:  MOVFF  69,384
1D718:  CLRF   x87
1D71A:  MOVLW  46
1D71C:  MOVWF  x86
1D71E:  MOVLB  0
1D720:  CALL   156A
1D724:  MOVFF  00,32D
1D728:  MOVLB  3
1D72A:  MOVFF  03,32E
1D72E:  MOVF   x2E,F
1D730:  BNZ   1D738
1D732:  MOVF   x2D,W
1D734:  SUBLW  3B
1D736:  BC    1D770
1D738:  MOVFF  6A,385
1D73C:  MOVFF  69,384
1D740:  CLRF   x87
1D742:  MOVLW  46
1D744:  MOVWF  x86
1D746:  MOVLB  0
1D748:  CALL   156A
1D74C:  MOVFF  00,32D
1D750:  MOVLB  3
1D752:  MOVFF  03,32E
1D756:  MOVF   x2E,F
1D758:  BNZ   1D770
1D75A:  MOVF   x2D,W
1D75C:  SUBLW  45
1D75E:  BNC   1D770
1D760:  MOVLB  0
1D762:  MOVF   x7C,F
1D764:  BTFSC  FD8.2
1D766:  BRA    1D76C
1D768:  MOVLB  3
1D76A:  BRA    1D770
....................       DAY60to69_ADDRESS(); 
1D76C:  RCALL  1D180
1D76E:  MOVLB  3
....................    } 
....................    return; 
1D770:  MOVLB  0
1D772:  RETURN 0
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@ AUTO MISSION OPERATION @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #ORG 0x0001B800 
.................... void AUTOMATICAL_MISSION_CHECK() 
.................... { 
....................    int c; 
....................    for(c = 0; c < 6; c++) 
1D774:  MOVLB  3
1D776:  CLRF   x2C
1D778:  MOVF   x2C,W
1D77A:  SUBLW  05
1D77C:  BNC   1D796
....................    { 
....................       COLLECT_RESET_DATA();                                                      //send cmd to get reset data 
1D77E:  MOVLB  0
1D780:  CALL   16AD6
....................       if(reset_bffr[0] == 0x8e) 
1D784:  MOVF   x9E,W
1D786:  SUBLW  8E
1D788:  BNZ   1D790
....................       { 
....................          break; 
1D78A:  MOVLB  3
1D78C:  BRA    1D796
1D78E:  MOVLB  0
....................       } 
1D790:  MOVLB  3
1D792:  INCF   x2C,F
1D794:  BRA    1D778
....................    } 
....................     
....................    for(c = 0; c < 10; c++)                                                       //print reset data 
1D796:  CLRF   x2C
1D798:  MOVF   x2C,W
1D79A:  SUBLW  09
1D79C:  BNC   1D7C8
....................    { 
....................       fprintf(PC,"%x,",reset_bffr[c]); 
1D79E:  CLRF   03
1D7A0:  MOVF   x2C,W
1D7A2:  ADDLW  9E
1D7A4:  MOVWF  FE9
1D7A6:  MOVLW  00
1D7A8:  ADDWFC 03,W
1D7AA:  MOVWF  FEA
1D7AC:  MOVFF  FEF,3A2
1D7B0:  MOVLW  57
1D7B2:  MOVWF  xA3
1D7B4:  MOVLB  0
1D7B6:  CALL   0734
1D7BA:  MOVLW  2C
1D7BC:  BTFSS  F9E.4
1D7BE:  BRA    1D7BC
1D7C0:  MOVWF  FAD
1D7C2:  MOVLB  3
1D7C4:  INCF   x2C,F
1D7C6:  BRA    1D798
....................    } 
....................    fprintf(PC,"%x\r\n",reset_bffr[10]); 
1D7C8:  MOVFF  A8,3A2
1D7CC:  MOVLW  57
1D7CE:  MOVWF  xA3
1D7D0:  MOVLB  0
1D7D2:  CALL   0734
1D7D6:  MOVLW  0D
1D7D8:  BTFSS  F9E.4
1D7DA:  BRA    1D7D8
1D7DC:  MOVWF  FAD
1D7DE:  MOVLW  0A
1D7E0:  BTFSS  F9E.4
1D7E2:  BRA    1D7E0
1D7E4:  MOVWF  FAD
....................     
....................    if(((PASSED_DAYS%loop_day==0)&&(PASSED_DAYS>69))&&UPLINK_SUCCESS == 0)        //after 70 day (one cycle), auto mission again 
1D7E6:  MOVFF  6A,385
1D7EA:  MOVFF  69,384
1D7EE:  MOVLB  3
1D7F0:  CLRF   x87
1D7F2:  MOVLW  46
1D7F4:  MOVWF  x86
1D7F6:  MOVLB  0
1D7F8:  CALL   156A
1D7FC:  MOVFF  00,32D
1D800:  MOVLB  3
1D802:  MOVFF  03,32E
1D806:  MOVF   x2D,F
1D808:  BNZ   1D840
1D80A:  MOVF   x2E,F
1D80C:  BNZ   1D840
1D80E:  MOVLB  0
1D810:  MOVF   x6A,F
1D812:  BNZ   1D820
1D814:  MOVF   x69,W
1D816:  SUBLW  45
1D818:  BTFSS  FD8.0
1D81A:  BRA    1D820
1D81C:  MOVLB  3
1D81E:  BRA    1D840
1D820:  MOVF   x7C,F
1D822:  BTFSC  FD8.2
1D824:  BRA    1D82A
1D826:  MOVLB  3
1D828:  BRA    1D840
....................    { 
....................       FIRST_HSSC_DONE = 0; 
1D82A:  CLRF   x77
....................       AUTO_CAM_DONE = 0; 
1D82C:  CLRF   x78
....................       AUTO_MBP_DONE = 0; 
1D82E:  CLRF   x79
....................       AUTO_ADCS_DONE = 0; 
1D830:  CLRF   x7A
....................       AUTO_MSN_AD_CHANGE();                                                      //update address for a new cycle 
1D832:  CALL   1B812
....................       STORE_FLAG_INFO();                                                         //save flag data to flash memory 
1D836:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //saves the flags in the EEPROM from the address 0x18000 (75%) 
1D83A:  CALL   11C84
1D83E:  MOVLB  3
....................    } 
....................    AUTOMATICAL_MSN_EXE(); 
1D840:  MOVLB  0
1D842:  CALL   1C6BA
....................    PREPARE_AUTOMATICAL_MSN_ADDRESS(); 
1D846:  RCALL  1D258
....................    return; 
1D848:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #include<analyze_command.c> 
.................... #ifndef ANALYZE_COMMAND_C 
.................... #define ANALYZE_COMMAND_C 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_CHECK() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E188:  MOVF   x7C,F
1E18A:  BNZ   1E198
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E18C:  MOVLW  01
1E18E:  MOVWF  x7C
....................       STORE_FLAG_INFO();                                                         //save flag data to flash memory 
1E190:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //save flags on EEPROM from address 0x18000 (75%) 
1E194:  CALL   11C84
....................    } 
....................    return; 
1E198:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_ADCS() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E13C:  MOVF   x7C,F
1E13E:  BNZ   1E150
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E140:  MOVLW  01
1E142:  MOVWF  x7C
....................       AUTO_ADCS_DONE = 1; 
1E144:  MOVWF  x7A
....................       STORE_FLAG_INFO(); 
1E146:  CALL   14000
....................       WRITE_FLAG_to_EEPROM(); 
1E14A:  CALL   11C84
....................    }else if(AUTO_ADCS_DONE == 0){ 
1E14E:  BRA    1E160
1E150:  MOVF   x7A,F
1E152:  BNZ   1E160
....................       AUTO_ADCS_DONE = 1; 
1E154:  MOVLW  01
1E156:  MOVWF  x7A
....................       STORE_FLAG_INFO(); 
1E158:  CALL   14000
....................       WRITE_FLAG_to_EEPROM(); 
1E15C:  CALL   11C84
....................    } 
....................    return; 
1E160:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_HSSC() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E19A:  MOVF   x7C,F
1E19C:  BNZ   1E1AE
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E19E:  MOVLW  01
1E1A0:  MOVWF  x7C
....................       FIRST_HSSC_DONE = 1; 
1E1A2:  MOVWF  x77
....................       STORE_FLAG_INFO(); 
1E1A4:  CALL   14000
....................       WRITE_FLAG_to_EEPROM(); 
1E1A8:  CALL   11C84
....................    }else if(FIRST_HSSC_DONE == 0){ 
1E1AC:  BRA    1E1BE
1E1AE:  MOVF   x77,F
1E1B0:  BNZ   1E1BE
....................       FIRST_HSSC_DONE = 1; 
1E1B2:  MOVLW  01
1E1B4:  MOVWF  x77
....................       STORE_FLAG_INFO(); 
1E1B6:  CALL   14000
....................       WRITE_FLAG_to_EEPROM(); 
1E1BA:  CALL   11C84
....................    } 
....................    return; 
1E1BE:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void UPLINK_SUCCESS_MBP() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
1E162:  MOVF   x7C,F
1E164:  BNZ   1E176
....................    { 
....................       UPLINK_SUCCESS = 1; 
1E166:  MOVLW  01
1E168:  MOVWF  x7C
....................       AUTO_MBP_DONE = 1; 
1E16A:  MOVWF  x79
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
1E16C:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
1E170:  CALL   11C84
....................    }else if(AUTO_MBP_DONE == 0){ 
1E174:  BRA    1E186
1E176:  MOVF   x79,F
1E178:  BNZ   1E186
....................       AUTO_MBP_DONE = 1; 
1E17A:  MOVLW  01
1E17C:  MOVWF  x79
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
1E17E:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
1E182:  CALL   11C84
....................    } 
....................    return; 
1E186:  RETURN 0
.................... } 
....................  
.................... void UPLINK_SUCCESS_CAM() 
.................... { 
....................    if(UPLINK_SUCCESS == 0) 
*
0255C:  MOVF   x7C,F
0255E:  BNZ   2570
....................    { 
....................       AUTO_CAM_DONE = 1; 
02560:  MOVLW  01
02562:  MOVWF  x78
....................       UPLINK_SUCCESS = 1; 
02564:  MOVWF  x7C
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
02566:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
0256A:  CALL   11C84
....................    }else if(AUTO_CAM_DONE == 0){ 
0256E:  BRA    2580
02570:  MOVF   x78,F
02572:  BNZ   2580
....................       AUTO_CAM_DONE = 1; 
02574:  MOVLW  01
02576:  MOVWF  x78
....................       STORE_FLAG_INFO();                                                         //store flag info on flash 
02578:  CALL   14000
....................       WRITE_FLAG_to_EEPROM();                                                    //store flag info on EEPROM 
0257C:  CALL   11C84
....................    } 
....................    return; 
02580:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0000C800 
.................... void EXECUTE_MISSION_from_COM(int8 CMD1,int8 CMD2,int8 CMD3,int8 CMD4,int8 CMD5,int8 CMD6,int8 CMD7) 
.................... { 
....................    if (CMD1 == 0xc0) 
*
0C800:  MOVLB  3
0C802:  MOVF   x2C,W
0C804:  SUBLW  C0
0C806:  BNZ   C842
....................    { 
....................       REPLY_TO_COM(0x66,0); 
0C808:  MOVLW  66
0C80A:  MOVWF  x37
0C80C:  CLRF   x38
0C80E:  MOVLB  0
0C810:  CALL   1D84A
....................       SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data          
0C814:  MOVFF  32C,353
0C818:  MOVLB  3
0C81A:  CLRF   x54
0C81C:  MOVFF  32D,355
0C820:  MOVLB  0
0C822:  CALL   16EE2
....................       UPLINK_SUCCESS_CAM();                                                   //put uplink succes flag in high and store flags 
0C826:  CALL   255C
....................       ACK_for_COM[14] = 0x00;         
0C82A:  MOVLB  1
0C82C:  CLRF   xF1
....................          CAM_TEST_OPERATION(CMD2);                                               //send command to CAM, execute mission and transfer data 
0C82E:  MOVFF  32D,337
0C832:  MOVLB  0
0C834:  CALL   1AD94
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated CAM address 
0C838:  CALL   144C8
....................       } 
0C83C:  GOTO   D1D8
0C840:  MOVLB  3
....................       else if(CMD1 == 0xA0){ 
0C842:  MOVF   x2C,W
0C844:  SUBLW  A0
0C846:  BNZ   C8AC
....................          REPLY_TO_COM(0x66,0); 
0C848:  MOVLW  66
0C84A:  MOVWF  x37
0C84C:  CLRF   x38
0C84E:  MOVLB  0
0C850:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1,CMD2,CMD4); 
0C854:  MOVFF  32C,353
0C858:  MOVFF  32D,354
0C85C:  MOVFF  32F,355
0C860:  CALL   16EE2
....................          unsigned int16 op_duration = (unsigned int16)CMD4*60;          
0C864:  MOVLB  3
0C866:  CLRF   x38
0C868:  MOVFF  32F,337
0C86C:  MOVFF  338,343
0C870:  MOVFF  32F,342
0C874:  CLRF   x45
0C876:  MOVLW  3C
0C878:  MOVWF  x44
0C87A:  MOVLB  0
0C87C:  CALL   253A
0C880:  MOVFF  02,334
0C884:  MOVFF  01,333
....................          UPLINK_SUCCESS_ADCS(); 
0C888:  CALL   1E13C
....................          ACK_for_COM[14] = 0x00;         
0C88C:  MOVLB  1
0C88E:  CLRF   xF1
....................          ADCS_TEST_OPERATION(op_duration,CMD2); 
0C890:  MOVFF  334,381
0C894:  MOVFF  333,380
0C898:  MOVFF  32D,382
0C89C:  MOVLB  0
0C89E:  CALL   127D4
....................          STORE_ADRESS_DATA_TO_FLASH(); 
0C8A2:  CALL   144C8
....................       } 
0C8A6:  GOTO   D1D8
0C8AA:  MOVLB  3
....................       else if(CMD1 ==  0xA1){                                                                 //TLE data reception  
0C8AC:  MOVF   x2C,W
0C8AE:  SUBLW  A1
0C8B0:  BNZ   C8FC
....................          REPLY_TO_COM(0x66,0); 
0C8B2:  MOVLW  66
0C8B4:  MOVWF  x37
0C8B6:  CLRF   x38
0C8B8:  MOVLB  0
0C8BA:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
0C8BE:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
0C8C2:  MOVFF  32C,353
0C8C6:  MOVLB  3
0C8C8:  CLRF   x54
0C8CA:  MOVFF  32D,355
0C8CE:  MOVLB  0
0C8D0:  CALL   16EE2
....................          ACK_for_COM[14] = 0x00; 
0C8D4:  MOVLB  1
0C8D6:  CLRF   xF1
....................          ADCS_TLE_JOIN(CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                           //Receive, assemble and save TLE data in flash 
0C8D8:  MOVFF  32D,337
0C8DC:  MOVFF  32E,338
0C8E0:  MOVFF  32F,339
0C8E4:  MOVFF  330,33A
0C8E8:  MOVFF  331,33B
0C8EC:  MOVFF  332,33C
0C8F0:  MOVLB  0
0C8F2:  CALL   1B0DC
....................       } 
0C8F6:  GOTO   D1D8
0C8FA:  MOVLB  3
....................       else if(CMD1 ==  0xA2){                                                                 //TLE data reception  
0C8FC:  MOVF   x2C,W
0C8FE:  SUBLW  A2
0C900:  BNZ   C934
....................          REPLY_TO_COM(0x66,0); 
0C902:  MOVLW  66
0C904:  MOVWF  x37
0C906:  CLRF   x38
0C908:  MOVLB  0
0C90A:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
0C90E:  CALL   1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
0C912:  MOVFF  32C,353
0C916:  MOVLB  3
0C918:  CLRF   x54
0C91A:  MOVFF  32D,355
0C91E:  MOVLB  0
0C920:  CALL   16EE2
....................          ACK_for_COM[14] = 0x00; 
0C924:  MOVLB  1
0C926:  CLRF   xF1
....................          ADCS_TLE_TRANSFER();                                                    //TRANSFER TLE data to ADCS 
0C928:  MOVLB  0
0C92A:  CALL   136C4
....................       }     
0C92E:  GOTO   D1D8
0C932:  MOVLB  3
....................       else if(CMD1 ==  0xD0){                                                                 //transfer data from Mission BOSS 
0C934:  MOVF   x2C,W
0C936:  SUBLW  D0
0C938:  BNZ   C998
....................          REPLY_TO_COM(0x66,0); 
0C93A:  MOVLW  66
0C93C:  MOVWF  x37
0C93E:  CLRF   x38
0C940:  MOVLB  0
0C942:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
0C946:  MOVFF  32C,353
0C94A:  MOVLB  3
0C94C:  CLRF   x54
0C94E:  MOVFF  32D,355
0C952:  MOVLB  0
0C954:  CALL   16EE2
....................          UPLINK_SUCCESS_MBP();                                                   //put uplink succes flag in high and store flags 
0C958:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;          
0C95C:  MOVLB  1
0C95E:  CLRF   xF1
....................          DATACOLLECTION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);      //Turn ON MBP, get data, store in flash 
0C960:  MOVFF  32C,337
0C964:  MOVFF  32D,338
0C968:  MOVFF  32E,339
0C96C:  MOVFF  32F,33A
0C970:  MOVFF  330,33B
0C974:  MOVFF  331,33C
0C978:  MOVFF  332,33D
0C97C:  MOVLB  0
0C97E:  CALL   138E0
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0C982:  CALL   144C8
....................          delay_ms(10); 
0C986:  MOVLW  0A
0C988:  MOVLB  3
0C98A:  MOVWF  x98
0C98C:  MOVLB  0
0C98E:  CALL   0526
....................       }  
0C992:  GOTO   D1D8
0C996:  MOVLB  3
....................       else if(CMD1 ==  0xD1){                                                                 //PSC Mission 
0C998:  MOVF   x2C,W
0C99A:  SUBLW  D1
0C99C:  BNZ   C9FA
....................          REPLY_TO_COM(0x66,0); 
0C99E:  MOVLW  66
0C9A0:  MOVWF  x37
0C9A2:  CLRF   x38
0C9A4:  MOVLB  0
0C9A6:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0C9AA:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
0C9AE:  MOVLB  1
0C9B0:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0C9B2:  MOVFF  32C,353
0C9B6:  MOVLB  3
0C9B8:  CLRF   x54
0C9BA:  MOVFF  32D,355
0C9BE:  MOVLB  0
0C9C0:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0C9C4:  MOVFF  32C,337
0C9C8:  MOVFF  32D,338
0C9CC:  MOVFF  32E,339
0C9D0:  MOVFF  32F,33A
0C9D4:  MOVFF  330,33B
0C9D8:  MOVFF  331,33C
0C9DC:  MOVFF  332,33D
0C9E0:  CALL   13A8A
....................          delay_ms(10); 
0C9E4:  MOVLW  0A
0C9E6:  MOVLB  3
0C9E8:  MOVWF  x98
0C9EA:  MOVLB  0
0C9EC:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0C9F0:  CALL   144C8
....................       } 
0C9F4:  GOTO   D1D8
0C9F8:  MOVLB  3
....................       else if(CMD1 ==  0xD2){                                                                 //TMCR Mission 
0C9FA:  MOVF   x2C,W
0C9FC:  SUBLW  D2
0C9FE:  BNZ   CA5C
....................          REPLY_TO_COM(0x66,0); 
0CA00:  MOVLW  66
0CA02:  MOVWF  x37
0CA04:  CLRF   x38
0CA06:  MOVLB  0
0CA08:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CA0C:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
0CA10:  MOVLB  1
0CA12:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CA14:  MOVFF  32C,353
0CA18:  MOVLB  3
0CA1A:  CLRF   x54
0CA1C:  MOVFF  32D,355
0CA20:  MOVLB  0
0CA22:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CA26:  MOVFF  32C,337
0CA2A:  MOVFF  32D,338
0CA2E:  MOVFF  32E,339
0CA32:  MOVFF  32F,33A
0CA36:  MOVFF  330,33B
0CA3A:  MOVFF  331,33C
0CA3E:  MOVFF  332,33D
0CA42:  CALL   13A8A
....................          delay_ms(10); 
0CA46:  MOVLW  0A
0CA48:  MOVLB  3
0CA4A:  MOVWF  x98
0CA4C:  MOVLB  0
0CA4E:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CA52:  CALL   144C8
....................       } 
0CA56:  GOTO   D1D8
0CA5A:  MOVLB  3
....................       else if(CMD1 ==  0xD3){                                                                 //NTU Mission 
0CA5C:  MOVF   x2C,W
0CA5E:  SUBLW  D3
0CA60:  BNZ   CABC
....................          REPLY_TO_COM(0x66,0); 
0CA62:  MOVLW  66
0CA64:  MOVWF  x37
0CA66:  CLRF   x38
0CA68:  MOVLB  0
0CA6A:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CA6E:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
0CA72:  MOVLB  1
0CA74:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CA76:  MOVFF  32C,353
0CA7A:  MOVLB  3
0CA7C:  CLRF   x54
0CA7E:  MOVFF  32D,355
0CA82:  MOVLB  0
0CA84:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CA88:  MOVFF  32C,337
0CA8C:  MOVFF  32D,338
0CA90:  MOVFF  32E,339
0CA94:  MOVFF  32F,33A
0CA98:  MOVFF  330,33B
0CA9C:  MOVFF  331,33C
0CAA0:  MOVFF  332,33D
0CAA4:  CALL   13A8A
....................          delay_ms(10); 
0CAA8:  MOVLW  0A
0CAAA:  MOVLB  3
0CAAC:  MOVWF  x98
0CAAE:  MOVLB  0
0CAB0:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CAB4:  CALL   144C8
....................       } 
0CAB8:  BRA    D1D8
0CABA:  MOVLB  3
....................       else if(CMD1 ==  0xD4){                                                                 //SF_WARD Mission 
0CABC:  MOVF   x2C,W
0CABE:  SUBLW  D4
0CAC0:  BNZ   CB1C
....................          REPLY_TO_COM(0x66,0); 
0CAC2:  MOVLW  66
0CAC4:  MOVWF  x37
0CAC6:  CLRF   x38
0CAC8:  MOVLB  0
0CACA:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CACE:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
0CAD2:  MOVLB  1
0CAD4:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CAD6:  MOVFF  32C,353
0CADA:  MOVLB  3
0CADC:  CLRF   x54
0CADE:  MOVFF  32D,355
0CAE2:  MOVLB  0
0CAE4:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CAE8:  MOVFF  32C,337
0CAEC:  MOVFF  32D,338
0CAF0:  MOVFF  32E,339
0CAF4:  MOVFF  32F,33A
0CAF8:  MOVFF  330,33B
0CAFC:  MOVFF  331,33C
0CB00:  MOVFF  332,33D
0CB04:  CALL   13A8A
....................          delay_ms(10); 
0CB08:  MOVLW  0A
0CB0A:  MOVLB  3
0CB0C:  MOVWF  x98
0CB0E:  MOVLB  0
0CB10:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CB14:  CALL   144C8
....................       } 
0CB18:  BRA    D1D8
0CB1A:  MOVLB  3
....................       else if(CMD1 ==  0xD5){                                                                 //HNT Mission 
0CB1C:  MOVF   x2C,W
0CB1E:  SUBLW  D5
0CB20:  BNZ   CB7C
....................          REPLY_TO_COM(0x66,0); 
0CB22:  MOVLW  66
0CB24:  MOVWF  x37
0CB26:  CLRF   x38
0CB28:  MOVLB  0
0CB2A:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CB2E:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
0CB32:  MOVLB  1
0CB34:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CB36:  MOVFF  32C,353
0CB3A:  MOVLB  3
0CB3C:  CLRF   x54
0CB3E:  MOVFF  32D,355
0CB42:  MOVLB  0
0CB44:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CB48:  MOVFF  32C,337
0CB4C:  MOVFF  32D,338
0CB50:  MOVFF  32E,339
0CB54:  MOVFF  32F,33A
0CB58:  MOVFF  330,33B
0CB5C:  MOVFF  331,33C
0CB60:  MOVFF  332,33D
0CB64:  CALL   13A8A
....................          delay_ms(10); 
0CB68:  MOVLW  0A
0CB6A:  MOVLB  3
0CB6C:  MOVWF  x98
0CB6E:  MOVLB  0
0CB70:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CB74:  CALL   144C8
....................       } 
0CB78:  BRA    D1D8
0CB7A:  MOVLB  3
....................       else if(CMD1 ==  0xD6){                                                                 //APRS_DP Mission 
0CB7C:  MOVF   x2C,W
0CB7E:  SUBLW  D6
0CB80:  BNZ   CBDC
....................          REPLY_TO_COM(0x66,0); 
0CB82:  MOVLW  66
0CB84:  MOVWF  x37
0CB86:  CLRF   x38
0CB88:  MOVLB  0
0CB8A:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CB8E:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
0CB92:  MOVLB  1
0CB94:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CB96:  MOVFF  32C,353
0CB9A:  MOVLB  3
0CB9C:  CLRF   x54
0CB9E:  MOVFF  32D,355
0CBA2:  MOVLB  0
0CBA4:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CBA8:  MOVFF  32C,337
0CBAC:  MOVFF  32D,338
0CBB0:  MOVFF  32E,339
0CBB4:  MOVFF  32F,33A
0CBB8:  MOVFF  330,33B
0CBBC:  MOVFF  331,33C
0CBC0:  MOVFF  332,33D
0CBC4:  CALL   13A8A
....................          delay_ms(10); 
0CBC8:  MOVLW  0A
0CBCA:  MOVLB  3
0CBCC:  MOVWF  x98
0CBCE:  MOVLB  0
0CBD0:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CBD4:  CALL   144C8
....................       } 
0CBD8:  BRA    D1D8
0CBDA:  MOVLB  3
....................       else if(CMD1 ==  0xD7){                                                                 //dummy data for MBP 
0CBDC:  MOVF   x2C,W
0CBDE:  SUBLW  D7
0CBE0:  BNZ   CC3C
....................          REPLY_TO_COM(0x66,0); 
0CBE2:  MOVLW  66
0CBE4:  MOVWF  x37
0CBE6:  CLRF   x38
0CBE8:  MOVLB  0
0CBEA:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CBEE:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;      
0CBF2:  MOVLB  1
0CBF4:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CBF6:  MOVFF  32C,353
0CBFA:  MOVLB  3
0CBFC:  CLRF   x54
0CBFE:  MOVFF  32D,355
0CC02:  MOVLB  0
0CC04:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CC08:  MOVFF  32C,337
0CC0C:  MOVFF  32D,338
0CC10:  MOVFF  32E,339
0CC14:  MOVFF  32F,33A
0CC18:  MOVFF  330,33B
0CC1C:  MOVFF  331,33C
0CC20:  MOVFF  332,33D
0CC24:  CALL   13A8A
....................          delay_ms(10); 
0CC28:  MOVLW  0A
0CC2A:  MOVLB  3
0CC2C:  MOVWF  x98
0CC2E:  MOVLB  0
0CC30:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CC34:  CALL   144C8
....................       } 
0CC38:  BRA    D1D8
0CC3A:  MOVLB  3
....................       else if(CMD1 ==  0xDF){                                                                 //dummy data for MBP 
0CC3C:  MOVF   x2C,W
0CC3E:  SUBLW  DF
0CC40:  BNZ   CC9C
....................          REPLY_TO_COM(0x66,0); 
0CC42:  MOVLW  66
0CC44:  MOVWF  x37
0CC46:  CLRF   x38
0CC48:  MOVLB  0
0CC4A:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
0CC4E:  CALL   1E162
....................          ACK_for_COM[14] = 0x00;       
0CC52:  MOVLB  1
0CC54:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
0CC56:  MOVFF  32C,353
0CC5A:  MOVLB  3
0CC5C:  CLRF   x54
0CC5E:  MOVFF  32D,355
0CC62:  MOVLB  0
0CC64:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
0CC68:  MOVFF  32C,337
0CC6C:  MOVFF  32D,338
0CC70:  MOVFF  32E,339
0CC74:  MOVFF  32F,33A
0CC78:  MOVFF  330,33B
0CC7C:  MOVFF  331,33C
0CC80:  MOVFF  332,33D
0CC84:  CALL   13A8A
....................          delay_ms(10); 
0CC88:  MOVLW  0A
0CC8A:  MOVLB  3
0CC8C:  MOVWF  x98
0CC8E:  MOVLB  0
0CC90:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
0CC94:  CALL   144C8
....................       } 
0CC98:  BRA    D1D8
0CC9A:  MOVLB  3
....................       else if(CMD1 ==  0xaa){ 
0CC9C:  MOVF   x2C,W
0CC9E:  SUBLW  AA
0CCA0:  BNZ   CCDA
....................          REPLY_TO_COM(0x66,0); 
0CCA2:  MOVLW  66
0CCA4:  MOVWF  x37
0CCA6:  CLRF   x38
0CCA8:  MOVLB  0
0CCAA:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
0CCAE:  MOVFF  32C,353
0CCB2:  MOVLB  3
0CCB4:  CLRF   x54
0CCB6:  MOVFF  32D,355
0CCBA:  MOVLB  0
0CCBC:  CALL   16EE2
....................          STORE_ADRESS_DATA_TO_FLASH();          
0CCC0:  CALL   144C8
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CCC4:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0CCC8:  MOVLB  1
0CCCA:  CLRF   xF1
....................          STORE_FLAG_INFO();                                                      //store flag info on flash 
0CCCC:  MOVLB  0
0CCCE:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //store flag info on EEPROM 
0CCD2:  CALL   11C84
....................       } 
0CCD6:  BRA    D1D8
0CCD8:  MOVLB  3
....................       else if(CMD1 ==  0x22){ 
0CCDA:  MOVF   x2C,W
0CCDC:  SUBLW  22
0CCDE:  BNZ   CD12
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CCE0:  MOVLB  0
0CCE2:  CALL   1E188
....................          ACK_for_COM[14] = 0x00; 
0CCE6:  MOVLB  1
0CCE8:  CLRF   xF1
....................          REPLY_TO_COM(0x66,0);                                                   //ACK_for_COM[12] = 0x66 ACK_for_COM[13] = 0          
0CCEA:  MOVLW  66
0CCEC:  MOVLB  3
0CCEE:  MOVWF  x37
0CCF0:  CLRF   x38
0CCF2:  MOVLB  0
0CCF4:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data, cmd1 and cmd2 as sat log         
0CCF8:  MOVFF  32C,353
0CCFC:  MOVLB  3
0CCFE:  CLRF   x54
0CD00:  MOVFF  32D,355
0CD04:  MOVLB  0
0CD06:  CALL   16EE2
....................          SEND_CMD_FOR_RESET_SATELLITE();                                         //save flag data, address data and RSV table in flash, send cmd for sat reset 
0CD0A:  CALL   16B20
....................       } 
0CD0E:  BRA    D1D8
0CD10:  MOVLB  3
....................       else if(CMD1 ==  0xb0){ 
0CD12:  MOVF   x2C,W
0CD14:  SUBLW  B0
0CD16:  BNZ   CD42
....................          REPLY_TO_COM(0x66,0); 
0CD18:  MOVLW  66
0CD1A:  MOVWF  x37
0CD1C:  CLRF   x38
0CD1E:  MOVLB  0
0CD20:  CALL   1D84A
....................          CLEAR_BC_FLAG();                                                        //BC_ATTEMPT_FLAG = 0        
0CD24:  CALL   1B3D8
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CD28:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
0CD2C:  MOVLB  1
0CD2E:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0CD30:  MOVLB  0
0CD32:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
0CD36:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
0CD3A:  CALL   11C84
....................       } 
0CD3E:  BRA    D1D8
0CD40:  MOVLB  3
....................       else if(CMD1 ==  0xb1){ 
0CD42:  MOVF   x2C,W
0CD44:  SUBLW  B1
0CD46:  BNZ   CD72
....................          REPLY_TO_COM(0x66,0); 
0CD48:  MOVLW  66
0CD4A:  MOVWF  x37
0CD4C:  CLRF   x38
0CD4E:  MOVLB  0
0CD50:  CALL   1D84A
....................          MAKE_BC_FLAG_1();                                                       //BC_ATTEMPT_FLAG = 1          
0CD54:  CALL   1B3EC
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CD58:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
0CD5C:  MOVLB  1
0CD5E:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0CD60:  MOVLB  0
0CD62:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
0CD66:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
0CD6A:  CALL   11C84
....................       } 
0CD6E:  BRA    D1D8
0CD70:  MOVLB  3
....................       else if(CMD1 ==  0xb2){ 
0CD72:  MOVF   x2C,W
0CD74:  SUBLW  B2
0CD76:  BNZ   CDA2
....................          REPLY_TO_COM(0x66,0); 
0CD78:  MOVLW  66
0CD7A:  MOVWF  x37
0CD7C:  CLRF   x38
0CD7E:  MOVLB  0
0CD80:  CALL   1D84A
....................          MAKE_BC_FLAG_2();                                                       //BC_ATTEMPT_FLAG = 2          
0CD84:  CALL   1B402
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CD88:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0CD8C:  MOVLB  1
0CD8E:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0CD90:  MOVLB  0
0CD92:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
0CD96:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
0CD9A:  CALL   11C84
....................       } 
0CD9E:  BRA    D1D8
0CDA0:  MOVLB  3
....................       else if(CMD1 ==  0xb3){ 
0CDA2:  MOVF   x2C,W
0CDA4:  SUBLW  B3
0CDA6:  BNZ   CDD2
....................          REPLY_TO_COM(0x66,0); 
0CDA8:  MOVLW  66
0CDAA:  MOVWF  x37
0CDAC:  CLRF   x38
0CDAE:  MOVLB  0
0CDB0:  CALL   1D84A
....................          MAKE_BC_FLAG_3();                                                       //BC_ATTEMPT_FLAG = 3         
0CDB4:  CALL   1B418
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CDB8:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0CDBC:  MOVLB  1
0CDBE:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0CDC0:  MOVLB  0
0CDC2:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
0CDC6:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
0CDCA:  CALL   11C84
....................       } 
0CDCE:  BRA    D1D8
0CDD0:  MOVLB  3
....................       else if(CMD1 ==  0xb4){ 
0CDD2:  MOVF   x2C,W
0CDD4:  SUBLW  B4
0CDD6:  BNZ   CE02
....................          REPLY_TO_COM(0x66,0); 
0CDD8:  MOVLW  66
0CDDA:  MOVWF  x37
0CDDC:  CLRF   x38
0CDDE:  MOVLB  0
0CDE0:  CALL   1D84A
....................          MAKE_BC_FLAG_4();                                                       //BC_ATTEMPT_FLAG = 4          
0CDE4:  CALL   1B42E
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CDE8:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
0CDEC:  MOVLB  1
0CDEE:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
0CDF0:  MOVLB  0
0CDF2:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
0CDF6:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
0CDFA:  CALL   11C84
....................       } 
0CDFE:  BRA    D1D8
0CE00:  MOVLB  3
....................       else if(CMD1 ==  0x4b){ 
0CE02:  MOVF   x2C,W
0CE04:  SUBLW  4B
0CE06:  BNZ   CE36
....................          REPLY_TO_COM(0x66,0); 
0CE08:  MOVLW  66
0CE0A:  MOVWF  x37
0CE0C:  CLRF   x38
0CE0E:  MOVLB  0
0CE10:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CE14:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0CE18:  MOVLB  1
0CE1A:  CLRF   xF1
....................          Count_Kill_Flag();                                                      //Enable if Kill_COUNTER > 4 
0CE1C:  MOVLB  0
0CE1E:  CALL   1B444
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
0CE22:  MOVFF  32C,353
0CE26:  MOVFF  31A,354
0CE2A:  MOVFF  32D,355
0CE2E:  CALL   16EE2
....................       } 
0CE32:  BRA    D1D8
0CE34:  MOVLB  3
....................       else if(CMD1 ==  0xbb){ 
0CE36:  MOVF   x2C,W
0CE38:  SUBLW  BB
0CE3A:  BNZ   CE6A
....................          REPLY_TO_COM(0x66,0); 
0CE3C:  MOVLW  66
0CE3E:  MOVWF  x37
0CE40:  CLRF   x38
0CE42:  MOVLB  0
0CE44:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
0CE48:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0CE4C:  MOVLB  1
0CE4E:  CLRF   xF1
....................          Disable_Kill();                                                         //Kill Switch OFF 
0CE50:  MOVLB  0
0CE52:  CALL   1B498
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
0CE56:  MOVFF  32C,353
0CE5A:  MOVFF  31A,354
0CE5E:  MOVFF  32D,355
0CE62:  CALL   16EE2
....................       } 
0CE66:  BRA    D1D8
0CE68:  MOVLB  3
....................       else if(CMD1 ==  0xfa){ 
0CE6A:  MOVF   x2C,W
0CE6C:  SUBLW  FA
0CE6E:  BNZ   CEEA
....................          REPLY_TO_COM(0x66,0); 
0CE70:  MOVLW  66
0CE72:  MOVWF  x37
0CE74:  CLRF   x38
0CE76:  MOVLB  0
0CE78:  CALL   1D84A
....................          UPLINK_SUCCESS_HSSC();                                                  //High Sampling Sensor Collect mission 
0CE7C:  CALL   1E19A
....................          ACK_for_COM[14] = 0x00;       
0CE80:  MOVLB  1
0CE82:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);          
0CE84:  MOVFF  32C,353
0CE88:  MOVLB  3
0CE8A:  CLRF   x54
0CE8C:  MOVFF  32D,355
0CE90:  MOVLB  0
0CE92:  CALL   16EE2
....................          unsigned int16 duration = (unsigned int16)CMD2*12;                      //CMD2 is operation time(min), maxima cantidad de lecturas en 2 horas = 1440 
0CE96:  MOVLB  3
0CE98:  CLRF   x38
0CE9A:  MOVFF  32D,337
0CE9E:  MOVFF  338,343
0CEA2:  MOVFF  32D,342
0CEA6:  CLRF   x45
0CEA8:  MOVLW  0C
0CEAA:  MOVWF  x44
0CEAC:  MOVLB  0
0CEAE:  CALL   253A
0CEB2:  MOVFF  02,336
0CEB6:  MOVFF  01,335
....................          if(duration > 1440) 
0CEBA:  MOVLB  3
0CEBC:  MOVF   x36,W
0CEBE:  SUBLW  04
0CEC0:  BC    CED4
0CEC2:  XORLW  FF
0CEC4:  BNZ   CECC
0CEC6:  MOVF   x35,W
0CEC8:  SUBLW  A0
0CECA:  BC    CED4
....................          { 
....................             duration = 1440;                                                     // 12 readings in 1 min, every 5 seconds 
0CECC:  MOVLW  05
0CECE:  MOVWF  x36
0CED0:  MOVLW  A0
0CED2:  MOVWF  x35
....................       } 
....................          HIGHSAMP_SENSOR_COLLECTION(duration);                                   //duration is how many times will be executed 
0CED4:  MOVFF  336,338
0CED8:  MOVFF  335,337
0CEDC:  MOVLB  0
0CEDE:  CALL   1BAB6
....................          STORE_ADRESS_DATA_TO_FLASH(); 
0CEE2:  CALL   144C8
....................       } 
0CEE6:  BRA    D1D8
0CEE8:  MOVLB  3
....................       else if(CMD1 ==  0x59){ 
0CEEA:  MOVF   x2C,W
0CEEC:  SUBLW  59
0CEEE:  BNZ   CF08
....................          REPLY_TO_COM(0x66,0);                                                   //send ACK to COM 
0CEF0:  MOVLW  66
0CEF2:  MOVWF  x37
0CEF4:  CLRF   x38
0CEF6:  MOVLB  0
0CEF8:  CALL   1D84A
....................          GIVE_ACCESS_SCF_Nsec(CMD2); 
0CEFC:  MOVFF  32D,337
0CF00:  CALL   1B4E4
....................       } 
0CF04:  BRA    D1D8
0CF06:  MOVLB  3
....................       else if(CMD1 ==  0xee){ 
0CF08:  MOVF   x2C,W
0CF0A:  SUBLW  EE
0CF0C:  BNZ   CF20
....................          UPLINK_SUCCESS_CHECK(); 
0CF0E:  MOVLB  0
0CF10:  CALL   1E188
....................          ERASE_EEPROM_INFO();                                                    //erase 512byte(from 0x18000 to 0x181ff) 
0CF14:  CALL   13C2E
....................          MEMORY_ERASE();                                                         //erase OF, SCF, SMF flash memories 
0CF18:  CALL   15B08
....................       } 
0CF1C:  BRA    D1D8
0CF1E:  MOVLB  3
....................       else if(CMD1 ==  0x88){ 
0CF20:  MOVF   x2C,W
0CF22:  SUBLW  88
0CF24:  BNZ   CF30
....................          CURRENT_FLAG_STATUS();                                                  //Print on PC port current flag status 
0CF26:  MOVLB  0
0CF28:  CALL   12A12
....................       } 
0CF2C:  BRA    D1D8
0CF2E:  MOVLB  3
....................       else if(CMD1 ==  0x9f){ 
0CF30:  MOVF   x2C,W
0CF32:  SUBLW  9F
0CF34:  BNZ   CF40
....................          Disp_RSV();                                                             //show the reserve status (reserve command and reserve table) 
0CF36:  MOVLB  0
0CF38:  CALL   1723A
....................       } 
0CF3C:  BRA    D1D8
0CF3E:  MOVLB  3
....................       else if(CMD1 ==  0x50){ 
0CF40:  MOVF   x2C,W
0CF42:  SUBLW  50
0CF44:  BNZ   CF5C
....................          if(UPLINK_SUCCESS == 0){ACK_for_COM[14]=0x77;} 
0CF46:  MOVLB  0
0CF48:  MOVF   x7C,F
0CF4A:  BNZ   CF54
0CF4C:  MOVLW  77
0CF4E:  MOVLB  1
0CF50:  MOVWF  xF1
0CF52:  MOVLB  0
....................          CW_RESPOND();                                                           //carga el array ACK_for_COM[] con los datos del CW 
0CF54:  CALL   1E024
....................       } 
0CF58:  BRA    D1D8
0CF5A:  MOVLB  3
....................       else if(CMD1 ==  0xe0){ 
0CF5C:  MOVF   x2C,W
0CF5E:  SUBLW  E0
0CF60:  BNZ   CF90
....................          REPLY_TO_COM(0x66,0); 
0CF62:  MOVLW  66
0CF64:  MOVWF  x37
0CF66:  CLRF   x38
0CF68:  MOVLB  0
0CF6A:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0CF6E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0CF72:  MOVLB  1
0CF74:  CLRF   xF1
....................          REFRESH_SECTOR_OF(CMD2,CMD3,CMD4,CMD5);                                 //Erase 1 sector of OBC flash, also this function contains saving log 
0CF76:  MOVFF  32D,347
0CF7A:  MOVFF  32E,348
0CF7E:  MOVFF  32F,349
0CF82:  MOVFF  330,34A
0CF86:  MOVLB  0
0CF88:  CALL   170D2
....................       } 
0CF8C:  BRA    D1D8
0CF8E:  MOVLB  3
....................       else if(CMD1 ==  0xe1){ 
0CF90:  MOVF   x2C,W
0CF92:  SUBLW  E1
0CF94:  BNZ   CFC4
....................          REPLY_TO_COM(0x66,0); 
0CF96:  MOVLW  66
0CF98:  MOVWF  x37
0CF9A:  CLRF   x38
0CF9C:  MOVLB  0
0CF9E:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0CFA2:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0CFA6:  MOVLB  1
0CFA8:  CLRF   xF1
....................          REFRESH_SECTOR_SCF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of COM flash, also this function contains saving log 
0CFAA:  MOVFF  32D,347
0CFAE:  MOVFF  32E,348
0CFB2:  MOVFF  32F,349
0CFB6:  MOVFF  330,34A
0CFBA:  MOVLB  0
0CFBC:  CALL   17182
....................       } 
0CFC0:  BRA    D1D8
0CFC2:  MOVLB  3
....................       else if(CMD1 ==  0xe2){ 
0CFC4:  MOVF   x2C,W
0CFC6:  SUBLW  E2
0CFC8:  BNZ   CFF8
....................          REPLY_TO_COM(0x66,0); 
0CFCA:  MOVLW  66
0CFCC:  MOVWF  x37
0CFCE:  CLRF   x38
0CFD0:  MOVLB  0
0CFD2:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0CFD6:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;         
0CFDA:  MOVLB  1
0CFDC:  CLRF   xF1
....................          REFRESH_SECTOR_SMF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of MISION flash, also this function contains saving log 
0CFDE:  MOVFF  32D,347
0CFE2:  MOVFF  32E,348
0CFE6:  MOVFF  32F,349
0CFEA:  MOVFF  330,34A
0CFEE:  MOVLB  0
0CFF0:  CALL   1701E
....................       } 
0CFF4:  BRA    D1D8
0CFF6:  MOVLB  3
....................       else if(CMD1 ==  0x12){ 
0CFF8:  MOVF   x2C,W
0CFFA:  SUBLW  12
0CFFC:  BNZ   D02C
....................          REPLY_TO_COM(0x66,0); 
0CFFE:  MOVLW  66
0D000:  MOVWF  x37
0D002:  CLRF   x38
0D004:  MOVLB  0
0D006:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D00A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0D00E:  MOVLB  1
0D010:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SCF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
0D012:  MOVFF  32D,337
0D016:  MOVFF  32E,338
0D01A:  MOVFF  32F,339
0D01E:  MOVFF  330,33A
0D022:  MOVLB  0
0D024:  CALL   17468
....................       } 
0D028:  BRA    D1D8
0D02A:  MOVLB  3
....................       else if(CMD1 ==  0x13){ 
0D02C:  MOVF   x2C,W
0D02E:  SUBLW  13
0D030:  BNZ   D060
....................          REPLY_TO_COM(0x66,0); 
0D032:  MOVLW  66
0D034:  MOVWF  x37
0D036:  CLRF   x38
0D038:  MOVLB  0
0D03A:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D03E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0D042:  MOVLB  1
0D044:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SMF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
0D046:  MOVFF  32D,337
0D04A:  MOVFF  32E,338
0D04E:  MOVFF  32F,339
0D052:  MOVFF  330,33A
0D056:  MOVLB  0
0D058:  CALL   175E0
....................       } 
0D05C:  BRA    D1D8
0D05E:  MOVLB  3
....................       else if(CMD1 ==  0x21){ 
0D060:  MOVF   x2C,W
0D062:  SUBLW  21
0D064:  BNZ   D094
....................          REPLY_TO_COM(0x66,0); 
0D066:  MOVLW  66
0D068:  MOVWF  x37
0D06A:  CLRF   x38
0D06C:  MOVLB  0
0D06E:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D072:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0D076:  MOVLB  1
0D078:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
0D07A:  MOVFF  32D,337
0D07E:  MOVFF  32E,338
0D082:  MOVFF  32F,339
0D086:  MOVFF  330,33A
0D08A:  MOVLB  0
0D08C:  CALL   17756
....................       } 
0D090:  BRA    D1D8
0D092:  MOVLB  3
....................       else if(CMD1 ==  0x23){ 
0D094:  MOVF   x2C,W
0D096:  SUBLW  23
0D098:  BNZ   D0C8
....................          REPLY_TO_COM(0x66,0); 
0D09A:  MOVLW  66
0D09C:  MOVWF  x37
0D09E:  CLRF   x38
0D0A0:  MOVLB  0
0D0A2:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D0A6:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0D0AA:  MOVLB  1
0D0AC:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2SMF(CMD2,CMD3,CMD4,CMD5);                           //transfer 1 sector, this function contains saving log 
0D0AE:  MOVFF  32D,337
0D0B2:  MOVFF  32E,338
0D0B6:  MOVFF  32F,339
0D0BA:  MOVFF  330,33A
0D0BE:  MOVLB  0
0D0C0:  CALL   178D0
....................       } 
0D0C4:  BRA    D1D8
0D0C6:  MOVLB  3
....................       else if(CMD1 ==  0x31){ 
0D0C8:  MOVF   x2C,W
0D0CA:  SUBLW  31
0D0CC:  BNZ   D0FC
....................          REPLY_TO_COM(0x66,0); 
0D0CE:  MOVLW  66
0D0D0:  MOVWF  x37
0D0D2:  CLRF   x38
0D0D4:  MOVLB  0
0D0D6:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D0DA:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
0D0DE:  MOVLB  1
0D0E0:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
0D0E2:  MOVFF  32D,337
0D0E6:  MOVFF  32E,338
0D0EA:  MOVFF  32F,339
0D0EE:  MOVFF  330,33A
0D0F2:  MOVLB  0
0D0F4:  CALL   17A50
....................       } 
0D0F8:  BRA    D1D8
0D0FA:  MOVLB  3
....................       else if(CMD1 ==  0x32){ 
0D0FC:  MOVF   x2C,W
0D0FE:  SUBLW  32
0D100:  BNZ   D130
....................          REPLY_TO_COM(0x66,0); 
0D102:  MOVLW  66
0D104:  MOVWF  x37
0D106:  CLRF   x38
0D108:  MOVLB  0
0D10A:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D10E:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0D112:  MOVLB  1
0D114:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2SCF(CMD2,CMD3,CMD4,CMD5);                          //transfer 1 sector, also this function contains saving log 
0D116:  MOVFF  32D,337
0D11A:  MOVFF  32E,338
0D11E:  MOVFF  32F,339
0D122:  MOVFF  330,33A
0D126:  MOVLB  0
0D128:  CALL   17BC8
....................       } 
0D12C:  BRA    D1D8
0D12E:  MOVLB  3
....................       else if(CMD1 ==  0x01){ 
0D130:  DECFSZ x2C,W
0D132:  BRA    D168
....................          REPLY_TO_COM(0x66,0); 
0D134:  MOVLW  66
0D136:  MOVWF  x37
0D138:  CLRF   x38
0D13A:  MOVLB  0
0D13C:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D140:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0D144:  MOVLB  1
0D146:  CLRF   xF1
....................          Send_Command_to_FAB(0x01);                                              //send cmd to FAB to turn ON battery heater 
0D148:  MOVLW  01
0D14A:  MOVLB  3
0D14C:  MOVWF  x4F
0D14E:  MOVLB  0
0D150:  CALL   1AC4
....................          fprintf(PC,"Sent CMD Heater ON\r\n"); 
0D154:  MOVLW  BC
0D156:  MOVWF  FF6
0D158:  MOVLW  15
0D15A:  MOVWF  FF7
0D15C:  MOVLW  00
0D15E:  MOVWF  FF8
0D160:  CALL   058C
....................       } 
0D164:  BRA    D1D8
0D166:  MOVLB  3
....................       else if(CMD1 ==  0x02){ 
0D168:  MOVF   x2C,W
0D16A:  SUBLW  02
0D16C:  BNZ   D1A2
....................          REPLY_TO_COM(0x66,0); 
0D16E:  MOVLW  66
0D170:  MOVWF  x37
0D172:  CLRF   x38
0D174:  MOVLB  0
0D176:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D17A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
0D17E:  MOVLB  1
0D180:  CLRF   xF1
....................          Send_Command_to_FAB(0x02);                                              //send cmd to FAB to turn OFF battery heater 
0D182:  MOVLW  02
0D184:  MOVLB  3
0D186:  MOVWF  x4F
0D188:  MOVLB  0
0D18A:  CALL   1AC4
....................          fprintf(PC,"Sent CMD Heater OFF\r\n"); 
0D18E:  MOVLW  D2
0D190:  MOVWF  FF6
0D192:  MOVLW  15
0D194:  MOVWF  FF7
0D196:  MOVLW  00
0D198:  MOVWF  FF8
0D19A:  CALL   058C
....................       } 
0D19E:  BRA    D1D8
0D1A0:  MOVLB  3
....................       else if(CMD1 ==  0x03){ 
0D1A2:  MOVF   x2C,W
0D1A4:  SUBLW  03
0D1A6:  BNZ   D1DA
....................             REPLY_TO_COM(0x66,0); 
0D1A8:  MOVLW  66
0D1AA:  MOVWF  x37
0D1AC:  CLRF   x38
0D1AE:  MOVLB  0
0D1B0:  CALL   1D84A
....................             UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
0D1B4:  CALL   1E188
....................             ACK_for_COM[14] = 0x00;       
0D1B8:  MOVLB  1
0D1BA:  CLRF   xF1
....................             Send_Command_to_FAB(0x03);                                              //send cmd to FAB to operate Heater in AUTO mode 
0D1BC:  MOVLW  03
0D1BE:  MOVLB  3
0D1C0:  MOVWF  x4F
0D1C2:  MOVLB  0
0D1C4:  CALL   1AC4
....................             fprintf(PC,"Sent CMD Heater AUTO\r\n"); 
0D1C8:  MOVLW  E8
0D1CA:  MOVWF  FF6
0D1CC:  MOVLW  15
0D1CE:  MOVWF  FF7
0D1D0:  MOVLW  00
0D1D2:  MOVWF  FF8
0D1D4:  CALL   058C
0D1D8:  MOVLB  3
....................          }          
....................    return; 
0D1DA:  MOVLB  0
0D1DC:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... void EXECUTE_MISSION_from_PC(int8 CMD1,int8 CMD2,int8 CMD3,int8 CMD4,int8 CMD5,int8 CMD6,int8 CMD7) 
.................... { 
.................... if (CMD1 == 0xc0) 
*
1E1C0:  MOVLB  3
1E1C2:  MOVF   x2C,W
1E1C4:  SUBLW  C0
1E1C6:  BNZ   1E202
....................    { 
....................       REPLY_TO_COM(0x66,0); 
1E1C8:  MOVLW  66
1E1CA:  MOVWF  x37
1E1CC:  CLRF   x38
1E1CE:  MOVLB  0
1E1D0:  CALL   1D84A
....................       SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data          
1E1D4:  MOVFF  32C,353
1E1D8:  MOVLB  3
1E1DA:  CLRF   x54
1E1DC:  MOVFF  32D,355
1E1E0:  MOVLB  0
1E1E2:  CALL   16EE2
....................       UPLINK_SUCCESS_CAM();                                                   //put uplink succes flag in high and store flags 
1E1E6:  CALL   255C
....................       ACK_for_COM[14] = 0x00;         
1E1EA:  MOVLB  1
1E1EC:  CLRF   xF1
....................          CAM_TEST_OPERATION(CMD2);                                               //send command to CAM, execute mission and transfer data 
1E1EE:  MOVFF  32D,337
1E1F2:  MOVLB  0
1E1F4:  CALL   1AD94
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated CAM address 
1E1F8:  CALL   144C8
....................       } 
1E1FC:  GOTO   1EB64
1E200:  MOVLB  3
....................       else if(CMD1 == 0xA0){ 
1E202:  MOVF   x2C,W
1E204:  SUBLW  A0
1E206:  BNZ   1E26A
....................          REPLY_TO_COM(0x66,0); 
1E208:  MOVLW  66
1E20A:  MOVWF  x37
1E20C:  CLRF   x38
1E20E:  MOVLB  0
1E210:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1,CMD2,CMD4); 
1E214:  MOVFF  32C,353
1E218:  MOVFF  32D,354
1E21C:  MOVFF  32F,355
1E220:  CALL   16EE2
....................          unsigned int16 op_duration = (unsigned int16)CMD4*60;          
1E224:  MOVLB  3
1E226:  CLRF   x38
1E228:  MOVFF  32F,337
1E22C:  MOVFF  338,343
1E230:  MOVFF  32F,342
1E234:  CLRF   x45
1E236:  MOVLW  3C
1E238:  MOVWF  x44
1E23A:  MOVLB  0
1E23C:  CALL   253A
1E240:  MOVFF  02,334
1E244:  MOVFF  01,333
....................          UPLINK_SUCCESS_ADCS(); 
1E248:  RCALL  1E13C
....................          ACK_for_COM[14] = 0x00;         
1E24A:  MOVLB  1
1E24C:  CLRF   xF1
....................          ADCS_TEST_OPERATION(op_duration,CMD2); 
1E24E:  MOVFF  334,381
1E252:  MOVFF  333,380
1E256:  MOVFF  32D,382
1E25A:  MOVLB  0
1E25C:  CALL   127D4
....................          STORE_ADRESS_DATA_TO_FLASH(); 
1E260:  CALL   144C8
....................       } 
1E264:  GOTO   1EB64
1E268:  MOVLB  3
....................       else if(CMD1 ==  0xA1){                                                                 //TLE data reception  
1E26A:  MOVF   x2C,W
1E26C:  SUBLW  A1
1E26E:  BNZ   1E2B8
....................          REPLY_TO_COM(0x66,0); 
1E270:  MOVLW  66
1E272:  MOVWF  x37
1E274:  CLRF   x38
1E276:  MOVLB  0
1E278:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
1E27C:  RCALL  1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
1E27E:  MOVFF  32C,353
1E282:  MOVLB  3
1E284:  CLRF   x54
1E286:  MOVFF  32D,355
1E28A:  MOVLB  0
1E28C:  CALL   16EE2
....................          ACK_for_COM[14] = 0x00; 
1E290:  MOVLB  1
1E292:  CLRF   xF1
....................          ADCS_TLE_JOIN(CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);                           //Receive, assemble and save TLE data in flash 
1E294:  MOVFF  32D,337
1E298:  MOVFF  32E,338
1E29C:  MOVFF  32F,339
1E2A0:  MOVFF  330,33A
1E2A4:  MOVFF  331,33B
1E2A8:  MOVFF  332,33C
1E2AC:  MOVLB  0
1E2AE:  CALL   1B0DC
....................       } 
1E2B2:  GOTO   1EB64
1E2B6:  MOVLB  3
....................       else if(CMD1 ==  0xA2){                                                                 //TLE data reception  
1E2B8:  MOVF   x2C,W
1E2BA:  SUBLW  A2
1E2BC:  BNZ   1E2EE
....................          REPLY_TO_COM(0x66,0); 
1E2BE:  MOVLW  66
1E2C0:  MOVWF  x37
1E2C2:  CLRF   x38
1E2C4:  MOVLB  0
1E2C6:  CALL   1D84A
....................          UPLINK_SUCCESS_ADCS(); 
1E2CA:  RCALL  1E13C
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command          
1E2CC:  MOVFF  32C,353
1E2D0:  MOVLB  3
1E2D2:  CLRF   x54
1E2D4:  MOVFF  32D,355
1E2D8:  MOVLB  0
1E2DA:  CALL   16EE2
....................          ACK_for_COM[14] = 0x00; 
1E2DE:  MOVLB  1
1E2E0:  CLRF   xF1
....................          ADCS_TLE_TRANSFER();                                                    //TRANSFER TLE data to ADCS 
1E2E2:  MOVLB  0
1E2E4:  CALL   136C4
....................       }     
1E2E8:  GOTO   1EB64
1E2EC:  MOVLB  3
....................       else if(CMD1 ==  0xD0){                                                                 //transfer data from Mission BOSS 
1E2EE:  MOVF   x2C,W
1E2F0:  SUBLW  D0
1E2F2:  BNZ   1E350
....................          REPLY_TO_COM(0x66,0); 
1E2F4:  MOVLW  66
1E2F6:  MOVWF  x37
1E2F8:  CLRF   x38
1E2FA:  MOVLB  0
1E2FC:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
1E300:  MOVFF  32C,353
1E304:  MOVLB  3
1E306:  CLRF   x54
1E308:  MOVFF  32D,355
1E30C:  MOVLB  0
1E30E:  CALL   16EE2
....................          UPLINK_SUCCESS_MBP();                                                   //put uplink succes flag in high and store flags 
1E312:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;          
1E314:  MOVLB  1
1E316:  CLRF   xF1
....................          DATACOLLECTION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);      //Turn ON MBP, get data, store in flash 
1E318:  MOVFF  32C,337
1E31C:  MOVFF  32D,338
1E320:  MOVFF  32E,339
1E324:  MOVFF  32F,33A
1E328:  MOVFF  330,33B
1E32C:  MOVFF  331,33C
1E330:  MOVFF  332,33D
1E334:  MOVLB  0
1E336:  CALL   138E0
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E33A:  CALL   144C8
....................          delay_ms(10); 
1E33E:  MOVLW  0A
1E340:  MOVLB  3
1E342:  MOVWF  x98
1E344:  MOVLB  0
1E346:  CALL   0526
....................       }  
1E34A:  GOTO   1EB64
1E34E:  MOVLB  3
....................       else if(CMD1 ==  0xD1){                                                                 //PSC Mission 
1E350:  MOVF   x2C,W
1E352:  SUBLW  D1
1E354:  BNZ   1E3B0
....................          REPLY_TO_COM(0x66,0); 
1E356:  MOVLW  66
1E358:  MOVWF  x37
1E35A:  CLRF   x38
1E35C:  MOVLB  0
1E35E:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E362:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;       
1E364:  MOVLB  1
1E366:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E368:  MOVFF  32C,353
1E36C:  MOVLB  3
1E36E:  CLRF   x54
1E370:  MOVFF  32D,355
1E374:  MOVLB  0
1E376:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E37A:  MOVFF  32C,337
1E37E:  MOVFF  32D,338
1E382:  MOVFF  32E,339
1E386:  MOVFF  32F,33A
1E38A:  MOVFF  330,33B
1E38E:  MOVFF  331,33C
1E392:  MOVFF  332,33D
1E396:  CALL   13A8A
....................          delay_ms(10); 
1E39A:  MOVLW  0A
1E39C:  MOVLB  3
1E39E:  MOVWF  x98
1E3A0:  MOVLB  0
1E3A2:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E3A6:  CALL   144C8
....................       } 
1E3AA:  GOTO   1EB64
1E3AE:  MOVLB  3
....................       else if(CMD1 ==  0xD2){                                                                 //TMCR Mission 
1E3B0:  MOVF   x2C,W
1E3B2:  SUBLW  D2
1E3B4:  BNZ   1E410
....................          REPLY_TO_COM(0x66,0); 
1E3B6:  MOVLW  66
1E3B8:  MOVWF  x37
1E3BA:  CLRF   x38
1E3BC:  MOVLB  0
1E3BE:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E3C2:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;      
1E3C4:  MOVLB  1
1E3C6:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E3C8:  MOVFF  32C,353
1E3CC:  MOVLB  3
1E3CE:  CLRF   x54
1E3D0:  MOVFF  32D,355
1E3D4:  MOVLB  0
1E3D6:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E3DA:  MOVFF  32C,337
1E3DE:  MOVFF  32D,338
1E3E2:  MOVFF  32E,339
1E3E6:  MOVFF  32F,33A
1E3EA:  MOVFF  330,33B
1E3EE:  MOVFF  331,33C
1E3F2:  MOVFF  332,33D
1E3F6:  CALL   13A8A
....................          delay_ms(10); 
1E3FA:  MOVLW  0A
1E3FC:  MOVLB  3
1E3FE:  MOVWF  x98
1E400:  MOVLB  0
1E402:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E406:  CALL   144C8
....................       } 
1E40A:  GOTO   1EB64
1E40E:  MOVLB  3
....................       else if(CMD1 ==  0xD3){                                                                 //NTU Mission 
1E410:  MOVF   x2C,W
1E412:  SUBLW  D3
1E414:  BNZ   1E46E
....................          REPLY_TO_COM(0x66,0); 
1E416:  MOVLW  66
1E418:  MOVWF  x37
1E41A:  CLRF   x38
1E41C:  MOVLB  0
1E41E:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E422:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;       
1E424:  MOVLB  1
1E426:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E428:  MOVFF  32C,353
1E42C:  MOVLB  3
1E42E:  CLRF   x54
1E430:  MOVFF  32D,355
1E434:  MOVLB  0
1E436:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E43A:  MOVFF  32C,337
1E43E:  MOVFF  32D,338
1E442:  MOVFF  32E,339
1E446:  MOVFF  32F,33A
1E44A:  MOVFF  330,33B
1E44E:  MOVFF  331,33C
1E452:  MOVFF  332,33D
1E456:  CALL   13A8A
....................          delay_ms(10); 
1E45A:  MOVLW  0A
1E45C:  MOVLB  3
1E45E:  MOVWF  x98
1E460:  MOVLB  0
1E462:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E466:  CALL   144C8
....................       } 
1E46A:  BRA    1EB64
1E46C:  MOVLB  3
....................       else if(CMD1 ==  0xD4){                                                                 //SF_WARD Mission 
1E46E:  MOVF   x2C,W
1E470:  SUBLW  D4
1E472:  BNZ   1E4CC
....................          REPLY_TO_COM(0x66,0); 
1E474:  MOVLW  66
1E476:  MOVWF  x37
1E478:  CLRF   x38
1E47A:  MOVLB  0
1E47C:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E480:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;      
1E482:  MOVLB  1
1E484:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E486:  MOVFF  32C,353
1E48A:  MOVLB  3
1E48C:  CLRF   x54
1E48E:  MOVFF  32D,355
1E492:  MOVLB  0
1E494:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E498:  MOVFF  32C,337
1E49C:  MOVFF  32D,338
1E4A0:  MOVFF  32E,339
1E4A4:  MOVFF  32F,33A
1E4A8:  MOVFF  330,33B
1E4AC:  MOVFF  331,33C
1E4B0:  MOVFF  332,33D
1E4B4:  CALL   13A8A
....................          delay_ms(10); 
1E4B8:  MOVLW  0A
1E4BA:  MOVLB  3
1E4BC:  MOVWF  x98
1E4BE:  MOVLB  0
1E4C0:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E4C4:  CALL   144C8
....................       } 
1E4C8:  BRA    1EB64
1E4CA:  MOVLB  3
....................       else if(CMD1 ==  0xD5){                                                                 //HNT Mission 
1E4CC:  MOVF   x2C,W
1E4CE:  SUBLW  D5
1E4D0:  BNZ   1E52A
....................          REPLY_TO_COM(0x66,0); 
1E4D2:  MOVLW  66
1E4D4:  MOVWF  x37
1E4D6:  CLRF   x38
1E4D8:  MOVLB  0
1E4DA:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E4DE:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;       
1E4E0:  MOVLB  1
1E4E2:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E4E4:  MOVFF  32C,353
1E4E8:  MOVLB  3
1E4EA:  CLRF   x54
1E4EC:  MOVFF  32D,355
1E4F0:  MOVLB  0
1E4F2:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E4F6:  MOVFF  32C,337
1E4FA:  MOVFF  32D,338
1E4FE:  MOVFF  32E,339
1E502:  MOVFF  32F,33A
1E506:  MOVFF  330,33B
1E50A:  MOVFF  331,33C
1E50E:  MOVFF  332,33D
1E512:  CALL   13A8A
....................          delay_ms(10); 
1E516:  MOVLW  0A
1E518:  MOVLB  3
1E51A:  MOVWF  x98
1E51C:  MOVLB  0
1E51E:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E522:  CALL   144C8
....................       } 
1E526:  BRA    1EB64
1E528:  MOVLB  3
....................       else if(CMD1 ==  0xD6){                                                                 //APRS_DP Mission 
1E52A:  MOVF   x2C,W
1E52C:  SUBLW  D6
1E52E:  BNZ   1E588
....................          REPLY_TO_COM(0x66,0); 
1E530:  MOVLW  66
1E532:  MOVWF  x37
1E534:  CLRF   x38
1E536:  MOVLB  0
1E538:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E53C:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;       
1E53E:  MOVLB  1
1E540:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E542:  MOVFF  32C,353
1E546:  MOVLB  3
1E548:  CLRF   x54
1E54A:  MOVFF  32D,355
1E54E:  MOVLB  0
1E550:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E554:  MOVFF  32C,337
1E558:  MOVFF  32D,338
1E55C:  MOVFF  32E,339
1E560:  MOVFF  32F,33A
1E564:  MOVFF  330,33B
1E568:  MOVFF  331,33C
1E56C:  MOVFF  332,33D
1E570:  CALL   13A8A
....................          delay_ms(10); 
1E574:  MOVLW  0A
1E576:  MOVLB  3
1E578:  MOVWF  x98
1E57A:  MOVLB  0
1E57C:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E580:  CALL   144C8
....................       } 
1E584:  BRA    1EB64
1E586:  MOVLB  3
....................       else if(CMD1 ==  0xD7){                                                                 //dummy data for MBP 
1E588:  MOVF   x2C,W
1E58A:  SUBLW  D7
1E58C:  BNZ   1E5E6
....................          REPLY_TO_COM(0x66,0); 
1E58E:  MOVLW  66
1E590:  MOVWF  x37
1E592:  CLRF   x38
1E594:  MOVLB  0
1E596:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E59A:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;      
1E59C:  MOVLB  1
1E59E:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E5A0:  MOVFF  32C,353
1E5A4:  MOVLB  3
1E5A6:  CLRF   x54
1E5A8:  MOVFF  32D,355
1E5AC:  MOVLB  0
1E5AE:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E5B2:  MOVFF  32C,337
1E5B6:  MOVFF  32D,338
1E5BA:  MOVFF  32E,339
1E5BE:  MOVFF  32F,33A
1E5C2:  MOVFF  330,33B
1E5C6:  MOVFF  331,33C
1E5CA:  MOVFF  332,33D
1E5CE:  CALL   13A8A
....................          delay_ms(10); 
1E5D2:  MOVLW  0A
1E5D4:  MOVLB  3
1E5D6:  MOVWF  x98
1E5D8:  MOVLB  0
1E5DA:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E5DE:  CALL   144C8
....................       } 
1E5E2:  BRA    1EB64
1E5E4:  MOVLB  3
....................       else if(CMD1 ==  0xDF){                                                                 //dummy data for MBP 
1E5E6:  MOVF   x2C,W
1E5E8:  SUBLW  DF
1E5EA:  BNZ   1E644
....................          REPLY_TO_COM(0x66,0); 
1E5EC:  MOVLW  66
1E5EE:  MOVWF  x37
1E5F0:  CLRF   x38
1E5F2:  MOVLB  0
1E5F4:  CALL   1D84A
....................          UPLINK_SUCCESS_MBP(); 
1E5F8:  RCALL  1E162
....................          ACK_for_COM[14] = 0x00;       
1E5FA:  MOVLB  1
1E5FC:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1,0,CMD2);                                              //save reset data and command 
1E5FE:  MOVFF  32C,353
1E602:  MOVLB  3
1E604:  CLRF   x54
1E606:  MOVFF  32D,355
1E60A:  MOVLB  0
1E60C:  CALL   16EE2
....................          MISSION_TEST_OPERATION(CMD1,CMD2,CMD3,CMD4,CMD5,CMD6,CMD7);             //send array of commnands to MBP 
1E610:  MOVFF  32C,337
1E614:  MOVFF  32D,338
1E618:  MOVFF  32E,339
1E61C:  MOVFF  32F,33A
1E620:  MOVFF  330,33B
1E624:  MOVFF  331,33C
1E628:  MOVFF  332,33D
1E62C:  CALL   13A8A
....................          delay_ms(10); 
1E630:  MOVLW  0A
1E632:  MOVLB  3
1E634:  MOVWF  x98
1E636:  MOVLB  0
1E638:  CALL   0526
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //store the updated address 
1E63C:  CALL   144C8
....................       } 
1E640:  BRA    1EB64
1E642:  MOVLB  3
....................       else if(CMD1 ==  0xaa){ 
1E644:  MOVF   x2C,W
1E646:  SUBLW  AA
1E648:  BNZ   1E680
....................          REPLY_TO_COM(0x66,0); 
1E64A:  MOVLW  66
1E64C:  MOVWF  x37
1E64E:  CLRF   x38
1E650:  MOVLB  0
1E652:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data and command 
1E656:  MOVFF  32C,353
1E65A:  MOVLB  3
1E65C:  CLRF   x54
1E65E:  MOVFF  32D,355
1E662:  MOVLB  0
1E664:  CALL   16EE2
....................          STORE_ADRESS_DATA_TO_FLASH();          
1E668:  CALL   144C8
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E66C:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;          
1E66E:  MOVLB  1
1E670:  CLRF   xF1
....................          STORE_FLAG_INFO();                                                      //store flag info on flash 
1E672:  MOVLB  0
1E674:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //store flag info on EEPROM 
1E678:  CALL   11C84
....................       } 
1E67C:  BRA    1EB64
1E67E:  MOVLB  3
....................       else if(CMD1 ==  0x22){ 
1E680:  MOVF   x2C,W
1E682:  SUBLW  22
1E684:  BNZ   1E6B6
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E686:  MOVLB  0
1E688:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00; 
1E68A:  MOVLB  1
1E68C:  CLRF   xF1
....................          REPLY_TO_COM(0x66,0);                                                   //ACK_for_COM[12] = 0x66 ACK_for_COM[13] = 0          
1E68E:  MOVLW  66
1E690:  MOVLB  3
1E692:  MOVWF  x37
1E694:  CLRF   x38
1E696:  MOVLB  0
1E698:  CALL   1D84A
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);                                            //save reset data, cmd1 and cmd2 as sat log         
1E69C:  MOVFF  32C,353
1E6A0:  MOVLB  3
1E6A2:  CLRF   x54
1E6A4:  MOVFF  32D,355
1E6A8:  MOVLB  0
1E6AA:  CALL   16EE2
....................          SEND_CMD_FOR_RESET_SATELLITE();                                         //save flag data, address data and RSV table in flash, send cmd for sat reset 
1E6AE:  CALL   16B20
....................       } 
1E6B2:  BRA    1EB64
1E6B4:  MOVLB  3
....................       else if(CMD1 ==  0xb0){ 
1E6B6:  MOVF   x2C,W
1E6B8:  SUBLW  B0
1E6BA:  BNZ   1E6E4
....................          REPLY_TO_COM(0x66,0); 
1E6BC:  MOVLW  66
1E6BE:  MOVWF  x37
1E6C0:  CLRF   x38
1E6C2:  MOVLB  0
1E6C4:  CALL   1D84A
....................          CLEAR_BC_FLAG();                                                        //BC_ATTEMPT_FLAG = 0        
1E6C8:  CALL   1B3D8
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E6CC:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;         
1E6CE:  MOVLB  1
1E6D0:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
1E6D2:  MOVLB  0
1E6D4:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1E6D8:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
1E6DC:  CALL   11C84
....................       } 
1E6E0:  BRA    1EB64
1E6E2:  MOVLB  3
....................       else if(CMD1 ==  0xb1){ 
1E6E4:  MOVF   x2C,W
1E6E6:  SUBLW  B1
1E6E8:  BNZ   1E712
....................          REPLY_TO_COM(0x66,0); 
1E6EA:  MOVLW  66
1E6EC:  MOVWF  x37
1E6EE:  CLRF   x38
1E6F0:  MOVLB  0
1E6F2:  CALL   1D84A
....................          MAKE_BC_FLAG_1();                                                       //BC_ATTEMPT_FLAG = 1          
1E6F6:  CALL   1B3EC
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E6FA:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;         
1E6FC:  MOVLB  1
1E6FE:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
1E700:  MOVLB  0
1E702:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1E706:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
1E70A:  CALL   11C84
....................       } 
1E70E:  BRA    1EB64
1E710:  MOVLB  3
....................       else if(CMD1 ==  0xb2){ 
1E712:  MOVF   x2C,W
1E714:  SUBLW  B2
1E716:  BNZ   1E740
....................          REPLY_TO_COM(0x66,0); 
1E718:  MOVLW  66
1E71A:  MOVWF  x37
1E71C:  CLRF   x38
1E71E:  MOVLB  0
1E720:  CALL   1D84A
....................          MAKE_BC_FLAG_2();                                                       //BC_ATTEMPT_FLAG = 2          
1E724:  CALL   1B402
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E728:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;          
1E72A:  MOVLB  1
1E72C:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
1E72E:  MOVLB  0
1E730:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1E734:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
1E738:  CALL   11C84
....................       } 
1E73C:  BRA    1EB64
1E73E:  MOVLB  3
....................       else if(CMD1 ==  0xb3){ 
1E740:  MOVF   x2C,W
1E742:  SUBLW  B3
1E744:  BNZ   1E76E
....................          REPLY_TO_COM(0x66,0); 
1E746:  MOVLW  66
1E748:  MOVWF  x37
1E74A:  CLRF   x38
1E74C:  MOVLB  0
1E74E:  CALL   1D84A
....................          MAKE_BC_FLAG_3();                                                       //BC_ATTEMPT_FLAG = 3         
1E752:  CALL   1B418
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E756:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;          
1E758:  MOVLB  1
1E75A:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
1E75C:  MOVLB  0
1E75E:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1E762:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
1E766:  CALL   11C84
....................       } 
1E76A:  BRA    1EB64
1E76C:  MOVLB  3
....................       else if(CMD1 ==  0xb4){ 
1E76E:  MOVF   x2C,W
1E770:  SUBLW  B4
1E772:  BNZ   1E79C
....................          REPLY_TO_COM(0x66,0); 
1E774:  MOVLW  66
1E776:  MOVWF  x37
1E778:  CLRF   x38
1E77A:  MOVLB  0
1E77C:  CALL   1D84A
....................          MAKE_BC_FLAG_4();                                                       //BC_ATTEMPT_FLAG = 4          
1E780:  CALL   1B42E
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E784:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;         
1E786:  MOVLB  1
1E788:  CLRF   xF1
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //save address data to flash memory 
1E78A:  MOVLB  0
1E78C:  CALL   144C8
....................          STORE_FLAG_INFO();                                                      //save flag data to flash memory 
1E790:  CALL   14000
....................          WRITE_FLAG_to_EEPROM();                                                 //save flag data to EEPROM 
1E794:  CALL   11C84
....................       } 
1E798:  BRA    1EB64
1E79A:  MOVLB  3
....................       else if(CMD1 ==  0x4b){ 
1E79C:  MOVF   x2C,W
1E79E:  SUBLW  4B
1E7A0:  BNZ   1E7CE
....................          REPLY_TO_COM(0x66,0); 
1E7A2:  MOVLW  66
1E7A4:  MOVWF  x37
1E7A6:  CLRF   x38
1E7A8:  MOVLB  0
1E7AA:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E7AE:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;          
1E7B0:  MOVLB  1
1E7B2:  CLRF   xF1
....................          Count_Kill_Flag();                                                      //Enable if Kill_COUNTER > 4 
1E7B4:  MOVLB  0
1E7B6:  CALL   1B444
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
1E7BA:  MOVFF  32C,353
1E7BE:  MOVFF  31A,354
1E7C2:  MOVFF  32D,355
1E7C6:  CALL   16EE2
....................       } 
1E7CA:  BRA    1EB64
1E7CC:  MOVLB  3
....................       else if(CMD1 ==  0xbb){ 
1E7CE:  MOVF   x2C,W
1E7D0:  SUBLW  BB
1E7D2:  BNZ   1E800
....................          REPLY_TO_COM(0x66,0); 
1E7D4:  MOVLW  66
1E7D6:  MOVWF  x37
1E7D8:  CLRF   x38
1E7DA:  MOVLB  0
1E7DC:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put in high uplink success flag and store flag info on flash 
1E7E0:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;       
1E7E2:  MOVLB  1
1E7E4:  CLRF   xF1
....................          Disable_Kill();                                                         //Kill Switch OFF 
1E7E6:  MOVLB  0
1E7E8:  CALL   1B498
....................          SAVE_SAT_LOG(CMD1, KILL_COUNTER, CMD2);                                 //save reset data and command 
1E7EC:  MOVFF  32C,353
1E7F0:  MOVFF  31A,354
1E7F4:  MOVFF  32D,355
1E7F8:  CALL   16EE2
....................       } 
1E7FC:  BRA    1EB64
1E7FE:  MOVLB  3
....................       else if(CMD1 ==  0xfa){ 
1E800:  MOVF   x2C,W
1E802:  SUBLW  FA
1E804:  BNZ   1E87E
....................          REPLY_TO_COM(0x66,0); 
1E806:  MOVLW  66
1E808:  MOVWF  x37
1E80A:  CLRF   x38
1E80C:  MOVLB  0
1E80E:  CALL   1D84A
....................          UPLINK_SUCCESS_HSSC();                                                  //High Sampling Sensor Collect mission 
1E812:  RCALL  1E19A
....................          ACK_for_COM[14] = 0x00;       
1E814:  MOVLB  1
1E816:  CLRF   xF1
....................          SAVE_SAT_LOG(CMD1, 0, CMD2);          
1E818:  MOVFF  32C,353
1E81C:  MOVLB  3
1E81E:  CLRF   x54
1E820:  MOVFF  32D,355
1E824:  MOVLB  0
1E826:  CALL   16EE2
....................          unsigned int16 duration = (unsigned int16)CMD2*12;                      //CMD2 is operation time(min), maxima cantidad de lecturas en 2 horas = 1440 
1E82A:  MOVLB  3
1E82C:  CLRF   x38
1E82E:  MOVFF  32D,337
1E832:  MOVFF  338,343
1E836:  MOVFF  32D,342
1E83A:  CLRF   x45
1E83C:  MOVLW  0C
1E83E:  MOVWF  x44
1E840:  MOVLB  0
1E842:  CALL   253A
1E846:  MOVFF  02,336
1E84A:  MOVFF  01,335
....................          if(duration > 1440) 
1E84E:  MOVLB  3
1E850:  MOVF   x36,W
1E852:  SUBLW  04
1E854:  BC    1E868
1E856:  XORLW  FF
1E858:  BNZ   1E860
1E85A:  MOVF   x35,W
1E85C:  SUBLW  A0
1E85E:  BC    1E868
....................          { 
....................             duration = 1440;                                                     // 12 readings in 1 min, every 5 seconds 
1E860:  MOVLW  05
1E862:  MOVWF  x36
1E864:  MOVLW  A0
1E866:  MOVWF  x35
....................       } 
....................          HIGHSAMP_SENSOR_COLLECTION(duration);                                   //duration is how many times will be executed 
1E868:  MOVFF  336,338
1E86C:  MOVFF  335,337
1E870:  MOVLB  0
1E872:  CALL   1BAB6
....................          STORE_ADRESS_DATA_TO_FLASH(); 
1E876:  CALL   144C8
....................       } 
1E87A:  BRA    1EB64
1E87C:  MOVLB  3
....................       else if(CMD1 ==  0x59){ 
1E87E:  MOVF   x2C,W
1E880:  SUBLW  59
1E882:  BNZ   1E89C
....................          REPLY_TO_COM(0x66,0);                                                   //send ACK to COM 
1E884:  MOVLW  66
1E886:  MOVWF  x37
1E888:  CLRF   x38
1E88A:  MOVLB  0
1E88C:  CALL   1D84A
....................          GIVE_ACCESS_SCF_Nsec(CMD2); 
1E890:  MOVFF  32D,337
1E894:  CALL   1B4E4
....................       } 
1E898:  BRA    1EB64
1E89A:  MOVLB  3
....................       else if(CMD1 ==  0xee){ 
1E89C:  MOVF   x2C,W
1E89E:  SUBLW  EE
1E8A0:  BNZ   1E8B2
....................          UPLINK_SUCCESS_CHECK(); 
1E8A2:  MOVLB  0
1E8A4:  RCALL  1E188
....................          ERASE_EEPROM_INFO();                                                    //erase 512byte(from 0x18000 to 0x181ff) 
1E8A6:  CALL   13C2E
....................          MEMORY_ERASE();                                                         //erase OF, SCF, SMF flash memories 
1E8AA:  CALL   15B08
....................       } 
1E8AE:  BRA    1EB64
1E8B0:  MOVLB  3
....................       else if(CMD1 ==  0x88){ 
1E8B2:  MOVF   x2C,W
1E8B4:  SUBLW  88
1E8B6:  BNZ   1E8C2
....................          CURRENT_FLAG_STATUS();                                                  //Print on PC port current flag status 
1E8B8:  MOVLB  0
1E8BA:  CALL   12A12
....................       } 
1E8BE:  BRA    1EB64
1E8C0:  MOVLB  3
....................       else if(CMD1 ==  0x9f){ 
1E8C2:  MOVF   x2C,W
1E8C4:  SUBLW  9F
1E8C6:  BNZ   1E8D2
....................          Disp_RSV();                                                             //show the reserve status (reserve command and reserve table) 
1E8C8:  MOVLB  0
1E8CA:  CALL   1723A
....................       } 
1E8CE:  BRA    1EB64
1E8D0:  MOVLB  3
....................       else if(CMD1 ==  0x50){ 
1E8D2:  MOVF   x2C,W
1E8D4:  SUBLW  50
1E8D6:  BNZ   1E8EE
....................          if(UPLINK_SUCCESS == 0){ACK_for_COM[14]=0x77;} 
1E8D8:  MOVLB  0
1E8DA:  MOVF   x7C,F
1E8DC:  BNZ   1E8E6
1E8DE:  MOVLW  77
1E8E0:  MOVLB  1
1E8E2:  MOVWF  xF1
1E8E4:  MOVLB  0
....................          CW_RESPOND();                                                           //carga el array ACK_for_COM[] con los datos del CW 
1E8E6:  CALL   1E024
....................       } 
1E8EA:  BRA    1EB64
1E8EC:  MOVLB  3
....................       else if(CMD1 ==  0xe0){ 
1E8EE:  MOVF   x2C,W
1E8F0:  SUBLW  E0
1E8F2:  BNZ   1E920
....................          REPLY_TO_COM(0x66,0); 
1E8F4:  MOVLW  66
1E8F6:  MOVWF  x37
1E8F8:  CLRF   x38
1E8FA:  MOVLB  0
1E8FC:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E900:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;       
1E902:  MOVLB  1
1E904:  CLRF   xF1
....................          REFRESH_SECTOR_OF(CMD2,CMD3,CMD4,CMD5);                                 //Erase 1 sector of OBC flash, also this function contains saving log 
1E906:  MOVFF  32D,347
1E90A:  MOVFF  32E,348
1E90E:  MOVFF  32F,349
1E912:  MOVFF  330,34A
1E916:  MOVLB  0
1E918:  CALL   170D2
....................       } 
1E91C:  BRA    1EB64
1E91E:  MOVLB  3
....................       else if(CMD1 ==  0xe1){ 
1E920:  MOVF   x2C,W
1E922:  SUBLW  E1
1E924:  BNZ   1E952
....................          REPLY_TO_COM(0x66,0); 
1E926:  MOVLW  66
1E928:  MOVWF  x37
1E92A:  CLRF   x38
1E92C:  MOVLB  0
1E92E:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E932:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;       
1E934:  MOVLB  1
1E936:  CLRF   xF1
....................          REFRESH_SECTOR_SCF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of COM flash, also this function contains saving log 
1E938:  MOVFF  32D,347
1E93C:  MOVFF  32E,348
1E940:  MOVFF  32F,349
1E944:  MOVFF  330,34A
1E948:  MOVLB  0
1E94A:  CALL   17182
....................       } 
1E94E:  BRA    1EB64
1E950:  MOVLB  3
....................       else if(CMD1 ==  0xe2){ 
1E952:  MOVF   x2C,W
1E954:  SUBLW  E2
1E956:  BNZ   1E984
....................          REPLY_TO_COM(0x66,0); 
1E958:  MOVLW  66
1E95A:  MOVWF  x37
1E95C:  CLRF   x38
1E95E:  MOVLB  0
1E960:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E964:  RCALL  1E188
....................          ACK_for_COM[14] = 0x00;         
1E966:  MOVLB  1
1E968:  CLRF   xF1
....................          REFRESH_SECTOR_SMF(CMD2,CMD3,CMD4,CMD5);                                //Erase 1 sector of MISION flash, also this function contains saving log 
1E96A:  MOVFF  32D,347
1E96E:  MOVFF  32E,348
1E972:  MOVFF  32F,349
1E976:  MOVFF  330,34A
1E97A:  MOVLB  0
1E97C:  CALL   1701E
....................       } 
1E980:  BRA    1EB64
1E982:  MOVLB  3
....................       else if(CMD1 ==  0x12){ 
1E984:  MOVF   x2C,W
1E986:  SUBLW  12
1E988:  BNZ   1E9B8
....................          REPLY_TO_COM(0x66,0); 
1E98A:  MOVLW  66
1E98C:  MOVWF  x37
1E98E:  CLRF   x38
1E990:  MOVLB  0
1E992:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E996:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
1E99A:  MOVLB  1
1E99C:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SCF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
1E99E:  MOVFF  32D,337
1E9A2:  MOVFF  32E,338
1E9A6:  MOVFF  32F,339
1E9AA:  MOVFF  330,33A
1E9AE:  MOVLB  0
1E9B0:  CALL   17468
....................       } 
1E9B4:  BRA    1EB64
1E9B6:  MOVLB  3
....................       else if(CMD1 ==  0x13){ 
1E9B8:  MOVF   x2C,W
1E9BA:  SUBLW  13
1E9BC:  BNZ   1E9EC
....................          REPLY_TO_COM(0x66,0); 
1E9BE:  MOVLW  66
1E9C0:  MOVWF  x37
1E9C2:  CLRF   x38
1E9C4:  MOVLB  0
1E9C6:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E9CA:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
1E9CE:  MOVLB  1
1E9D0:  CLRF   xF1
....................          TRANSFER_SECTOR_OF2SMF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
1E9D2:  MOVFF  32D,337
1E9D6:  MOVFF  32E,338
1E9DA:  MOVFF  32F,339
1E9DE:  MOVFF  330,33A
1E9E2:  MOVLB  0
1E9E4:  CALL   175E0
....................       } 
1E9E8:  BRA    1EB64
1E9EA:  MOVLB  3
....................       else if(CMD1 ==  0x21){ 
1E9EC:  MOVF   x2C,W
1E9EE:  SUBLW  21
1E9F0:  BNZ   1EA20
....................          REPLY_TO_COM(0x66,0); 
1E9F2:  MOVLW  66
1E9F4:  MOVWF  x37
1E9F6:  CLRF   x38
1E9F8:  MOVLB  0
1E9FA:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1E9FE:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
1EA02:  MOVLB  1
1EA04:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
1EA06:  MOVFF  32D,337
1EA0A:  MOVFF  32E,338
1EA0E:  MOVFF  32F,339
1EA12:  MOVFF  330,33A
1EA16:  MOVLB  0
1EA18:  CALL   17756
....................       } 
1EA1C:  BRA    1EB64
1EA1E:  MOVLB  3
....................       else if(CMD1 ==  0x23){ 
1EA20:  MOVF   x2C,W
1EA22:  SUBLW  23
1EA24:  BNZ   1EA54
....................          REPLY_TO_COM(0x66,0); 
1EA26:  MOVLW  66
1EA28:  MOVWF  x37
1EA2A:  CLRF   x38
1EA2C:  MOVLB  0
1EA2E:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EA32:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
1EA36:  MOVLB  1
1EA38:  CLRF   xF1
....................          TRANSFER_SECTOR_SCF2SMF(CMD2,CMD3,CMD4,CMD5);                           //transfer 1 sector, this function contains saving log 
1EA3A:  MOVFF  32D,337
1EA3E:  MOVFF  32E,338
1EA42:  MOVFF  32F,339
1EA46:  MOVFF  330,33A
1EA4A:  MOVLB  0
1EA4C:  CALL   178D0
....................       } 
1EA50:  BRA    1EB64
1EA52:  MOVLB  3
....................       else if(CMD1 ==  0x31){ 
1EA54:  MOVF   x2C,W
1EA56:  SUBLW  31
1EA58:  BNZ   1EA88
....................          REPLY_TO_COM(0x66,0); 
1EA5A:  MOVLW  66
1EA5C:  MOVWF  x37
1EA5E:  CLRF   x38
1EA60:  MOVLB  0
1EA62:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EA66:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;          
1EA6A:  MOVLB  1
1EA6C:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2OF(CMD2,CMD3,CMD4,CMD5);                            //transfer 1 sector, also this function contains saving log 
1EA6E:  MOVFF  32D,337
1EA72:  MOVFF  32E,338
1EA76:  MOVFF  32F,339
1EA7A:  MOVFF  330,33A
1EA7E:  MOVLB  0
1EA80:  CALL   17A50
....................       } 
1EA84:  BRA    1EB64
1EA86:  MOVLB  3
....................       else if(CMD1 ==  0x32){ 
1EA88:  MOVF   x2C,W
1EA8A:  SUBLW  32
1EA8C:  BNZ   1EABC
....................          REPLY_TO_COM(0x66,0); 
1EA8E:  MOVLW  66
1EA90:  MOVWF  x37
1EA92:  CLRF   x38
1EA94:  MOVLB  0
1EA96:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EA9A:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
1EA9E:  MOVLB  1
1EAA0:  CLRF   xF1
....................          TRANSFER_SECTOR_SMF2SCF(CMD2,CMD3,CMD4,CMD5);                          //transfer 1 sector, also this function contains saving log 
1EAA2:  MOVFF  32D,337
1EAA6:  MOVFF  32E,338
1EAAA:  MOVFF  32F,339
1EAAE:  MOVFF  330,33A
1EAB2:  MOVLB  0
1EAB4:  CALL   17BC8
....................       } 
1EAB8:  BRA    1EB64
1EABA:  MOVLB  3
....................       else if(CMD1 ==  0x01){ 
1EABC:  DECFSZ x2C,W
1EABE:  BRA    1EAF4
....................          REPLY_TO_COM(0x66,0); 
1EAC0:  MOVLW  66
1EAC2:  MOVWF  x37
1EAC4:  CLRF   x38
1EAC6:  MOVLB  0
1EAC8:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EACC:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
1EAD0:  MOVLB  1
1EAD2:  CLRF   xF1
....................          Send_Command_to_FAB(0x01);                                              //send cmd to FAB to turn ON battery heater 
1EAD4:  MOVLW  01
1EAD6:  MOVLB  3
1EAD8:  MOVWF  x4F
1EADA:  MOVLB  0
1EADC:  CALL   1AC4
....................          fprintf(PC,"Sent CMD Heater ON\r\n"); 
1EAE0:  MOVLW  00
1EAE2:  MOVWF  FF6
1EAE4:  MOVLW  16
1EAE6:  MOVWF  FF7
1EAE8:  MOVLW  00
1EAEA:  MOVWF  FF8
1EAEC:  CALL   058C
....................       } 
1EAF0:  BRA    1EB64
1EAF2:  MOVLB  3
....................       else if(CMD1 ==  0x02){ 
1EAF4:  MOVF   x2C,W
1EAF6:  SUBLW  02
1EAF8:  BNZ   1EB2E
....................          REPLY_TO_COM(0x66,0); 
1EAFA:  MOVLW  66
1EAFC:  MOVWF  x37
1EAFE:  CLRF   x38
1EB00:  MOVLB  0
1EB02:  CALL   1D84A
....................          UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EB06:  CALL   1E188
....................          ACK_for_COM[14] = 0x00;       
1EB0A:  MOVLB  1
1EB0C:  CLRF   xF1
....................          Send_Command_to_FAB(0x02);                                              //send cmd to FAB to turn OFF battery heater 
1EB0E:  MOVLW  02
1EB10:  MOVLB  3
1EB12:  MOVWF  x4F
1EB14:  MOVLB  0
1EB16:  CALL   1AC4
....................          fprintf(PC,"Sent CMD Heater OFF\r\n"); 
1EB1A:  MOVLW  16
1EB1C:  MOVWF  FF6
1EB1E:  MOVLW  16
1EB20:  MOVWF  FF7
1EB22:  MOVLW  00
1EB24:  MOVWF  FF8
1EB26:  CALL   058C
....................       } 
1EB2A:  BRA    1EB64
1EB2C:  MOVLB  3
....................       else if(CMD1 ==  0x03){ 
1EB2E:  MOVF   x2C,W
1EB30:  SUBLW  03
1EB32:  BNZ   1EB66
....................             REPLY_TO_COM(0x66,0); 
1EB34:  MOVLW  66
1EB36:  MOVWF  x37
1EB38:  CLRF   x38
1EB3A:  MOVLB  0
1EB3C:  CALL   1D84A
....................             UPLINK_SUCCESS_CHECK();                                                 //put uplink success flag in HIGH and store flags 
1EB40:  CALL   1E188
....................             ACK_for_COM[14] = 0x00;       
1EB44:  MOVLB  1
1EB46:  CLRF   xF1
....................             Send_Command_to_FAB(0x03);                                              //send cmd to FAB to operate Heater in AUTO mode 
1EB48:  MOVLW  03
1EB4A:  MOVLB  3
1EB4C:  MOVWF  x4F
1EB4E:  MOVLB  0
1EB50:  CALL   1AC4
....................             fprintf(PC,"Sent CMD Heater AUTO\r\n"); 
1EB54:  MOVLW  2C
1EB56:  MOVWF  FF6
1EB58:  MOVLW  16
1EB5A:  MOVWF  FF7
1EB5C:  MOVLW  00
1EB5E:  MOVWF  FF8
1EB60:  CALL   058C
1EB64:  MOVLB  3
....................          }          
....................    return; 
1EB66:  MOVLB  0
1EB68:  RETURN 0
.................... } 
....................  
.................... #ORG 0x0001E000 
.................... int8 CHECK_MEMORY_FUNCTION(int8 data)                                            //evita operacion de memoria como comandos reservados 
.................... { 
....................    if((data == 0xe0)||(data == 0xe1)||(data == 0xe2)) 
*
1E10A:  MOVLB  3
1E10C:  MOVF   x2C,W
1E10E:  SUBLW  E0
1E110:  BZ    1E11E
1E112:  MOVF   x2C,W
1E114:  SUBLW  E1
1E116:  BZ    1E11E
1E118:  MOVF   x2C,W
1E11A:  SUBLW  E2
1E11C:  BNZ   1E120
....................    { 
....................       data = 0; 
1E11E:  CLRF   x2C
....................    } 
....................    if((data == 0x12)||(data == 0x32)||(data == 0x21)) 
1E120:  MOVF   x2C,W
1E122:  SUBLW  12
1E124:  BZ    1E132
1E126:  MOVF   x2C,W
1E128:  SUBLW  32
1E12A:  BZ    1E132
1E12C:  MOVF   x2C,W
1E12E:  SUBLW  21
1E130:  BNZ   1E134
....................    { 
....................       data = 0; 
1E132:  CLRF   x2C
....................    } 
....................    return data; 
1E134:  MOVFF  32C,01
1E138:  MOVLB  0
1E13A:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #int_timer0                                                                      //Interrupcion del TMR0 
....................  
.................... void intval() 
.................... {    
....................    static int32 counter = 0;                                                     //la variable se activa como global, mantiene su valor al entrar y salir de la funcion 
....................    counter++;                                                                    //se incrementa cada 16.384ms 
*
01644:  MOVLW  01
01646:  MOVLB  3
01648:  ADDWF  x25,F
0164A:  BTFSC  FD8.0
0164C:  INCF   x26,F
0164E:  BTFSC  FD8.2
01650:  INCF   x27,F
01652:  BTFSC  FD8.2
01654:  INCF   x28,F
....................    if (counter > 60)                                                             //los contadores dentro del if se incrementan aprox cada 1s 
01656:  MOVF   x28,F
01658:  BNZ   1668
0165A:  MOVF   x27,F
0165C:  BNZ   1668
0165E:  MOVF   x26,F
01660:  BNZ   1668
01662:  MOVF   x25,W
01664:  SUBLW  3C
01666:  BC    169C
....................    { 
....................       counter = 0; 
01668:  CLRF   x28
0166A:  CLRF   x27
0166C:  CLRF   x26
0166E:  CLRF   x25
....................  
....................       FAB_FLAG++;                                                                //contador de tiempo en segundos, a los 90 segundos pide datos al FAB 
01670:  MOVLW  01
01672:  MOVLB  2
01674:  ADDWF  xFC,F
01676:  BTFSC  FD8.0
01678:  INCF   xFD,F
0167A:  BTFSC  FD8.2
0167C:  INCF   xFE,F
0167E:  BTFSC  FD8.2
01680:  INCF   xFF,F
....................       RESERVE_SEC_FLAG++;                                                        //contador de tiempo en segundos (used in Table) 
01682:  MOVLB  0
01684:  INCF   x7D,F
....................       currenttime++;                                                             //contador de tiempo en segundos (Reset Function) 
01686:  MOVLB  2
01688:  INCF   x49,F
0168A:  BTFSC  FD8.2
0168C:  INCF   x4A,F
....................  
....................       if(RESERVE_SEC_FLAG > 59)                                                  //los contadores dentro del if se incrementan cada 60s 
0168E:  MOVLB  0
01690:  MOVF   x7D,W
01692:  SUBLW  3B
01694:  BC    169A
....................       { 
....................          RESERVE_SEC_FLAG = 0; 
01696:  CLRF   x7D
....................          RESERVE_MIN_FLAG++;                                                     //contador de tiempo en minutos (used in Table) 
01698:  INCF   x6C,F
0169A:  MOVLB  3
....................       } 
....................    } 
.................... } 
....................  
0169C:  BCF    FF2.2
0169E:  MOVLB  0
016A0:  GOTO   009E
.................... #INT_rda                                                                         //PC Interrupt, RS232 receive data available in buffer 1 
.................... void UART1_RXD(void) 
.................... { 
....................    CMD_FROM_PC[PC_DATA] = fgetc(PC);                                             //carga el array CMD_FROM_PC[] con los datos enviados por PC 
016A4:  CLRF   03
016A6:  MOVF   x99,W
016A8:  ADDLW  7E
016AA:  MOVWF  FE9
016AC:  MOVLW  00
016AE:  ADDWFC 03,W
016B0:  MOVWF  FEA
016B2:  BTFSS  F9E.5
016B4:  BRA    16B2
016B6:  MOVFF  FAE,FEF
....................    PC_DATA = ((PC_DATA + 1) % 8);                                                //cuando se obtenga el dato en la posicion 6, PC_DATA=0 
016BA:  MOVLW  01
016BC:  ADDWF  x99,W
016BE:  ANDLW  07
016C0:  MOVWF  x99
....................    //fputc(fgetc(PC),PC); 
.................... } 
....................  
....................  
016C2:  BCF    F9E.5
016C4:  GOTO   009E
.................... #INT_rda2 HIGH                                                                   //COM Interrupt, RS232 receive data available in buffer 2 
.................... void UART2_RXD(void) 
.................... {    
....................    in_bffr_main[COM_DATA] = fgetc(COM);                                          //carga el array in_bffr_main[] con los datos enviados por COM PIC 
016C8:  CLRF   03
016CA:  MOVF   x96,W
016CC:  ADDLW  86
016CE:  MOVWF  FE9
016D0:  MOVLW  00
016D2:  ADDWFC 03,W
016D4:  MOVWF  FEA
016D6:  BTFSS  FA4.5
016D8:  BRA    16D6
016DA:  MOVLB  F
016DC:  MOVFF  F1E,FEF
....................    COM_DATA = ((COM_DATA + 1) % 16);                                             //cuando se obtenga el dato en la posicion 16, COM_DATA=0 
016E0:  MOVLW  01
016E2:  MOVLB  0
016E4:  ADDWF  x96,W
016E6:  ANDLW  0F
016E8:  MOVWF  x96
.................... }  
....................  
....................  
016EA:  BCF    FA4.5
016EC:  GOTO   014A
.................... #INT_rda3                                                                        //FAB Interrupt, RS232 receive data available in buffer 3 
.................... void UART3_RXD(void) 
.................... { 
....................    //collect_HK_from_FAB(); 
....................    in_HK[FAB_DATA] = fgetc(FAB);                                                 //carga el array in_HK[] con los datos enviados por el FAB PIC 
*
0171C:  CLRF   03
0171E:  MOVLB  2
01720:  MOVF   xF9,W
01722:  ADDLW  50
01724:  MOVWF  FE9
01726:  MOVLW  02
01728:  ADDWFC 03,W
0172A:  MOVWF  FEA
0172C:  BTFSS  FA6.5
0172E:  BRA    172C
01730:  MOVLB  F
01732:  MOVFF  F2A,FEF
....................    FAB_DATA = ((FAB_DATA + 1) % FAB_SENSOR_size);                                //cuando se obtenga el dato en la posicion 45 FAB_DATA=0 
01736:  MOVLW  01
01738:  MOVLB  2
0173A:  ADDWF  xF9,W
0173C:  MOVLB  3
0173E:  MOVWF  x77
01740:  MOVWF  x78
01742:  MOVLW  2D
01744:  MOVWF  x79
01746:  MOVLB  0
01748:  RCALL  16F0
0174A:  MOVFF  00,2F9
.................... }  
....................  
....................  
0174E:  BCF    FA6.5
01750:  GOTO   009E
.................... #INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4 
.................... void UART4_RXD(void) 
.................... { 
....................    reset_bffr[RESET_DATA] = fgetc(reset);                                        //carga el array reset_bffr con los datos enviados por el Reset PIC 
01754:  CLRF   03
01756:  MOVF   x9D,W
01758:  ADDLW  9E
0175A:  MOVWF  FE9
0175C:  MOVLW  00
0175E:  ADDWFC 03,W
01760:  MOVWF  FEA
01762:  BTFSS  FA6.7
01764:  BRA    1762
01766:  MOVLB  E
01768:  MOVFF  EFA,FEF
....................    RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //cuando se obtenga el dato en la posicion 11 RESET_DATA=0 
0176C:  MOVLW  01
0176E:  MOVLB  0
01770:  ADDWF  x9D,W
01772:  MOVLB  3
01774:  MOVWF  x77
01776:  MOVWF  x78
01778:  MOVLW  0B
0177A:  MOVWF  x79
0177C:  MOVLB  0
0177E:  RCALL  16F0
01780:  MOVFF  00,9D
....................    //fputc(fgetc(reset),PC); 
....................    if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite 
01784:  MOVF   x9E,W
01786:  SUBLW  AA
01788:  BNZ   1790
....................    { 
....................       reset_flag = 1;                                                            //pone a alto bandera para reseteo 
0178A:  MOVLW  01
0178C:  MOVWF  xA9
....................       RESET_DATA = 0;                                                            //indicador de posicion dentro del vector reset_data 
0178E:  CLRF   x9D
....................    } 
....................     
01790:  BCF    FA6.7
01792:  GOTO   009E
.................... }  
....................  
.................... void settings() 
.................... { 
....................    set_tris_b(0b11010000);                                                       // Configuracion del puerto b 
*
01812:  MOVLW  D0
01814:  MOVWF  F93
....................    enable_interrupts(global);                                                    // Habilitacion de interrupciones globales       
01816:  MOVLW  C0
01818:  IORWF  FF2,F
....................    enable_interrupts(INT_rda);                                                   // Main to PC 
0181A:  BSF    F9D.5
....................    enable_interrupts(INT_rda2);                                                  // Main to COM PIC 
0181C:  BSF    FA3.5
....................    enable_interrupts(INT_rda3);                                                  // Main to FAB PIC    
0181E:  BSF    F61.5
....................    enable_interrupts(INT_rda4);                                                  // Main to RESET PIC 
01820:  BSF    F61.7
....................  
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_BIT);                     //Config TMR0, internal clock, prescaler 256, clock/counter 8bit 
01822:  MOVLW  D7
01824:  MOVWF  FD5
....................    set_timer0(0);                                                                //this sets timer0 register to 0 
01826:  CLRF   FD7
01828:  CLRF   FD6
....................     
....................    READ_WRTITING_ADDRESS_LOCATION();                                             //save in ADD_INFO_ADDRESS with address info location 
0182A:  CALL   149AE
....................    RESERVE_CHECK = 0;                                                            //bandera que indica si una tabla esta utilizada 
0182E:  CLRF   x6B
....................    RESET_DATA = 0;                                                               //indicador de posicion dentro del vector reset_data 
01830:  CLRF   x9D
....................   
....................    CHECK_FLAG_INFO();                                                            //imprime el estado de los flags y los separa en cada variable correspondiente 
01832:  CALL   16D4E
....................    CHECK_ADDRESS_DATA();                                                         //imprime los datos de direcciones y los separa en cada variable correspondiente 
01836:  CALL   1555E
....................     
....................    BC_SETUP();                                                                   //configuracion del conversor analogico digital para lectura de sensor de temperatura 
0183A:  CALL   190A0
....................    
....................    output_low(PIN_A4);                                                           //kill switch off 
0183E:  BCF    F92.4
01840:  BCF    F89.4
....................    Turn_OFF_CAM();                                                               //Camera switch OFF, RD7=0 
01842:  CALL   190BC
....................    //Turn_OFF_ADCS();                                                              //ADCS switch OFF, RD6=0   
....................    Turn_ON_ADCS();                                                               //ADCS switch ON, RD6=1 
01846:  CALL   1277C
....................    Turn_ON_MBP();                                                                //Mission Boss switch ON, RF5=1 
0184A:  CALL   12A0C
....................    Turn_OFF_BC();                                                                //Burner Circuit switch OFF, RD5=0 
0184E:  CALL   190C2
....................  
....................    fprintf(PC,"\r\n"); 
01852:  MOVLW  0D
01854:  BTFSS  F9E.4
01856:  BRA    1854
01858:  MOVWF  FAD
0185A:  MOVLW  0A
0185C:  BTFSS  F9E.4
0185E:  BRA    185C
01860:  MOVWF  FAD
....................    CURRENT_FLAG_STATUS();                                                        //Imprime en pantalla el estado de todos los flags 
01862:  CALL   12A12
....................    fprintf(PC,"\r\n"); 
01866:  MOVLW  0D
01868:  BTFSS  F9E.4
0186A:  BRA    1868
0186C:  MOVWF  FAD
0186E:  MOVLW  0A
01870:  BTFSS  F9E.4
01872:  BRA    1870
01874:  MOVWF  FAD
....................    CURRENT_ADDRESS_OF_FLASH();                                                   //Print current address allocation 
01876:  CALL   12C84
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion de escritura cuando se superan los 95.000 ciclos 
0187A:  CALL   141F8
....................  
....................    output_high(PIN_C4);                                                          //MUX: COM side (MAIN-COM) 
0187E:  BCF    F94.4
01880:  BSF    F8B.4
....................    output_low(PIN_A5);                                                           //MUX: Main side (MAIN-MISSION) 
01882:  BCF    F92.5
01884:  BCF    F89.5
....................    
....................    Get_RSV();                                                                    //read the reservation table info from flash memory 
01886:  CALL   16E24
....................    SAVE_SAT_LOG(0x25,0x25,0x25);                                                 //carga el RESET_bffr[] con los datos del reset PIC, verifica nro de escrituras flash  
0188A:  MOVLW  25
0188C:  MOVLB  3
0188E:  MOVWF  x53
01890:  MOVWF  x54
01892:  MOVWF  x55
01894:  MOVLB  0
01896:  CALL   16EE2
....................    return;                                                                       //y guarda en las flash los datos en la direccion indicada por SAT_LOG   
0189A:  GOTO   294E (RETURN)
.................... }                                   
....................  
....................  
.................... void main() 
*
026AE:  CLRF   FF8
026B0:  BCF    FF1.2
026B2:  BCF    F9F.5
026B4:  BSF    FA5.5
026B6:  BCF    FA9.5
026B8:  BCF    FA9.7
026BA:  BSF    FD0.7
026BC:  BSF    07.7
026BE:  MOVLB  E
026C0:  MOVLW  55
026C2:  MOVWF  F7E
026C4:  MOVLW  AA
026C6:  MOVWF  F7E
026C8:  BCF    F66.6
026CA:  MOVLW  F4
026CC:  MOVWF  x2A
026CE:  MOVLW  F5
026D0:  MOVWF  x2B
026D2:  MOVLW  F8
026D4:  MOVWF  x2C
026D6:  MOVLW  F9
026D8:  MOVWF  x2D
026DA:  MOVLW  01
026DC:  MOVWF  x1B
026DE:  MOVLW  20
026E0:  MOVWF  x1D
026E2:  MOVLW  30
026E4:  MOVWF  x22
026E6:  MOVLW  20
026E8:  MOVWF  x24
026EA:  MOVLW  55
026EC:  MOVWF  F7E
026EE:  MOVLW  AA
026F0:  MOVWF  F7E
026F2:  BSF    F66.6
026F4:  CLRF   F9B
026F6:  CLRF   F64
026F8:  CLRF   F65
026FA:  CLRF   F66
026FC:  MOVLW  02
026FE:  MOVWF  FD3
02700:  BSF    F67.3
02702:  MOVLW  22
02704:  MOVWF  FAF
02706:  MOVLW  00
02708:  MOVLB  F
0270A:  MOVWF  x30
0270C:  MOVLW  A6
0270E:  MOVWF  FAC
02710:  MOVLW  90
02712:  MOVWF  FAB
02714:  BSF    x31.3
02716:  MOVLW  A0
02718:  MOVWF  x1F
0271A:  MOVLW  01
0271C:  MOVWF  x20
0271E:  MOVLW  A6
02720:  MOVWF  x32
02722:  MOVLW  90
02724:  MOVWF  x33
02726:  BSF    x2D.3
02728:  MOVLW  A0
0272A:  MOVWF  x2B
0272C:  MOVLW  01
0272E:  MOVWF  x2C
02730:  MOVLW  A6
02732:  MOVWF  x2E
02734:  MOVLW  90
02736:  MOVWF  x2F
02738:  MOVLB  E
0273A:  BSF    xFD.3
0273C:  MOVLW  A0
0273E:  MOVWF  xFB
02740:  MOVLW  01
02742:  MOVWF  xFC
02744:  MOVLW  A6
02746:  MOVWF  xFE
02748:  MOVLW  90
0274A:  MOVWF  xFF
0274C:  BCF    F97.7
0274E:  BSF    F8E.7
02750:  BCF    F98.2
02752:  BSF    F8F.2
02754:  BCF    F98.0
02756:  BSF    F8F.0
02758:  BSF    F96.0
0275A:  BCF    F96.6
0275C:  BCF    F96.1
0275E:  BCF    F8D.1
02760:  BSF    F93.5
02762:  BCF    F93.4
02764:  BCF    F93.2
02766:  BCF    F8A.2
02768:  BSF    F92.0
0276A:  BCF    F92.1
0276C:  BCF    F92.3
0276E:  BCF    F89.3
02770:  CLRF   33
02772:  CLRF   32
02774:  MOVLW  10
02776:  MOVWF  31
02778:  CLRF   30
0277A:  CLRF   37
0277C:  CLRF   36
0277E:  CLRF   35
02780:  CLRF   34
02782:  CLRF   3B
02784:  MOVLW  04
02786:  MOVWF  3A
02788:  CLRF   39
0278A:  CLRF   38
0278C:  CLRF   3F
0278E:  MOVLW  05
02790:  MOVWF  3E
02792:  CLRF   3D
02794:  CLRF   3C
02796:  CLRF   43
02798:  MOVLW  06
0279A:  MOVWF  42
0279C:  CLRF   41
0279E:  CLRF   40
027A0:  CLRF   47
027A2:  MOVLW  08
027A4:  MOVWF  46
027A6:  CLRF   45
027A8:  CLRF   44
027AA:  CLRF   4B
027AC:  MOVLW  62
027AE:  MOVWF  4A
027B0:  CLRF   49
027B2:  CLRF   48
027B4:  MOVLW  04
027B6:  MOVWF  4F
027B8:  MOVLW  4A
027BA:  MOVWF  4E
027BC:  CLRF   4D
027BE:  CLRF   4C
027C0:  MOVLW  04
027C2:  MOVWF  53
027C4:  MOVLW  72
027C6:  MOVWF  52
027C8:  CLRF   51
027CA:  CLRF   50
027CC:  MOVLW  06
027CE:  MOVWF  57
027D0:  MOVLW  65
027D2:  MOVWF  56
027D4:  CLRF   55
027D6:  CLRF   54
027D8:  MOVLW  06
027DA:  MOVWF  5B
027DC:  MOVLW  66
027DE:  MOVWF  5A
027E0:  CLRF   59
027E2:  CLRF   58
027E4:  MOVLW  06
027E6:  MOVWF  5F
027E8:  MOVLW  67
027EA:  MOVWF  5E
027EC:  CLRF   5D
027EE:  CLRF   5C
027F0:  MOVLB  0
027F2:  CLRF   x63
027F4:  MOVLW  01
027F6:  MOVWF  x62
027F8:  MOVLW  80
027FA:  MOVWF  x61
027FC:  CLRF   x60
027FE:  CLRF   x67
02800:  MOVLW  01
02802:  MOVWF  x66
02804:  MOVLW  80
02806:  MOVWF  x65
02808:  MOVLW  1C
0280A:  MOVWF  x64
0280C:  CLRF   x68
0280E:  CLRF   x6A
02810:  CLRF   x69
02812:  CLRF   x6B
02814:  CLRF   x6C
02816:  CLRF   x6D
02818:  CLRF   x6E
0281A:  CLRF   x6F
0281C:  CLRF   x70
0281E:  CLRF   x71
02820:  CLRF   x72
02822:  CLRF   x73
02824:  CLRF   x74
02826:  CLRF   x75
02828:  CLRF   x76
0282A:  CLRF   x77
0282C:  CLRF   x78
0282E:  CLRF   x79
02830:  CLRF   x7A
02832:  CLRF   x7B
02834:  CLRF   x7C
02836:  CLRF   x7D
02838:  CLRF   x96
0283A:  CLRF   x97
0283C:  CLRF   x98
0283E:  CLRF   x99
02840:  CLRF   x9A
02842:  CLRF   x9B
02844:  CLRF   x9C
02846:  CLRF   x9D
02848:  CLRF   xA9
0284A:  CLRF   xE4
0284C:  CLRF   xE3
0284E:  MOVLB  1
02850:  CLRF   x36
02852:  CLRF   x95
02854:  MOVLB  2
02856:  CLRF   x4A
02858:  CLRF   x49
0285A:  CLRF   xF9
0285C:  CLRF   xFA
0285E:  CLRF   xFB
02860:  CLRF   xFF
02862:  CLRF   xFE
02864:  CLRF   xFD
02866:  CLRF   xFC
02868:  MOVLB  3
0286A:  CLRF   x00
0286C:  CLRF   x04
0286E:  CLRF   x03
02870:  CLRF   x02
02872:  CLRF   x01
02874:  CLRF   x06
02876:  CLRF   x05
02878:  CLRF   x08
0287A:  CLRF   x07
0287C:  CLRF   x0A
0287E:  CLRF   x09
02880:  CLRF   x0E
02882:  CLRF   x0D
02884:  CLRF   x0C
02886:  CLRF   x0B
02888:  CLRF   x12
0288A:  CLRF   x11
0288C:  CLRF   x10
0288E:  CLRF   x0F
02890:  CLRF   x16
02892:  CLRF   x15
02894:  CLRF   x14
02896:  CLRF   x13
02898:  CLRF   x18
0289A:  CLRF   x17
0289C:  CLRF   x19
0289E:  CLRF   x1A
028A0:  CLRF   x1C
028A2:  CLRF   x1B
028A4:  CLRF   x1E
028A6:  CLRF   x1D
028A8:  CLRF   x1F
028AA:  CLRF   x20
028AC:  CLRF   x24
028AE:  CLRF   x23
028B0:  CLRF   x22
028B2:  CLRF   x21
028B4:  CLRF   x28
028B6:  CLRF   x27
028B8:  CLRF   x26
028BA:  CLRF   x25
028BC:  MOVLB  E
028BE:  CLRF   xD9
028C0:  CLRF   xDA
028C2:  CLRF   x45
028C4:  CLRF   x46
028C6:  CLRF   x47
028C8:  BCF    x8D.7
028CA:  BCF    x8D.6
028CC:  BCF    x8D.5
028CE:  MOVLB  1
028D0:  CLRF   x88
028D2:  MOVLB  F
028D4:  CLRF   x53
028D6:  CLRF   x38
028D8:  CLRF   x37
028DA:  BRA    290A
028DC:  DATA 18,40
028DE:  DATA 7E,00
028E0:  DATA 0B,40
028E2:  DATA 9E,00
028E4:  DATA 39,40
028E6:  DATA AA,00
028E8:  DATA 51,40
028EA:  DATA E5,00
028EC:  DATA 5E,41
028EE:  DATA 37,00
028F0:  DATA 01,01
028F2:  DATA 96,AA
028F4:  DATA 4B,C0
028F6:  DATA 00,02
028F8:  DATA 80,BB
028FA:  DATA AA,16
028FC:  DATA C0,00
028FE:  DATA 01,80
02900:  DATA BB,4E
02902:  DATA C0,00
02904:  DATA AE,42
02906:  DATA 4B,00
02908:  DATA 00,00
0290A:  MOVLW  00
0290C:  MOVWF  FF8
0290E:  MOVLW  28
02910:  MOVWF  FF7
02912:  MOVLW  DC
02914:  MOVWF  FF6
02916:  TBLRD*+
02918:  MOVF   FF5,W
0291A:  MOVWF  00
0291C:  XORLW  00
0291E:  BZ    2946
02920:  TBLRD*+
02922:  MOVF   FF5,W
02924:  MOVWF  01
02926:  BTFSC  FE8.7
02928:  BRA    2934
0292A:  ANDLW  0F
0292C:  MOVWF  FEA
0292E:  TBLRD*+
02930:  MOVFF  FF5,FE9
02934:  BTFSC  01.6
02936:  TBLRD*+
02938:  BTFSS  01.6
0293A:  TBLRD*+
0293C:  MOVFF  FF5,FEE
02940:  DCFSNZ 00,F
02942:  BRA    2916
02944:  BRA    2938
02946:  CLRF   FF8
.................... { 
....................  
....................    settings(); 
02948:  MOVLB  0
0294A:  GOTO   1812
....................    enable_interrupts(INT_TIMER0); 
0294E:  BSF    FF2.5
....................    fprintf(PC,"Start Operating\r\n"); 
02950:  MOVLW  96
02952:  MOVWF  FF6
02954:  MOVLW  17
02956:  MOVWF  FF7
02958:  MOVLW  00
0295A:  MOVWF  FF8
0295C:  CALL   058C
....................     
....................    FAB_TEST_OPERATION();                                                         //carga el array FABDATA[], crea el CW format y los guarda en la Flash 
02960:  CALL   19CDA
....................     
....................    STORE_ADRESS_DATA_TO_FLASH();                                                 //guarda los datos de direcciones en flash, y en un nuevo sector si se cumple el ciclo 95000 
02964:  CALL   144C8
....................    CURRENT_ADDRESS_OF_FLASH();                                                   //imprime la asignacion de direcciones de la Flash memory 
02968:  CALL   12C84
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory (in OF, SCF and SMF) 
0296C:  CALL   14000
....................    WRITE_FLAG_to_EEPROM();                                                       //guarda los flags en la EEPROM a partir de la direccion 0x18000 (75%) 
02970:  CALL   11C84
....................  
....................    
....................    fprintf(PC,"\r\nCW:"); 
02974:  MOVLW  A8
02976:  MOVWF  FF6
02978:  MOVLW  17
0297A:  MOVWF  FF7
0297C:  MOVLW  00
0297E:  MOVWF  FF8
02980:  CALL   058C
....................    for(int i = 0; i < 4; i++)                                                    //imprime el contenido del array CW_FORMAT[] 
02984:  MOVLB  3
02986:  CLRF   x29
02988:  MOVF   x29,W
0298A:  SUBLW  03
0298C:  BNC   29B8
....................    { 
....................       fprintf(PC,"%x,",CW_FORMAT[i]); 
0298E:  CLRF   03
02990:  MOVF   x29,W
02992:  ADDLW  4B
02994:  MOVWF  FE9
02996:  MOVLW  02
02998:  ADDWFC 03,W
0299A:  MOVWF  FEA
0299C:  MOVFF  FEF,3A2
029A0:  MOVLW  57
029A2:  MOVWF  xA3
029A4:  MOVLB  0
029A6:  CALL   0734
029AA:  MOVLW  2C
029AC:  BTFSS  F9E.4
029AE:  BRA    29AC
029B0:  MOVWF  FAD
029B2:  MOVLB  3
029B4:  INCF   x29,F
029B6:  BRA    2988
....................    } 
....................    fprintf(PC,"%x\r\n",CW_FORMAT[4]); 
029B8:  MOVFF  24F,3A2
029BC:  MOVLW  57
029BE:  MOVWF  xA3
029C0:  MOVLB  0
029C2:  CALL   0734
029C6:  MOVLW  0D
029C8:  BTFSS  F9E.4
029CA:  BRA    29C8
029CC:  MOVWF  FAD
029CE:  MOVLW  0A
029D0:  BTFSS  F9E.4
029D2:  BRA    29D0
029D4:  MOVWF  FAD
....................    Antenna_Deploy();                                                             //after each restart check BC_ATTEMPT_FLAG to deploy antenna 
029D6:  CALL   1A37A
....................    //CAM deployment 
....................    if(PASSED_DAYS == 0 && UPLINK_SUCCESS == 0)                                  //automated CAM DEPLOYMENT mission condition 
029DA:  MOVF   x69,F
029DC:  BNZ   29F2
029DE:  MOVF   x6A,F
029E0:  BNZ   29F2
029E2:  MOVF   x7C,F
029E4:  BNZ   29F2
....................    {   
....................       CAM_DEPLOYMENT_OPERATION(0xAD);                                           //CMD for CAM deployment mode 
029E6:  MOVLW  AD
029E8:  MOVLB  3
029EA:  MOVWF  x2C
029EC:  MOVLB  0
029EE:  CALL   1A5A2
....................    } 
....................    //try 5 times for reliability 
....................    AUTOMATICAL_MISSION_CHECK(); 
029F2:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
029F6:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
029FA:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
029FE:  CALL   1D774
....................    AUTOMATICAL_MISSION_CHECK(); 
02A02:  CALL   1D774
....................  
....................    RESET_DATA = 0;                                                               //bandera a cero 
02A06:  CLRF   x9D
....................  
....................  
....................    while(true) 
....................    { 
....................  
....................       BC_ON_30min();                                                             //if satellite shut down during automatical MSN, this function will be used after start again       
02A08:  CALL   1B9DC
....................       RESET_SATELLITE();                                                         //check reset command from RESET PIC 
02A0C:  CALL   16CEE
....................        
....................       if(FAB_FLAG > 89)                                                          //every 90 sec, OBC gather sensor data and update CW format  
02A10:  MOVLB  2
02A12:  MOVF   xFF,F
02A14:  BNZ   2A24
02A16:  MOVF   xFE,F
02A18:  BNZ   2A24
02A1A:  MOVF   xFD,F
02A1C:  BNZ   2A24
02A1E:  MOVF   xFC,W
02A20:  SUBLW  59
02A22:  BC    2AB6
....................       { 
....................          FAB_FLAG = 0; 
02A24:  CLRF   xFF
02A26:  CLRF   xFE
02A28:  CLRF   xFD
02A2A:  CLRF   xFC
....................          fprintf(PC,"\r\n***90sec passed***\r\n"); 
02A2C:  MOVLW  AE
02A2E:  MOVWF  FF6
02A30:  MOVLW  17
02A32:  MOVWF  FF7
02A34:  MOVLW  00
02A36:  MOVWF  FF8
02A38:  MOVLB  0
02A3A:  CALL   058C
....................          FAB_TEST_OPERATION();                                                   //carga el array FABDATA[], crea el CW format y los guarda en la Flash 
02A3E:  CALL   19CDA
....................          COM_DATA = 0; 
02A42:  CLRF   x96
....................          STORE_ADRESS_DATA_TO_FLASH();                                           //for store the address info 
02A44:  CALL   144C8
....................          fprintf(PC,"CW:"); 
02A48:  MOVLW  C6
02A4A:  MOVWF  FF6
02A4C:  MOVLW  17
02A4E:  MOVWF  FF7
02A50:  MOVLW  00
02A52:  MOVWF  FF8
02A54:  CALL   058C
....................          for(int i = 0; i < 4; i++)                                              //show CW format 
02A58:  MOVLB  3
02A5A:  CLRF   x2A
02A5C:  MOVF   x2A,W
02A5E:  SUBLW  03
02A60:  BNC   2A8C
....................          { 
....................             fprintf(PC,"%x,",CW_FORMAT[i]); 
02A62:  CLRF   03
02A64:  MOVF   x2A,W
02A66:  ADDLW  4B
02A68:  MOVWF  FE9
02A6A:  MOVLW  02
02A6C:  ADDWFC 03,W
02A6E:  MOVWF  FEA
02A70:  MOVFF  FEF,3A2
02A74:  MOVLW  57
02A76:  MOVWF  xA3
02A78:  MOVLB  0
02A7A:  CALL   0734
02A7E:  MOVLW  2C
02A80:  BTFSS  F9E.4
02A82:  BRA    2A80
02A84:  MOVWF  FAD
02A86:  MOVLB  3
02A88:  INCF   x2A,F
02A8A:  BRA    2A5C
....................          } 
....................          fprintf(PC,"%x\r\n",CW_FORMAT[4]); 
02A8C:  MOVFF  24F,3A2
02A90:  MOVLW  57
02A92:  MOVWF  xA3
02A94:  MOVLB  0
02A96:  CALL   0734
02A9A:  MOVLW  0D
02A9C:  BTFSS  F9E.4
02A9E:  BRA    2A9C
02AA0:  MOVWF  FAD
02AA2:  MOVLW  0A
02AA4:  BTFSS  F9E.4
02AA6:  BRA    2AA4
02AA8:  MOVWF  FAD
....................          DELETE_CMD_FROM_PC();                                                   //delete PC command 
02AAA:  CALL   1B0BA
....................          PC_DATA = 0;                                                            //reset interrupt data for safety 
02AAE:  CLRF   x99
....................          COM_DATA = 0;                                                           //reset interrupt data for safety 
02AB0:  CLRF   x96
....................          RESET_DATA = 0;                                                         //reset interrupt data for safety 
02AB2:  CLRF   x9D
02AB4:  MOVLB  2
....................       }    
....................        
....................       if((RESERVE_MIN_FLAG >= RESERVE_TARGET_FLAG) && RESERVE_CHECK == 1)        //check the reservation command, if time came, execute 
02AB6:  MOVLB  0
02AB8:  MOVF   x6D,W
02ABA:  SUBWF  x6C,W
02ABC:  BNC   2B1C
02ABE:  DECFSZ x6B,W
02AC0:  BRA    2B1C
....................       { 
....................          fprintf(PC,"Execute reserved command\r\n"); 
02AC2:  MOVLW  CA
02AC4:  MOVWF  FF6
02AC6:  MOVLW  17
02AC8:  MOVWF  FF7
02ACA:  MOVLW  00
02ACC:  MOVWF  FF8
02ACE:  CALL   058C
....................          MISSION_CONTENTS = CHECK_MEMORY_FUNCTION(MISSION_CONTENTS);             //avoid erase or transfer sectors from memory as reserved commands 
02AD2:  MOVFF  6E,32C
02AD6:  CALL   1E10A
02ADA:  MOVFF  01,6E
....................          EXECUTE_MISSION_from_COM(MISSION_CONTENTS,MISSION_DETAIL,RESERVE_ADDRESS_1,RESERVE_ADDRESS_2,RESERVE_ADDRESS_3,RESERVE_ADDRESS_4,RESERVE_PACKET_NUM);    //execute command 
02ADE:  MOVFF  6E,32C
02AE2:  MOVFF  6F,32D
02AE6:  MOVFF  70,32E
02AEA:  MOVFF  71,32F
02AEE:  MOVFF  72,330
02AF2:  MOVFF  73,331
02AF6:  MOVFF  74,332
02AFA:  CALL   C800
....................          Remove_1_Reservation();                                                 //remove the finished command and sort again and save updated command table 
02AFE:  CALL   18068
....................          if(reserve_table[80] != 0x00)                                           //if next reservation is registered, wait until time will be come 
02B02:  MOVLB  1
02B04:  MOVF   x35,F
02B06:  BZ    2B12
....................          { 
....................             Reserve_next();                                                      //take the next CMD from the table 
02B08:  MOVLB  0
02B0A:  CALL   18102
....................          }else{                                                                  //if all reservation finished, reset flag about reservation 
02B0E:  BRA    2B1C
02B10:  MOVLB  1
....................             RESERVE_TARGET_FLAG = 0;                                             //reset flag 
02B12:  MOVLB  0
02B14:  CLRF   x6D
....................             RESERVE_CHECK = 0; 
02B16:  CLRF   x6B
....................             MISSION_CONTENTS = 0; 
02B18:  CLRF   x6E
....................             MISSION_DETAIL = 0; 
02B1A:  CLRF   x6F
....................          } 
....................       } 
....................        
....................       if(buffer_from_com)                                                        //If TRU -> (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
02B1C:  MOVF   x86,W
02B1E:  SUBLW  AA
02B20:  BNZ   2BB4
02B22:  MOVF   x95,W
02B24:  SUBLW  BB
02B26:  BNZ   2BB4
....................       { 
....................          fprintf(PC,"COM COMMAND:\r\n"); 
02B28:  MOVLW  E6
02B2A:  MOVWF  FF6
02B2C:  MOVLW  17
02B2E:  MOVWF  FF7
02B30:  MOVLW  00
02B32:  MOVWF  FF8
02B34:  CALL   058C
....................          for(COM_DATA = 0; COM_DATA < 16; COM_DATA++)                            //display command in PC 
02B38:  CLRF   x96
02B3A:  MOVF   x96,W
02B3C:  SUBLW  0F
02B3E:  BNC   2B6A
....................          { 
....................             //fputc(in_bffr_main[COM_DATA],PC); 
....................             fprintf(PC,"%x,",in_bffr_main[COM_DATA]);                            //para visualizar en la PC 
02B40:  CLRF   03
02B42:  MOVF   x96,W
02B44:  ADDLW  86
02B46:  MOVWF  FE9
02B48:  MOVLW  00
02B4A:  ADDWFC 03,W
02B4C:  MOVWF  FEA
02B4E:  MOVFF  FEF,3A2
02B52:  MOVLW  57
02B54:  MOVLB  3
02B56:  MOVWF  xA3
02B58:  MOVLB  0
02B5A:  CALL   0734
02B5E:  MOVLW  2C
02B60:  BTFSS  F9E.4
02B62:  BRA    2B60
02B64:  MOVWF  FAD
02B66:  INCF   x96,F
02B68:  BRA    2B3A
....................          } 
....................          COM_DATA = 0;                                                           //position indicator for the vector in_bffr_main[] 
02B6A:  CLRF   x96
....................          //fprintf(PC,"COM COMMAND\r\n"); 
....................          if(in_bffr_main[5] == 0)                                                //if time data is not placed 
02B6C:  MOVF   x8B,F
02B6E:  BNZ   2B92
....................          { 
....................             EXECUTE_MISSION_from_COM(in_bffr_main[4],in_bffr_main[6],in_bffr_main[7],in_bffr_main[8],in_bffr_main[9],in_bffr_main[10],in_bffr_main[11]); 
02B70:  MOVFF  8A,32C
02B74:  MOVFF  8C,32D
02B78:  MOVFF  8D,32E
02B7C:  MOVFF  8E,32F
02B80:  MOVFF  8F,330
02B84:  MOVFF  90,331
02B88:  MOVFF  91,332
02B8C:  CALL   C800
....................          } 
02B90:  BRA    2BA6
....................          else 
....................          {                                                                  //if time data is placed (that means reservation command) 
....................             SAVE_SAT_LOG(in_bffr_main[4],in_bffr_main[5],in_bffr_main[6]);       //reservation command log 
02B92:  MOVFF  8A,353
02B96:  MOVFF  8B,354
02B9A:  MOVFF  8C,355
02B9E:  CALL   16EE2
....................             Reserve_command_COM();                                               //used when in_bffr_main[5] has a Time value 
02BA2:  CALL   18346
....................          } 
....................          DELETE_CMD_FROM_PC();                                                   //set to zero the array CMD_FROM_PC[] 
02BA6:  CALL   1B0BA
....................          Delete_Buffer();                                                        //set to zero the array in_bffr_main[] 
02BAA:  CALL   1272A
....................          CMD_FROM_PC[1] = 0; 
02BAE:  CLRF   x7F
....................          COM_DATA = 0;                                                           //position indicator for the vector in_bffr_main[] 
02BB0:  CLRF   x96
....................          PC_DATA = 0;                                                            //position indicator for the vector CMD_FROM_PC[] 
02BB2:  CLRF   x99
....................       } 
....................        
....................       //COMMANDS EXECUTION FROM PC//        
....................        
....................       if(CMD_FROM_PC[0]) 
02BB4:  MOVF   x7E,F
02BB6:  BZ    2C4E
....................       { 
....................          fprintf(PC,"COMMAND RECEIVED FROM PC: "); 
02BB8:  MOVLW  F6
02BBA:  MOVWF  FF6
02BBC:  MOVLW  17
02BBE:  MOVWF  FF7
02BC0:  MOVLW  00
02BC2:  MOVWF  FF8
02BC4:  CALL   058C
....................          for(int m = 0; m < 8; m++) 
02BC8:  MOVLB  3
02BCA:  CLRF   x2B
02BCC:  MOVF   x2B,W
02BCE:  SUBLW  07
02BD0:  BNC   2BF4
....................          { 
....................             fprintf(PC,"%x",CMD_FROM_PC[m]); 
02BD2:  CLRF   03
02BD4:  MOVF   x2B,W
02BD6:  ADDLW  7E
02BD8:  MOVWF  FE9
02BDA:  MOVLW  00
02BDC:  ADDWFC 03,W
02BDE:  MOVWF  FEA
02BE0:  MOVFF  FEF,3A2
02BE4:  MOVLW  57
02BE6:  MOVWF  xA3
02BE8:  MOVLB  0
02BEA:  CALL   0734
02BEE:  MOVLB  3
02BF0:  INCF   x2B,F
02BF2:  BRA    2BCC
....................          } 
....................          fprintf(PC,"\r\n"); 
02BF4:  MOVLW  0D
02BF6:  BTFSS  F9E.4
02BF8:  BRA    2BF6
02BFA:  MOVWF  FAD
02BFC:  MOVLW  0A
02BFE:  BTFSS  F9E.4
02C00:  BRA    2BFE
02C02:  MOVWF  FAD
....................           
....................          if(CMD_FROM_PC[1] == 0)                                                 //if time data is not placed 
02C04:  MOVLB  0
02C06:  MOVF   x7F,F
02C08:  BNZ   2C2C
....................          { 
....................             EXECUTE_MISSION_from_PC(CMD_FROM_PC[0],CMD_FROM_PC[2],CMD_FROM_PC[3],CMD_FROM_PC[4],CMD_FROM_PC[5],CMD_FROM_PC[6],CMD_FROM_PC[7]);//execute mission 
02C0A:  MOVFF  7E,32C
02C0E:  MOVFF  80,32D
02C12:  MOVFF  81,32E
02C16:  MOVFF  82,32F
02C1A:  MOVFF  83,330
02C1E:  MOVFF  84,331
02C22:  MOVFF  85,332
02C26:  CALL   1E1C0
....................          } 
02C2A:  BRA    2C40
....................          else 
....................          {                                                                  //if time data is placed (that means reservation command) 
....................             SAVE_SAT_LOG(CMD_FROM_PC[0],CMD_FROM_PC[1],CMD_FROM_PC[2]);          //reservation command log 
02C2C:  MOVFF  7E,353
02C30:  MOVFF  7F,354
02C34:  MOVFF  80,355
02C38:  CALL   16EE2
....................             Reserve_command_PC();                                                //mission command reservation from PC comand 
02C3C:  CALL   185DE
....................          } 
....................          DELETE_CMD_FROM_PC();                                                   //clear CMD_FROM_PC[] array 
02C40:  CALL   1B0BA
....................          Delete_Buffer();                                                        //clear in_bffr_main[] array 
02C44:  CALL   1272A
....................          CMD_FROM_PC[1] = 0; 
02C48:  CLRF   x7F
....................          COM_DATA = 0;                                                           //clear COM correct receiving data flag 
02C4A:  CLRF   x96
....................          PC_DATA = 0;                                                            //clear PC correct receiving data flag 
02C4C:  CLRF   x99
....................       } 
....................              
....................       if(COM_DATA != 0 || PC_DATA != 0)                                          //COM_DATA Y PC_DATA SERAN CERO SI SE RECIBEN LA CANTIDAD CORRECTA DE CARACTERES 
02C4E:  MOVF   x96,F
02C50:  BNZ   2C56
02C52:  MOVF   x99,F
02C54:  BZ    2C86
....................       { 
....................          delay_ms(500); 
02C56:  MOVLW  02
02C58:  MOVLB  3
02C5A:  MOVWF  x2C
02C5C:  MOVLW  FA
02C5E:  MOVWF  x98
02C60:  MOVLB  0
02C62:  CALL   0526
02C66:  MOVLB  3
02C68:  DECFSZ x2C,F
02C6A:  BRA    2C5C
....................          if(PC_DATA != 0)                                                        //Si no se recibio la cantidad correcta de caracteres pone a cero el array CMD_FROM_PC 
02C6C:  MOVLB  0
02C6E:  MOVF   x99,F
02C70:  BZ    2C86
....................          { 
....................             CMD_FROM_PC[0] = 0; 
02C72:  CLRF   x7E
....................             CMD_FROM_PC[1] = 0; 
02C74:  CLRF   x7F
....................             CMD_FROM_PC[2] = 0; 
02C76:  CLRF   x80
....................             CMD_FROM_PC[3] = 0; 
02C78:  CLRF   x81
....................             CMD_FROM_PC[4] = 0; 
02C7A:  CLRF   x82
....................             CMD_FROM_PC[5] = 0; 
02C7C:  CLRF   x83
....................             CMD_FROM_PC[6] = 0; 
02C7E:  CLRF   x84
....................             CMD_FROM_PC[7] = 0; 
02C80:  CLRF   x85
....................             COM_DATA = 0; 
02C82:  CLRF   x96
....................             PC_DATA = 0; 
02C84:  CLRF   x99
....................          } 
....................       } 
....................       delay_ms(400);     
02C86:  MOVLW  02
02C88:  MOVLB  3
02C8A:  MOVWF  x2C
02C8C:  MOVLW  C8
02C8E:  MOVWF  x98
02C90:  MOVLB  0
02C92:  CALL   0526
02C96:  MOVLB  3
02C98:  DECFSZ x2C,F
02C9A:  BRA    2C8C
02C9C:  MOVLB  0
02C9E:  BRA    2A08
....................    } 
.................... } 
02CA0:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
